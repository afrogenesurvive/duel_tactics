import React, { Component } from 'react';
import Easystar from 'easystarjs';
import Pathfinding from 'pathfinding';
// import { AStarFinder } from "astar-typescript";
import OverlayTrigger from 'react-bootstrap/OverlayTrigger'
import Popover from 'react-bootstrap/Popover';
import { FontAwesomeIcon } from '@fortawesome/react-fontawesome';
import {
  faCogs,
  faRobot,
  faVideo,
  faSearchPlus,
  faExpandAlt,
  faUndo,
  faQuestionCircle,
  faBorderAll,
  faChessBoard,
  faExclamationTriangle,
} from '@fortawesome/free-solid-svg-icons';


import logo from './logo.svg';
import floorDirt from './assets/floorDirt.png';
import floorGrass from './assets/floorGrass.png';
import floorIce from './assets/floorIce.png';
import floorMud from './assets/floorMud.png';
import floorPond from './assets/floorPond.png';
import floorRiver from './assets/floorRiver.png';
import floorSand from './assets/floorSand.png';
import floorStone from './assets/floorStone.png';
import floorBramble from './assets/floorBramble.png';
import floorLava from './assets/floorLava.png';
import floorAttack from './assets/floorAttacked.png';
import floorAttack2 from './assets/floorAttacked2.png';
import floorVoid from './assets/floorVoid.png';
import floorVoid2 from './assets/floorVoid2.png';
import floorVoid3 from './assets/floorVoid3.png';
import floorHighlight from './assets/floorHighlight.png';
import floorRubble from './assets/floorRubble.png';
import wall from './assets/wall.png';
import wall2 from './assets/wall2.png';
import wall3 from './assets/wall3.png';
import obstacleAHalf from './assets/obstacleA_half.png';
import obstacleAFull from './assets/obstacleA_full.png';
import obstacleBHalf from './assets/obstacleB_half.png';
import obstacleBFull from './assets/obstacleB_full.png';
import obstacleCHalf from './assets/obstacleC_half.png';
import obstacleCFull from './assets/obstacleC_full.png';
import obstacleDHalf from './assets/obstacleD_half.png';
import obstacleDFull from './assets/obstacleD_full.png';
import obstacleEHalf from './assets/obstacleE_half.png';
import obstacleEFull from './assets/obstacleE_full.png';
import obstacleCrate from './assets/obstacle_crate.png';
import obstacleBarrel from './assets/obstacle_barrel.png';
import barrierANorth from './assets/barrierA_north.png';
import barrierASouth from './assets/barrierA_south.png';
import barrierAEast from './assets/barrierA_east.png';
import barrierAWest from './assets/barrierA_west.png';


import attack1Indicate from './assets/indicators/attack1.png';
import attack2Indicate from './assets/indicators/attack2.png';
import attack3Indicate from './assets/indicators/attacky.png';
import attackUnarmedIndicate from './assets/items/unarmed.png';
import attackBluntIndicate from './assets/indicators/blunt.png';
import attackSuccessIndicate from './assets/indicators/attackSuccess.png';
import missedIndicate from './assets/indicators/miss.png';
import missedIndicate2 from './assets/indicators/miss2.png';
import defendIndicate from './assets/indicators/defend.png';
import defendIndicate1 from './assets/indicators/defend3.png';
import defendIndicate2 from './assets/indicators/defend4.png';
import defendIndicate3 from './assets/indicators/defend5.png';
import defendIndicate4 from './assets/indicators/defend6.png';
import deflectIndicate from './assets/indicators/deflect.png';
import deflectIndicate2 from './assets/indicators/deflect2.png';
import deflectInjuredIndicate from './assets/indicators/deflectInjured2.png';
import deflectInjuredIndicate2 from './assets/indicators/deflectInjured.png';
import deflectBluntIndicate from './assets/indicators/death2.png';
import pushbackIndicate from './assets/indicators/pushback.png';
import ghostIndicate from './assets/indicators/ghost.png';
import deathIndicate from './assets/indicators/death.png';
import preAttackIndicate from './assets/indicators/preAttack.png';
import healIndicate from './assets/indicators/healIndicate.png';

import prePushIndicate from './assets/indicators/prePush.png';
import canPushIndicate from './assets/indicators/canPush.png';
import noPushingIndicate from './assets/indicators/noPushing.png';
import pushingIndicate from './assets/indicators/pushing.png';
import prePullIndicate from './assets/indicators/prePull.png';
import canPullIndicate from './assets/indicators/canPull.png';
import noPullingIndicate from './assets/indicators/noPulling.png';
import pullingIndicate from './assets/indicators/pulling.png';
import pushedPulledIndicate from './assets/indicators/pushedPulled.png';
import unbreakableIndicate from './assets/indicators/unbreakable.png';
import attackFeintIndicate from './assets/indicators/attackFeint.png';
import attackFeintIndicate2 from './assets/indicators/attackFeint2.png';
import defendFeintIndicate from './assets/indicators/defendFeint.png';
import defendFeintIndicate2 from './assets/indicators/defendFeint2.png';


import defendFeintIndicate3 from './assets/indicators/defendFeint3.png';
import attackFeintIndicate3 from './assets/indicators/attackFeint3.png';
import dodgeFeintIndicate from './assets/indicators/dodgeFeint.png';
import dodgeFeintIndicate2 from './assets/indicators/dodgeFeint2.png';

import cellVoidingIndicate from './assets/indicators/cellVoiding.png';
import cellVoidingIndicate2 from './assets/indicators/cellVoiding2.png';
import boltDefendIndicate2 from './assets/indicators/boltDefend2.png';
import flankIndicate2 from './assets/indicators/flanking2.png';
import noFlankIndicate from './assets/indicators/noFlanking.png';


import preAttack2Indicate from './assets/indicators/preAttack2.png';
import preAction1Indicate from './assets/indicators/preAction1.png';
import preAction2Indicate from './assets/indicators/preAction2.png';
import attackBreakIndicate from './assets/indicators/attackBreak.png';
import defendBreakIndicate from './assets/indicators/defendBreak.png';
import boltDefendIndicate from './assets/indicators/boltDefend.png';
import dodgeIndicate from './assets/indicators/dodge.png';
import dodgeIndicate2 from './assets/indicators/dodge2.png';
import fallingIndicate from './assets/indicators/falling.png';
import completeMissionIndicate from './assets/indicators/complete.png';
import flankIndicate from './assets/indicators/flank.png';
import attackBluntIndicate2 from './assets/indicators/blunt2.png';
import enrouteIndicate from './assets/indicators/enroute.png';
import targetSwitchIndicate from './assets/indicators/targetSwitch.png';
import pathSwitchIndicate from './assets/indicators/pathSwitch.svg';
import retreatIndicate from './assets/indicators/retreat.png';
import defendSuccessIndicate from './assets/indicators/defendSuccess.png';
import aggressiveModeIndicate from './assets/indicators/angry.png';
import passiveModeIndicate from './assets/indicators/meditation.png';
import thinkingIndicate from './assets/indicators/mind.png';
import defendMissionIndicate from './assets/indicators/police.png';
import patrolMissionIndicate from './assets/indicators/location.png';
import pursueMissionIndicate from './assets/indicators/treasure-map.png';
import pursueMissionIndicate2 from './assets/indicators/missionPursue.png';
import retrieveMissionIndicate from './assets/indicators/treasure.png';
import drowningIndicate from './assets/indicators/drown.png';
import destroyedItemIndicate from './assets/indicators/destroyedItem.png';
import pickupBuffIndicate from './assets/indicators/pickupBuff.png';
import pickupDebuffIndicate from './assets/indicators/pickupDebuff.png';
import pickupWeaponIndicate from './assets/indicators/pickupWeapon.png';
import dropWeaponIndicate from './assets/indicators/dropWeapon.png';
import dropArmorIndicate from './assets/indicators/dropArmor.png';
import pickupArmorIndicate from './assets/indicators/pickupArmor.png';
import pickupAmmoIndicate from './assets/indicators/pickupAmmo.png';
import terrainSpeedupIndicate from './assets/indicators/terrainSpeedup.png';
import terrainSlowdownIndicate from './assets/indicators/terrainSlowdown.png';
import terrainInjuredIndicate from './assets/indicators/terrainInjured.png';
import outOfStaminaIndicate from './assets/indicators/outOfStamina.png';
import boltKilledIndicate from './assets/indicators/boltKilled.png';
import attackParriedIndicate from './assets/indicators/attackParried.png';
import inventoryFullIndicate from './assets/indicators/inventoryFull.png';
import outOfAmmoIndicate from './assets/indicators/outOfAmmo.png';


import mail1 from './assets/items/mail1.png';
import mail2 from './assets/items/mail2.png';
import mail3 from './assets/items/mail3.png';
import greaves1 from './assets/items/greaves1.png';
import greaves2 from './assets/items/greaves2.png';
import greaves3 from './assets/items/greaves3.png';
import helmet1 from './assets/items/helmet1.png';
import hpUp from './assets/items/hpUp.png';
import hpDown from './assets/items/hpDown.png';
import spdUp from './assets/items/spdUp.png';
import spdDown from './assets/items/spdDown.png';
import strUp from './assets/items/strUp.png';
import strDown from './assets/items/strDown.png';
import focusUp from './assets/items/focusUp.png';
import focusDown from './assets/items/focusDown.png';
import ammo from './assets/items/ammo.png';
import bow from './assets/items/bow.png';
import boltNorth from './assets/items/boltNorth.png';
import boltSouth from './assets/items/boltSouth.png';
import boltEast from './assets/items/boltEast.png';
import boltWest from './assets/items/boltWest.png';
import spear from './assets/items/spear.png';
import sword from './assets/items/sword.png';
import crossbow from './assets/items/crossbow.png';


import playerImgIdleSheet from './assets/sheet1.png';
import player2ImgIdleSheet from './assets/sheet2.png';
import playerComAImgIdleSheet from './assets/sheetComA.png';
import playerComBImgIdleSheet from './assets/sheetComB.png';
import playerImgMoveSheet from './assets/sheetMoving1.png';
import player2ImgMoveSheet from './assets/sheetMoving2.png';
import comAImgMoveSheet from './assets/sheetMovingComA.png';
import comBImgMoveSheet from './assets/sheetMovingComB.png';
import player1DefendSheet from './assets/sheetDefend1.png';
import player2DefendSheet from './assets/sheetDefend2.png';
import comADefendSheet from './assets/sheetDefendComA.png';
import comBDefendSheet from './assets/sheetDefendComB.png';
import player1AttackSheet from './assets/sheetAttack1.png';
import player2AttackSheet from './assets/sheetAttack2.png';
import comAAttackSheet from './assets/sheetAttackComA.png';
import comBAttackSheet from './assets/sheetAttackComB.png';


import './App.css';

import DebugBox from './debugBox'
import Settings from './settings'
import CellInfo from './cellInfo'
import Loading from './loading'
import AiStatus from './aiStatus'
import CameraControl from './cameraControl'

import pointInPolygon from 'point-in-polygon';

class App extends Component {
  state = {
    showSettings: true,
    showAiStatus: false,
    canvas: undefined,
    context: undefined,
    canvas2: undefined,
    context2: undefined,
    canvas3: undefined,
    context3: undefined,
    canvas4: undefined,
    context4: undefined,
    containerInnerClass: 'containerInner',
    sceneY: {
      three: 400,
      six: 300,
      nine: 220,
      twelve: 150,
    },
    loading: true,
    stateUpdater: '',
    settingAiPlayers: 0,
  }

  constructor(props) {
    super(props);
    this.time = 0;

    this.canvasRef = React.createRef();
    this.canvasRef2 = React.createRef();

    // SETTINGS CANVASES
    this.canvasRef3 = React.createRef();
    this.canvasRef4 = React.createRef();

    this.cellInfoBoxRef = React.createRef();

    this.debugBoxStyle = "debugDisplay closedDebug";
    this.debugBoxStyle2 = "debugDisplay2 closedDebug";

    // LEVEL DRAW SETUP
    this.tileColumnOffset = 100; // pixels
    this.tileRowOffset = 50; // pixels
    this.originX = 0; // offset from left
    this.originY = 0; // offset from top
    this.Xtiles = 10;
    this.Ytiles = 10;
    this.showCoordinates = true;
    this.selectedTileX = -1;
    this.selectedTileY = -1;

    this.canvasWidth = 1300;
    this.canvasHeight = 790;

    // this.canvasWidth = 1000;
    // this.canvasHeight = 600;

    this.floorImageWidth = 103;
    this.floorImageHeight = 53;

    this.wallImageWidth = 103;
    this.wallImageHeight = 98;
    this.sceneY = 220;
    this.tileWidth = 50;
    this.gridWidth = 9;

    this.cellCenterOffsetX = 23;
    this.cellCenterOffsetY = 2;


    // '**_*_0.0_a_0**'
    // barrierType(a,b,c)BarrierPosition(n,s,e,w)_obstacle_x.y_terrain_elevationNumber(0,1,2)ElevationType(a,b,c)ElevationPosition(n,s,e,w)

    // GRIND INFO, LEVEL DATA & MAPPING
    this.init = false;
    // this.openVoid = true;
    this.openVoid = false;
    this.cellToVoid = {
      state: false,
      x: 0,
      y: 0,
      count: 0,
      limit: 35,
    };
    this.voidTimer = {
      count: 0,
      limit: 10000,
    }
    this.voidCustomCell = false;
    this.gridInfo = [];
    this.settingsGridInfo = [];
    this.gridInfo2D = [];
    this.gridInfo2 = [];
    this.gridInfo2D2 = [];
    this.levelData = [
      [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
      [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
      [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
      [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
      [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
      [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
      [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
      [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
      [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
      [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
      [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
    ];
    this.levelData12 = {
      row0: ['**_a_0.0_a_0a*','**_*_0.1_a_0a*','**_*_0.2_a_0a*','**_*_0.3_a_0a*','**_*_0.4_a_0a*','**_*_0.5_a_0a*','**_*_0.6_a_0a*','**_*_0.7_a_0a*','**_*_0.8_a_0a*','**_*_0.9_a_0a*','**_*_0.10_a_0a*','**_*_0.11_a_0a*','**_*_0.12_a_0a*'],
      row1: ['**_*_1.0_a_0a*','**_*_1.1_a_0a*','**_*_1.2_a_0a*','**_*_1.3_a_0a*','**_*_1.4_a_0a*','**_*_1.5_a_0a*','**_*_1.6_a_0a*','**_*_1.7_a_0a*','**_*_1.8_a_0a*','**_*_1.9_a_0a*','**_*_1.10_a_0a*','**_*_1.11_a_0a*','**_*_1.12_a_0a*'],
      row2: ['**_*_2.0_a_0a*','**_*_2.1_a_0a*','**_b_2.2_a_0a*','**_*_2.3_a_0a*','**_*_2.4_a_0a*','**_*_2.5_a_0a*','**_*_2.6_a_0a*','**_*_2.7_a_0a*','**_*_2.8_a_0a*','**_*_2.9_a_0a*','**_*_2.10_a_0a*','**_*_2.11_a_0a*','**_*_2.12_a_0a*'],
      row3: ['**_c_3.0_a_0a*','**_*_3.1_a_0a*','**_c_3.2_a_0a*','**_*_3.3_a_0a*','**_*_3.4_a_0a*','**_*_3.5_a_0a*','**_h_3.6_a_0a*','**_*_3.7_a_0a*','**_*_3.8_a_0a*','**_*_3.9_a_0a*','**_*_3.10_a_0a*','**_*_3.11_a_0a*','**_*_3.12_a_0a*'],
      row4: ['**_*_4.0_a_0a*','**_*_4.1_a_0a*','**_*_4.2_a_0a*','**_*_4.3_a_0a*','**_*_4.4_a_0a*','**_*_4.5_a_0a*','**_h_4.6_a_0a*','**_*_4.7_a_0a*','**_*_4.8_a_0a*','**_*_4.9_a_0a*','**_*_4.10_a_0a*','**_*_4.11_a_0a*','**_*_4.12_a_0a*'],
      row5: ['**_*_5.0_a_0a*','**_*_5.1_a_0a*','**_*_5.2_a_0a*','**_*_5.3_a_0a*','**_*_5.4_a_0a*','**_*_5.5_a_0a*','**_*_5.6_a_0a*','**_*_5.7_a_0a*','**_*_5.8_a_0a*','**_*_5.9_a_0a*','**_*_5.10_a_0a*','**_*_5.11_a_0a*','**_*_5.12_a_0a*'],
      row6: ['**_*_6.0_a_0a*','**_*_6.1_a_0a*','**_*_6.2_a_0a*','**_*_6.3_a_0a*','**_*_6.4_a_0a*','**_*_6.5_a_0a*','**_*_6.6_a_0a*','**_*_6.7_a_0a*','**_*_6.8_a_0a*','**_*_6.9_a_0a*','**_*_6.10_a_0a*','**_*_6.11_a_0a*','**_*_6.12_a_0a*'],
      row7: ['**_*_7.0_a_0a*','**_*_7.1_a_0a*','**_*_7.2_a_0a*','**_*_7.3_a_0a*','**_*_7.4_a_0a*','**_*_7.5_a_0a*','**_*_7.6_a_0a*','**_*_7.7_a_0a*','**_*_7.8_a_0a*','**_*_7.9_a_0a*','**_*_7.10_a_0a*','**_*_7.11_a_0a*','**_*_7.12_a_0a*'],
      row8: ['**_*_8.0_a_0a*','**_*_8.1_a_0a*','**_*_8.2_a_0a*','**_*_8.3_a_0a*','**_*_8.4_a_0a*','**_*_8.5_a_0a*','**_*_8.6_a_0a*','**_*_8.7_a_0a*','**_*_8.8_a_0a*','**_*_8.9_a_0a*','**_*_8.10_a_0a*','**_*_8.11_a_0a*','**_*_8.12_a_0a*'],
      row9: ['**_*_9.0_a_0a*','**_*_9.1_a_0a*','**_*_9.2_a_0a*','**_*_9.3_a_0a*','**_*_9.4_a_0a*','**_*_9.5_a_0a*','**_*_9.6_a_0a*','**_*_9.7_a_0a*','**_*_9.8_a_0a*','**_*_9.9_a_0a*','**_*_9.10_a_0a*','**_*_9.11_a_0a*','**_*_9.12_a_0a*'],
      row10: ['**_*_10.0_a_0a*','**_*_10.1_a_0a*','**_*_10.2_a_0a*','**_*_10.3_a_0a*','**_*_10.4_a_0a*','**_*_10.5_a_0a*','**_*_10.6_a_0a*','**_*_10.7_a_0a*','**_*_10.8_a_0a*','**_*_10.9_a_0a*','**_*_10.10_a_0a*','**_*_10.11_a_0a*','**_*_10.12_a_0a*'],
      row11: ['**_*_11.0_a_0a*','**_*_11.1_a_0a*','**_*_11.2_a_0a*','**_*_11.3_a_0a*','**_*_11.4_a_0a*','**_*_11.5_a_0a*','**_*_11.6_a_0a*','**_*_11.7_a_0a*','**_*_11.8_a_0a*','**_*_11.9_a_0a*','**_*_11.10_a_0a*','**_*_11.11_a_0a*','**_*_11.12_a_0a*'],
      row12: ['**_*_12.0_a_0a*','**_*_12.1_a_0a*','**_*_12.2_a_0a*','**_*_12.3_a_0a*','**_*_12.4_a_0a*','**_*_12.5_a_0a*','**_*_12.6_a_0a*','**_*_12.7_a_0a*','**_*_12.8_a_0a*','**_*_12.9_a_0a*','**_*_12.10_a_0a*','**_*_12.11_a_0a*','**_*_12.12_a_0a*'],
    };
    this.levelData9 = {
      row0: ['**_a_0.0_a_0a*','**_i_0.1_a_0a*','**_*_0.2_a_0a*','cw_*_0.3_a_0a*','cw_h_0.4_a_0a*','cw_*_0.5_a_0a*','**_*_0.6_a_0a*','**_i_0.7_a_0a*','**_*_0.8_h_0a*','**_*_0.9_h_0a*'],
      row1: ['**_*_1.0_a_0a*','**_*_1.1_a_0a*','**_*_1.2_a_0a*','**_*_1.3_a_0a*','**_*_1.4_a_0a*','**_*_1.5_a_0a*','**_*_1.6_a_0a*','**_*_1.7_a_0a*','**_*_1.8_a_0a*','**_*_1.9_a_0a*'],
      row2: ['**_*_2.0_a_0a*','**_*_2.1_a_0a*','**_*_2.2_a_0a*','**_*_2.3_a_0a*','**_c_2.4_a_0a*','**_*_2.5_a_0a*','**_*_2.6_a_0a*','**_*_2.7_a_0a*','**_*_2.8_a_0a*','**_*_2.9_a_0a*'],
      row3: ['**_c_3.0_a_0a*','**_*_3.1_a_0a*','**_h_3.2_a_0a*','**_h_3.3_a_0a*','**_h_3.4_a_0a*','**_*_3.5_a_0a*','**_*_3.6_a_0a*','**_*_3.7_a_0a*','**_*_3.8_a_0a*','**_a_3.9_a_0a*'],
      row4: ['**_*_4.0_a_0a*','**_*_4.1_a_0a*','**_*_4.2_f_0a*','**_c_4.3_f_0a*','**_*_4.4_a_0a*','**_*_4.5_a_0a*','**_*_4.6_g_0a*','**_*_4.7_a_0a*','**_*_4.8_a_0a*','**_*_4.9_a_0a*'],
      row5: ['**_*_5.0_a_0a*','**_*_5.1_a_0a*','**_*_5.2_f_0a*','**_*_5.3_f_0a*','**_*_5.4_k_0a*','**_*_5.5_a_0a*','**_*_5.6_g_0a*','**_*_5.7_a_0a*','**_*_5.8_a_0a*','**_*_5.9_a_0a*'],
      row6: ['**_*_6.0_j_0a*','**_*_6.1_j_0a*','**_*_6.2_b_0a*','**_*_6.3_j_0a*','**_*_6.4_j_0a*','**_*_6.5_j_0a*','**_*_6.6_j_0a*','**_*_6.7_b_0a*','**_*_6.8_j_0a*','**_*_6.9_d_0a*'],
      row7: ['**_*_7.0_j_0a*','**_*_7.1_j_0a*','**_*_7.2_j_0a*','**_*_7.3_j_0a*','**_*_7.4_j_0a*','**_*_7.5_a_0a*','**_c_7.6_a_0a*','**_*_7.7_a_0a*','**_*_7.8_a_0a*','**_*_7.9_d_0a*'],
      row8: ['**_*_8.0_a_0a*','**_*_8.1_a_0a*','**_*_8.2_a_0a*','**_*_8.3_a_0a*','**_*_8.4_a_0a*','**_*_8.5_a_0a*','**_c_8.6_a_0a*','**_*_8.7_a_0a*','**_*_8.8_a_0a*','**_*_8.9_d_0a*'],
      row9: ['**_*_9.0_a_0a*','**_a_9.1_a_0a*','**_*_9.2_a_0a*','**_*_9.3_a_0a*','**_*_9.4_a_0a*','**_*_9.5_a_0a*','**_*_9.6_a_0a*','**_*_9.7_a_0a*','**_*_9.8_a_0a*','**_*_9.9_a_0a*'],
    };
    this.levelData6 = {
      row0: ['**_a_0.0_a_0a*','**_*_0.1_a_0a*','**_*_0.2_a_0a*','**_*_0.3_a_0a*','**_*_0.4_a_0a*','**_*_0.5_a_0a*','**_*_0.6_a_0a*'],
      row1: ['**_*_1.0_a_0a*','**_*_1.1_a_0a*','**_*_1.2_a_0a*','**_*_1.3_a_0a*','**_*_1.4_a_0a*','**_*_1.5_a_0a*','**_*_1.6_a_0a*'],
      row2: ['**_h_2.0_a_0a*','**_*_2.1_j_0a*','**_*_2.2_j_0a*','**_*_2.3_j_0a*','**_*_2.4_j_0a*','**_*_2.5_j_0a*','**_*_2.6_a_0a*'],
      row3: ['**_h_3.0_a_0a*','**_*_3.1_j_0a*','**_*_3.2_b_0a*','**_*_3.3_j_0a*','**_*_3.4_b_0a*','**_*_3.5_j_0a*','**_*_3.6_a_0a*'],
      row4: ['**_*_4.0_a_0a*','**_*_4.1_j_0a*','**_*_4.2_j_0a*','**_*_4.3_j_0a*','**_*_4.4_j_0a*','**_*_4.5_j_0a*','**_*_4.6_a_0a*'],
      row5: ['**_*_5.0_a_0a*','**_*_5.1_a_0a*','**_*_5.2_a_0a*','**_*_5.3_a_0a*','**_*_5.4_a_0a*','**_*_5.5_a_0a*','**_*_5.6_a_0a*'],
      row6: ['**_*_6.0_a_0a*','**_*_6.1_a_0a*','**_*_6.2_a_0a*','**_*_6.3_a_0a*','**_*_6.4_a_0a*','**_*_6.5_a_0a*','**_*_6.6_a_0a*'],
    };
    this.levelData3 = {
      row0: ['**_a_0.0_a_0a*','**_*_0.1_a_0a*','**_*_0.2_a_0a*','**_*_0.3_a_0a*'],
      row1: ['**_*_1.0_a_0a*','**_*_1.1_a_0a*','**_*_1.2_a_0a*','**_*_1.3_a_0a*'],
      row2: ['**_*_2.0_a_0a*','**_*_2.1_a_0a*','**_b_2.2_a_0a*','**_*_2.3_a_0a*'],
      row3: ['**_h_3.0_a_0a*','**_*_3.1_a_0a*','**_h_3.2_a_0a*','**_*_3.3_a_0a*'],
    };
    // this.levelData3 = {
    //   row0: ['x00x','x01x','x02x','x03x'],
    //   row1: ['x10x','x11x','x12x','x13x'],
    //   row2: ['x20x','x21x','x22x','y23x'],
    //   row3: ['z30x','x31x','x32x','x33x'],
    // };
    this.terrainLevelDataRef = {
      a:{
        name: 'grass',
        type: 'grass',
        effect: '',
      },
      b:{
        name: 'stone',
        type: 'road',
        effect: '',
      },
      c:{
        name: 'dirt',
        type: 'road',
        effect: '',
      },
      d:{
        name: 'pond',
        type: 'shallow',
        effect: '',
      },
      e:{
        name: 'mud',
        type: 'sticky',
        effect: '',
      },
      f:{
        name: 'sand',
        type: 'sticky',
        effect: '',
      },
      g:{
        name: 'ice',
        type: 'slippery',
        effect: '',
      },
      h:{
        name: 'lava',
        type: 'hazard',
        effect: '',
      },
      i:{
        name: 'bramble',
        type: 'hazard',
        effect: '',
      },
      j:{
        name: 'river',
        type: 'deep',
        effect: '',
      },
      k:{
        name: 'void',
        type: 'void',
        effect: 'void',
      },
    }
    this.terrainMoveSpeedRef = {
      shallow: .1,
      sticky: .05,
      slippery: .2,
    };



    // OBSTACLES HAVE MAX 5 ITEMS
    this.obstacleLevelDataRef = {
      a: {
        state: true,
        name: 'chest1',
        type: 'chest',
        hp: 5,
        destructible: {
          state: true,
          weapons: ['sword1','spear1'],
          leaveRubble: false,
        },
        locked: {
          state: false,
          key: '',
        },
        weight: 1,
        height: 0.5,
        items: [],
        effects: [],
        moving: {
          state: false,
          step: 0,
          origin: {
            number: {
              x: undefined,
              y: undefined,
            },
            center: {
              x: undefined,
              y: undefined,
            },
          },
          destination: {
            number: {
              x: undefined,
              y: undefined,
            },
            center: {
              x: undefined,
              y: undefined,
            },
          },
          currentPosition: {
            x: undefined,
            y: undefined,
          },
          nextPosition: {
            x: undefined,
            y: undefined,
          },
          moveSpeed: 0,
          pushable: true,
          pushed: false,
          pusher: undefined,
          falling: {
            state: false,
            count: 0,
            limit: 25,
          },
        }
      },
      b: {
        state: true,
        name: 'table1',
        type: 'table',
        hp: 1,
        destructible: {
          state: true,
          weapons: ['sword1','bolt','spear1'],
          leaveRubble: false,
        },
        locked: {
          state: false,
          key: '',
        },
        weight: 1,
        height: 0.5,
        items: [{
          name: 'sword1',
          type: 'weapon',
          subType: 'sword',
          effect: '',
        }],
        effects: [],
        moving: {
          state: false,
          step: 0,
          origin: {
            number: {
              x: undefined,
              y: undefined,
            },
            center: {
              x: undefined,
              y: undefined,
            },
          },
          destination: {
            number: {
              x: undefined,
              y: undefined,
            },
            center: {
              x: undefined,
              y: undefined,
            },
          },
          currentPosition: {
            x: undefined,
            y: undefined,
          },
          nextPosition: {
            x: undefined,
            y: undefined,
          },
          moveSpeed: 0,
          pushable: true,
          pushed: false,
          pusher: undefined,
          falling: {
            state: false,
            count: 0,
            limit: 25,
          },
        }
      },
      c: {
        state: true,
        name: 'closet1',
        type: 'barrel',
        hp: 2,
        destructible: {
          state: true,
          weapons: ['sword1','bolt','spear1'],
          leaveRubble: true,
        },
        locked: {
          state: false,
          key: '',
        },
        weight: .5,
        height: 1,
        items: [{
          name: 'hpUp',
          type: 'item',
          subType: '',
          effect: 'hpUp',
        },
        {
          name: 'sword1',
          type: 'weapon',
          subType: 'sword',
          effect: '',
        }],
        effects: [],
        moving: {
          state: false,
          step: 0,
          origin: {
            number: {
              x: undefined,
              y: undefined,
            },
            center: {
              x: undefined,
              y: undefined,
            },
          },
          destination: {
            number: {
              x: undefined,
              y: undefined,
            },
            center: {
              x: undefined,
              y: undefined,
            },
          },
          currentPosition: {
            x: undefined,
            y: undefined,
          },
          nextPosition: {
            x: undefined,
            y: undefined,
          },
          moveSpeed: 0,
          pushable: true,
          pushed: false,
          pusher: undefined,
          falling: {
            state: false,
            count: 0,
            limit: 25,
          },
        }
      },
      d: {
        state: true,
        name: 'chair1',
        type: 'chair',
        hp: 2,
        destructible: {
          state: true,
          weapons: ['sword1'],
          leaveRubble: false,
        },
        locked: {
          state: false,
          key: '',
        },
        weight: 1,
        height: 0.5,
        items: [],
        effects: [],
        moving: {
          state: false,
          step: 0,
          origin: {
            number: {
              x: undefined,
              y: undefined,
            },
            center: {
              x: undefined,
              y: undefined,
            },
          },
          destination: {
            number: {
              x: undefined,
              y: undefined,
            },
            center: {
              x: undefined,
              y: undefined,
            },
          },
          currentPosition: {
            x: undefined,
            y: undefined,
          },
          nextPosition: {
            x: undefined,
            y: undefined,
          },
          moveSpeed: 0,
          pushable: true,
          pushed: false,
          pusher: undefined,
          falling: {
            state: false,
            count: 0,
            limit: 25,
          },
        }
      },
      e: {
        state: true,
        name: 'shelf1',
        type: 'shelf',
        hp: 2,
        destructible: {
          state: true,
          weapons: ['sword1'],
          leaveRubble: false,
        },
        locked: {
          state: false,
          key: '',
        },
        weight: 1,
        height: 1,
        items: [],
        effects: [],
        moving: {
          state: false,
          step: 0,
          origin: {
            number: {
              x: undefined,
              y: undefined,
            },
            center: {
              x: undefined,
              y: undefined,
            },
          },
          destination: {
            number: {
              x: undefined,
              y: undefined,
            },
            center: {
              x: undefined,
              y: undefined,
            },
          },
          currentPosition: {
            x: undefined,
            y: undefined,
          },
          nextPosition: {
            x: undefined,
            y: undefined,
          },
          moveSpeed: 0,
          pushable: true,
          pushed: false,
          pusher: undefined,
          falling: {
            state: false,
            count: 0,
            limit: 25,
          },
        }
      },
      f: {
        state: true,
        name: 'counter1',
        type: 'counter',
        hp: 2,
        destructible: {
          state: true,
          weapons: ['sword1'],
          leaveRubble: false,
        },
        locked: {
          state: false,
          key: '',
        },
        weight: 1,
        height: 0.5,
        items: [],
        effects: [],
        moving: {
          state: false,
          step: 0,
          origin: {
            number: {
              x: undefined,
              y: undefined,
            },
            center: {
              x: undefined,
              y: undefined,
            },
          },
          destination: {
            number: {
              x: undefined,
              y: undefined,
            },
            center: {
              x: undefined,
              y: undefined,
            },
          },
          currentPosition: {
            x: undefined,
            y: undefined,
          },
          nextPosition: {
            x: undefined,
            y: undefined,
          },
          moveSpeed: 0,
          pushable: true,
          pushed: false,
          pusher: undefined,
          falling: {
            state: false,
            count: 0,
            limit: 25,
          },
        }
      },
      g: {
        state: true,
        name: 'smallBox1',
        type: 'smallBox',
        hp: 2,
        destructible: {
          state: true,
          weapons: ['sword1'],
          leaveRubble: false,
        },
        locked: {
          state: false,
          key: '',
        },
        weight: 1,
        height: 0.5,
        items: [],
        effects: [],
        moving: {
          state: false,
          step: 0,
          origin: {
            number: {
              x: undefined,
              y: undefined,
            },
            center: {
              x: undefined,
              y: undefined,
            },
          },
          destination: {
            number: {
              x: undefined,
              y: undefined,
            },
            center: {
              x: undefined,
              y: undefined,
            },
          },
          currentPosition: {
            x: undefined,
            y: undefined,
          },
          nextPosition: {
            x: undefined,
            y: undefined,
          },
          moveSpeed: 0,
          pushable: true,
          pushed: false,
          pusher: undefined,
          falling: {
            state: false,
            count: 0,
            limit: 25,
          },
        }
      },
      h: {
        state: true,
        name: 'largeBox1',
        type: 'largeBox',
        hp: 2,
        destructible: {
          state: false,
          weapons: ['sword1'],
          leaveRubble: false,
        },
        locked: {
          state: false,
          key: '',
        },
        weight: 1,
        height: 1,
        items: [],
        effects: [],
        moving: {
          state: false,
          step: 0,
          origin: {
            number: {
              x: undefined,
              y: undefined,
            },
            center: {
              x: undefined,
              y: undefined,
            },
          },
          destination: {
            number: {
              x: undefined,
              y: undefined,
            },
            center: {
              x: undefined,
              y: undefined,
            },
          },
          currentPosition: {
            x: undefined,
            y: undefined,
          },
          nextPosition: {
            x: undefined,
            y: undefined,
          },
          moveSpeed: 0,
          pushable: true,
          pushed: false,
          pusher: undefined,
          falling: {
            state: false,
            count: 0,
            limit: 25,
          },
        }
      },
      i: {
        state: true,
        name: 'closet2',
        type: 'barrel',
        hp: 2,
        destructible: {
          state: true,
          weapons: ['sword1','bolt','spear1'],
          leaveRubble: true,
        },
        locked: {
          state: false,
          key: '',
        },
        weight: 1,
        height: 1,
        items: [
          {
            name: 'hpUp',
            type: 'item',
            subType: '',
            effect: 'hpUp',
          },
          {
            name: 'sword1',
            type: 'weapon',
            subType: 'sword',
            effect: '',
          },
          {
            name: 'spear1',
            type: 'weapon',
            subType: 'spear',
            effect: '',
          },
          {
            name: 'crossbow1',
            type: 'weapon',
            subType: 'crossbow',
            effect: 'ammo+5',
          },
          {
            name: 'ironPlate',
            type: 'armor',
            subType: 'mail',
            effect: 'hpUp',
          },
          {
            name: 'ammo10',
            type: 'item',
            subType: '',
            effect: '',
          },
        ],
        effects: [],
        moving: {
          state: false,
          step: 0,
          origin: {
            number: {
              x: undefined,
              y: undefined,
            },
            center: {
              x: undefined,
              y: undefined,
            },
          },
          destination: {
            number: {
              x: undefined,
              y: undefined,
            },
            center: {
              x: undefined,
              y: undefined,
            },
          },
          currentPosition: {
            x: undefined,
            y: undefined,
          },
          nextPosition: {
            x: undefined,
            y: undefined,
          },
          moveSpeed: 0,
          pushable: true,
          pushed: false,
          pusher: undefined,
          falling: {
            state: false,
            count: 0,
            limit: 25,
          },
        }
      },
    };
    this.barrierLevelDataRef = {
      a: {
        state: true,
        name: 'wall1',
        type: 'wall',
        hp: 2,
        destructible: {
          state: false,
          weapons: [],
          leaveRubble: false,
        },
        locked: {
          state: false,
          key: '',
        },
        position: '',
        height: 1,
      },
      b: {
        state: true,
        name: 'door1',
        type: 'door',
        hp: 3,
        destructible: {
          state: true,
          weapons: ['sword1'],
          leaveRubble: false,
        },
        locked: {
          state: false,
          key: '',
        },
        position: '',
        height: 1,
      },
      c: {
        state: true,
        name: 'balcony1',
        type: 'balcony',
        hp: 2,
        destructible: {
          state: true,
          weapons: ['sword1','spear1','bolt'],
          leaveRubble: true,
        },
        locked: {
          state: false,
          key: '',
        },
        position: '',
        height: 1,
      },
    };
    this.elevationTypeLevelDataRef = {
      a: 'floor',
      b: 'step',
      c: 'ramp',
    };
    this.pathArray = [];


    // ITEMS
    this.itemList = [
      {
        name: 'moveSpeedUp',
        amount: 5,
        total: 5,
        type: 'item',
        effect: 'speedUp',
      },
      {
        name: 'moveSpeedDown',
        amount: 5,
        total: 5,
        type: 'item',
        effect: 'speedDown',
      },
      {
        name: 'hpUp',
        amount: 4,
        total: 4,
        type: 'item',
        effect: 'hpUp',
      },
      {
        name: 'hpDown',
        amount: 4,
        total: 4,
        type: 'item',
        effect: 'hpDown',
      },
      {
        name: 'focusUp',
        amount: 4,
        total: 4,
        type: 'item',
        effect: 'focusUp',
      },
      {
        name: 'focusDown',
        amount: 4,
        total: 4,
        type: 'item',
        effect: 'focusDown',
      },
      {
        name: 'strengthUp',
        amount: 4,
        total: 4,
        type: 'item',
        effect: 'strengthUp',
      },
      {
        name: 'strengthDown',
        amount: 4,
        total: 4,
        type: 'item',
        effect: 'strengthDown',
      },
      {
        name: 'spear1',
        amount: 3,
        total: 3,
        type: 'weapon',
        subType: 'spear',
        effect: '',
      },
      {
        name: 'sword1',
        amount: 2,
        total: 2,
        type: 'weapon',
        subType: 'sword',
        effect: '',
      },
      {
        name: 'sword2',
        amount: 2,
        total: 2,
        type: 'weapon',
        subType: 'sword',
        effect: '',
      },
      {
        name: 'crossbow1',
        amount: 2,
        total: 2,
        type: 'weapon',
        subType: 'crossbow',
        effect: 'ammo+5',
      },
      {
        name: 'crossbow2',
        amount: 2,
        total: 2,
        type: 'weapon',
        subType: 'crossbow',
        effect: 'ammo+0',
      },
      {
        name: 'helmet1',
        amount: 3,
        total: 3,
        type: 'armor',
        subType: 'helmet',
        effect: '+10',
      },
      {
        name: 'ironPlate',
        amount: 2,
        total: 2,
        type: 'armor',
        subType: 'mail',
        effect: 'hpUp',
      },
      {
        name: 'ninjaGi',
        amount: 2,
        total: 2,
        type: 'armor',
        subType: 'mail',
        effect: 'snghit-5',
      },
      {
        name: 'ghostMail',
        amount: 1,
        total: 1,
        type: 'armor',
        subType: 'mail',
        effect: 'snghit-10',
      },
      {
        name: 'speedGreaves',
        amount: 2,
        total: 2,
        type: 'armor',
        subType: 'greaves',
        effect: 'speedUp',
      },
      {
        name: 'ammo5',
        amount: 4,
        total: 4,
        type: 'item',
        effect: '',
      },
      {
        name: 'ammo10',
        amount: 2,
        total: 2,
        type: 'item',
        effect: '',
      },
    ];
    this.disableInitItems = true;
    this.initItemList = [
      // {
      //   name: 'moveSpeedUp',
      //   type: 'item',
      //   effect: 'speedUp',
      // },
      // {
      //   name: 'moveSpeedDown',
      //   type: 'item',
      //   effect: 'speedDown',
      // },

      {
        name: 'ammo5',
        type: 'item',
        effect: '',
      },
      // {
      //   name: 'ammo10',
      //   type: 'item',
      //   effect: '',
      // },
      {
        name: 'hpUp',
        type: 'item',
        effect: 'hpUp',
      },
      // {
      //   name: 'hpDown',
      //   type: 'item',
      //   effect: 'hpDown',
      // },
      {
        name: 'spear1',
        type: 'weapon',
        subType: 'spear',
        effect: '',
      },
      // {
      //   name: 'sword2',
      //   type: 'weapon',
      //   subType: 'sword',
      //   effect: '',
      // },
      {
        name: 'crossbow1',
        type: 'weapon',
        subType: 'crossbow',
        effect: 'ammo+10',
      },
      // {
      //   name: 'ghostMail',
      //   type: 'armor',
      //   subType: 'mail',
      //   effect: 'snghit-5',
      // },
      {
        name: 'speedGreaves',
        type: 'armor',
        subType: 'greaves',
        effect: 'speedUp',
      },
      {
        name: 'ironPlate',
        type: 'armor',
        subType: 'mail',
        effect: 'hpUp',
      },
      // {
      //   name: 'helmet1',
      //   type: 'armor',
      //   subType: 'helmet',
      //   effect: '+10',
      // },
      // {
      //   name: 'helmet2',
      //   type: 'armor',
      //   subType: 'helmet',
      //   effect: '',
      // },
      {
        name: 'strengthUp',
        type: 'item',
        effect: 'strengthUp',
      },
      {
        name: 'strengthUp',
        type: 'item',
        effect: 'strengthUp',
      },
      // {
      //   name: 'hpUp',
      //   type: 'item',
      //   effect: 'hpUp',
      // },
      {
        name: 'strengthUp',
        type: 'item',
        effect: 'strengthUp',
      },
      {
        name: 'strengthUp',
        type: 'item',
        effect: 'strengthUp',
      },
    ];
    this.customItemPlacement = {
      state: true,
      cells: [
        {x:0 ,y:9 },
        {x:0 ,y:8 },
        {x:0 ,y:7 },
        {x:0 ,y:6 },
        {x:1 ,y:9 },
        {x:1 ,y:8 },
        {x:1 ,y:7 },
        {x:1 ,y:6 },
        {x:2 ,y:9 },
        {x:2 ,y:8 },
        {x:2 ,y:7 },
        {x:2 ,y:6 },
        {x:5 ,y:6 },
        {x:6 ,y:6 },
        {x:6 ,y:6 },
      ]
    };


    // PLAYER
    this.playerNumber = 2;
    this.currentPlayer = 1;
    this.players = [
      {
        number: 1,
        startPosition: {
          cell: {
            number: {
              x: 2,
              y: 5,
            },
            center: {
              x: 0,
              y: 0,
            }
          }
        },
        currentPosition: {
          cell: {
            number: {
              x: 0,
              y: 0,
            },
            center: {
              x: 0,
              y: 0,
            }
          }
        },
        nextPosition: {
          x: 0,
          y: 0,
        },
        target: {
          cell1: {
            number: {
              x: 0,
              y: 0,
            },
            center: {
              x: 0,
              y: 0,
            },
            free: true,
            occupant: {
              type: '',
              player: '',
            },
            void: false,
          },
          cell2: {
            number: {
              x: 0,
              y: 0,
            },
            center: {
              x: 0,
              y: 0,
            },
            free: true,
            occupant: {
              type: '',
              player: '',
            },
            void: false,
          },
          myCellBlock: false,
        },
        direction: 'south',
        turning: {
          state: false,
          toDirection: '',
          delayCount: 0,
          limit: 5.1,
        },
        turnCheckerDirection: '',
        action: 'idle',
        moving: {
          state: false,
          step: 0,
          course: '',
          origin: {
            number: {
              x: 0,
              y: 0,
            },
            center: {
              x: 0,
              y: 0,
            },
          },
          destination: {
            x: 0,
            y: 0,
          }
        },
        newMoveDelay: {
          state: false,
          count: 0,
          limit: 7,
        },
        strafing: {
          state: false,
          direction: '',
        },
        strafeReleaseHook: false,
        flanking: {
          checking: false,
          preFlankDirection: '',
          direction: '',
          state: false,
          step: 0,
          target1: {x:0 ,y:0},
          target2: {x:0 ,y:0},
        },
        drowning: false,
        attacking: {
          state: false,
          count: 0,
          limit: 20,
        },
        attackStrength: 0,
        attackPeak: false,
        defendPeak: false,
        bluntAttack: false,
        clashing: {
          state: false,
          count: 0,
          limit: 10,
        },
        dodging: {
          countState: false,
          state: false,
          count: 0,
          limit: 20,
          peak: {
            start: 7,
            end: 12,
          }
        },
        dodgeDirection: '',
        jumping: {
          checking: false,
          state: false,
        },
        success: {
          attackSuccess: {
            state: false,
            count: 0,
            limit: 10,
          },
          defendSuccess: {
            state: false,
            count: 0,
            limit: 10,
          },
          deflected: {
            state: false,
            count: 0,
            limit: 20,
            predeflect: false,
            type: '',
          }
        },
        pushBack: {
          state: false,
          prePushBackMoveSpeed: 0,
        },
        halfPushBack: {
          state: false,
          direction: "",
          type: "",
          countUp: {
            state: true,
            count: 0,
            limit: 0,
          },
          countDown: {
            state: false,
            count: 0,
            limit: 0,
          },
          coords: {
            x: undefined,
            y: undefined,
          },
        },
        defending: {
          state: false,
          count: 0,
          limit: 4,
        },
        defendDecay: {
          state: false,
          count: 0,
          limit: 25,
        },
        falling: {
          state: false,
          count: 0,
          limit: 10,
        },
        dead: {
          state: false,
          count: 0,
          limit: 10
        },
        ghost: {
          state: false,
          position: {
            cell: {
              number: {
                x: 0,
                y: 0,
              },
              center: {
                x: 0,
                y: 0,
              }
            }
          }
        },
        respawn: false,
        points: 0,
        speed: {
          move: .1,
          range: [.05,.1,.125,.2]
        },
        terrainMoveSpeed: {
          state: false,
          speed: 0,
        },
        hp: 2,
        currentWeapon: {
          name: 'sword1',
          type: 'sword',
          effect: '',
        },
        currentArmor: {
          name: '',
          type: '',
          effect: '',
        },
        items: {
          weaponIndex: 0,
          armorIndex: 0,
          weapons: [
            {
              name: 'sword1',
              type: 'sword',
              effect: '',
            },
          ],
          armor: [

          ],
          ammo: 20,
        },
        inventorySize: 4,
        cycleWeapon: {
          state: false,
          count: 0,
          limit: 3,
        },
        cycleArmor: {
          state: false,
          count: 0,
          limit: 3,
        },
        crits: {
          singleHit: 1,
          doubleHit: 6,
          pushBack: 4,
          guardBreak: 3,
          dodge: 0,
        },
        statusDisplay: {
          state: false,
          status: '',
          count: 0,
          limit: 15,
        },
        popups: [{
          state: true,
          count: 0,
          limit: 0,
          type: '',
          position: 'northWest',
          msg: '',
          img: '',
        }],
        itemDrop: {
          state: false,
          count: 0,
          limit: 10,
          item: {
            name: '',
          },
          gear: {
            type: '',
          }
        },
        itemPickup: {
          state: false,
          count: 0,
          limit: 10,
          item: {
            name: '',
          },
          gear: {
            type: '',
          }
        },
        discardGear:{
          state: false,
          count: 0,
          limit: 8,
        },
        idleAnim: {
          state: false,
          count: 0,
          limit: 5,
        },
        ai: {
          state: false,
          imgType: '',
          primaryMission: '',
          mission: '',
          prevMission: '',
          currentObjective: '',
          targetSet: false,
          targetAcquired: false,
          safeRange: true,
          pathArray: [],
          targetPlayer: {
            number: 1,
            currentPosition: {
              x: undefined,
              y: undefined,
            },
            target: {
              number1: {
                x: undefined,
                y: undefined,
              },
              number2: {
                x: undefined,
                y: undefined,
              },
            },
            action: '',
          },
          instructions: [],
          currentInstruction: 0,
          resetInstructions: false,
          patrolling: {
            checkin: undefined,
            state: false,
            area: [],
            loopControl: false,
          },
          defending: {
            checkin: undefined,
            state: false,
            area: [],
          },
          persuing: {
            state: false,
          },
          engaging: {
            state: true,
            targetAction: '',
          },
          retrieving: {
            checkin: undefined,
            state: false,
            point: {x: undefined, y: undefined},
            targetItem: {
              name: '',
              type: '',
              subType: '',
              effect: ''
            },
            safe: true,
          },
          retreating: {
            checkin: undefined,
            state: false,
            point: {x: undefined, y: undefined},
            level: 0,
            safe: true,
          },
          organizing: {
            weaponPriorityIndex: 0,
            armorPriorityIndex: 0,
            dropped: {
              state: false,
              gear: {
                name: '',
                type: '',
                subType: '',
                effect: ''
              },
            },
          },
          mode: '',
          upgradeWeapon: false,
          upgradeArmor: false,
          pathfindingRanges: {
            spear: 3,
            crossbow: 5,
          }
        },
        stamina: {
          current: 20,
          max: 20,
        },
        newPushPullDelay: {
          state: false,
          count: 0,
          limit: 10,
        },
        prePush: {
          state: false,
          count: 0,
          limit: 15,
          targetCell: undefined,
          direction: "",
          pusher: undefined,
        },
        pushing: {
          state: false,
          targetCell: undefined,
          moveSpeed: 0,
        },
        prePull: {
          state: false,
          count: 0,
          limit: 15,
          targetCell: undefined,
          direction: "",
          puller: undefined,
        },
        pulling: {
          state: false,
          targetCell: undefined,
          moveSpeed: 0,
        },
        postPull: {
          state: false,
          count: 0,
          limit: 10,
        },
        pushed: {
          state: false,
          pusher: 0,
          moveSpeed: 0,
        },
        pulled: {
          state: false,
          puller: 0,
          moveSpeed: 0,
        },
        elasticCounter: {
          preState: false,
          state: false,
          direction: "",
          type: "",
          subType: "",
          countUp: {
            state: false,
            count: 0,
            limit: 6,
          },
          countDown: {
            state: false,
            count: 0,
            limit: 6,
          },
          coords: {
            x: undefined,
            y: undefined,
          },
          pause: {
            preState: false,
            state: false,
            type: "",
            count: 0,
            limit: 6,
          },
        },
        team: 'Red',
        input: 'Keyboard',
      },
      {
        number: 2,
        startPosition: {
          cell: {
            number: {
              x: 1,
              y: 2,
            },
            center: {
              x: 0,
              y: 0,
            }
          }
        },
        currentPosition: {
          cell: {
            number: {
              x: 0,
              y: 0,
            },
            center: {
              x: 0,
              y: 0,
            }
          }
        },
        nextPosition: {
          x: 0,
          y: 0,
        },
        target: {
          cell1: {
            number: {
              x: 0,
              y: 0,
            },
            center: {
              x: 0,
              y: 0,
            },
            free: true,
            occupant: {
              type: '',
              player: '',
            },
            void: false,
          },
          cell2: {
            number: {
              x: 0,
              y: 0,
            },
            center: {
              x: 0,
              y: 0,
            },
            free: true,
            occupant: {
              type: '',
              player: '',
            },
            void: false,
          },
          myCellBlock: false,
        },
        direction: 'west',
        turning: {
          state: false,
          toDirection: '',
          delayCount: 0,
          limit: 5.1,
        },
        turnCheckerDirection: '',
        action: 'idle',
        moving: {
          state: false,
          step: 0,
          course: '',
          origin: {
            number: {
              x: 0,
              y: 0,
            },
            center: {
              x: 0,
              y: 0,
            },
          },
          destination: {
            x: 0,
            y: 0,
          }
        },
        newMoveDelay: {
          state: false,
          count: 0,
          limit: 7,
        },
        strafing: {
          state: false,
          direction: '',
        },
        strafeReleaseHook: false,
        flanking: {
          checking: false,
          preFlankDirection: '',
          direction: '',
          state: false,
          step: 0,
          target1: {x:0 ,y:0},
          target2: {x:0 ,y:0},
        },
        drowning: false,
        attacking: {
          state: false,
          count: 0,
          limit: 20,
        },
        attackStrength: 0,
        attackPeak: false,
        defendPeak: false,
        bluntAttack: false,
        clashing: {
          state: false,
          count: 0,
          limit: 10,
        },
        dodging: {
          countState: false,
          state: false,
          count: 0,
          limit: 20,
          peak: {
            start: 7,
            end: 12,
          }
        },
        dodgeDirection: '',
        jumping: {
          checking: false,
          state: false,
        },
        success: {
          attackSuccess: {
            state: false,
            count: 0,
            limit: 10,
          },
          defendSuccess: {
            state: false,
            count: 0,
            limit: 10,
          },
          deflected: {
            state: false,
            count: 0,
            limit: 20,
            predeflect: false,
            type: '',
          }
        },
        pushBack: {
          state: false,
          prePushBackMoveSpeed: 0,
        },
        halfPushBack: {
          state: false,
          direction: "",
          type: "",
          countUp: {
            state: true,
            count: 0,
            limit: 0,
          },
          countDown: {
            state: false,
            count: 0,
            limit: 0,
          },
          coords: {
            x: undefined,
            y: undefined,
          },
        },
        defending: {
          state: false,
          count: 0,
          limit: 4,
        },
        defendDecay: {
          state: false,
          count: 0,
          limit: 25,
        },
        defended: {
          state: false
        },
        falling: {
          state: false,
          count: 0,
          limit: 10,
        },
        dead: {
          state: false,
          count: 0,
          limit: 10
        },
        ghost: {
          state: false,
          position: {
            cell: {
              number: {
                x: 0,
                y: 0,
              },
              center: {
                x: 0,
                y: 0,
              }
            }
          }
        },
        respawn: false,
        points: 0,
        speed: {
          move: .1,
          range: [.05,.1,.125,.2]
        },
        terrainMoveSpeed: {
          state: false,
          speed: 0,
        },
        hp: 2,
        currentWeapon: {
          name: 'sword1',
          type: 'sword',
          effect: '',
        },
        currentArmor: {
          name: '',
          type: '',
          effect: '',
        },
        items: {
          weaponIndex: 0,
          armorIndex: 0,
          weapons: [{
            name: 'sword1',
            type: 'sword',
            effect: '',
          }],
          armor: [],
          ammo: 0,
        },
        inventorySize: 4,
        cycleWeapon: {
          state: false,
          count: 0,
          limit: 3,
        },
        cycleArmor: {
          state: false,
          count: 0,
          limit: 3,
        },
        crits: {
          singleHit: 1,
          doubleHit: 6,
          pushBack: 4,
          guardBreak: 3,
          dodge: 0,
        },
        statusDisplay: {
          state: false,
          status: '',
          count: 0,
          limit: 15,
        },
        popups: [{
          state: true,
          count: 0,
          limit: 0,
          type: '',
          position: 'northWest',
          msg: '',
          img: '',
        }],
        itemDrop: {
          state: false,
          count: 0,
          limit: 10,
          item: {
            name: '',
          },
          gear: {
            type: '',
          }
        },
        itemPickup: {
          state: false,
          count: 0,
          limit: 10,
          item: {
            name: '',
          },
          gear: {
            type: '',
          }
        },
        discardGear:{
          state: false,
          count: 0,
          limit: 8,
        },
        idleAnim: {
          state: false,
          count: 0,
          limit: 5,
        },
        ai: {
          state: false,
          imgType: '',
          primaryMission: '',
          mission: '',
          prevMission: '',
          currentObjective: '',
          targetSet: false,
          targetAcquired: false,
          safeRange: true,
          pathArray: [],
          targetPlayer: {
            number: 1,
            currentPosition: {
              x: undefined,
              y: undefined,
            },
            target: {
              number1: {
                x: undefined,
                y: undefined,
              },
              number2: {
                x: undefined,
                y: undefined,
              },
            },
            action: '',
          },
          instructions: [],
          currentInstruction: 0,
          resetInstructions: false,
          patrolling: {
            checkin: undefined,
            state: false,
            area: [],
            loopControl: false,
          },
          defending: {
            checkin: undefined,
            state: false,
            area: [],
          },
          persuing: {
            state: false,
          },
          engaging: {
            state: true,
            targetAction: '',
          },
          retrieving: {
            checkin: undefined,
            state: false,
            point: {x: undefined, y: undefined},
            targetItem: {
              name: '',
              type: '',
              subType: '',
              effect: ''
            },
            safe: true,
          },
          retreating: {
            checkin: undefined,
            state: false,
            point: {x: undefined, y: undefined},
            level: 0,
            safe: true,
          },
          organizing: {
            weaponPriorityIndex: 0,
            armorPriorityIndex: 0,
            dropped: {
              state: false,
              gear: {
                name: '',
                type: '',
                subType: '',
                effect: ''
              },
            },
          },
          mode: '',
          upgradeWeapon: false,
          upgradeArmor: false,
          pathfindingRanges: {
            spear: 3,
            crossbow: 5,
          }
        },
        stamina: {
          current: 20,
          max: 20,
        },
        newPushPullDelay: {
          state: false,
          count: 0,
          limit: 10,
        },
        prePush: {
          state: false,
          count: 0,
          limit: 15,
          targetCell: undefined,
          direction: "",
          pusher: undefined,
        },
        pushing: {
          state: false,
          targetCell: undefined,
          moveSpeed: 0,
        },
        prePull: {
          state: false,
          count: 0,
          limit: 15,
          targetCell: undefined,
          direction: "",
          puller: undefined,
        },
        pulling: {
          state: false,
          targetCell: undefined,
          moveSpeed: 0,
        },
        postPull: {
          state: false,
          count: 0,
          limit: 10,
        },
        pushed: {
          state: false,
          pusher: 0,
          moveSpeed: 0,
        },
        pulled: {
          state: false,
          puller: 0,
          moveSpeed: 0,
        },
        elasticCounter: {
          preState: false,
          state: false,
          direction: "",
          type: "",
          subType: "",
          countUp: {
            state: false,
            count: 0,
            limit: 6,
          },
          countDown: {
            state: false,
            count: 0,
            limit: 6,
          },
          coords: {
            x: undefined,
            y: undefined,
          },
          pause: {
            preState: false,
            state: false,
            type: "",
            count: 0,
            limit: 6,
          },
        },
        team: 'Blue',
        input: 'Keyboard',
      }
    ];


    // INPUT
    this.gamepad = false;
    this.keyPressed = [
      {
        north: false,
        south: false,
        east: false,
        west: false,
        northEast: false,
        northWest: false,
        southEast: false,
        southWest: false,
        attack: false,
        defend: false,
        strafe: false,
        cycleWeapon: false,
        cycleArmor: false,
        dodge: false,
        menu: false,
      },
      {
        north: false,
        south: false,
        east: false,
        west: false,
        northEast: false,
        northWest: false,
        southEast: false,
        southWest: false,
        attack: false,
        defend: false,
        strafe: false,
        cycleWeapon: false,
        cycleArmor: false,
        dodge: false,
        menu: false,
      },
    ]
    this.clicked = {
      cell: {
        number:{
          x:0,
          y:0
        },
        center:{
          x:0,
          y:0
        },
        drawCenter:{
          x:0,
          y:0
        },
        vertices: [
          {
            x:0,
            y:0
          },
          {
            x:0,
            y:0
          },
          {
            x:0,
            y:0
          },
          {
            x:0,
            y:0
          },
        ],
        side: 0,
        levelData: '',
        edge: {
          state: false,
          side: ''
        },
        terrain: {
          name: '',
          type: '',
          effect: ''
        },
        item: {
          name: '',
          type: '',
          subType: '',
          effect: '',
          initDrawn: false
        },
        void: {
          state: false
        },
        obstacle: {
          state: false,
          name: '',
          type: '',
          hp: 2,
          destructible: {
            state: false,
            weapons: [],
            leaveRubble: false,
          },
          locked: {
            state: false,
            key: '',
          },
          weight: 1,
          height: 0.5,
          items: [],
          effects: [],
          moving: {
            state: false,
            step: 0,
            origin: {
              number: {
                x: undefined,
                y: undefined,
              },
              center: {
                x: undefined,
                y: undefined,
              },
            },
            destination: {
              number: {
                x: undefined,
                y: undefined,
              },
              center: {
                x: undefined,
                y: undefined,
              },
            },
            currentPosition: {
              x: undefined,
              y: undefined,
            },
            nextPosition: {
              x: undefined,
              y: undefined,
            },
            moveSpeed: 0,
            pushable: true,
            pushed: false,
            pusher: undefined,
            falling: {
              state: false,
              count: 0,
              limit: 10,
            },
          }
        },
        barrier: {
          state: false,
          name: '',
          type: '',
          hp: 2,
          destructible: {
            state: false,
            weapons: [],
            leaveRubble: false,
          },
          locked: {
            state: false,
            key: '',
          },
          position: '',
          height: 1,
        },
        elevation: {
          number: 0,
          type: '',
          position: '',
        },
        rubble: false,
      },
      player: undefined,
    };
    this.turnCheckerDirection = '';


    // SETTINGS
    this.settingsGridWidth = 9;
    this.settingsCanvasHeight = 500;
    this.settingsCanvasWidth = 700;
    this.settingsSceneX = 250;
    this.settingsSceneY = 40;
    this.settingsClicked = {
      number:{
        x:0,
        y:0
      },
      center:{
        x:0,
        y:0
      },
      drawCenter:{
        x:0,
        y:0
      },
      vertices: [
        {
          x:0,
          y:0
        },
        {
          x:0,
          y:0
        },
        {
          x:0,
          y:0
        },
        {
          x:0,
          y:0
        },
      ],
      side: 0,
      levelData: '',
      edge: {
        state: false,
        side: ''
      },
      terrain: {
        name: '',
        type: '',
        effect: ''
      },
      item: {
        name: '',
        type: '',
        subType: '',
        effect: '',
        initDrawn: false
      },
      void: {
        state: false
      },
      obstacle: {
        state: false,
        name: '',
        type: '',
        hp: 2,
        destructible: {
          state: false,
          weapons: [],
          leaveRubble: false,
        },
        locked: {
          state: false,
          key: '',
        },
        weight: 1,
        height: 0.5,
        items: [],
        effects: [],
        moving: {
          state: false,
          step: 0,
          origin: {
            number: {
              x: undefined,
              y: undefined,
            },
            center: {
              x: undefined,
              y: undefined,
            },
          },
          destination: {
            number: {
              x: undefined,
              y: undefined,
            },
            center: {
              x: undefined,
              y: undefined,
            },
          },
          currentPosition: {
            x: undefined,
            y: undefined,
          },
          nextPosition: {
            x: undefined,
            y: undefined,
          },
          moveSpeed: 0,
          pushable: true,
          pushed: false,
          pusher: undefined,
          falling: {
            state: false,
            count: 0,
            limit: 10,
          },
        }
      },
      barrier: {
        state: false,
        name: '',
        type: '',
        hp: 2,
        destructible: {
          state: false,
          weapons: [],
          leaveRubble: false,
        },
        locked: {
          state: false,
          key: '',
        },
        position: '',
        height: 1,
      },
      elevation: {
        number: 0,
        type: '',
        position: '',
      },
      rubble: false,
    };
    this.settingsFormAiGridInfo = [] ;
    this.settingsFormAiStartPosList = [];
    this.updateSettingsFormAiDataData = {};
    this.settingsFormPlyrGridInfo = [];
    this.settingsFormPlyrStartPosList = [];
    this.settingsFormPlayerData = {};
    this.showSettingsKeyPress = {
      state: false,
      count: 0,
      limit: 4,
    }
    this.showSettingsCanvasData = {
      state: true,
      field: 'human_start',
      plyrNo: 1,
      type: 'start',
    }
    this.gamepadConfig = [];
    this.connectedGamepadsInit = false;


    // CELL INFO
    this.showCellInfoBox = false;
    this.mouseOverCell = {
      state: false,
      cell: undefined,
      count: 0,
      threshold: 40,
    };
    this.mousedOverCellCoords = {
      x: undefined,
      y: undefined
    };
    this.mouseMoving = false;
    this.mouseOverCellSwitchOff = {
      state: false,
      count: 0,
      limit: 100,
    };
    this.cellInfoMouseOver = false;


    //LOOP & ANIMATION
    this.stepper = {
      now: 0,
      dt: 0,
      last: 0,
      step: 1 / 60,
      fps: 0,

      secondsPassed: 0,
      oldTimeStamp: 0,
      movingSpeed: 30,
      frameCount: 0,

      fps2: 30,
      interval: 1000/30,
      lastTime: 0,
      currentTime: (new Date()).getTime(),
      deltaTime: 0,

    };
    this.moveStepRef = [
      [.05,.1,.15,.2,.25,.3,.35,.4,.45,.5,.55,.6,.65,.7,.75,.8,.85,.9,.95,1],
      [.1,.2,.3,.4,.5,.6,.7,.8,.9,1],
      [.125,.25,.375,.5,.625,.75,.875,1],
      [.2,.4,.6,.8,1],
    ]
    this.attackAnimRef = {
      limit: {
        unarmed: 20,
        sword: 25,
        spear: 30,
        crossbow: 30,
      },
      peak: {
        unarmed: 10,
        sword: 15,
        spear: 20,
        crossbow: 20,
      },
    };
    this.defendAnimRef = {
      limit: {
        unarmed: 25,
        sword: 30,
        spear: 35,
        crossbow: 30,
      },
      peak: {
        unarmed: 5,
        sword: 10,
        spear: 15,
        crossbow: 10,
      }
    };
    this.staminaCostRef = {
      attack: {
        unarmed: {
          blunt: {
            pre: 1,
            peak: 2,
          },
          normal: {
            pre: 1,
            peak: 2,
          },
        },
        sword: {
          blunt: {
            pre: 2,
            peak: 3,
          },
          normal: {
            pre: 2,
            peak: 3,
          },
        },
        spear: {
          blunt: {
            pre: 2,
            peak: 4,
          },
          normal: {
            pre: 2,
            peak: 4,
          },
        },
        crossbow: {
          blunt: {
            pre: 1,
            peak: 3,
          },
          normal: {
            pre: 1,
            peak: 3,
          },
        },
      },
      deflected: {
        outOfStamina: 0,
        attacked: 3,
        bluntAttacked: 2,
        defended: 3,
        parried: 5,
        knockedOut: 0,
      },
      defend: {
        pre: 1.5,
        peak: 2,
      },
      dodge: {
        pre: 2,
        peak: 4
      },
      flank: 5,
      jump: 6,
      pushBack: 7,
      push: 3,
      pull: 4,
      move: .1,
      strafe: .5,
      turn: .5,
    }
    this.deflectedLengthRef = {
      outOfStamina: 50,
      attacked: 18,
      bluntAttacked: 23,
      defended: 10,
      parried: 25,
      knockedOut: 65,
    };
    this.projectiles = [];
    this.projectileSpeed = .1;
    this.cellsUnderAttack = [];
    this.cellsUnderPreAttack = [];
    this.cellsToHighlight = [];
    this.cellsToHighlight2 = [];
    this.gamepadPollCounter = {
      count1: 0,
      count2: 0,
      store1: [],
      store2: [],
    };
    this.charSpriteHeight = 100;
    this.charSpriteWidth = 100;
    this.playerColourRef = {
      player1: 'red',
      player2: 'blue',
      player3: 'green',
      player4: 'purple',
      player5: 'orange',
      player6: 'brown',
      player7: '',
      player8: '',
    };
    this.playerDrawWidth = 45;
    this.playerDrawHeight = 45;
    this.popupSize = 45;
    this.popupImgSize = 25;
    this.movingObstacles = [];
    this.halfPushBackObstacles = [];

    this.obstacleBarrierToDestroy = [];
    this.obstacleItemsToDrop = [];
    this.obstaclesOutOfBoundsFall = [];
    this.cellPopups = [];
    this.popupImageRef = {};
    this.indicatorImgs = {};
    this.playerImgs = [];
    this.itemImgs = {};
    this.boltImgs = {};
    this.floorImgs = {};
    this.obstacleImgs = {};
    this.barrierImgs = {};
    this.cellColorRef = [];
    this.popupProgressBorderSvgPath = "";
    this.popupProgressImgGradColor1 = "rgb(255,0,0)";
    this.popupProgressImgGradColor2 = "rgb(255,255,0)";

    this.halfPushBackChaining = true;
    this.halfPushBackChainingMoveAll = true;

    this.showPlayerOutlines = false;



    // CAMERA
    this.toggleCameraMode = false;
    this.camera = {
      state: false,
      startCount: 0,
      startLimit: 4,
      mode: 'pan',
      fixed: false,
      target: {
        type: 'player',
        plyrNo: 1,
        cell: {
          x: undefined,
          y: undefined,
        }
      },
      focus: {
        x: undefined,
        y: undefined,
      },
      focusCell: {
        x: 4,
        y: 4,
      },
      cellToPanOrigin: {
        x: 4,
        y: 4,
      },
      zoom: {
        x: 1,
        y: 1,
      },
      zoomDirection: 'in',
      pan: {
        x: 1,
        y: 1,
      },
      panDirection: 'east',
      adjustedPan: {
        x: -1,
        y: -1,
      },
      zoomFocusPan: {
        x: -1,
        y: -1,
      },
      limits: {
        zoom: {
          min: .5,
          max: 2.5,
        },
        pan: {
          x: {
            min: -350,
            max: 350,
          },
          y: {
            min: -200,
            max: 200,
          }
        },
        state: {
          count: 0,
          limit: 10,
          zoom: false,
          pan: false,
        }
      },
      instructionType: 'default',
      currentPreInstruction: 0,
      preInstructions: [],
      currentInstruction: 0,
      instructions: [],
    };
    this.cameraInstructionRef = {
      default: {},
      story: {},
      // FollowPlayer2, centerOnCell21 etc
    };
    this.resetCameraSwitch = false;
    this.setInitZoom = {
      state: false,
      windowWidth: 0,
      gridWidth: 0,
      count: 0,
      limit: 0,
    }
    this.engagedZoomThreshold = {
      melee: 0.50,
      ranged: 0.10,
    }
    this.settingAutoCamera = false;
    this.highlightZoomPanFocusCell = true;


    // AI
    this.aiInitSettings = {
      randomStart: false,
      startPosition: {
        number: {x: 1, y: 7}
      },
      primaryMission: 'defend',
      mission: undefined,
      mode: 'careful',
      partolArea: [
        {x: 8, y: 6},
        // {x: 7, y: 4}
      ],
      weapons: [],
      armor: [],
      team: ''
    }
    this.addAiPlayerKeyPress = false;
    this.addAiCount = {
      state: false,
      count: 0,
      limit: 10,
    };
    this.aiPlayers = [];
    this.aiTarget =  1;
    this.resetAiTarget = {
      state: false,
      state2: false,
      player: 1,
      count: 0,
      limit: 25,
    };
    this.allPlayersDead = false;
    this.removeAi = undefined;
    this.easyStar = undefined;
    this.getPath = false;
    this.aiDeflectCheck = false;
    this.aiDeflectedCheck = [];


    this.bloodSacrificeEvent = {
      state: false,
      count: 0,
      limit: 100,
      restore: false,
    }
    this.bloodSacrificeVoidedCells = [];


    this.testDraw = [];
    this.testData = "";

  }

  componentDidMount() {


    this.easyStar = new Easystar.js();

    if (window.innerWidth < 1100) {
      this.setState({
        containerInnerClass: "containerInnerSmall",
        sceneY: {
          three: 300,
          six: 200,
          nine: 120,
          twelve: 50,
        }
      })


      switch(this.gridWidth) {
        case 3 :
          this.sceneY = 300;
        break;
        case 6 :
          this.sceneY = 200;
        break;
        case 9 :
          this.sceneY = 120;
        break;
        case 12 :
          this.sceneY = 50;
        break;
      }

      this.canvasWidth = 1000;
      this.canvasHeight = 600;

    }

    let canvas = this.canvasRef.current;
    let context = canvas.getContext('2d');

    let canvas2 = this.canvasRef2.current;
    let context2 = canvas2.getContext('2d');



    this.setState({
      canvas: canvas,
      context: context,
      canvas2: canvas2,
      context2: context2,
    })

    this.refs.comBImgAttackSheet.onload = () => {
      this.addListeners(canvas, canvas2);

      this.updateSettingsFormPlayerData(
        {
          input: [
            {plyrNo: 1,input: 'keyboard'},
            {plyrNo: 2,input: 'keyboard'},
          ],
          weapon: [
            {plyrNo: 1,weapons: ['sword','spear','crossbow']},
            {plyrNo: 2,weapons: ['sword','spear','crossbow']},
          ],
          armor: [
            {plyrNo: 1,armor: []},
            {plyrNo: 2,armor: []},
          ],
          team: [
            {plyrNo: 1,team: 'Red'},
            {plyrNo: 2,team: 'Blue'}
          ]
        }
      )
      this.drawGridInit(this.state.canvas, this.state.context, this.state.canvas2, this.state.context2);
      this.getCustomPlyrStartPosList(
        [
          {
            plyrNo: 1,
            selected: undefined,
            posArray: [],
          },
          {
            plyrNo: 2,
            selected: undefined,
            posArray: [],
          },
        ]
      );


      window.requestAnimationFrame(this.gameLoop);

    }

  }
  componentWillUnmount() {
    window.cancelAnimationFrame(this.stepper.currentTime);
  }


  pollGamepads = () => {


  const gamepads = navigator.getGamepads ? navigator.getGamepads() : [];
  // console.log('gamepads',gamepads,navigator.getGamepads ? navigator.getGamepads() : []);

  let connectedGamepadsCount = gamepads.filter(x => x !== null).length;
  let connectedGamepads = gamepads.filter(x => x !== null);
  for (const pad of connectedGamepads) {
    if (
      pad.id.substr(0,11) === "Joy-Con (R)" ||
      pad.id.substr(0,11) === "Joy-Con (L)"
    ) {

      connectedGamepads.splice(connectedGamepads.indexOf(x=>x.index===pad.index),1);
    }
  }

  // console.log('connectedGamepads',connectedGamepads);

  let currentGamepadPlayer;
  let settingsGamepadPlayerCount = this.gamepadConfig.filter(x => x.input === "Gamepad").length;

  if (this.gamepadPollCounter.count1 === 0) {
    this.gamepadPollCounter.count1 = 1;
  } else {
    this.gamepadPollCounter.count1 = 0;
  }
  if (this.gamepadPollCounter.count2 === 0) {
    this.gamepadPollCounter.count2 = 1;
  } else {
    this.gamepadPollCounter.count2 = 0;
  }

  let keyPressed = []
  let connectedGamepadIndexB = 0;

  for (const elem of this.gamepadConfig) {
    let indx = this.gamepadConfig.indexOf(x=>x.plyrNo === elem.plyrNo);

    if (elem.input === "Gamepad") {

      keyPressed.push(
        {
          state: true,
          plyrNo: elem.plyrNo,
          keyPressed: {
            north: false,
            south: false,
            east: false,
            west: false,
            northEast: false,
            northWest: false,
            southEast: false,
            southWest: false,
            attack: false,
            defend: false,
            strafe: false,
            cycleWeapon: false,
            cycleArmor: false,
            dodge: false,
            menu: false,
          },
        }
      )

      this.players[elem.plyrNo-1].strafing.state = false;

      if (this.connectedGamepadsInit !== true && connectedGamepads[0]) {

        if (connectedGamepads[connectedGamepadIndexB]) {
          elem.type = connectedGamepads[connectedGamepadIndexB].id.substr(0,11);
          elem.id = connectedGamepads[connectedGamepadIndexB].id.substr(0,11)+'_'+connectedGamepads[connectedGamepadIndexB].index;
          elem.mapping = connectedGamepads[connectedGamepadIndexB].mapping;
          elem.gamepadIndex = connectedGamepads[connectedGamepadIndexB].index;

          connectedGamepadIndexB++;
        }

        // console.log('this.gamepadConfig + connected gamepads',this.gamepadConfig,connectedGamepads,settingsGamepadPlayerCount);


        if (this.gamepadConfig.filter(x => x.id !== "").length === settingsGamepadPlayerCount) {
          this.connectedGamepadsInit = true;
        }

      }

    }
    else {
      keyPressed.push(
        {
          state: false,
          plyrNo: elem.plyrNo,
          keyPressed: undefined,
        }
      )
    }


  }
  connectedGamepadIndexB = 0;



  let showSettingsKeyPressState = false;

  let gamepadEngaged = false;
  // for(let g = 0; g < gamepads.length; g++) {
  for(let g = 0; g < connectedGamepads.length; g++) {
    const gp = connectedGamepads[g];

    if (!!gp) {

      // console.log('gp',gp);
      let gamepadConfigRef = this.gamepadConfig.find(x => x.gamepadIndex === gp.index);

      if (gamepadConfigRef) {

        currentGamepadPlayer = gamepadConfigRef.plyrNo;
        const keyPressedIndex = currentGamepadPlayer-1;

        if (
          gp.id.substr(0,11) !== "Joy-Con (R)" &&
          gp.id.substr(0,11) !== "Joy-Con (L)"
        ) {



          // CHECK BUTTONS!!
          for (const btn of gp.buttons) {
            if (btn.pressed === true ) {

              // DEBUGGING
              if (
                // b btn
                gp.buttons.indexOf(btn) === 0 ||
                // a btn
                gp.buttons.indexOf(btn) === 1 ||
                // y btn
                gp.buttons.indexOf(btn) === 2 ||
                // x btn
                gp.buttons.indexOf(btn) === 3 ||
                // l btn
                gp.buttons.indexOf(btn) === 4 ||
                // r btn
                gp.buttons.indexOf(btn) === 5 ||
                // l trigger
                gp.buttons.indexOf(btn) === 6 ||
                // r trigger
                gp.buttons.indexOf(btn) === 7 ||
                // - btn
                gp.buttons.indexOf(btn) === 8 ||
                // + btn
                gp.buttons.indexOf(btn) === 9 ||
                // l stick press
                gp.buttons.indexOf(btn) === 10 ||
                // r stick press
                gp.buttons.indexOf(btn) === 11 ||
                // dpad up
                gp.buttons.indexOf(btn) === 12 ||
                // dpad down
                gp.buttons.indexOf(btn) === 13 ||
                // dpad left
                gp.buttons.indexOf(btn) === 14 ||
                // dpad right
                gp.buttons.indexOf(btn) === 15
              ) {
                // console.log('player '+currentGamepadPlayer+' btn ',gp.buttons.indexOf(btn),' pressed');
                // console.log('gp',gp);
                gamepadEngaged = true;
              }


              switch (gp.buttons.indexOf(btn)) {
                case 0:
                  // b btn
                  // console.log('player '+currentGamepadPlayer+' attack btn pressed');
                  // keyPressed[keyPressedIndex].keyPressed.attack = true;
                break;
                case 1:
                  // a btn
                break;
                case 2:
                  // y btn
                break;
                case 3:
                  // x btn
                break;
                case 4:
                  // l btn
                break;
                case 5:
                  // r btn
                break;
                case 6:
                  // l trigger
                break;
                case 7:
                  // r trigger
                break;
                case 8:
                  // - btn
                break;
                case 9:
                  // + btn
                break;
                case 10:
                  // l stick press
                break;
                case 11:
                  // r stick press
                break;
                case 12:
                  // dpad up
                break;
                case 13:
                  // dpad down
                break;
                case 14:
                  // dpad left
                break;
                case 15:
                  // dpad right
                break;
                default:

              }

            }
          }



          // CHECK AXES!!
          // DEBUGGING
          for (const axis of gp.axes) {

            if (axis !== 0) {
              if (gp.axes.indexOf(axis) === 0) {
                // console.log('player '+currentGamepadPlayer+' left stick x axis value',axis.toFixed(2));
              }
              if (gp.axes.indexOf(axis) === 1) {
                // console.log('player '+currentGamepadPlayer+' left stick y axis value',axis.toFixed(2));
              }
              if (gp.axes.indexOf(axis) === 2) {
                // console.log('player '+currentGamepadPlayer+' right stick x axis value',axis.toFixed(2));
              }
              if (gp.axes.indexOf(axis) === 3) {
                // console.log('player '+currentGamepadPlayer+' right stick y axis value',axis.toFixed(2));
              }

              // console.log('gp',gp);
            }
          }
          const getAxesDirection = (x,y) => {

            let dir;
            let magnitude;

            if (x < -0.5 && y < -0.5) dir = 'up-left';
            else if (x < -0.5 && y >= -0.5 && y <= 0.5) dir = 'left';
            else if (x < -0.5 && y > 0.5) dir = 'down-left';
            else if (x >= -0.5 && x <= 0.5 && y < -0.5) dir = 'up';
            else if (x >= -0.5 && x <= 0.5 && y >= -0.5 && y <= 0.5) dir = 'neutral';
            else if (x >= -0.5 && x <= 0.5 && y > 0.5) dir = 'down';
            else if (x > 0.5 && y < -0.5) dir = 'up-right';
            else if (x > 0.5 && y >= -0.5 && y <= 0.5) dir = 'right';
            else if (x > 0.5 && y > 0.5) dir = 'down-right';


            // if (Math.abs(x) > Math.abs(y)) {
            //   if (x < -0.5 && y < -0.5) dir = 'up-left';
            //   else if (x < -0.5 && y > 0.5) dir = 'down-left';
            //   else if (x > 0.5 && y < -0.5) dir = 'up-right';
            //   else if (x > 0.5 && y > 0.5) dir = 'down-right';
            //   else if (x < -0.5) dir = 'left';
            //   else dir = 'right';
            // } else {
            //   if (x < -0.5 && y < -0.5) dir = 'up-left';
            //   else if (x < -0.5 && y > 0.5) dir = 'down-left';
            //   else if (x > 0.5 && y < -0.5) dir = 'up-right';
            //   else if (x > 0.5 && y > 0.5) dir = 'down-right';
            //   else if (y < -0.5) dir = 'up';
            //   else dir = 'down';
            // }

            // if (Math.abs(x) > Math.abs(y)) {
            //    if (x < -0.5 && y < -0.5) {
            //       dir = 'up-left';
            //       magnitude = Math.sqrt(x*x + y*y);
            //     }
            //    else if (x < -0.5 && y > 0.5) {
            //       dir = 'down-left';
            //       magnitude = Math.sqrt(x*x + y*y);
            //     }
            //    else if (x > 0.5 && y < -0.5) {
            //       dir = 'up-right';
            //       magnitude = Math.sqrt(x*x + y*y);
            //     }
            //    else if (x > 0.5 && y > 0.5) {
            //       dir = 'down-right';
            //       magnitude = Math.sqrt(x*x + y*y);
            //     }
            //    else if (x < -0.5) {
            //       dir = 'left';
            //       magnitude = Math.abs(x);
            //     }
            //    else {
            //       dir = 'right';
            //       magnitude = Math.abs(x);
            //     }
            //  } else {
            //    if (x < -0.5 && y < -0.5) {
            //       dir = 'up-left';
            //       magnitude = Math.sqrt(x*x + y*y);
            //     }
            //    else if (x < -0.5 && y > 0.5) {
            //       dir = 'down-left';
            //       magnitude = Math.sqrt(x*x + y*y);
            //     }
            //    else if (x > 0.5 && y < -0.5) {
            //       dir = 'up-right';
            //       magnitude = Math.sqrt(x*x + y*y);
            //     }
            //    else if (x > 0.5 && y > 0.5) {
            //       dir = 'down-right';
            //       magnitude = Math.sqrt(x*x + y*y);
            //     }
            //    else if (y < -0.5) {
            //       dir = 'up';
            //       magnitude = Math.abs(y);
            //     }
            //    else {
            //       dir = 'down';
            //       magnitude = Math.abs(y);
            //     }
            //  }


            // only return direction if magnitude is more than a a certain amount
             if (!dir) {
               dir = 'neutral';
             }
             if (!magnitude) {
               magnitude = 0;
             }


             return {direction:dir,magnitude:magnitude};

          }

          // axes 0(x),1(y) == left stick, 2(x),3(y) == right stick


          let preDirection;
          let direction;
          let x;
          let y;
          if (gp.axes[0]!== 0 || gp.axes[1] !== 0) {
            x = gp.axes[0];
            y = gp.axes[1];
            preDirection = getAxesDirection(x,y).direction;
            switch (preDirection) {
              case 'up':
              case 'up-right':
                direction = 'north'
              break;
              case 'left':
              case 'up-left':
                direction = 'west'
              break;
              case 'down':
              case 'down-left':
                direction = 'south'
              break;
              case 'right':
              case 'down-right':
                direction = 'east'
              break;
              default:
            }
            if (direction) {
              gamepadEngaged = true;
              keyPressed[keyPressedIndex].keyPressed[direction] = true;
            }
            console.log('player ',currentGamepadPlayer,' gamepad left stick to ',preDirection,direction,' magnitude',getAxesDirection(x,y).magnitude);
          }
          if (gp.axes[2]!== 0 || gp.axes[3] !== 0) {
            x = gp.axes[2];
            y = gp.axes[3];
            preDirection = getAxesDirection(x,y).direction;
            switch (preDirection) {
              case 'up':
              case 'up-right':
                direction = 'north'
              break;
              case 'left':
              case 'up-left':
                direction = 'west'
              break;
              case 'down':
              case 'down-left':
                direction = 'south'
              break;
              case 'right':
              case 'down-right':
                direction = 'east'
              break;
              default:
            }
            if (direction) {
              gamepadEngaged = true;
              keyPressed[keyPressedIndex].keyPressed[direction] = true;
            }

            console.log('player ',currentGamepadPlayer,' gamepad right stick to ',preDirection,direction,' magnitude',getAxesDirection(x,y).magnitude);
          }



        }
        else {

          if (
            gp.id.substr(0,11) === "Joy-Con (R)" ||
            gp.id.substr(0,11) === "Joy-Con (L)"
          ) {
            console.log("can't use single joycon. please re-configure controller/gamepad settings");
            keyPressed[keyPressedIndex].state = false;
            keyPressed[keyPressedIndex].keyPressed = {
              north: false,
              south: false,
              east: false,
              west: false,
              northEast: false,
              northWest: false,
              southEast: false,
              southWest: false,
              attack: false,
              defend: false,
              strafe: false,
              cycleWeapon: false,
              cycleArmor: false,
              dodge: false,
              menu: false,
            };
            showSettingsKeyPressState = true;
            this.connectedGamepadsInit = false;
          }


        }

      }
      else {
        // console.log('found a connected gamepad not assigned to a player. do nothing',gp.index);
      }


    }
  }



  let player = this.players[currentGamepadPlayer-1];
  // if (player) {
  if (player && gamepadEngaged === true) {

    if (keyPressed[currentGamepadPlayer-1].state === true) {
      this.keyPressed[currentGamepadPlayer-1] = keyPressed[currentGamepadPlayer-1].keyPressed;
      // console.log('xxx',this.keyPressed[currentGamepadPlayer-1]);
    }


    if (showSettingsKeyPressState === true) {
      this.showSettingsKeyPress.state = showSettingsKeyPressState;
    }



    if (player.defending.state === true && player.defending.count === 0) {
      if (this.keyPressed[currentGamepadPlayer-1].defend === false) {
        console.log('player',player.number,' stop defending1 @ gamepad');
        // player.defending.state = false;

        // player.defending = {
        //   state: false,
        //   count: 0,
        //   limit: player.defending.limit,
        // }
        // player.defendDecay = {
        //   state: false,
        //   count: 0,
        //   limit: player.defendDecay.limit,
        // }
      }
    }


    // STRAFE CHECKS
    if (
      keyPressed[currentGamepadPlayer-1].keyPressed.strafe === false &&
      this.players[currentGamepadPlayer-1].moving.state === true &&
      this.players[currentGamepadPlayer-1].strafing.state === true
    ) {
      this.players[currentGamepadPlayer-1].strafeReleaseHook = true
    }
    if (
      keyPressed[currentGamepadPlayer-1].keyPressed.strafe === false &&
      this.players[currentGamepadPlayer-1].moving.state !== true &&
      this.keyPressed[currentGamepadPlayer-1].strafe === true
    ) {
      this.players[currentGamepadPlayer-1].strafeReleaseHook = true;
    }


    // if (player.turning.state === true && player.turning.toDirection === this.turnCheckerDirection) {
    //   console.log('player',player.number,' turn-ing');
    //   if (this.keyPressed[currentGamepadPlayer-1][this.turnCheckerDirection] == false) {
    //     console.log('player',player.number,' turn-stop');
    //     player.turning.state = false;
    //   }
    // }


  }



}
  addListeners = (canvas,canvas2) => {
    // console.log('adding listeners');

    canvas2.addEventListener("click", e => {
      this.getCanvasClick(canvas2, e,"click")
    });

    window.addEventListener("gamepadconnected", (e) => {
      // console.log('new gamepad?',e);
      this.handleGamepadEvent(e, 'connected');
    })

    window.addEventListener('gamepaddisconnected', (e) => {
      // console.log('Lost connection with the gamepad.');
      this.handleGamepadEvent(e, 'disconnected');

    });

    // canvas3.addEventListener("click", e => {
    //   this.getSettingsCanvasClick(canvas3, e)
    // });

    // if (this.showSettingsCanvasData.state === true) {
    //   canvas3.addEventListener("click", e => {
    //     this.getSettingsCanvasClick(canvas3, e)
    //   });
    // }


    document.addEventListener("keydown", e => {
      this.handleKeyPress(e, true)
    });
    document.addEventListener("keyup", e => {
      this.handleKeyPress(e, false)
    });

    canvas2.addEventListener("mousemove", e => {

      this.getCanvasClick(canvas2, e,"mousemove")
    });


  }
  getCanvasClick = (canvas, event, type) => {


    const rect = canvas.getBoundingClientRect()
    const scale = rect.width / canvas.offsetWidth;
    // const scale = (rect.width / canvas.offsetWidth)*this.camera.zoom.x;
    // const scale = (rect.width / canvas.offsetWidth)*(this.camera.zoom.x-1);
    const x = (event.clientX - rect.left)*scale;
    const y = (event.clientY - rect.top)*scale;

    // ADJUSTED FOR CANVAS SCALE & TRANSFORM
    let newX = (x-this.camera.zoomFocusPan.x)/this.camera.zoom.x;
    let newY = (y-this.camera.zoomFocusPan.y)/this.camera.zoom.y;


    // console.log("clicked the canvas", 'x: ',x,'y: ',y,'newX',newX,'newY',newY,'zoom',this.camera.zoom.x.toFixed(2),'pan',this.camera.pan.x,this.camera.pan.y);

    let insideGrid = false;

    for(const cell of this.gridInfo) {
      let point = [newX,newY];
      let polygon = [];
      for (const vertex of cell.vertices) {
        let vertexPoint = [vertex.x+10,vertex.y+5];
        polygon.push(vertexPoint)
      }
      let pip = pointInPolygon(point, polygon)
      if (pip === true) {
        insideGrid = true;
        // console.log("clicked a cell",cell.center,"x: " + x + " y: " + y);
        let player = undefined;
        for(const plyr of this.players) {
          if (plyr.currentPosition.cell.number.x === cell.number.x && plyr.currentPosition.cell.number.y === cell.number.y) {
            player = plyr;
          }
        }
        if (type === 'click' && this.cellInfoMouseOver !== true) {
            this.clicked.cell = cell;
            if (player) {
              this.clicked.player = player;
            }
            else {
              this.clicked.player = undefined;
            }
            this.showCellInfoBox = true;
            this.mouseOverCell = {
              state: true,
              cell: cell,
              count: 0,
              threshold: this.mouseOverCell.threshold,
            };
        }

        if (type === "mousemove") {

          this.mouseMoving = true;


          if (this.mouseOverCellSwitchOff.state === true) {
            this.mouseOverCellSwitchOff.state = false;
          }


          if (this.cellInfoMouseOver !== true) {
            if (this.mouseOverCell.cell) {
              if (this.mouseOverCell.cell.number.x === cell.number.x && this.mouseOverCell.cell.number.y === cell.number.y) {
                if (this.mouseOverCell.state === true) {
                  // console.log('do nothing');
                }
                else {
                  if (this.mouseOverCell.count < this.mouseOverCell.threshold) {
                    this.mouseOverCell.count++;
                  }
                  if (this.mouseOverCell.count >= this.mouseOverCell.threshold) {
                    this.clicked.cell = cell;
                    if (player) {
                      this.clicked.player = player;
                    }
                    else {
                      this.clicked.player = undefined;
                    }
                    this.showCellInfoBox = true;
                    this.mouseOverCell = {
                      state: true,
                      cell: cell,
                      count: 0,
                      threshold: this.mouseOverCell.threshold,
                    };

                  }
                }
              }
              else {
                this.mouseOverCell = {
                  state: false,
                  cell: cell,
                  count: 0,
                  threshold: this.mouseOverCell.threshold,
                }
              }

            }
            else {
              this.mouseOverCell = {
                state: false,
                cell: cell,
                count: 0,
                threshold: this.mouseOverCell.threshold,
              }

            }
          }
          else {
            // console.log("mouse in cell info box. do nothing");
          }

        }
      }
    }
    if ( insideGrid === false ) {
      // console.log("clicked or moused over the canvas out of bounds", 'x: ',x,'y: ',y);
      // console.log('clicked or mouse moved outside the grid',this.cellInfoMouseOver);
      if (type === "click") {

        if (this.mouseOverCellSwitchOff.state === true) {
          this.mouseOverCellSwitchOff.state = false;
        }
        if (this.cellInfoMouseOver !== true) {
          this.showCellInfoBox = false;
          this.mouseOverCell = {
            state: false,
            cell: undefined,
            count: 0,
            threshold: this.mouseOverCell.threshold,
          };
        }
        else {
          this.showCellInfoBox = true;
        }

      }
      else if (type === "mousemove") {

        if (this.cellInfoMouseOver !== true) {
          if (this.mouseOverCellSwitchOff.state !== true) {
            this.mouseOverCellSwitchOff.state = true;
          }

          if (this.mouseOverCell.cell && this.mouseOverCell.state !== true && this.mouseOverCell.count > 1) {
            this.mouseOverCell = {
              state: false,
              cell: undefined,
              count: 0,
              threshold: this.mouseOverCell.threshold,
            };
          }

        }
        else {
          console.log('heeere!',this.cellInfoMouseOver);
          this.cellInfoMouseOver = false;

          this.showCellInfoBox = true;
          this.mouseOverCell.state = false;
          if (this.mouseOverCellSwitchOff.state === true) {
            this.mouseOverCellSwitchOff.state = false;
            this.mouseOverCellSwitchOff.count = 0;
          }
        }

      }
    }

    if (type === "mousemove") {
      this.mouseMoving = true;
    }


  }
  getSettingsCanvasClick = (canvas, event) => {
    // console.log('getSettingsCanvasClick');

    const rect = canvas.getBoundingClientRect()

    const x = (event.clientX - rect.left);
    const y = (event.clientY - rect.top);

    let insideGrid = false;

    for(const cell of this.settingsGridInfo) {
      let point = [x,y];
      let polygon = [];
      for (const vertex of cell.vertices) {
        let vertexPoint = [vertex.x+(10/2),vertex.y+(5/2)];

        polygon.push(vertexPoint)
      }
      let pip = pointInPolygon(point, polygon)
      if (pip === true) {
        insideGrid = true;
        // console.log("clicked a cell",cell.number,"x: " + x + " y: " + y);
        this.settingsClicked = cell;
      }
    }
    if ( insideGrid === false ) {
      // console.log("clicked the settings canvas", 'x: ',x,'y: ',y);

      this.settingsClicked = {
        number:{
          x:0,
          y:0
        },
        center:{
          x:0,
          y:0
        },
        drawCenter:{
          x:0,
          y:0
        },
        vertices: [
          {
            x:0,
            y:0
          },
          {
            x:0,
            y:0
          },
          {
            x:0,
            y:0
          },
          {
            x:0,
            y:0
          },
        ],
        side: 0,
        levelData: '',
        edge: {
          state: false,
          side: ''
        },
        terrain: {
          name: '',
          type: '',
          effect: ''
        },
        item: {
          name: '',
          type: '',
          subType: '',
          effect: '',
          initDrawn: false
        },
        void: {
          state: false
        },
        obstacle: {
          state: false,
          name: '',
          type: '',
          hp: 2,
          destructible: {
            state: false,
            weapons: [],
            leaveRubble: false,
          },
          locked: {
            state: false,
            key: '',
          },
          weight: 1,
          height: 0.5,
          items: [],
          effects: [],
          moving: {
            state: false,
            step: 0,
            origin: {
              number: {
                x: undefined,
                y: undefined,
              },
              center: {
                x: undefined,
                y: undefined,
              },
            },
            destination: {
              number: {
                x: undefined,
                y: undefined,
              },
              center: {
                x: undefined,
                y: undefined,
              },
            },
            currentPosition: {
              x: undefined,
              y: undefined,
            },
            nextPosition: {
              x: undefined,
              y: undefined,
            },
            moveSpeed: 0,
            pushable: true,
            pushed: false,
            pusher: undefined,
            falling: {
              state: false,
              count: 0,
              limit: 10,
            },
          }
        },
        barrier: {
          state: false,
          name: '',
          type: '',
          hp: 2,
          destructible: {
            state: false,
            weapons: [],
            leaveRubble: false,
          },
          locked: {
            state: false,
            key: '',
          },
          position: '',
          height: 1,
        },
        elevation: {
          number: 0,
          type: '',
          position: '',
        },
        rubble: false,
      }
    }


    if (this.showSettingsCanvasData.state === true) {

      let availibleCells = this.settingsFormPlyrStartPosList[this.settingsFormPlyrStartPosList.length-1].posArray;
      if (this.settingsFormPlyrStartPosList.length < 0) {
        availibleCells = this.settingsFormPlyrStartPosList[this.settingsFormPlyrStartPosList.length-1].posArray;
      }
      let validCell = false;
      for (const cell of availibleCells) {
        if (
          cell.x === this.settingsClicked.number.x &&
          cell.y === this.settingsClicked.number.y
        ) {
          validCell = true;
        }
      }


      if (validCell === true) {

        if (this.showSettingsCanvasData.field.split("_")[0] === 'human') {

          let plyrNo = this.showSettingsCanvasData.plyrNo;

          let newArray = this.settingsFormPlyrStartPosList.map(y => y = {
            plyrNo: y.plyrNo,
            selected: y.selected,
          });

          let plyrChange = newArray.find(x => x.plyrNo === plyrNo);
          plyrChange.selected = {x: this.settingsClicked.number.x ,y: this.settingsClicked.number.y };

          this.getCustomPlyrStartPosList(newArray);


          let newArray2 = this.settingsFormAiStartPosList.map(y => y = {
            plyrNo: y.plyrNo,
            mission: y.mission,
            selected: y.selected,
          });

          this.getCustomAiStartPosList(newArray2);

        }

        if (this.showSettingsCanvasData.field.split("_")[0] === 'ai') {

          let plyrNo = this.showSettingsCanvasData.plyrNo - this.settingsFormPlyrStartPosList.length;
          let type = this.showSettingsCanvasData.type;
          let value = this.settingsClicked.number;

          let newArray3 = this.settingsFormAiStartPosList.map(y => y = {
            plyrNo: y.plyrNo,
            mission: y.mission,
            selected: y.selected,
          });

          let plyrChange = newArray3.find(x => x.plyrNo === plyrNo);

          if (plyrChange.selected.length === 0) {
            plyrChange.selected.push({type:type,cell:{x:value.x,y:value.y}})
          }
          else {
            // console.log('plyrChange',plyrChange);
            let selectedElem = plyrChange.selected.find(j=>j.type === type)
            let indx = newArray3.findIndex(j=>j.plyrNo === plyrChange.plyrNo)
            if (selectedElem) {
              selectedElem.cell = {x:value.x,y:value.y};
            }
            else {
              plyrChange.selected.push({type:type,cell:{x:value.x,y:value.y}});
            }
          }

          this.getCustomAiStartPosList(newArray3)

        }

      }
      else {
        // console.log('cant choose that cell',this.settingsClicked.number);
      }

    }

    this.setState({
      stateUpdater: '..'
    })

  }
  handleKeyPress = (event, state) => {

    // console.log('handling key press', event.key, state);


    let direction;
    let keyInput = event.key

    switch(keyInput) {
      // case 'q' :
      //  this.keyPressed[0].northWest = state;
      //  // direction = 'northWest';
      //  this.turnCheckerDirection = 'northWest';
      //  this.currentPlayer = 1;
      // break;
      // case 'e' :
      //  this.keyPressed[0].northEast = state;
      //  // direction = 'northEast';
      //  this.turnCheckerDirection = 'northEast';
      //  this.currentPlayer = 1;
      // break;
      // case 'z' :
      //  this.keyPressed[0].southWest = state;
      //  // direction = 'southWest';
      //  this.turnCheckerDirection = 'southWest';
      //  this.currentPlayer = 1;
      // break;
      // case 'c' :
      //  this.keyPressed[0].southEast = state;
      //  // direction = 'southEast';
      //  this.turnCheckerDirection = 'southEast';
      //  this.currentPlayer = 1;
      // break;

      case 'w' :
       this.keyPressed[0].north = state;
       // direction = 'north';
       this.players[0].turnCheckerDirection = 'north';
       this.currentPlayer = 1;
      break;
      case 'a' :
       this.keyPressed[0].west = state;
       // direction = 'west';
       this.players[0].turnCheckerDirection = 'west';
       this.currentPlayer = 1;
      break;
      case 'd' :
       this.keyPressed[0].east = state;
       // direction = 'east';
       this.players[0].turnCheckerDirection = 'east';
       this.currentPlayer = 1;
      break;
      case 's' :
       this.keyPressed[0].south = state;
       // direction = 'south';
       this.players[0].turnCheckerDirection = 'south';
       this.currentPlayer = 1;
      break;
      case 'f' :
       this.keyPressed[0].attack = state;
       this.currentPlayer = 1;
      break;
      case 'v' :
       this.keyPressed[0].defend = state;
       this.currentPlayer = 1;
      break;
      case ' ' :
        if (
          state === false &&
          this.players[0].moving.state === true &&
          this.players[0].strafing.state === true
        ) {
          this.players[0].strafeReleaseHook = true
        }
        if (
          state === false &&
          this.players[0].moving.state !== true &&
          this.keyPressed[0].strafe === true
        ) {
          this.players[0].strafeReleaseHook = true;
        }
        else {

          this.keyPressed[0].strafe = state;
          this.players[0].strafing.state = state;
          this.currentPlayer = 1;
        }
      break;
      case '1' :
        if (this.players[0].dead.state === true) {
          this.respawn(this.players[0])
        }
      break;
      case 'r' :
        this.gameReset('soft');
      break;
      case '2' :
       this.keyPressed[0].cycleWeapon = state;
       this.currentPlayer = 1;
      break;
      case '3' :
       this.keyPressed[0].cycleArmor = state;
       this.currentPlayer = 1;
      break;
      case 'c' :
       this.keyPressed[0].dodge = state;
       this.currentPlayer = 1;
      break;


      // case 'p' :
      //  this.openVoid = !this.openVoid;
      // break;

      case '4' :
       // this.toggleCameraMode(state);
       this.toggleCameraMode = state ;
      break;
      case '5' :
       this.addAiPlayerKeyPress = state;
      break;
      case 'Enter' :
        this.showSettingsKeyPress.state = state;
      break;


      // case 'ArrowUp' :
      //   this.keyPressed[2].north = state;
      //   this.turnCheckerDirection = 'north';
      //   this.currentPlayer = 3;
      // break;
      // case 'ArrowDown' :
      //   this.keyPressed[2].south = state;
      //   this.turnCheckerDirection = 'south';
      //   this.currentPlayer = 3;
      // break;


      // case 'u' :
      //  this.keyPressed[1].northWest = state;
      //  // direction = 'northWest';
      //  this.turnCheckerDirection = 'northWest';
      //  this.currentPlayer = 2;
      // break;
      // case 'o' :
      //  this.keyPressed[1].northEast = state;
      //  // direction = 'northEast';
      //  this.turnCheckerDirection = 'northEast';
      //  this.currentPlayer = 2;
      // break;
      // case 'm' :
      //  this.keyPressed[1].southWest = state;
      //  // direction = 'southWest';
      //  this.turnCheckerDirection = 'southWest';
      //  this.currentPlayer = 2;
      // break;
      // case '.' :
      //  this.keyPressed[1].southEast = state;
      //  // direction = 'southEast';
      //  this.turnCheckerDirection = 'southEast';
      //  this.currentPlayer = 2;
      // break;

      case 'i' :
       this.keyPressed[1].north = state;
       // direction = 'north';
       this.players[1].turnCheckerDirection = 'north';
       this.currentPlayer = 2;
      break;

      case 'j' :
       this.keyPressed[1].west = state;
       // direction = 'west';
       this.players[1].turnCheckerDirection = 'west';
       this.currentPlayer = 2;
      break;
      case 'k' :
       this.keyPressed[1].south = state;
       // direction = 'south';
       this.players[1].turnCheckerDirection = 'south';
       this.currentPlayer = 2;
      break;
      case 'l' :
       this.keyPressed[1].east = state;
       // direction = 'east';
       this.players[1].turnCheckerDirection = 'east';
       this.currentPlayer = 2;
      break;
      case 'b' :
       this.keyPressed[1].attack = state;
       this.currentPlayer = 2;
      break;
      case 'n' :
       this.keyPressed[1].defend = state;
       this.currentPlayer = 2;
      break;
      case '/' :
        if (
          state === false &&
          this.players[1].moving.state === true &&
          this.players[1].strafing.state === true
        ) {
          this.players[1].strafeReleaseHook = true
        }
        if (
          state === false &&
          this.players[1].moving.state !== true &&
          this.keyPressed[1].strafe === true
        ) {
          this.players[1].strafeReleaseHook = true;
        }
        else {
          this.keyPressed[1].strafe = state;
          this.players[1].strafing.state = state;
          this.currentPlayer = 2;
        }
      break;
      case '0' :
        if (this.players[1].dead.state === true) {
          this.respawn(this.players[1])
        }
      break;
      case '9' :
       this.keyPressed[1].cycleWeapon = state;
       this.currentPlayer = 2;
      break;
      case '8' :
       this.keyPressed[1].cycleArmor = state;
       this.currentPlayer = 2;
      break;
      case 'm' :
       this.keyPressed[1].dodge = state;
       this.currentPlayer = 2;
      break;
    }

    let player = this.players[this.currentPlayer-1];

    // if (player.turning.state === true && player.turning.toDirection === this.turnCheckerDirection) {
    //   // console.log('player',player.number,' turn-ing');
    //   if (this.keyPressed[this.currentPlayer-1][this.turnCheckerDirection] == false) {
    //     // console.log('player',player.number,' turn-stop');
    //     player.turning.state = false;
    //   }
    // }

    // KEY RELEASE FEINTING
    if (player.defending.state === true && player.defending.count === 0) {
      if (this.keyPressed[this.currentPlayer-1].defend === false) {
        // console.log('player',player.number,' defend key release');
        // player.defending.state = false;

        // player.defending = {
        //   state: false,
        //   count: 0,
        //   limit: player.defending.limit,
        // }
        // player.defendDecay = {
        //   state: false,
        //   count: 0,
        //   limit: player.defendDecay.limit,
        // }
      }
    }


    // STEP GAME ON KEYPRESS FOR DEBUGGING
    // for (const player of this.players) {
    //   this.playerUpdate(player, this.state.canvas, this.state.context, this.state.canvas2, this.state.context2);
    // }
    // this.time++
    // this.setState({
    //   stateUpdater: '..'
    // })

  }
  handleGamepadEvent = (event,type) => {

    if (type === 'disconnected') {

      this.connectedGamepadsInit = false;
      this.showSettingsKeyPress.state = true;
      console.log("connected gamepads state change! please re-configure controller/gamepad settings");

    }



  }


  setCellInfoMouseOver = (state,origin) => {
    // console.log('setCellInfoMouseOver',state,origin);

    this.cellInfoMouseOver = state;
    if (state === true) {
      this.showCellInfoBox = true;
      if (this.mouseOverCellSwitchOff.state === true) {
        this.mouseOverCellSwitchOff.state = false;
      }
      if (this.mouseOverCell.cell && this.mouseOverCell.state !== true) {
        this.mouseOverCell = {
          state: false,
          cell: undefined,
          count: 0,
          threshold: this.mouseOverCell.threshold,
        };

      }
    }
    else {

    }

  }
  closeCellInfoBox = () => {

    this.cellInfoMouseOver = false;
    this.showCellInfoBox = !this.showCellInfoBox;
    if (this.mouseOverCellSwitchOff.state === true) {
      this.mouseOverCellSwitchOff.state = false;
    }

    if (this.mouseOverCell.cell && this.mouseOverCell.state !== true) {
      // this.mouseOverCell.cell = {
      //   state: false,
      //   cell: undefined,
      //   count: 0,
      //   threshold: this.mouseOverCell.threshold,
      // };
    }

  }
  loadSettings = (event) => {
    event.preventDefault();


    let gridSize = event.target.gridSize.value;



    let playerNumber = event.target.humanPlayers.value;
    let aiPlayerNumber = event.target.aiCount.value;

    switch(gridSize) {
      case '3' :
        this.gridWidth = 3;
        this.sceneY = this.state.sceneY.three;
      break;
      case '6' :
        this.gridWidth = 6;
        this.sceneY = this.state.sceneY.six;
      break;
      case '9' :
        this.gridWidth = 9;
        this.sceneY = this.state.sceneY.nine;
      break;
      case '12' :
        this.gridWidth = 12;
        this.sceneY = this.state.sceneY.twelve;
      break;
    }


    this.gamepadConfig = [];
    for (const plyr2 of this.settingsFormPlayerData.input) {
        this.gamepadConfig.push({
          plyrNo:plyr2.plyrNo,
          input:plyr2.input,
          type:'',
          id:'',
          mapping: '',
          gamepadIndex: undefined,
        })
        if (plyr2.input === "Gamepad") {
          this.gamepad = true;
        }
        this.players[plyr2.plyrNo-1].input = plyr2.input;
    }
    if (!this.settingsFormPlayerData.input.find(x => x.input === "Gamepad")) {
      this.gamepad = false;
    }
    this.connectedGamepadsInit = false;
    for (const plyr3 of this.settingsFormPlayerData.team) {
     this.players[plyr3.plyrNo-1].team = plyr3.team
    }

    // console.log('load settings this.gamepadConfig',this.gamepadConfig);



    if (playerNumber < 2) {
      this.players.splice(1,1)
      this.playerNumber = 1;
    } else {
      this.playerNumber = 2;
    }


    for (const plyr of this.settingsFormPlyrStartPosList) {
      this.players[plyr.plyrNo-1].startPosition.cell.number = plyr.selected
    }

    if (this.updateSettingsFormAiDataData.startItems === true) {
      this.disableInitItems = false;
    } else {
      this.disableInitItems = true;
    }

    this.gameReset('hard');

    // this.placeItems({init: true, items: ''});

    if (aiPlayerNumber > 0) {

      this.loadAiSettings()

    } else {

      this.updateSettingsFormAiDataData = {
        // count: {
        //   count: '0'
        // }
      };
      this.settingsFormAiStartPosList = [];
      this.setState({
        showSettings: false,
      })
      this.showSettingsCanvasData.state = false;

    }

    // console.log('this.settingsFormPlyrStartPosList',this.settingsFormPlyrStartPosList);
    // console.log('this.updateSettingsFormAiData',this.updateSettingsFormAiDataData);
    // console.log('this.settingsFormAiStartPosList',this.settingsFormAiStartPosList);

  }
  loadAiSettings = () => {
    // console.log('this.settingsFormAiStartPosList.length',this.settingsFormAiStartPosList.length);

    // if (this.settingsFormAiStartPosList.length > 0) {


      let initArray = this.updateSettingsFormAiDataData.random.map(x=>x = {
        plyrNo: x.plyrNo,
        random: x.random,
        mode: null,
        weapon: null,
        armor: null,
        team: null,
        mission: null,
        startPos: null,
        otherPositions: [],
      });


      for (const plyr of initArray) {

        for (const elem of this.updateSettingsFormAiDataData.mode) {
          if (elem.plyrNo === plyr.plyrNo) {

            if (elem.mode === 'random') {
              let whatMode = this.rnJesus(1,2);

              switch(whatMode) {
                case 1:
                  elem.mode = 'aggressive'
                break;
                case 2:
                  elem.mode = 'careful'
                break;
              }

            }

            plyr.mode = elem.mode;
          }
        }

        for (const elem2 of this.updateSettingsFormAiDataData.weapon) {
          if (elem2.plyrNo === plyr.plyrNo) {

            plyr.weapon = elem2.weapons;
          }
        }

        for (const elem5 of this.updateSettingsFormAiDataData.armor) {
          if (elem5.plyrNo === plyr.plyrNo) {

            plyr.armor = elem5.armor;
          }
        }

        for (const elem3 of this.updateSettingsFormAiDataData.mission) {
          if (elem3.plyrNo === plyr.plyrNo) {
            plyr.mission = elem3.mission;
          }
        }

        for (const elem6 of this.updateSettingsFormAiDataData.team) {
          if (elem6.plyrNo === plyr.plyrNo) {
            plyr.team = elem6.team;
          }
        }

        for (const elem4 of this.settingsFormAiStartPosList) {
          if (elem4.plyrNo === plyr.plyrNo) {
            for (const cell of elem4.selected) {
              if (cell.type === 'start') {
                plyr.startPos = cell.cell;
              }
              else {
                plyr.otherPositions.push(cell.cell)
              }
            }
          }
        }

      }

      if (this.updateSettingsFormAiDataData.startItems === true) {
        this.disableInitItems = false;
      } else {
        this.disableInitItems = true;
      }

      // console.log('initArray',initArray);


      for (let i = 1; i < initArray.length+1; i++) {
        setTimeout(() => {
        // setTimeout(function timer() {

          let elem5 = initArray[i-1]

          // console.log('plyr',elem5.plyrNo,'this.addAiCount.state',this.addAiCount.state);

          if (elem5.random === 'random') {
            this.addAiRandomPlayer(elem5.random)
          }
          else {

            this.aiInitSettings = {
              randomStart: false,
              startPosition: {
                number: {
                  x: elem5.startPos.x,
                  y: elem5.startPos.y,
                }
              },
              primaryMission: elem5.mission,
              mission: undefined,
              mode: elem5.mode,
              partolArea: elem5.otherPositions,
              weapons: elem5.weapon,
              armor: elem5.armor,
              team: elem5.team,
            }

            this.addAiPlayer();
          }

        }, i * 1000);
      }


      // this.updateSettingsFormAiDataData = {};
      // this.settingsFormAiStartPosList = [];
      this.setState({
        showSettings: false,
      })


    // }

  }
  cancelSettings = () => {

    // this.updateSettingsFormAiDataData = {};
    this.settingsFormAiStartPosList = [];
    this.setState({
      showSettings: false,
    })
    this.showSettingsCanvasData.state = false;



  }
  openSettings = () => {
    this.setState({
      showSettings: true,
    })

    // if (this.showSettingsCanvasData.state === true) {
    //   this.settingsFormGridWidthUpdate(this.settingsGridWidth)
    // }
    //
    // this.settingsFormAiGridInfo = this.gridInfo;
    //
    // this.getCustomPlyrStartPosList(
    //   [
    //     {
    //       plyrNo: 1,
    //       selected: undefined,
    //       posArray: []
    //     },
    //     {
    //       plyrNo: 2,
    //       selected: undefined,
    //       posArray: []
    //     }
    //   ]
    // )

  }
  expandDebugBox = (plyrNo) => {
    if (plyrNo === 1) {
      this.debugBoxStyle = "debugDisplay openDebug"
    }
    if (plyrNo === 2) {
      this.debugBoxStyle2 = "debugDisplay2 openDebug"
    }
  }
  minimizeDebugBox = (plyrNo) => {
    if (plyrNo === 1) {
      this.debugBoxStyle = "debugDisplay closedDebug"
    }
    if (plyrNo === 2) {
      this.debugBoxStyle2 = "debugDisplay2 closedDebug"
    }
  }


  getCustomPlyrStartPosList = (args) => {
    // console.log('getCustomPlyrStartPosList',this.gridInfo.length,args);
    this.settingsFormPlyrGridInfo = this.gridInfo;

    this.playerNumber = args.length;

    let avoidCells = [];

    this.settingsFormPlyrStartPosList = [];

    for (const plyr of args) {

      let array1 = [];

      // AVOID ALREADY SELECTRED POSITIONS
      if (plyr.selected) {
        avoidCells.push(plyr.selected)
      }


      // NO POSITION SELECTED, GAME STARTING. USE DEFAULT START POSITIONS
      if (!plyr.selected) {

        if (!this.gridInfo.find(x => x.number.x === this.players[plyr.plyrNo-1].startPosition.cell.number.x && x.number.y === this.players[plyr.plyrNo-1].startPosition.cell.number.y)) {

          let cll = {x: undefined, y: undefined};
          let randomFreeCellChosen = false;

          while (randomFreeCellChosen !== true) {
            cll.x = this.rnJesus(0,this.gridWidth)
              cll.y = this.rnJesus(0,this.gridWidth)
              randomFreeCellChosen = this.checkCell(cll);
          }

          if (randomFreeCellChosen === true) {
            this.players[plyr.plyrNo-1].startPosition.cell.number = cll;
          }

        }

        let playerStartPos = this.players[plyr.plyrNo-1].startPosition.cell.number;


        avoidCells.push({x:playerStartPos.x,y:playerStartPos.y})

      }


      // CHECK FOR AI POSITIONS TO ADD TO CELLS TO AVOID
      if (this.updateSettingsFormAiDataData.count) {
        if (parseInt(this.updateSettingsFormAiDataData.count.count) > 0) {
          for (const plyr2 of this.settingsFormAiStartPosList) {
            for (const selected of plyr2.selected) {
              avoidCells.push(selected.cell)
            }
          }
        }
      }


      // BUILD AVALIBLE POSITION ARRAY EXCLUDING CELLS TO AVOID

      for (const elem of this.settingsFormPlyrGridInfo) {
        if (
          this.plyrStartPosCheckCell({x:elem.number.x,y:elem.number.y}) === true &&
          !avoidCells.find(elem2 => elem2.x === elem.number.x && elem2.y === elem.number.y)
        ) {
          array1.push({x:elem.number.x,y:elem.number.y});
        }

      }

      // NO POSITION SELECTED, GAME STARTING. MARK PLAYR POSITION SELECTED
      if (!plyr.selected) {
        let playerStartPos = this.players[plyr.plyrNo-1].startPosition.cell.number;

        plyr.selected = {x:playerStartPos.x,y:playerStartPos.y}

      }


      // PUSH TO SETTINGS PLAYER POSITION DATA
      this.settingsFormPlyrStartPosList.push({
        plyrNo:plyr.plyrNo,
        posArray:array1,
        selected: plyr.selected,
      })


      // FORCE STATE UPDATE FOR SETTINGS COMPONENT
      this.setState({
        stateUpdater: '..'
      })


    }
    // console.log('this.settingsFormPlyrStartPosList',this.settingsFormPlyrStartPosList);

    // ADD 'RANDOM' CHOICE TO NEW POSITION AVAILIBLE ARRAY
    let lastAvailiblePosArray = this.settingsFormPlyrStartPosList[this.settingsFormPlyrStartPosList.length-1].posArray;
    let hasRandomCell = lastAvailiblePosArray.find(x=>x === 'random')
    if (!hasRandomCell) {
      lastAvailiblePosArray.push('random')
    }
    // console.log('lastAvailiblePosArray',lastAvailiblePosArray);
    for (const elem of this.settingsFormPlyrStartPosList) {
      // console.log('elem',elem);
      elem.posArray = lastAvailiblePosArray;
    }

    this.setState({
      stateUpdater: '..'
    })

    this.settingsFormGridWidthUpdate(this.settingsGridWidth)

    // console.log('this.settingsFormPlyrStartPosList',this.settingsFormPlyrStartPosList);

  }
  plyrStartPosCheckCell = (cell) => {

    let cellFree = true;
    let cell2 = this.gridInfo.find(elem => elem.number.x === cell.x && elem.number.y === cell.y);
    // if (
    //   cell2.levelData.charAt(0) ===  'z' ||
    //   cell2.levelData.charAt(0) ===  'y'
    // ) {
    //   cellFree = false;
    // }
    // if (cell2.item.name !== '') {
    //   cellFree = false;
    // }
    // if (
    //   cell2.terrain.type === 'deep' ||
    //   cell2.terrain.type === 'hazard'
    // ) {
    //   cellFree = false;
    // }

    if (
      cell2.obstacle.state === true ||
      // cell2.barrier.state === true ||
      cell2.item.name !== '' ||
      cell2.terrain.type === 'deep' ||
      cell2.terrain.type === 'hazard'
    ) {
      cellFree = false;
    }

    // PLAYERS 1&2 ALT RESPAWN POINTS!
    if (cell.x === this.gridWidth && cell.y === this.gridWidth) {
      cellFree = false;
    }
    if (cell.x === this.gridWidth && cell.y === 0) {
      cellFree = false;
    }

    return cellFree;

  }
  getCustomAiStartPosList = (args) => {
    // console.log('getCustomAiStartPosList',args);

    let avoidCells = [];

    if (args.length === 0) {

      this.settingsFormAiStartPosList = [];

      this.setState({
        stateUpdater: '..'
      })
    }
    else {
      avoidCells = [];
      this.settingsFormAiStartPosList = [];
      for (const plyr of args) {
        // switch(plyr.mission) {
        //   case 'pursue':
        //
        //   break;
        //   case 'patrol':
        //   break;
        //   case 'defend':
        //   break;
        // }

        let array1 = [];
        if (plyr.selected.length > 0) {
          for (const selected of plyr.selected) {
            avoidCells.push(selected.cell)
          }
        }

        if (this.settingsFormPlyrStartPosList[0]) {
          for (const plyr2 of this.settingsFormPlyrStartPosList) {
            avoidCells.push(plyr2.selected)
          }
        }

        for (const elem of this.settingsFormAiGridInfo) {

          if (
            this.checkCell({x:elem.number.x,y:elem.number.y}) === true
            && !avoidCells.find(elem2 => elem2.x === elem.number.x && elem2.y === elem.number.y)
          ) {
            array1.push({x:elem.number.x,y:elem.number.y});
          }

        }
        // console.log('this.settingsFormAiGridInfo',this.settingsFormAiGridInfo);
        // console.log('array1',array1);


        if (plyr.selected.length === 0) {
          let doubleCheckArray = array1;

          if (plyr.mission === 'patrol') {
            avoidCells.push({x:array1[0].x,y:array1[0].y})
            avoidCells.push({x:array1[1].x,y:array1[1].y})
            avoidCells.push({x:array1[2].x,y:array1[2].y})

            plyr.selected.push({type:'start',cell:{x:array1[0].x,y:array1[0].y}})
            plyr.selected.push({type:'patrol1',cell:{x:array1[1].x,y:array1[1].y}})
            plyr.selected.push({type:'patrol2',cell:{x:array1[2].x,y:array1[2].y}})

            doubleCheckArray = array1.filter(i=>i !== array1[0])
            doubleCheckArray = doubleCheckArray.filter(i=>i !== array1[1])
            doubleCheckArray = doubleCheckArray.filter(i=>i !== array1[2])
          }
          if (plyr.mission === 'defend') {
            avoidCells.push({x:array1[0].x,y:array1[0].y})
            avoidCells.push({x:array1[1].x,y:array1[1].y})

            plyr.selected.push({type:'start',cell:{x:array1[0].x,y:array1[0].y}})
            plyr.selected.push({type:'defend',cell:{x:array1[1].x,y:array1[1].y}})

            doubleCheckArray = array1.filter(i=>i !== array1[0])
            doubleCheckArray = doubleCheckArray.filter(i=>i !== array1[1])
          }
          if (plyr.mission === 'pursue') {
            avoidCells.push({x:array1[0].x,y:array1[0].y})

            plyr.selected.push({type:'start',cell:{x:array1[0].x,y:array1[0].y}})

            doubleCheckArray = array1.filter(i=>i !== array1[0])
          }

          array1 = doubleCheckArray;
        }


        this.settingsFormAiStartPosList.push({
          plyrNo:plyr.plyrNo,
          mission:plyr.mission,
          posArray:array1,
          selected: plyr.selected,
        })

        this.setState({
          stateUpdater: '..'
        })

      }

      let lastAvailiblePosArray = this.settingsFormAiStartPosList[this.settingsFormAiStartPosList.length-1].posArray;
      let hasRandomCell = lastAvailiblePosArray.find(x=>x === 'random')
      if (!hasRandomCell) {
        lastAvailiblePosArray.push('random')
      }

      for (const elem of this.settingsFormAiStartPosList) {
        // console.log('elem',elem);
        elem.posArray = lastAvailiblePosArray;
      }

      this.setState({
        stateUpdater: '..'
      })

    }
    // console.log('updateSettingsFormAiData',this.updateSettingsFormAiDataData);
    this.settingsFormGridWidthUpdate(this.settingsGridWidth)

  }
  settingsFormGridWidthUpdate = (args) => {
    // console.log('settingsFormGridWidthUpdate args',args);

    // this.showSettingsCanvasData = {
    //   state: true,
    //   field: 'human_start',
    //   plyrNo: 1,
    //   type: 'start',
    // }


    if (this.gridWidth <= 9) {
      this.camera.zoom.x = 1;
      this.camera.zoom.y = 1;
    }


    let prevGridWidth = this.gridWidth;
    let canvas = this.state.canvas;

    this.gridWidth = args;


    let gridInfo;

    // ----------------
    this.startProcessLevelData(this.state.canvas);
    gridInfo = this.gridInfo;
    this.processLevelData(gridInfo);
    // ----------------



    // this.settingsFormAiGridInfo = this.gridInfo;
    this.settingsFormAiGridInfo = this.settingsGridInfo;

    // console.log('post process barrier check settings',this.settingsGridInfo.filter(x => x.barrier.state === true).map(y => y = y.barrier.position));

    this.settingsGridWidth = args;

    if (this.settingsGridWidth === 12) {
      this.settingsCanvasWidth = 700;
      this.settingsCanvasHeight = 400;
      this.settingsSceneX = 350;
      this.settingsSceneY = 50;
    }
    if (this.settingsGridWidth === 9) {
      this.settingsCanvasWidth = 500;
      this.settingsCanvasHeight = 300;
      this.settingsSceneX = 250;
      this.settingsSceneY = 40;
    }
    if (this.settingsGridWidth === 6) {
      this.settingsCanvasWidth = 400;
      this.settingsCanvasHeight = 250;
      this.settingsSceneX = 200;
      this.settingsSceneY = 50;
    }
    if (this.settingsGridWidth === 3) {
      this.settingsCanvasWidth = 300;
      this.settingsCanvasHeight = 150;
      this.settingsSceneX = 150;
      this.settingsSceneY = 40;
    }



    if (this.state.showSettings === true && this.showSettingsCanvasData.state === true) {

      let canvas3 = this.canvasRef3.current;
      let context3 = canvas3.getContext('2d');


      canvas3.addEventListener("click", e => {
        this.getSettingsCanvasClick(canvas3, e)
      });

      let canvas4;
      let context4;

      if (this.showSettingsCanvasData.field.split("_")[0] === 'ai') {
        canvas4 = this.canvasRef4.current;
        context4 = canvas4.getContext('2d');
        canvas4.addEventListener("click", e => {
          this.getSettingsCanvasClick(canvas4, e)
        });
      }


      setTimeout(()=>{
        this.redrawSettingsGrid(canvas3,context3,canvas4,context4);
      }, 30);

    }

    // this.redrawSettingsGrid(this.state.canvas3,this.state.context3);

    // this.gridWidth = prevGridWidth;


    // ----------------
    // this.startProcessLevelData(this.state.canvas);
    // gridInfo = this.gridInfo;
    // this.processLevelData(gridInfo);
    // ----------------



    // this.setState({
    //   stateUpdater: '..'
    // })


  }
  updateSettingsFormAiData = (args) => {

    this.updateSettingsFormAiDataData = {
      startItems: args.startItems,
      count: args.count,
      random: args.random,
      mode: args.mode,
      weapon: args.weapon,
      armor: args.armor,
      team: args.team,
      mission: args.mission,
    }
    this.setState({
      stateUpdater: '..'
    })
    // console.log('updateSettingsFormAiData',this.updateSettingsFormAiDataData);
    this.settingsFormGridWidthUpdate(this.settingsGridWidth)

  }
  redrawSettingsGrid = (canvas3,context3,canvas4,context4) => {
    // console.log('redrawSettingsGrid',this.settingsFormPlyrStartPosList);


    let takenSpaces = [];
    for (const elem of this.settingsFormPlyrStartPosList) {

      takenSpaces.push({
        plyrNo: elem.plyrNo,
        type: 'start',
        pos: {
          x: elem.selected.x,
          y: elem.selected.y,
        },
      })
    }
    for (const elem2 of this.settingsFormAiStartPosList) {

      let humanPlyrCount = this.settingsFormPlyrStartPosList.length
      let plyrNo = humanPlyrCount+elem2.plyrNo;

      for (const elem3 of elem2.selected) {

        takenSpaces.push({
          plyrNo: plyrNo,
          type: elem3.type,
          pos: {
            x: elem3.cell.x,
            y: elem3.cell.y,
          },
        })

      }


    }

    let floorImageWidth = this.floorImageWidth;
    let floorImageHeight = this.floorImageHeight;
    let wallImageWidth = this.wallImageWidth;
    let wallImageHeight = this.wallImageHeight;
    let sceneX = this.settingsSceneX;
    let sceneY = this.settingsSceneY;
    let tileWidth = this.tileWidth;

    let wall = this.refs.wall;
    let wall2 = this.refs.wall2;
    let wall3 = this.refs.wall3;

    let floorImgs = this.floorImgs;
    let obstacleImgs = this.obstacleImgs;
    let barrierImgs = this.barrierImgs;


    class Point {
        constructor(x, y) {
            this.x = x;
            this.y = y;
        }
    }

    for (var x = 0; x < this.settingsGridWidth+1; x++) {
      for (var y = 0; y < this.settingsGridWidth+1; y++) {

        let p2 = new Point();
        p2.x = x * (tileWidth/2);
        p2.y = y * (tileWidth/2);

        let iso2 = this.cartesianToIsometric(p2);
        let offset2 = {x: (floorImageWidth/2)/2, y: (floorImageHeight/2)}

        // apply offset to center scene for a better view
        iso2.x += sceneX
        iso2.y += sceneY


        let center2 = {
          x: iso2.x - offset2.x/2+(this.cellCenterOffsetX/2),
          y: iso2.y - offset2.y/2-(this.cellCenterOffsetY/2),
        }

        let cell = this.settingsGridInfo.find(elem => elem.number.x === x && elem.number.y === y);
        let cellLevelData = this.settingsGridInfo.find(elem => elem.number.x === x && elem.number.y === y).levelData;


        let floor = floorImgs[cell.terrain.name]

        if (cell.void.state === true) {
          // drawFloor = false;
          floor = floorImgs.void3
        }

        if (x === this.gridWidth && y === this.gridWidth) {
          floor = floorImgs.void2;
        }
        if (x === this.gridWidth && y === 0) {
          floor = floorImgs.void2;
        }

        context3.drawImage(floor, iso2.x - offset2.x, iso2.y - offset2.y, 50, 50);

        context3.fillStyle = 'black';
        context3.fillText(""+x+","+y+"",iso2.x - offset2.x/2 + 5,iso2.y - offset2.y/2 + 2)

        // context3.fillStyle = "black";
        // context3.fillRect(center2.x, center2.y,2.5,2.5);

        if (context4) {
          context4.drawImage(floor, iso2.x - offset2.x, iso2.y - offset2.y, 50, 50);
          context4.fillStyle = 'black';
          context4.fillText(""+x+","+y+"",iso2.x - offset2.x/2 + 5,iso2.y - offset2.y/2 + 2)
        }

        let vertices = [
          {x:center2.x, y:center2.y+this.tileWidth/4},
          {x:center2.x+this.tileWidth/2, y:center2.y},
          {x:center2.x, y:center2.y-this.tileWidth/4},
          {x:center2.x-this.tileWidth/2, y:center2.y},
        ];

        for (const vertex of vertices) {
          context3.fillStyle = "yellow";
          context3.fillRect(vertex.x-1.5, vertex.y-1.5,2.5,2.5);
          if (context4) {
            context4.fillStyle = "yellow";
            context4.fillRect(vertex.x-1.5, vertex.y-1.5,2.5,2.5);
          }
        }

        // TAKEN POSITIONS HIGHLIGHT!!
        let floorHighlight;
        for (const space of takenSpaces) {

          if (
            x === space.pos.x &&
            y === space.pos.y
          ) {
            switch(space.plyrNo) {
              case 1:
                floorHighlight = 'blue';
              break;
              case 2:
                floorHighlight = 'red';
              break;
              case 3:
                floorHighlight = 'green';
              break;
              case 4:
                floorHighlight = 'purple';
              break;
              case 5:
                floorHighlight = 'orange';
              break;
              case 6:
                floorHighlight = 'black';
              break;
            }
            context3.lineWidth = 5;
            context3.beginPath();
            if (context4) {
              context4.lineWidth = 5;
              context4.beginPath();
            }
            for (const vertex of vertices) {
              context3.strokeStyle = floorHighlight;
              context3.lineTo(vertex.x, vertex.y);
              if (context4) {
                context4.strokeStyle = floorHighlight;
                context4.lineTo(vertex.x, vertex.y);
              }
            }
            context3.closePath();
            context3.stroke();
            if (context4) {
              context4.closePath();
              context4.stroke();
            }
          }
        }



        // BARRIERS & OBSTACLES

        if (cell.obstacle.state === true && cell.void.state !== true) {
          // let offset = {x: wallImageWidth/4, y: wallImageHeight/2}
          let obstacleImg = obstacleImgs[cell.obstacle.type]

          context3.drawImage(obstacleImg, iso2.x - offset2.x, iso2.y - (obstacleImg.height/2), obstacleImg.width/2, obstacleImg.height/2);
          if (context4) {
            context4.drawImage(obstacleImg, iso2.x - offset2.x, iso2.y - (obstacleImg.height/2), obstacleImg.width/2, obstacleImg.height/2);
          }

        }

        if (cell.barrier.state === true && cell.void.state !== true) {

          let barrierImg = barrierImgs[cell.barrier.type][cell.barrier.position]
          context3.drawImage(barrierImg, iso2.x - offset2.x, iso2.y - (barrierImg.height/2), barrierImg.width/2, barrierImg.height/2);
          if (context4) {
            context4.drawImage(barrierImg, iso2.x - offset2.x, iso2.y - (barrierImg.height/2), barrierImg.width/2, barrierImg.height/2);
          }

        }

      }
    }

    this.setState({
      stateUpdater: '..'
    })

  }
  updateSettingsCanvasData = (args) => {
    // console.log('updateSettingsCanvasData',args);

    let el = document.getElementsByClassName('settingsOverlay')[0];
    let el2 = document.getElementsByClassName('settingsContainer')[0];
    // console.log('xx',el.scrollLeft, el.scrollTop);
    // console.log('xx',el2.scrollLeft, el2.scrollTop);

    let humanPlyrCount = this.settingsFormPlyrStartPosList.length;
    let plyrNo = args.plyrNo;
    if (args.type.split("_")[0] === 'ai') {
      plyrNo = humanPlyrCount+args.plyrNo;
    }


    this.showSettingsCanvasData = {
      state: true,
      field: args.type,
      plyrNo: plyrNo,
      type: args.type.split("_")[1],
    }

    this.setState({
      stateUpdater: '..'
    })

    setTimeout(()=>{
      // this.redrawSettingsGrid(canvas3,context3,canvas4,context4);
      this.settingsFormGridWidthUpdate(this.settingsGridWidth)
    }, 30);
    // this.settingsFormGridWidthUpdate(this.settingsGridWidth)


    // this.setState({
    //   stateUpdater: '..'
    // })

  }
  updateSettingsFormPlayerData = (args) => {

    this.settingsFormPlayerData = args;

    this.setState({
      stateUpdater: '..'
    })

  }



  findFocusCell = (inputType,focus,canvas,context,speed) => {

    let cell = {
      x: undefined,
      y: undefined
    }
    let direction = "";
    let cellOffsetX = 0;
    let cellOffsetY = 0;
    let centerCellRef = {
      x: 4,
      y: 4,
    }
    let newCell = {
      x: undefined,
      y: undefined,
    }


    if (inputType === 'cellToPan') {


      let destCell = focus;
      let originCell = {
        x: this.camera.focusCell.x,
        y: this.camera.focusCell.y,
      };
      // let originCell = this.camera.cellToPanOrigin;
      let x1 = originCell.x;
      let y1 = originCell.y;
      let x2 = destCell.x;
      let y2 = destCell.y;
      let xSteps = 0;
      let ySteps = 0;
      let xDirection = "";
      let yDirection = "";
      let preInstructions = [];

      if (x1 > x2) {
        xDirection = "west";
        xSteps = x1-x2;
      }
      if (x2 > x1) {
        xDirection = "east";
        xSteps = x2-x1;
      }
      if (y1 > y2) {
        yDirection = "north";
        ySteps = y1-y2;
      }
      if (y2 > y1) {
        yDirection = "south";
        ySteps = y2-y1;
      }

      for (var i = 0; i < xSteps; i++) {
        preInstructions.push(
          xDirection
        )
      }
      for (var j = 0; j < ySteps; j++) {
        preInstructions.push(
          yDirection
        )
      }

      // console.log('origin',originCell,'destination',destCell,'instructions',preInstructions);

      // this.camera.cellToPanOrigin.x = destCell.x;
      // this.camera.cellToPanOrigin.y = destCell.y;



      for (const instruction of preInstructions) {
        let indx = preInstructions.indexOf(instruction);

        switch (instruction) {
          case 'north':
          this.camera.instructions.push(
            {
              action:'pan_north',
              action2:'pan_east',
              count: 0,
              count2: 0,
              limit: 25,
              limit2: 50,
              speed: speed,
            },
            // {
            //   action:'pan_north',
            //   action2:'pan_east',
            //   count: 0,
            //   count2: 0,
            //   limit: 25,
            //   limit2: 50,
            // },
          )
          break;
          case 'south':
          this.camera.instructions.push(
            {
              action:'pan_south',
              action2:'pan_west',
              count: 0,
              count2: 0,
              limit: 25,
              limit2: 50,
              speed: speed,
            },
            // {
            //   action:'pan_south',
            //   action2:'pan_west',
            //   count: 0,
            //   count2: 0,
            //   limit: 25,
            //   limit2: 50,
            // },
          )
          break;
          case 'east':
          this.camera.instructions.push(
            {
              action:'pan_south',
              action2:'pan_east',
              count: 0,
              count2: 0,
              limit: 25,
              limit2: 50,
              speed: speed,
            },
            // {
            //   action:'pan_south',
            //   action2:'pan_east',
            //   count: 0,
            //   count2: 0,
            //   limit: 25,
            //   limit2: 50,
            // },
          )
          break;
          case 'west':
          this.camera.instructions.push(
            {
              action:'pan_north',
              action2:'pan_west',
              count: 0,
              count2: 0,
              limit: 25,
              limit2: 50,
              speed: speed,
            },
            // {
            //   action:'pan_north',
            //   action2:'pan_west',
            //   count: 0,
            //   count2: 0,
            //   limit: 25,
            //   limit2: 50,
            // },
          )
          break;
        }

      }

      // console.log('auto camera instructions',this.camera.instructions);

    }

    if (inputType === 'panToCell') {

      let focusCell;
      const rect = canvas.getBoundingClientRect()
      const scale = rect.width / canvas.offsetWidth;
      // console.log('rect.width',rect.width);

      const x = this.canvasWidth/2;
      const y = this.canvasHeight/2;

      // ADJUSTED FOR CANVAS SCALE & TRANSFORM
      let newX = (x-this.camera.zoomFocusPan.x)/this.camera.zoom.x;
      let newY = (y-this.camera.zoomFocusPan.y)/this.camera.zoom.y;

      let insideGrid = false;

      for(const cell of this.gridInfo) {
        let point = [newX,newY];
        // let point = [newX,newY];
        let polygon = [];
        for (const vertex of cell.vertices) {
          let vertexPoint = [vertex.x+10,vertex.y+5];
          polygon.push(vertexPoint)
        }
        let pip = pointInPolygon(point, polygon)
        if (pip === true) {
          insideGrid = true;
          // console.log("camera focus cell",cell.number,"x: " + x + " y: " + y);
          focusCell = cell;
        }
      }
      if ( insideGrid === false ) {
        // console.log("clicked the canvas", 'x: ',x,'y: ',y);
        // console.log('clicked outside the grid');
        // this.showCellInfoBox = false;
        focusCell = {
          number:{
            x:0,
            y:0
          },
          center:{
            x:0,
            y:0
          },
          drawCenter:{
            x:0,
            y:0
          },
          vertices: [
            {
              x:0,
              y:0
            },
            {
              x:0,
              y:0
            },
            {
              x:0,
              y:0
            },
            {
              x:0,
              y:0
            },
          ],
          side: 0,
          levelData: '',
          edge: {
            state: false,
            side: ''
          },
          terrain: {
            name: '',
            type: '',
            effect: ''
          },
          item: {
            name: '',
            type: '',
            subType: '',
            effect: '',
            initDrawn: false
          },
          void: {
            state: false
          },
          obstacle: {
            state: false,
            name: '',
            type: '',
            hp: 2,
            destructible: {
              state: false,
              weapons: [],
              leaveRubble: false,
            },
            locked: {
              state: false,
              key: '',
            },
            weight: 1,
            height: 0.5,
            items: [],
            effects: [],
            moving: {
              state: false,
              step: 0,
              origin: {
                number: {
                  x: undefined,
                  y: undefined,
                },
                center: {
                  x: undefined,
                  y: undefined,
                },
              },
              destination: {
                number: {
                  x: undefined,
                  y: undefined,
                },
                center: {
                  x: undefined,
                  y: undefined,
                },
              },
              currentPosition: {
                x: undefined,
                y: undefined,
              },
              nextPosition: {
                x: undefined,
                y: undefined,
              },
              moveSpeed: 0,
              pushable: true,
              pushed: false,
              pusher: undefined,
              falling: {
                state: false,
                count: 0,
                limit: 10,
              },
            }
          },
          barrier: {
            state: false,
            name: '',
            type: '',
            hp: 2,
            destructible: {
              state: false,
              weapons: [],
              leaveRubble: false,
            },
            locked: {
              state: false,
              key: '',
            },
            position: '',
            height: 1,
          },
          elevation: {
            number: 0,
            type: '',
            position: '',
          },
          rubble: false,
        }
        this.cellsToHighlight2 = [];
      }


      // SEND FOCUS CELL TO cellsToHighlight

      if (insideGrid === true) {
        // console.log('panToCell using pointInPolygon',focusCell.number);
        this.camera.focusCell.x = focusCell.number.x;
        this.camera.focusCell.y = focusCell.number.y;
        // console.log('panToCell camera.focusCell',this.camera.focusCell);
        if (this.highlightZoomPanFocusCell === true) {
          for (const cell2 of this.cellsToHighlight2) {
            if (cell2.number.x !== focusCell.number.x || cell2.number.y !== focusCell.number.y) {
              let indx = this.cellsToHighlight2.indexOf(cell2);
              this.cellsToHighlight2.splice(indx,1)
            }
          }
          if (!this.cellsToHighlight2.find(x=> x.number.x === focusCell.number.x && x.number.y === focusCell.number.y)) {
            this.cellsToHighlight2.push(
              {
                number: {
                  x: focusCell.number.x,
                  y: focusCell.number.y,
                },
                count: 0,
                limit: 0,
              },
            )
          }
          // console.log('this.cellsToHighlight2',this.cellsToHighlight2);
        }

      }


      if (this.camera.pan.x < 0) {
        direction = 'east';
        cellOffsetX = parseInt((this.camera.pan.x/50).toFixed(0))
      }
      if (this.camera.pan.x > 0) {
        direction = 'west';
        cellOffsetX = parseInt((this.camera.pan.x/50).toFixed(0))
      }
      if (this.camera.pan.y > 0) {
        direction = 'north';
        cellOffsetY = parseInt((this.camera.pan.y/25).toFixed(0))
      }
      if (this.camera.pan.y < 0) {
        direction = 'south';
        cellOffsetY = parseInt((this.camera.pan.y/25).toFixed(0))
      }

      if (this.camera.pan.x === -1) {
        cellOffsetX = 0;
      }
      if (this.camera.pan.y === -1) {
        cellOffsetY = 0;
      }

      // console.log('cellOffsetX',cellOffsetX,'cellOffsetY',cellOffsetY);

    }


  }
  toggleCameraModeUI = (mode) => {

    this.camera.mode = mode;
  }
  closeCamera = () => {
    this.camera.state = false;
  }
  preResetCamera = () => {

    this.resetCameraSwitch = true;

  }
  setAutoCamera = (args,player) => {

    this.camera.state = false;
    this.camera.fixed = false;
    this.settingAutoCamera = true;
    // console.log('setting auto camera instructions: ',args);


    // if board is over a certain size
    //   if 1 player and positions changes x amount of times within a this.time interval (use modulo), pan hard to follow
    //   if 2 players only follow if both positions change x amount of times within a this.time interval (use modulo) and they are in range (use targetArea scan func), pan soft to follow
    //   else, zoom and pan to get them both as centered and close zoomed as possible

    let weaponType = "";
    if (
      player.currentWeapon.type === 'spear' ||
      player.currentWeapon.type === 'sword' ||
      player.currentWeapon.type === ''
    ) {
      weaponType = 'melee'
    }
    if (
      player.currentWeapon.type === 'crossbow' ||
      player.currentWeapon.type === 'bow'
    ) {
      weaponType = 'ranged'
    }


    let zoomAdjust = 0;
    switch (args) {
      case 'attackFocus':


        if (this.playerNumber === 1) {

          this.camera.preInstructions.push(
            'moveTo_'+player.currentPosition.cell.number.x+'_'+player.currentPosition.cell.number.y+'_fast',
            // 'waitFor_50',
          )

          if (weaponType === 'melee') {

            if ((this.camera.zoom.x-1) < .50) {
              // console.log('auto camera single player attack focus zoom amt',Math.ceil(((.50-(this.camera.zoom.x-1))*10)*5));
              zoomAdjust = Math.ceil(((.50-(this.camera.zoom.x-1))*10)*5);
              this.camera.preInstructions.push(
                'zoom_in_'+zoomAdjust+''
              )
            }

          }

          if (weaponType === 'ranged') {

            if ((this.camera.zoom.x-1) < .35) {
              // console.log('auto camera single player attack focus zoom amt',Math.ceil(((.35-(this.camera.zoom.x-1))*10)*5));
              zoomAdjust = Math.ceil(((.35-(this.camera.zoom.x-1))*10)*5);
              this.camera.preInstructions.push(
                'zoom_in_'+zoomAdjust+''
              )
            }

          }



        }

        if (this.playerNumber === 2) {


          let originCell = {
            x: player.currentPosition.cell.number.x,
            y: player.currentPosition.cell.number.y,
          };
          let destCell = {
            x: this.players[1].currentPosition.cell.number.x,
            y: this.players[1].currentPosition.cell.number.y,
          };

          let x1 = originCell.x;
          let y1 = originCell.y;
          let x2 = destCell.x;
          let y2 = destCell.y;
          let xSteps = 0;
          let ySteps = 0;
          let xDirection = "";
          let yDirection = "";
          let preInstructions = [];

          if (x1 > x2) {
            xDirection = "west";
            xSteps = x1-x2;
          }
          if (x2 > x1) {
            xDirection = "east";
            xSteps = x2-x1;
          }
          if (y1 > y2) {
            yDirection = "north";
            ySteps = y1-y2;
          }
          if (y2 > y1) {
            yDirection = "south";
            ySteps = y2-y1;
          }

          for (var i = 0; i < xSteps; i++) {
            preInstructions.push(
              xDirection
            )
          }
          for (var j = 0; j < ySteps; j++) {
            preInstructions.push(
              yDirection
            )
          }

          let parsedPreInstructions = []
          let currentCell = {
            x: originCell.x,
            y: originCell.y,
          }

          parsedPreInstructions.push(originCell)

          for (const instruction of preInstructions) {

            switch (instruction) {
              case 'north':
                currentCell.y -= 1;
                parsedPreInstructions.push({
                  x: currentCell.x,
                  y: currentCell.y,
                })
              break;
              case 'south':
                currentCell.y += 1;
                parsedPreInstructions.push({
                  x: currentCell.x,
                  y: currentCell.y,
                })
              break;
              case 'west':
                currentCell.x -= 1;
                parsedPreInstructions.push({
                  x: currentCell.x,
                  y: currentCell.y,
                })
              break;
              case 'east':
                currentCell.x += 1;
                parsedPreInstructions.push({
                  x: currentCell.x,
                  y: currentCell.y,
                })
              break;
            }

              // console.log(''+preInstructions.indexOf(instruction)+'',parsedPreInstructions);

          }

          if (parsedPreInstructions.length < 4) {

            // console.log('attack focus auto cam: 2 players in close range');


            this.camera.preInstructions.push(
              'moveTo_'+player.currentPosition.cell.number.x+'_'+player.currentPosition.cell.number.y+'_fast',
              // 'moveTo_'+this.players[0].currentPosition.cell.number.x+'_'+this.players[0].currentPosition.cell.number.y+'_fast',
              // 'waitFor_50',
            )

            if (weaponType === 'melee') {
              if ((this.camera.zoom.x-1) < .50) {
                // console.log('auto camera 2 player close melee attack focus zoom in amt',Math.ceil(((.50-(this.camera.zoom.x-1))*10)*5));
                zoomAdjust = Math.ceil(((.50-(this.camera.zoom.x-1))*10)*5);
                this.camera.preInstructions.push(
                  'zoom_in_'+zoomAdjust+''
                )
              }
              if ((this.camera.zoom.x-1) > .50) {
                // console.log('auto camera 2 player close melee attack focus zoom out amt',Math.ceil((((this.camera.zoom.x-1)-.50)*10)*5));
                zoomAdjust = Math.ceil((((this.camera.zoom.x-1)-.50)*10)*5);
                this.camera.preInstructions.push(
                  'zoom_out_'+zoomAdjust+''
                )
              }
            }

            if (weaponType === 'ranged') {
              if ((this.camera.zoom.x-1) < .35) {
                // console.log('auto camera 2 player close ranged attack focus zoom in amt',Math.ceil(((.35-(this.camera.zoom.x-1))*10)*5));
                zoomAdjust = Math.ceil(((.35-(this.camera.zoom.x-1))*10)*5);
                this.camera.preInstructions.push(
                  'zoom_in_'+zoomAdjust+''
                )
              }
              if ((this.camera.zoom.x-1) > .35) {
                // console.log('auto camera 2 player close ranged attack focus zoom out amt',Math.ceil((((this.camera.zoom.x-1)-.35)*10)*5));
                zoomAdjust = Math.ceil((((this.camera.zoom.x-1)-.35)*10)*5);
                this.camera.preInstructions.push(
                  'zoom_out_'+zoomAdjust+''
                )
              }
            }



          }
          else {


            // console.log('attack focus auto cam: 2 players at a distance');

            // console.log('preInstructions',parsedPreInstructions,parsedPreInstructions[(parsedPreInstructions.length/2).toFixed(0)]);

            // let intermediateCell = {
            //   x: parsedPreInstructions[(parsedPreInstructions.length/2).toFixed(0)].x,
            //   y: parsedPreInstructions[(parsedPreInstructions.length/2).toFixed(0)].y,
            // }
            let intermediateCell = {
              x: parsedPreInstructions[Math.ceil((parsedPreInstructions.length/2))].x,
              y: parsedPreInstructions[Math.ceil((parsedPreInstructions.length/2))].y,
            }

            this.camera.preInstructions.push(
              'moveTo_'+intermediateCell.x+'_'+intermediateCell.y+'_fast',
              // 'waitFor_50',
            )


            if ((this.camera.zoom.x-1) < .35) {
              // console.log('auto cam 2 player attack focus distance zoom in amt',Math.ceil(((.35-(this.camera.zoom.x-1))*10)*5));
              zoomAdjust = Math.ceil(((.35-(this.camera.zoom.x-1))*10)*5);
              this.camera.preInstructions.push(
                'zoom_in_'+zoomAdjust+''
              )
            }
            if ((this.camera.zoom.x-1) > .35) {
              // console.log('auto cam 2 player attack focus distance zoom out amt',Math.ceil((((this.camera.zoom.x-1)-.35)*10)*5));
              zoomAdjust = Math.ceil((((this.camera.zoom.x-1)-.35)*10)*5);
              this.camera.preInstructions.push(
                'zoom_out_'+zoomAdjust+''
              )
            }

          }

        }

      break;
      case 'attackFocusBreak':
        // if ((this.camera.zoom.x-1) > 0) {
        //   console.log('auto cam attack focus break zoom out amt ',Math.ceil(((this.camera.zoom.x-1)*10)*5));
        //   zoomAdjust = Math.ceil(((this.camera.zoom.x-1)*10)*5)
        //   this.camera.preInstructions.push(
        //     'zoom_out_'+zoomAdjust+''
        //   )
        // }

        if ((this.camera.zoom.x-1) > .15) {
          // console.log('auto cam attack focus break zoom out amt ',Math.ceil((((this.camera.zoom.x-1)-.15)*10)*5));
          zoomAdjust = Math.ceil((((this.camera.zoom.x-1)-.15)*10)*5);
          this.camera.preInstructions.push(
            'zoom_out_'+zoomAdjust+''
          )
        }
        else {
          this.settingAutoCamera = false;
        }
      break;
      case 'playerSpawnFocus':

        this.camera.preInstructions.push(
          'moveTo_'+player.currentPosition.cell.number.x+'_'+player.currentPosition.cell.number.y+'_fast',
          // 'waitFor_50',
        )

        if ((this.camera.zoom.x-1) < .50) {
          // console.log('auto camera 1 player spawn focus zoom in amt',Math.ceil(((.50-(this.camera.zoom.x-1))*10)*5));
          zoomAdjust = Math.ceil(((.50-(this.camera.zoom.x-1))*10)*5);
          this.camera.preInstructions.push(
            'zoom_in_'+zoomAdjust+''
          )
        }
        if ((this.camera.zoom.x-1) > .50) {
          // console.log('auto camera 1 player spawn focus zoom out amt',Math.ceil((((this.camera.zoom.x-1)-.50)*10)*5));
          zoomAdjust = Math.ceil((((this.camera.zoom.x-1)-.50)*10)*5);
          this.camera.preInstructions.push(
            'zoom_out_'+zoomAdjust+''
          )
        }

        this.camera.preInstructions.push(
          'waitFor_50'
        )



        if (this.playerNumber === 2) {

          let originCell = {
            x: this.players[0].currentPosition.cell.number.x,
            y: this.players[0].currentPosition.cell.number.y,
          };
          let destCell = {
            x: this.players[1].currentPosition.cell.number.x,
            y: this.players[1].currentPosition.cell.number.y,
          };

          let x1 = originCell.x;
          let y1 = originCell.y;
          let x2 = destCell.x;
          let y2 = destCell.y;
          let xSteps = 0;
          let ySteps = 0;
          let xDirection = "";
          let yDirection = "";
          let preInstructions = [];

          if (x1 > x2) {
            xDirection = "west";
            xSteps = x1-x2;
          }
          if (x2 > x1) {
            xDirection = "east";
            xSteps = x2-x1;
          }
          if (y1 > y2) {
            yDirection = "north";
            ySteps = y1-y2;
          }
          if (y2 > y1) {
            yDirection = "south";
            ySteps = y2-y1;
          }

          for (var i = 0; i < xSteps; i++) {
            preInstructions.push(
              xDirection
            )
          }
          for (var j = 0; j < ySteps; j++) {
            preInstructions.push(
              yDirection
            )
          }

          let parsedPreInstructions = []
          let currentCell = {
            x: originCell.x,
            y: originCell.y,
          }

          parsedPreInstructions.push(originCell)

          for (const instruction of preInstructions) {

            switch (instruction) {
              case 'north':
                currentCell.y -= 1;
                parsedPreInstructions.push({
                  x: currentCell.x,
                  y: currentCell.y,
                })
              break;
              case 'south':
                currentCell.y += 1;
                parsedPreInstructions.push({
                  x: currentCell.x,
                  y: currentCell.y,
                })
              break;
              case 'west':
                currentCell.x -= 1;
                parsedPreInstructions.push({
                  x: currentCell.x,
                  y: currentCell.y,
                })
              break;
              case 'east':
                currentCell.x += 1;
                parsedPreInstructions.push({
                  x: currentCell.x,
                  y: currentCell.y,
                })
              break;
            }

              // console.log(''+preInstructions.indexOf(instruction)+'',parsedPreInstructions);

          }

          if (parsedPreInstructions.length < 4) {

            // console.log('plyr spawn focus auto cam: 2 players in close range');

            this.camera.preInstructions.push(
              'moveTo_'+this.players[0].currentPosition.cell.number.x+'_'+this.players[0].currentPosition.cell.number.y+'_fast',
              // 'moveTo_'+this.players[0].currentPosition.cell.number.x+'_'+this.players[0].currentPosition.cell.number.y+'_fast',
              // 'waitFor_50',
            )

            // if ((this.camera.zoom.x-1) < .50) {
            //   console.log('auto camera 2 player close melee attack focus zoom in amt',Math.ceil(((.50-(this.camera.zoom.x-1))*10)*5),'current zoom',1-this.camera.zoom.x);
            //   zoomAdjust = Math.ceil(((.50-(this.camera.zoom.x-1))*10)*5);
            //   this.camera.preInstructions.push(
            //     'zoom_in_'+zoomAdjust+''
            //   )
            // }
            // if ((this.camera.zoom.x-1) > .50) {
            //   console.log('auto camera 2 player close melee attack focus zoom out amt',Math.ceil((((this.camera.zoom.x-1)-.50)*10)*5),'current zoom',1-this.camera.zoom.x);
            //   zoomAdjust = Math.ceil((((this.camera.zoom.x-1)-.50)*10)*5);
            //   this.camera.preInstructions.push(
            //     'zoom_out_'+zoomAdjust+''
            //   )
            // }

            // zoomAdjust = Math.ceil((((this.camera.zoom.x-1)-.50)*10)*5);
            zoomAdjust = Math.ceil(((.50-(this.camera.zoom.x-1))*10)*5);
            this.camera.preInstructions.push(
              'zoom_out_'+zoomAdjust+''
              // 'zoom_outToInit'
            )
            console.log('zoomAdjust',zoomAdjust);

          }
          else {

            // console.log('plyr spawn focus auto cam: 2 players at a distance','zoomadjust',Math.ceil((((this.camera.zoom.x-1)-.35)*10)*5));

            // console.log('preInstructions',parsedPreInstructions,parsedPreInstructions[(parsedPreInstructions.length/2).toFixed(0)]);

            let intermediateCell = {
              x: parsedPreInstructions[Math.ceil((parsedPreInstructions.length/2))].x,
              y: parsedPreInstructions[Math.ceil((parsedPreInstructions.length/2))].y,
            }

            this.camera.preInstructions.push(
              'moveTo_'+intermediateCell.x+'_'+intermediateCell.y+'_fast',
              // 'waitFor_50',
            )


            // if ((this.camera.zoom.x-1) < .35) {
            //   console.log('auto cam 2 player attack focus distance zoom in amt',Math.ceil(((.35-(this.camera.zoom.x-1))*10)*5),'current zoom',1-this.camera.zoom.x);
            //   zoomAdjust = Math.ceil(((.35-(this.camera.zoom.x-1))*10)*5);
            //   this.camera.preInstructions.push(
            //     'zoom_in_'+zoomAdjust+''
            //   )
            // }
            // if ((this.camera.zoom.x-1) > .35) {
            //   console.log('auto cam 2 player attack focus distance zoom out amt',Math.ceil((((this.camera.zoom.x-1)-.35)*10)*5),'current zoom',1-this.camera.zoom.x);
            //   zoomAdjust = Math.ceil((((this.camera.zoom.x-1)-.35)*10)*5);
            //   this.camera.preInstructions.push(
            //     'zoom_out_'+zoomAdjust+''
            //   )
            // }

            // zoomAdjust = Math.ceil((((this.camera.zoom.x-1)-.35)*10)*5);
            zoomAdjust = Math.ceil(((.35-(this.camera.zoom.x-1))*10)*5);
            this.camera.preInstructions.push(
              'zoom_out_'+(zoomAdjust+0)+''
              // 'zoom_outToInit'
            )
            console.log('zoomAdjust2',zoomAdjust);

          }

        }
        else {
          zoomAdjust = Math.ceil(((.35-(this.camera.zoom.x-1))*10)*5)
          this.camera.preInstructions.push(
            'zoom_out_'+zoomAdjust+''
            // 'zoom_outToInit'
          )
        }
        // console.log('player spawn focus preInstructions',this.camera.preInstructions);

      break;
      case 'aiSpawnFocus':

        this.camera.preInstructions.push(
          'moveTo_'+player.currentPosition.cell.number.x+'_'+player.currentPosition.cell.number.y+'_fast',
          // 'waitFor_50',
        )

        if ((this.camera.zoom.x-1) < .35) {
          // console.log('auto camera 2 player close ranged attack focus zoom in amt',Math.ceil(((.35-(this.camera.zoom.x-1))*10)*5));
          zoomAdjust = Math.ceil(((.35-(this.camera.zoom.x-1))*10)*5);
          this.camera.preInstructions.push(
            'zoom_in_'+zoomAdjust+''
          )
        }
        if ((this.camera.zoom.x-1) > .35) {
          // console.log('auto camera 2 player close ranged attack focus zoom out amt',Math.ceil((((this.camera.zoom.x-1)-.35)*10)*5));
          zoomAdjust = Math.ceil((((this.camera.zoom.x-1)-.35)*10)*5);
          this.camera.preInstructions.push(
            'zoom_out_'+zoomAdjust+'',
            'waitFor_50'
          )
        }


        this.camera.preInstructions.push(
          'waitFor_100'
        )

        if (this.playerNumber === 1) {

          this.camera.preInstructions.push(
            'moveTo_'+this.players[0].currentPosition.cell.number.x+'_'+this.players[0].currentPosition.cell.number.y+'_fast',
            // 'waitFor_50',
          )

          if ((this.camera.zoom.x-1) < .35) {
              // console.log('auto camera 1 player ai spawn focus zoom in amt',Math.ceil(((.35-(this.camera.zoom.x-1))*10)*5),'current zoom',1-this.camera.zoom.x);
              zoomAdjust = Math.ceil(((.35-(this.camera.zoom.x-1))*10)*5);
              this.camera.preInstructions.push(
                'zoom_in_'+zoomAdjust+''
              )
            }
          if ((this.camera.zoom.x-1) > .35) {
            // console.log('auto camera 1 player ai spawn focus zoom out amt',Math.ceil((((this.camera.zoom.x-1)-.35)*10)*5),'current zoom',1-this.camera.zoom.x);
            zoomAdjust = Math.ceil((((this.camera.zoom.x-1)-.35)*10)*5);
            this.camera.preInstructions.push(
              'zoom_out_'+zoomAdjust+''
              // 'zoom_outToInit'
            )
          }

        }


        if (this.playerNumber === 2) {


          let originCell = {
            x: this.players[0].currentPosition.cell.number.x,
            y: this.players[0].currentPosition.cell.number.y,
          };
          let destCell = {
            x: this.players[1].currentPosition.cell.number.x,
            y: this.players[1].currentPosition.cell.number.y,
          };

          let x1 = originCell.x;
          let y1 = originCell.y;
          let x2 = destCell.x;
          let y2 = destCell.y;
          let xSteps = 0;
          let ySteps = 0;
          let xDirection = "";
          let yDirection = "";
          let preInstructions = [];

          if (x1 > x2) {
            xDirection = "west";
            xSteps = x1-x2;
          }
          if (x2 > x1) {
            xDirection = "east";
            xSteps = x2-x1;
          }
          if (y1 > y2) {
            yDirection = "north";
            ySteps = y1-y2;
          }
          if (y2 > y1) {
            yDirection = "south";
            ySteps = y2-y1;
          }

          for (var i = 0; i < xSteps; i++) {
            preInstructions.push(
              xDirection
            )
          }
          for (var j = 0; j < ySteps; j++) {
            preInstructions.push(
              yDirection
            )
          }

          let parsedPreInstructions = []
          let currentCell = {
            x: originCell.x,
            y: originCell.y,
          }

          parsedPreInstructions.push(originCell)

          for (const instruction of preInstructions) {

            switch (instruction) {
              case 'north':
                currentCell.y -= 1;
                parsedPreInstructions.push({
                  x: currentCell.x,
                  y: currentCell.y,
                })
              break;
              case 'south':
                currentCell.y += 1;
                parsedPreInstructions.push({
                  x: currentCell.x,
                  y: currentCell.y,
                })
              break;
              case 'west':
                currentCell.x -= 1;
                parsedPreInstructions.push({
                  x: currentCell.x,
                  y: currentCell.y,
                })
              break;
              case 'east':
                currentCell.x += 1;
                parsedPreInstructions.push({
                  x: currentCell.x,
                  y: currentCell.y,
                })
              break;
            }

              // console.log(''+preInstructions.indexOf(instruction)+'',parsedPreInstructions);

          }

          if (parsedPreInstructions.length < 4) {

            // console.log('ai spawn focus auto cam: 2 players in close range');

            this.camera.preInstructions.push(
              'moveTo_'+this.players[0].currentPosition.cell.number.x+'_'+this.players[0].currentPosition.cell.number.y+'_fast',
              // 'moveTo_'+this.players[0].currentPosition.cell.number.x+'_'+this.players[0].currentPosition.cell.number.y+'_fast',
              // 'waitFor_50',
            )
            // if ((this.camera.zoom.x-1) < .35) {
            //     console.log('auto camera 2 player ai spawn focus zoom in amt',Math.ceil(((.35-(this.camera.zoom.x-1))*10)*5),'current zoom',1-this.camera.zoom.x);
            //     zoomAdjust = Math.ceil(((.35-(this.camera.zoom.x-1))*10)*5);
            //     this.camera.preInstructions.push(
            //       'zoom_in_'+zoomAdjust+''
            //     )
            //   }
            // if ((this.camera.zoom.x-1) > .35) {
            //   console.log('auto camera 2 player ai spawn focus zoom out amt',Math.ceil((((this.camera.zoom.x-1)-.35)*10)*5),'current zoom',1-this.camera.zoom.x);
            //   zoomAdjust = Math.ceil((((this.camera.zoom.x-1)-.35)*10)*5);
            //   this.camera.preInstructions.push(
            //     'zoom_out_'+zoomAdjust+''
            //   )
            // }

            // zoomAdjust = Math.ceil((((this.camera.zoom.x-1)-.35)*10)*5);
            zoomAdjust = Math.ceil(((.35-(this.camera.zoom.x-1))*10)*5);
            this.camera.preInstructions.push(
              'zoom_out_'+zoomAdjust+''
              // 'zoom_outToInit'
            )
            // console.log('zoomAdjust',zoomAdjust);

          }
          else {

            // console.log('ai spawn focus auto cam: 2 players at a distance');

            // console.log('preInstructions',parsedPreInstructions,parsedPreInstructions[(parsedPreInstructions.length/2).toFixed(0)]);

            // let intermediateCell = {
            //   x: parsedPreInstructions[(parsedPreInstructions.length/2).toFixed(0)].x,
            //   y: parsedPreInstructions[(parsedPreInstructions.length/2).toFixed(0)].y,
            // }
            let intermediateCell = {
              x: parsedPreInstructions[Math.ceil((parsedPreInstructions.length/2))].x,
              y: parsedPreInstructions[Math.ceil((parsedPreInstructions.length/2))].y,
            }

            this.camera.preInstructions.push(
              'moveTo_'+intermediateCell.x+'_'+intermediateCell.y+'_fast',
              // 'waitFor_50',
            )


            // if ((this.camera.zoom.x-1) < .35) {
            //   console.log('auto cam 2 player attack focus distance zoom in amt',Math.ceil(((.35-(this.camera.zoom.x-1))*10)*5),'current zoom',1-this.camera.zoom.x);
            //   zoomAdjust = Math.ceil(((.35-(this.camera.zoom.x-1))*10)*5);
            //   this.camera.preInstructions.push(
            //     'zoom_in_'+zoomAdjust+''
            //   )
            // }
            // if ((this.camera.zoom.x-1) > .35) {
            //   console.log('auto cam 2 player attack focus distance zoom out amt',Math.ceil((((this.camera.zoom.x-1)-.35)*10)*5),'current zoom',1-this.camera.zoom.x);
            //   zoomAdjust = Math.ceil((((this.camera.zoom.x-1)-.35)*10)*5);
            //   this.camera.preInstructions.push(
            //     'zoom_out_'+zoomAdjust+''
            //   )
            // }

            // zoomAdjust = Math.ceil((((this.camera.zoom.x-1)-.35)*10)*5);
            zoomAdjust = Math.ceil(((.35-(this.camera.zoom.x-1))*10)*5);
            this.camera.preInstructions.push(
              'zoom_out_'+zoomAdjust+''
              // 'zoom_outToInit'
            )
            // console.log('zoomAdjust',zoomAdjust);

          }

        }
        // console.log('aiSpawnFocus this.camera.preInstructions',this.camera.preInstructions);

      break;
      case 'pushbackPan':
        // pan to pushback target
      break;
      case 'followBolt':
        // pan to somewhere along bolt path, then pan back to bolt owner position
      break;
      default:

    }

  }
  setCameraFocus = (focusType, canvas, context, canvas2, context2) => {
    // console.log('setting camera focus','zoom',this.camera.zoom.x,'pan',this.camera.pan);

    if (focusType === 'init' || focusType === 'reset') {

      if (this.camera.mode === 'pan') {
        this.camera.focus.x = (canvas.width/2);
        this.camera.focus.y = (canvas.height/2);
      }

      if (this.camera.mode === 'zoom') {
        this.camera.focus.x = (canvas.width/2);
        this.camera.focus.y = (canvas.height/2);
      }

    }

    if (focusType === 'input') {

      class Point {
          constructor(x, y) {
              this.x = x;
              this.y = y;
          }
      }

      let zoom = this.camera.zoom.x;
      if (this.camera.mode === 'pan') {
        console.log('beep');
        switch (this.camera.panDirection) {
          case 'north':
            this.camera.focus.y -= 10;
          break;
          case 'south':
            this.camera.focus.y += 10;
          break;
          case 'east':
            this.camera.focus.x += 10;
          break;
          case 'west':
            this.camera.focus.x -= 10;
          break;
          default:
        }

      }

      if (this.camera.mode === 'zoom') {


        // if (this.camera.zoomDirection === 'out' && this.camera.zoom.x > 1) {
        //
        //
        //
        //     if (this.camera.pan.x !== -1) {
        //
        //       if (this.camera.pan.x < 1) {
        //         // this.camera.focus.x -= 10;
        //         this.camera.focus.x -= (10*this.camera.zoom.x);
        //       }
        //       if (this.camera.pan.x > 1) {
        //         // this.camera.focus.x += 10;
        //         this.camera.focus.x += (10*this.camera.zoom.x);
        //       }
        //
        //     }
        //     if (this.camera.pan.y !== -1) {
        //
        //       if (this.camera.pan.y < 1) {
        //         // this.camera.focus.y -= 10;
        //         this.camera.focus.y -= (5*this.camera.zoom.x);
        //       }
        //       if (this.camera.pan.y > 1) {
        //         // this.camera.focus.y += 10;
        //         this.camera.focus.y += (5*this.camera.zoom.x);
        //       }
        //
        //     }
        //
        //
        //     this.camera.focus.x = ((canvas.width/2)-this.camera.zoomFocusPan.x)/this.camera.zoom.x;
        //     this.camera.focus.y = ((canvas.height/2)-this.camera.zoomFocusPan.y)/this.camera.zoom.y;
        //
        //
        //
        // }
        //
        // if (this.camera.zoomDirection === 'in') {
        //
        //
        // }

      }

    }

    // console.log('camera focus set',this.camera.focus,focusType,'zoom',this.camera.zoom,'pan',this.camera.pan);

  }
  menuToggleCamera = () => {
    this.camera.state = true;
    this.camera.fixed = true;
  }


  lineCrementer = (player) => {
    // console.log('line crementer',player.number,player.target);

    let currentPosition = player.currentPosition.cell.center;
    let target = player.target;
    let moveSpeed = player.speed.move;
    if (player.terrainMoveSpeed.state === true) {
      // console.log('terrain speed mod',player.terrainMoveSpeed.speed);
      moveSpeed = player.terrainMoveSpeed.speed;
    }
    if (player.jumping.state === true) {
      moveSpeed = .1;
    }
    if (player.stamina.current < 1) {
      moveSpeed = .05;
    }

    if (player.flanking.state === true) {
      // moveSpeed = .1
      moveSpeed = .2
      // if (moveSpeed === .05) {
      //   moveSpeed = .1
      // }
      // else if (moveSpeed === .1) {
      //   moveSpeed = .125
      // }
      // else if (moveSpeed === .125) {
      //   moveSpeed = .2
      // }
    }

    if (player.pushing.state === true) {
      moveSpeed = player.pushing.moveSpeed;
      // console.log('player ',player.number,' pushing speed',moveSpeed);
    }
    if (player.pulling.state === true) {
      moveSpeed = player.pulling.moveSpeed;
      // console.log('player ',player.number,' pulling speed',moveSpeed);
    }
    if (player.pulled.state === true) {
      moveSpeed = player.pulled.moveSpeed;
      // console.log('player ',player.number,' pulled speed',moveSpeed);
    }
    if (player.pushed.state === true) {
      moveSpeed = player.pushed.moveSpeed;
      // console.log('player ',player.number,' pushed speed',moveSpeed);
    }

    // console.log('mover stepper',player.moving.step);
    player.moving.step = +(Math.round((player.moving.step + moveSpeed) + "e+" + 3)  + "e-" + 3);
    // player.moving.step = player.moving.step + moveSpeed;

    let newPosition;



    // line: percent is 0-1
    let startPt = currentPosition;
    let endPt;
    if (player.jumping.state === true) {
      endPt = target.cell2.center;
    } else {
      endPt = target.cell1.center;
    }


    let percent = player.moving.step;

    function getLineXYatPercent(startPt,endPt,percent) {
      let dx = endPt.x-startPt.x;
      let dy = endPt.y-startPt.y;
      let X = startPt.x + dx*percent;
      let Y = startPt.y + dy*percent;
      // newPosition = {x:X,y:Y}
      newPosition = {x:Math.round(X),y:Math.round(Y)}
    }
    getLineXYatPercent(startPt,endPt,percent);

    if (player.falling.state === true) {

      player.falling.count++;

      newPosition = {
        x: target.cell1.center.x,
        y: target.cell1.center.y+player.falling.count*5,
      }
      player.currentPosition.cell.center = newPosition;

    }

    player.nextPosition = newPosition

    this.players[player.number-1] = player;

    return newPosition;

  }
  boltCrementer = (bolt) => {
    // console.log('boltCrementer');


    // let index = this.projectiles.findIndex(blt => blt.id === bolt.id);
    let distanceFactor = bolt.target.path.length;
    // if (distanceFactor == 1) {
    //   distanceFactor = 2;
    // }

    let moveSpeed = bolt.speed;
    // moveSpeed = bolt.speed/distanceFactor;
    moveSpeed = bolt.speed/(distanceFactor/5);
    // moveSpeed = bolt.speed/(distanceFactor/10);


    bolt.moving.step += moveSpeed;
    // console.log('boltCrementer',bolt.moving.step,bolt.speed,moveSpeed,distanceFactor);
    let newPosition;

    // line: percent is 0-1
    let startPt = bolt.moving.origin.center;
    let endPt = bolt.target.path[bolt.target.path.length-1].center;
    let percent = bolt.moving.step;
    // if (distanceFactor == 1) {
    //   endPt.x+=2
    //   endPt.y+=2
    // }

    // console.log('bolt crement',startPt,endPt,percent);
    // console.log('percent',percent,'time',this.time);
    //
    function getLineXYatPercent(startPt,endPt,percent) {
      let dx = endPt.x-startPt.x;
      let dy = endPt.y-startPt.y;
      let X = startPt.x + dx*percent;
      let Y = startPt.y + dy*percent;
      // newPosition = {
      //   x: X,
      //   y: Y
      // }
      newPosition = {
        x: Math.round(X),
        y: Math.round(Y)
      }
    }
    getLineXYatPercent(startPt,endPt,percent);

    // bolt.nextPosition = newPosition;

    // this.projectiles[index] = bolt;
    // console.log('bolt crementer new position',newPosition);
    return newPosition;

  }
  arcBoltCrementer = () => {

  }
  obstacleMoveCrementer = (obstacleCell,destCell) => {
    // console.log('obstacle line crementer',obstacle.moving.step,obstacle.moving.moveSpeed);

    let currentPosition = obstacleCell.obstacle.moving.currentPosition;
    let moveSpeed = obstacleCell.obstacle.moving.moveSpeed;


    let step = +(Math.round((obstacleCell.obstacle.moving.step + moveSpeed) + "e+" + 3)  + "e-" + 3);
    // console.log('obstacle moving crementer',step);

    // player.moving.step = player.moving.step + moveSpeed;
    // console.log('mover stepper',player.moving.step);
    let newPosition;

    // line: percent is 0-1
    let startPt = currentPosition;
    let endPt;
    endPt = destCell.center;


    let percent = step;

    function getLineXYatPercent(startPt,endPt,percent) {
      let dx = endPt.x-startPt.x;
      let dy = endPt.y-startPt.y;
      let X = startPt.x + dx*percent;
      let Y = startPt.y + dy*percent;
      // newPosition = {x:X,y:Y}
      newPosition = {x:Math.round(X),y:Math.round(Y)}
    }
    getLineXYatPercent(startPt,endPt,percent);


    return {pos:newPosition, step:step};

  }
  drawPopupBubble = (ctx,x,y,w,h,radius,px,py,color) => {

    var r = x + w;
    var b = y + h;
    if(py<y || py>y+h){
     var con1 = Math.min(Math.max(x+radius,px-10),r-radius-20);
     var con2 = Math.min(Math.max(x+radius+20,px+10),r-radius);
    }
    else{
     var con1 = Math.min(Math.max(y+radius,py-10),b-radius-20);
     var con2 = Math.min(Math.max(y+radius+20,py+10),b-radius);
    }
    var dir;
    if(py < y) dir = 2;
    if(py > y) dir = 3;
    if(px < x && py>=y && py<=b) dir = 0;
    if(px > x && py>=y && py<=b) dir = 1;
    if(px >= x && px <= r && py >= y && py <= b) dir = -1;
    ctx.clearRect(x,y,this.popupSize,this.popupSize);
    ctx.beginPath();
    ctx.strokeStyle=color;
    ctx.lineWidth="1";
    ctx.moveTo(x+radius,y);
    if(dir==2){
     ctx.lineTo(con1,y);
     ctx.lineTo(px,py);
     ctx.lineTo(con2,y);
     ctx.lineTo(r-radius,y);
    }
    else ctx.lineTo(r-radius,y);
    ctx.quadraticCurveTo(r,y,r,y+radius);
    if(dir==1){
     ctx.lineTo(r,con1);
     ctx.lineTo(px,py);
     ctx.lineTo(r,con2);
     ctx.lineTo(r,b-radius);
    }
    else ctx.lineTo(r,b-radius);
    ctx.quadraticCurveTo(r, b, r-radius, b);
    if(dir==3){
     ctx.lineTo(con2,b);
     ctx.lineTo(px,py);
     ctx.lineTo(con1,b);
     ctx.lineTo(x+radius,b);
    }
    else ctx.lineTo(x+radius,b);
    ctx.quadraticCurveTo(x, b, x, b-radius);
    if(dir==0){
     ctx.lineTo(x,con2);
     ctx.lineTo(px,py);
     ctx.lineTo(x,con1);
     ctx.lineTo(x,y+radius);
    }
    else ctx.lineTo(x,y+radius);
    ctx.quadraticCurveTo(x, y, x+radius, y);
    ctx.fillStyle = 'white';
    ctx.fill();
    ctx.stroke();
    // ctx.globalCompositeOperation = "source-over";
    ctx.closePath();

  }
  popupDrawCalc = (position,playerOrigin,plyrNo) => {

    let offset = (this.playerDrawWidth-this.popupSize)/2;
    let pointerLength = this.popupSize/3;
    let offset2 = pointerLength+offset;


    let playerCorners = [
      {x:playerOrigin.x,y:playerOrigin.y},
      {x:undefined,y:undefined},
      {x:undefined,y:undefined},
      {x:undefined,y:undefined},
    ];

    playerCorners[1] = {
      x: (playerCorners[0].x+this.playerDrawWidth),
      y: playerCorners[0].y
    }
    playerCorners[2] = {
      x: playerCorners[1].x,
      y: (playerCorners[1].y+this.playerDrawHeight)
    }
    playerCorners[3] = {
      x: playerCorners[0].x,
      y: (playerCorners[0].y+this.playerDrawHeight)
    }


    let popupCoords = {
      playerOrigin: playerCorners[0],
      origin: {x:undefined,y:undefined},
      pt2: {x:undefined,y:undefined},
      pt3: {x:undefined,y:undefined},
      pt4: {x:undefined,y:undefined},
      anchor: {x:undefined,y:undefined},
      midpoint: {x:undefined,y:undefined},
    }
    let midpoint;


    switch (position) {
      case 'northWest':
        popupCoords.origin = {
          x: playerCorners[0].x+offset,
          y: playerCorners[0].y-(this.popupSize+offset2)
        };
        popupCoords.pt2 = {
          x: popupCoords.origin.x+this.popupSize,
          y: popupCoords.origin.y,
        }
        popupCoords.pt3 = {
          x: popupCoords.pt2.x,
          y: popupCoords.pt2.y+this.popupSize,
        }
        popupCoords.pt4 = {
          x: popupCoords.origin.x,
          y: popupCoords.origin.y+this.popupSize,
        }
        midpoint = {
          x: popupCoords.pt3.x+(popupCoords.pt4.x-popupCoords.pt3.x)*0.50,
          y: popupCoords.pt3.y+(popupCoords.pt4.y-popupCoords.pt3.y)*0.50,
        }
        popupCoords.anchor = {
          x: midpoint.x,
          y: midpoint.y+pointerLength,
        }
        popupCoords.midpoint = {
          x: midpoint.x,
          y: midpoint.y,
        }
      break;
      case 'southEast':
        popupCoords.origin = {
          x: playerCorners[3].x+offset,
          y: playerCorners[3].y+offset2,
        };
        popupCoords.pt2 = {
          x: popupCoords.origin.x+this.popupSize,
          y: popupCoords.origin.y,
        }
        popupCoords.pt3 = {
          x: popupCoords.pt2.x,
          y: popupCoords.pt2.y+this.popupSize,
        }
        popupCoords.pt4 = {
          x: popupCoords.origin.x,
          y: popupCoords.origin.y+this.popupSize,
        }
        midpoint = {
          x: popupCoords.origin.x+(popupCoords.pt2.x-popupCoords.origin.x)*0.50,
          y: popupCoords.origin.y+(popupCoords.pt2.y-popupCoords.origin.y)*0.50,
        }
        popupCoords.anchor = {
          x: midpoint.x,
          y: midpoint.y-pointerLength,
        }
        popupCoords.midpoint = {
          x: midpoint.x,
          y: midpoint.y,
        }
      break;
      case 'northEast':
        popupCoords.origin = {
          x: playerCorners[1].x+offset2,
          y: playerCorners[1].y+offset,
        };
        popupCoords.pt2 = {
          x: popupCoords.origin.x+this.popupSize,
          y: popupCoords.origin.y,
        }
        popupCoords.pt3 = {
          x: popupCoords.pt2.x,
          y: popupCoords.pt2.y+this.popupSize,
        }
        popupCoords.pt4 = {
          x: popupCoords.origin.x,
          y: popupCoords.origin.y+this.popupSize,
        }
        midpoint = {
          x: popupCoords.origin.x+(popupCoords.pt4.x-popupCoords.origin.x)*0.50,
          y: popupCoords.origin.y+(popupCoords.pt4.y-popupCoords.origin.y)*0.50,
        }
        popupCoords.anchor = {
          x: midpoint.x-pointerLength,
          y: midpoint.y,
        }
        popupCoords.midpoint = {
          x: midpoint.x,
          y: midpoint.y,
        }
      break;
      case 'southWest':
        popupCoords.origin = {
          x: playerCorners[0].x-(offset2+this.popupSize),
          y: playerCorners[0].y+offset,
        };
        popupCoords.pt2 = {
          x: popupCoords.origin.x+this.popupSize,
          y: popupCoords.origin.y,
        }
        popupCoords.pt3 = {
          x: popupCoords.pt2.x,
          y: popupCoords.pt2.y+this.popupSize,
        }
        popupCoords.pt4 = {
          x: popupCoords.origin.x,
          y: popupCoords.origin.y+this.popupSize,
        }
        midpoint = {
          x: popupCoords.pt2.x+(popupCoords.pt3.x-popupCoords.pt2.x)*0.50,
          y: popupCoords.pt2.y+(popupCoords.pt3.y-popupCoords.pt2.y)*0.50,
        }
        popupCoords.anchor = {
          x: midpoint.x+pointerLength,
          y: midpoint.y,
        }
        popupCoords.midpoint = {
          x: midpoint.x,
          y: midpoint.y,
        }
      break;
      case 'west':

        popupCoords.origin = {
          x: playerCorners[0].x-(offset2+this.popupSize),
          // y: playerCorners[0].y,
          y: playerCorners[0].y-(this.popupSize)-5,
        };
        popupCoords.pt2 = {
          x: popupCoords.origin.x+this.popupSize,
          y: popupCoords.origin.y,
        }
        popupCoords.pt3 = {
          x: popupCoords.pt2.x,
          y: popupCoords.pt2.y+this.popupSize,
        }
        popupCoords.pt4 = {
          x: popupCoords.origin.x,
          y: popupCoords.origin.y+this.popupSize,
        }
        midpoint = {
          x: popupCoords.pt2.x+(popupCoords.pt3.x-popupCoords.pt2.x)*0.50,
          y: popupCoords.pt2.y+(popupCoords.pt3.y-popupCoords.pt2.y)*0.50,
        }
        popupCoords.anchor = {
          x: popupCoords.pt3.x+pointerLength,
          y: popupCoords.pt3.y,
        }
        popupCoords.midpoint = {
          x: midpoint.x,
          y: midpoint.y,
        }
      break;
      case 'north':
        popupCoords.origin = {
          x: playerCorners[1].x+offset2,
          y: playerCorners[1].y-(this.popupSize)-5,
        };
        popupCoords.pt2 = {
          x: popupCoords.origin.x+this.popupSize,
          y: popupCoords.origin.y,
        }
        popupCoords.pt3 = {
          x: popupCoords.pt2.x,
          y: popupCoords.pt2.y+this.popupSize,
        }
        popupCoords.pt4 = {
          x: popupCoords.origin.x,
          y: popupCoords.origin.y+this.popupSize,
        }
        midpoint = {
          x: popupCoords.pt2.x+(popupCoords.pt3.x-popupCoords.pt2.x)*0.50,
          y: popupCoords.pt2.y+(popupCoords.pt3.y-popupCoords.pt2.y)*0.50,
        }
        popupCoords.anchor = {
          x: popupCoords.pt4.x-pointerLength,
          y: popupCoords.pt4.y,
        }
        popupCoords.midpoint = {
          x: midpoint.x,
          y: midpoint.y,
        }
      break;
      case 'south':
        popupCoords.origin = {
          x: playerCorners[3].x-(this.popupSize+offset2),
          y: playerCorners[3].y+5,
        };
        popupCoords.pt2 = {
          x: popupCoords.origin.x+this.popupSize,
          y: popupCoords.origin.y,
        }
        popupCoords.pt3 = {
          x: popupCoords.pt2.x,
          y: popupCoords.pt2.y+this.popupSize,
        }
        popupCoords.pt4 = {
          x: popupCoords.origin.x,
          y: popupCoords.origin.y+this.popupSize,
        }
        midpoint = {
          x: popupCoords.pt2.x+(popupCoords.pt3.x-popupCoords.pt2.x)*0.50,
          y: popupCoords.pt2.y+(popupCoords.pt3.y-popupCoords.pt2.y)*0.50,
        }
        popupCoords.anchor = {
          x: popupCoords.pt2.x+pointerLength,
          y: popupCoords.pt2.y,
        }
        popupCoords.midpoint = {
          x: midpoint.x,
          y: midpoint.y,
        }
      break;
      case 'east':
        popupCoords.origin = {
          x: playerCorners[2].x+offset2,
          y: playerCorners[2].y+5,
        };
        popupCoords.pt2 = {
          x: popupCoords.origin.x+this.popupSize,
          y: popupCoords.origin.y,
        }
        popupCoords.pt3 = {
          x: popupCoords.pt2.x,
          y: popupCoords.pt2.y+this.popupSize,
        }
        popupCoords.pt4 = {
          x: popupCoords.origin.x,
          y: popupCoords.origin.y+this.popupSize,
        }
        midpoint = {
          x: popupCoords.pt2.x+(popupCoords.pt3.x-popupCoords.pt2.x)*0.50,
          y: popupCoords.pt2.y+(popupCoords.pt3.y-popupCoords.pt2.y)*0.50,
        }
        popupCoords.anchor = {
          x: popupCoords.origin.x-pointerLength,
          y: popupCoords.origin.y,
        }
        popupCoords.midpoint = {
          x: midpoint.x,
          y: midpoint.y,
        }
      break;
    }

    return popupCoords;

  }
  playerPopupProgressCalc = (player,popup) => {

      // this.refs.popupProgressSvg.children[2].setAttribute("height","0")
      // this.refs.popupProgressSvg.children[2].setAttribute("fill","white")

    let path = this.refs.popupProgressSvg.children[1];
    let rect = this.refs.popupProgressSvg.children[2];

    let phase = "";
    let perc = 0;
    let arr = this.popupProgressBorderSvgPath.split(" ");
    path.setAttribute("fill","blue")
    let start = 0;
    let end = 0;
    let count = 0;
    let upperIndex = Math.ceil(arr.length*(perc/100));
    let fillPath = false;
    let emptyPath = true;


    // plyr.prePush.state === true ||
    // plyr.prePull.state === true ||


    if (player.action === "defending") {

      let defendType = player.currentWeapon.type;
      if ( player.currentWeapon.name === "") {
        defendType  = "unarmed";
      }
      let defendPeak = this.defendAnimRef.peak[defendType];
      player.defending.limit = this.defendAnimRef.limit[defendType];

      if (player.defending.count < defendPeak && player.defendDecay.state !== true) {
        phase = "windup";
        perc = (player.defending.count/defendPeak)*100;
      }
      else if (player.defending.count === defendPeak && player.defendDecay.state !== true) {
          phase = "peak";
      }
      if (player.defendDecay.state === true) {
        if (player.defendDecay.count < 5) {
          phase = "peak";
        }
        if (player.defendDecay.count < player.defendDecay.limit && player.defendDecay.count > 5) {
          phase = "cooldown";
          perc = (player.defendDecay.count/player.defendDecay.limit)*100;
        }
        if (player.defendDecay.count >= player.defendDecay.limit) {
          phase = "off";
        }
      }

    }
    if (player.action === "attacking") {

      let atkType = player.currentWeapon.type;
      if (player.currentWeapon.name === "") {
        atkType = "unarmed";
      }
      let end = this.attackAnimRef.limit[atkType]
      let attackPeak = this.attackAnimRef.peak[atkType];

      if (player.attacking.count < attackPeak) {
        phase = "windup";
        perc = (player.attacking.count/attackPeak)*100;
      }
      if (player.attacking.count === attackPeak) {
        phase = "peak";
      }
      if (player.attacking.count > attackPeak && player.attacking.count < end) {
        if (player.attacking.count < attackPeak + 5) {
          phase = "peak";
        }
        if (player.attacking.count > attackPeak + 5) {
          phase = "cooldown";
          perc = (player.attacking.count-(attackPeak+5))/(end-(attackPeak+5))*100;
        }
      }
      if (player.attacking.count >= end) {
        phase = "off";
      }

    }
    if (player.action === "dodging") {
      // console.log('popup progress dodging',this.time);
      let dodgeCondition = false;
      if (player.dodging.countState === true && player.dodging.count <= (player.dodging.peak.start - player.crits.dodge) && this.keyPressed[player.number-1].dodge === true) {
        // console.log('dodge condition 1: true');
        dodgeCondition = true;
      }
      if (player.dodging.countState === true && player.dodging.count > (player.dodging.peak.start - player.crits.dodge)) {
        // console.log('dodge condition 2: true');
        dodgeCondition = true;
      }

      let startMod = player.crits.dodge;
      let endMod = player.crits.dodge;
      if (player.crits.dodge > 5) {
        player.crits.dodge = 5;
      }
      if (player.dodging.peak.start - startMod < 2) {
        startMod = player.dodging.peak.start-2;
      }
      if ((player.dodging.peak.end + endMod) > player.dodging.limit-2) {
        endMod = player.dodging.limit-(2+player.dodging.peak.end);
      }
      if (dodgeCondition === true) {

      }

      if (player.dodging.count === 0) {
        // console.log('windup',player.dodging.count);
        phase = "windup";
        perc = (player.dodging.count/(player.dodging.peak.start - startMod))*100
      }
      if ( player.dodging.count >= 1 && player.dodging.count < (player.dodging.peak.start - startMod)) {
        // console.log('windup start:',1,'count:',player.dodging.count,'limit:',(player.dodging.peak.start - startMod));
        phase = "windup";
        perc = (player.dodging.count/(player.dodging.peak.start - startMod))*100;
      }
      if (player.dodging.count >= (player.dodging.peak.start - startMod) && player.dodging.count < (player.dodging.peak.end + endMod)) {
        // console.log('peak start:',(player.dodging.peak.start - startMod),'count:',player.dodging.count,'limit:',(player.dodging.peak.end + endMod));
        phase = "peak";
      }

      if (player.dodging.count > (player.dodging.peak.end + endMod)) {
        // console.log('cooldown start:',(player.dodging.peak.end + endMod),'count:',player.dodging.count,'limit:',player.dodging.limit);
        phase = "cooldown";
        // perc = ((player.dodging.count-(player.dodging.peak.end + endMod))/(player.dodging.limit-(player.dodging.peak.end + endMod)))*100;
        perc = (player.dodging.count/player.dodging.limit)*100;
      }
      if (player.dodging.count >= player.dodging.limit) {
        // console.log('end count',player.dodging.count);
        phase = "off";
      }
    }
    if (player.prePush.state === true) {
      if (player.prePush.count < player.prePush.limit) {
        phase = "windup";
        perc = (player.prePush.count/player.prePush.limit)*100;
      }
      if (player.prePush.count >= player.prePush.limit) {
        phase = "off";
      }

    }
    if (player.prePull.state === true) {
      if (player.prePull.count < player.prePull.limit) {
        phase = "windup";
        perc = (player.prePull.count/player.prePull.limit)*100;
      }
      if (player.prePull.count >= player.prePull.limit) {
        phase = "off";
      }
    }



    if (phase === 'windup') {
      fillPath = true;
    }
    if (phase === "peak") {
      perc = 100;
      path.setAttribute("d",arr.join(" "));
      fillPath = false;
      emptyPath = false;
    }
    if (phase === "cooldown") {
      perc = 100-perc;
      emptyPath = true;
    }
    if (phase === "off") {
      perc = 0;
      // perc = 100;
      path.setAttribute("d",arr.join(" "));
      fillPath = false;
      emptyPath = false;
    }
    switch (phase) {
      case "windup":
          path.setAttribute("fill","red")
        break;
      case "peak":
          path.setAttribute("fill","green")
        break;
      case "cooldown":
          path.setAttribute("fill","blue")
        break;
      case "off":
          path.setAttribute("fill","yellow")
        break;
      default:

    }

    // SET MOVING BG COLOR
    let baseColor = "";
    if (perc >= 0 && perc <= 40) {
      rect.setAttribute("fill", "red")
      baseColor = "red";
    }
    if (perc >= 40 && perc <= 60) {
      rect.setAttribute("fill", "orange")
      baseColor = "orange";
    }
    if (perc >= 60 && perc <= 70) {
      rect.setAttribute("fill", "yellow")
      baseColor = "yellow";
    }
    if (perc >= 70 && perc <= 80) {
      rect.setAttribute("fill", "blue")
      baseColor = "blue";
    }
    if (perc >= 80) {
      rect.setAttribute("fill", "green")
      baseColor = "green";
    }
    if (player.action === "defending" && phase === 'cooldown') {
      baseColor = "green";
    }

    // Gradients:
    // rect.setAttribute("fill","url(#grad)");
    this.popupProgressImgGradColor1 = baseColor;
    switch (phase) {
      case "windup" || "off":
          this.popupProgressImgGradColor2 = "red";
        break;
      case "peak":
          this.popupProgressImgGradColor2 = "green";
        break;
      case "cooldown":
          this.popupProgressImgGradColor2 = "blue";
        break;
      default:

    }


    // if (fillPath === true) {
    //   let newArr = [];
    //   for (var i = 0; i < upperIndex+1; i++) {
    //     newArr.push(arr[i]);
    //   }
    //   this.refs.popupProgressSvg.children[2].setAttribute("d",newArr.join(" "));
    // }
    // if (emptyPath === true) {
    //   let newArr = arr;
    //   this.refs.popupProgressSvg.children[2].setAttribute("d",arr.join(" "));
    //   for (var i = 0; i < upperIndex+1; i++) {
    //     newArr.pop();
    //   }
    //   this.refs.popupProgressSvg.children[2].setAttribute("d",newArr.join(" "));
    // }

    // function svgToPng(svg, callback) {
    //   const url = getSvgUrl(svg);
    // }
    // function getSvgUrl(svg) {
    //   return URL.createObjectURL(new Blob([svg], {
    //     type: 'image/svg+xml'
    //   }));
    // }
    // svgToPng(svg, (imgData) => {
    //   pngImage.src = imgData;
    // });

    // SET SVG IMAGE filter
    // var xml = new XMLSerializer().serializeToString(this.refs.popupProgressSvg);
    // var svg64 = btoa(xml); //for utf8: btoa(unescape(encodeURIComponent(xml)))
    // var b64start = 'data:image/svg+xml;base64,';
    // var image64 = b64start + svg64;
    // this.refs.popupProgressImg.src = image64;

    // console.log("playerPopupProgressCalc perc: ",((100-perc)/100).toFixed(2) ,(perc/100).toFixed(2));

    // return (100-perc)/100;
    return -(perc/100).toFixed(2);

  }
  cartesianToIsometric = (cartPt) => {

    class Point {
        constructor(x, y) {
            this.x = x;
            this.y = y;
        }
    }

    var tempPt = new Point();
    tempPt.x = cartPt.x - cartPt.y;
    tempPt.y = (cartPt.x + cartPt.y) / 2;
    return (tempPt);

  }
  setElasticCounter = (type,subType,pause,player) => {
    // console.log('setElasticCounter');

    if (type === "deflected") {

      let point = {
        x: player.currentPosition.cell.center.x,
        y: player.currentPosition.cell.center.y,
      };



      let countCalcPause = player.success.deflected.limit/2;
      let countCalc = countCalcPause/2;

      if (countCalc > 6) {
        countCalc = 6;
        countCalcPause = (player.success.deflected.limit-12);
      }


      player.elasticCounter = {
        state: true,
        direction: this.getOppositeDirection(player.direction),
        type: "deflected",
        subType: "",
        countUp: {
          state: false,
          count: 0,
          limit: countCalc,
        },
        countDown: {
          state: false,
          count: 0,
          limit: countCalc,
        },
        coords: {
          x: point.x-(this.playerDrawWidth/2),
          y: point.y-(this.playerDrawHeight/2),
        },
        pause: {
          preState: pause,
          state: false,
          type: "peak",
          count: 0,
          limit: countCalcPause,
        },
      }


    }

    if (type === "dodging") {


      let point = {
        x: player.currentPosition.cell.center.x,
        y: player.currentPosition.cell.center.y,
      };


      let startMod = player.crits.dodge;
      let endMod = player.crits.dodge;
      if (player.crits.dodge > 5) {
        player.crits.dodge = 5;
      }
      if (player.dodging.peak.start - startMod < 2) {
        startMod = player.dodging.peak.start-2;
      }
      if ((player.dodging.peak.end + endMod) > player.dodging.limit-2) {
        endMod = player.dodging.limit-(2+player.dodging.peak.end);
      }


      // console.log('count up: ',player.dodging.peak.start - startMod);
      // console.log('pause: ',(player.dodging.peak.end + endMod)-(player.dodging.peak.start - startMod));
      // console.log('count down',player.dodging.limit-(player.dodging.peak.end + endMod));
      // console.log('limit',player.dodging.limit);

      let countCalcPause = (player.dodging.peak.end + endMod)-(player.dodging.peak.start - startMod);
      let countCalcUp = player.dodging.peak.start - startMod;
      let countCalcDown = player.dodging.limit-(player.dodging.peak.end + endMod);


      // if (countCalc > 6) {
      //   countCalc = 6;
      //   countCalcPause = (player.success.deflected.limit-12);
      // }


      player.elasticCounter = {
        state: true,
        direction: player.dodgeDirection,
        type: "dodging",
        subType: "",
        countUp: {
          state: false,
          count: 0,
          limit: countCalcUp,
        },
        countDown: {
          state: false,
          count: 0,
          limit: countCalcUp,
          // limit: countCalcDown,
        },
        coords: {
          x: point.x-(this.playerDrawWidth/2),
          y: point.y-(this.playerDrawHeight/2),
        },
        pause: {
          preState: pause,
          state: false,
          type: "peak",
          count: 0,
          limit: countCalcPause,
        },
      }


    }

    if (type === "attacking") {


      let point = {
        x: player.currentPosition.cell.center.x,
        y: player.currentPosition.cell.center.y,
      };

      let attackPeak = this.attackAnimRef.peak[player.currentWeapon.type];
      let stamAtkType = player.currentWeapon.type;

      if (player.currentWeapon.type === '') {
        // this.players[player.number-1].attacking.limit = this.attackAnimRef.limit.unarmed;
        attackPeak = this.attackAnimRef.peak.unarmed;
        stamAtkType = 'unarmed';
      }
      let limit = player.attacking.limit = this.attackAnimRef.limit[stamAtkType];



      let countCalcUp = limit-attackPeak;


      player.elasticCounter = {
        state: true,
        direction: player.direction,
        type: "attacking",
        subType: "",
        countUp: {
          state: false,
          count: 0,
          limit: countCalcUp,
        },
        countDown: {
          state: false,
          count: 0,
          limit: countCalcUp,
        },
        coords: {
          x: point.x-(this.playerDrawWidth/2),
          y: point.y-(this.playerDrawHeight/2),
        },
        pause: {
          preState: pause,
          state: false,
          type: "",
          count: 0,
          limit: 0,
        },
      }


    }

  }
  calcElasticCountCoords = (type,subType,data) => {

    let drawCell;
    let mod = {
      x: undefined,
      y: undefined,
    }
    let finalCoords = {
      x: undefined,
      y: undefined,
    }


    let getMod = (direction,unit2) => {

      let mod2 = mod;
      switch (direction) {
        case "north":
            mod2 = {
              x: unit2*2,
              y: -unit2,
            }
          break;
        case "south":
            mod2 = {
              x: -(unit2*2),
              y: unit2,
            }
          break;
        case "east":
            mod2 = {
              x: (unit2*2),
              y: unit2,
            }
          break;
        case "west":
            mod2 = {
              x: -(unit2*2),
              y: -unit2,
            }
          break;
        default:

      }

      return mod2;

    }

    if (type === 'halfPushBack') {


      let base = .015;
      let unit;
      let baseCoords = {
        x: undefined,
        y: undefined,
      }
      let dir = "";

      if (subType === "player") {


        switch (this.gridWidth) {
          case 12:
              unit = base/3;
            break;
          case 9:
              unit = base;
            break;
          case 6:
              unit = base*1.2;
            break;
          case 3:
              unit = base*3;
            break;
          default:

        }

        baseCoords = {
          x: data.halfPushBack.coords.x,
          y: data.halfPushBack.coords.y,
        }

        if (data.halfPushBack.countUp.state === true) {
          dir = data.halfPushBack.direction;
        }
        if (data.halfPushBack.countDown.state === true) {
          dir = this.getOppositeDirection(data.halfPushBack.direction);
        }

      }

      if (subType === "obstacle") {

        unit = 2;

        baseCoords = {
          x: data.coords.x,
          y: data.coords.y,
        }

        if (data.countUp.state === true) {
          dir = data.direction;
        }
        if (data.countDown.state === true) {
          dir = this.getOppositeDirection(data.direction);
        }

      }


      mod = getMod(dir,unit);


      finalCoords = {
        x: (baseCoords.x + mod.x),
        y: (baseCoords.y + mod.y),
      }
      let targetCell;

      if (subType === "player") {

        data.halfPushBack.coords = finalCoords;

        targetCell = this.getCellFromDirection(1,data.currentPosition.cell.number,data.halfPushBack.direction)

      }
      if (subType === "obstacle") {

        data.coords = finalCoords;

        targetCell = this.getCellFromDirection(1,data.myCellNo,data.direction)

      }


      let targetCellRef = this.gridInfo.find(x => x.number.x === targetCell.x && x.number.y === targetCell.y)
      drawCell = {x: undefined, y: undefined};

      if (subType === "player") {

        if (data.halfPushBack.countUp.state === true) {

          if (targetCellRef) {
            drawCell = targetCellRef.number;
          }
          else {
            drawCell = data.currentPosition.cell.number;
          }

        }
        if (data.halfPushBack.countDown.state === true) {
          drawCell = data.currentPosition.cell.number;
        }

        this.players[data.number-1] = data;

      }
      if (subType === "obstacle") {

        if (data.countUp.state === true) {

          if (targetCellRef) {
            drawCell = targetCellRef.number;
          }
          else {
            drawCell = data.myCellNo;
          }

        }
        if (data.countDown.state === true) {
          drawCell = data.myCellNo;
        }

      }

    }

    if (type === 'deflected') {


      let base = .002;
      let unit;

      if (data.elasticCounter.countUp.count <= 3) {
        base = .007
      }
      if (data.elasticCounter.countUp.count > 3 && data.elasticCounter.countUp.count < 6) {
        base = .005
      }
      if (data.elasticCounter.countUp.count > 6) {
        base = .002
      }


      switch (this.gridWidth) {
        case 12:
            unit = base/1.5;
          break;
        case 9:
            unit = base;
          break;
        case 6:
            unit = base*2;
          break;
        case 3:
            unit = base*6;
          break;
        default:

      }



      let dir = data.elasticCounter.direction;
      let baseCoords = {
        x: data.elasticCounter.coords.x,
        y: data.elasticCounter.coords.y,
      }

      if (data.elasticCounter.countUp.state === true) {
        dir = data.elasticCounter.direction;
      }
      if (data.elasticCounter.countDown.state === true) {
        dir = this.getOppositeDirection(data.elasticCounter.direction);
      }


      mod = getMod(dir,unit);

      if (data.elasticCounter.pause.state !== true) {
        finalCoords = {
          x: (baseCoords.x + mod.x),
          y: (baseCoords.y + mod.y),
        }
      }
      else {
        finalCoords = {
          x: (baseCoords.x),
          y: (baseCoords.y),
        }
      }


      let targetCell;
      data.elasticCounter.coords = finalCoords;

      targetCell = this.getCellFromDirection(1,data.currentPosition.cell.number,data.elasticCounter.direction)
      let targetCellRef = this.gridInfo.find(x => x.number.x === targetCell.x && x.number.y === targetCell.y)
      drawCell = {x: undefined, y: undefined};

      if (data.elasticCounter.countUp.state === true) {

        if (targetCellRef) {
          drawCell = targetCellRef.number;
        }
        else {
          drawCell = data.currentPosition.cell.number;
        }

      }
      if (data.elasticCounter.pause.state === true && data.elasticCounter.pause.type === "peak") {

        if (targetCellRef) {
          drawCell = targetCellRef.number;
        }
        else {
          drawCell = data.currentPosition.cell.number;
        }

      }
      if (data.elasticCounter.countDown.state === true) {
        drawCell = data.currentPosition.cell.number;
      }
      if (data.elasticCounter.pause.state === true && data.elasticCounter.pause.type === "start" ||
        data.elasticCounter.pause.state === true && data.elasticCounter.pause.type === "end"
      ) {
        drawCell = data.currentPosition.cell.number;
      }

      this.players[data.number-1] = data;


    }

    if (type === "dodging") {

      let base = .002;
      let unit;

      if (data.elasticCounter.countUp.count <= 3) {
        base = .007;
      }
      if (data.elasticCounter.countUp.count > 3 && data.elasticCounter.countUp.count < 6) {
        base = .005
      }
      if (data.elasticCounter.countUp.count > 6) {
        base = .002
      }

      switch (this.gridWidth) {
        case 12:
            unit = base/1.5;
          break;
        case 9:
            unit = base;
          break;
        case 6:
            unit = base*2;
          break;
        case 3:
            unit = base*6;
          break;
        default:

      }


      // console.log('unit',unit);
      let dir = data.elasticCounter.direction;
      let baseCoords = {
        x: data.elasticCounter.coords.x,
        y: data.elasticCounter.coords.y,
      }

      if (data.elasticCounter.countUp.state === true) {
        dir = data.elasticCounter.direction;
      }
      if (data.elasticCounter.countDown.state === true) {
        dir = this.getOppositeDirection(data.elasticCounter.direction);
      }


      mod = getMod(dir,unit);

      if (data.elasticCounter.pause.state !== true) {
        finalCoords = {
          x: (baseCoords.x + mod.x),
          y: (baseCoords.y + mod.y),
        }
      }
      else {
        finalCoords = {
          x: (baseCoords.x),
          y: (baseCoords.y),
        }
      }

      // console.log('calcElasticCountCoords',baseCoords,'plyr coords',data.elasticCounter.coords,'mod',mod,'dir',dir,data.elasticCounter.direction);


      let targetCell;
      data.elasticCounter.coords = finalCoords;

      targetCell = this.getCellFromDirection(1,data.currentPosition.cell.number,data.elasticCounter.direction)
      let targetCellRef = this.gridInfo.find(x => x.number.x === targetCell.x && x.number.y === targetCell.y)
      drawCell = {x: undefined, y: undefined};

      if (data.elasticCounter.countUp.state === true) {

        if (targetCellRef) {
          drawCell = targetCellRef.number;
        }
        else {
          drawCell = data.currentPosition.cell.number;
        }

      }
      if (data.elasticCounter.pause.state === true && data.elasticCounter.pause.type === "peak") {

        if (targetCellRef) {
          drawCell = targetCellRef.number;
        }
        else {
          drawCell = data.currentPosition.cell.number;
        }

      }
      if (data.elasticCounter.countDown.state === true) {
        drawCell = data.currentPosition.cell.number;
      }
      if (data.elasticCounter.pause.state === true && data.elasticCounter.pause.type === "start" ||
        data.elasticCounter.pause.state === true && data.elasticCounter.pause.type === "end"
      ) {
        drawCell = data.currentPosition.cell.number;
      }

      this.players[data.number-1] = data;

    }

    if (type === 'attacking') {

      let base = .002;
      let unit;

      if (data.elasticCounter.countUp.count <= 3) {
        base = .003
      }
      if (data.elasticCounter.countUp.count > 3 && data.elasticCounter.countUp.count < 6) {
        base = .001
      }
      if (data.elasticCounter.countUp.count > 6) {
        base = .0008
      }


      switch (this.gridWidth) {
        case 12:
            unit = base/1.5;
          break;
        case 9:
            unit = base;
          break;
        case 6:
            unit = base*2;
          break;
        case 3:
            unit = base*6;
          break;
        default:

      }



      let dir = data.elasticCounter.direction;
      let baseCoords = {
        x: data.elasticCounter.coords.x,
        y: data.elasticCounter.coords.y,
      }

      if (data.elasticCounter.countUp.state === true) {
        dir = data.elasticCounter.direction;
      }
      if (data.elasticCounter.countDown.state === true) {
        dir = this.getOppositeDirection(data.elasticCounter.direction);
      }


      mod = getMod(dir,unit);

      if (data.elasticCounter.pause.state !== true) {
        finalCoords = {
          x: (baseCoords.x + mod.x),
          y: (baseCoords.y + mod.y),
        }
      }
      else {
        finalCoords = {
          x: (baseCoords.x),
          y: (baseCoords.y),
        }
      }


      let targetCell;
      data.elasticCounter.coords = finalCoords;

      targetCell = this.getCellFromDirection(1,data.currentPosition.cell.number,data.elasticCounter.direction)
      let targetCellRef = this.gridInfo.find(x => x.number.x === targetCell.x && x.number.y === targetCell.y)
      drawCell = {x: undefined, y: undefined};

      if (data.elasticCounter.countUp.state === true) {

        if (targetCellRef) {
          drawCell = targetCellRef.number;
        }
        else {
          drawCell = data.currentPosition.cell.number;
        }

      }
      if (data.elasticCounter.pause.state === true && data.elasticCounter.pause.type === "peak") {

        if (targetCellRef) {
          drawCell = targetCellRef.number;
        }
        else {
          drawCell = data.currentPosition.cell.number;
        }

      }
      if (data.elasticCounter.countDown.state === true) {
        drawCell = data.currentPosition.cell.number;
      }
      if (data.elasticCounter.pause.state === true && data.elasticCounter.pause.type === "start" ||
        data.elasticCounter.pause.state === true && data.elasticCounter.pause.type === "end"
      ) {
        drawCell = data.currentPosition.cell.number;
      }

      this.players[data.number-1] = data;

    }

    return {
      coords: finalCoords,
      drawCell: drawCell,
    };


  }



  rnJesus = (min,max) => {
    min = Math.ceil(min);
    max = Math.floor(max);
    return Math.floor(Math.random() * (max - min + 1)) + min;
  };
  getTarget = (player) => {
    // console.log('checking target',player.number,'dir',player.direction);

    let canvas = this.canvasRef.current;
    let context = canvas.getContext('2d');

    let gridInfo = this.gridInfo;
    // let player = this.players[this.currentPlayer-1];
    let currentPosition = player.currentPosition.cell.number;
    let direction = player.direction;
    let voidDirection;
    let target = this.resetTarget();
    let midGridVoid1 = false;
    let midGridVoid2 = false;
    let edgeVoid1 = false;
    let edgeVoid2 = false;


    // DIRECTION MOD: STRAFING
    if (player.strafing.state === true &&  player.strafing.direction !== '') {
      direction = player.strafing.direction;
    }

    // DIRECTION MOD: FLANKING!!
    if (player.flanking.checking === true ) {
      if (player.flanking.step === 0) {
        direction = player.flanking.direction;
      }
    }
    if (player.flanking.state === true) {
      if (player.flanking.step === 1) {
        direction = player.flanking.preFlankDirection;
      }
    }
    if (player.flanking.state === true) {
      if (player.flanking.step === 2) {
        direction = player.direction;
        // direction = player.flanking.preFlankDirection;
      }
    }

    if (player.jumping.checking === true) {
      direction = player.direction;
    }


    // SET CELL 1 & 2 NUMBERS

    target.cell1.number = this.getCellFromDirection(1,currentPosition,direction);
    target.cell2.number = this.getCellFromDirection(2,currentPosition,direction);


    let targetCell1Ref = this.gridInfo.find(x => x.number.x === target.cell1.number.x && x.number.y === target.cell1.number.y)
    let targetCell2Ref = this.gridInfo.find(x => x.number.x === target.cell2.number.x && x.number.y === target.cell2.number.y)


    // CHECK SET VOID AND CENTERS
    voidDirection = player.direction;
    if (player.strafing.state === true) {
      voidDirection = player.strafing.direction;
    }
    if (!targetCell1Ref) {
      target.cell1.void = true;
      edgeVoid1 = true;
      target.cell1.center = this.getVoidCenter(1,voidDirection,player.currentPosition.cell.center);
      // this.testDraw.push({color:'red',x:target.cell1.center.x,y:target.cell1.center.y})
    }
    if (targetCell1Ref) {
      target.cell1.center = targetCell1Ref.center;
      if (targetCell1Ref.void.state === true) {
        target.cell1.void = true;
        midGridVoid1 = true;
      }
    }
    if (!targetCell2Ref) {
      target.cell2.void = true;
      edgeVoid2 = true;
        target.cell2.center = this.getVoidCenter(2,voidDirection,player.currentPosition.cell.center);
      // this.testDraw.push({color:'red',x:target.cell2.center.x,y:target.cell2.center.y})
    }
    if (targetCell2Ref) {
      target.cell2.center = targetCell2Ref.center;
      if (targetCell2Ref.void.state === true) {
        target.cell2.void = true;
        midGridVoid2 = true;
      }
    }


    let myCell = this.gridInfo.find(elem2 => elem2.number.x === player.currentPosition.cell.number.x && elem2.number.y === player.currentPosition.cell.number.y)


    target.myCellBlock = this.checkMyCellBarrier(direction,myCell);
    // let fwdBarrier = this.checkForwardBarrier(direction,cellRef);

    for (const plyr of this.players) {
      if (plyr.number !== player.number) {
        if (
          target.cell1.number.x === plyr.currentPosition.cell.number.x &&
          target.cell1.number.y === plyr.currentPosition.cell.number.y
        ) {
          target.cell1.occupant.type = "player";
          target.cell1.occupant.player = plyr.number;
          target.cell1.free = false;
        }
        if (
          target.cell2.number.x === plyr.currentPosition.cell.number.x &&
          target.cell2.number.y === plyr.currentPosition.cell.number.y
        ) {
          target.cell2.occupant.type = "player";
          target.cell2.occupant.player = plyr.number;
          target.cell2.free = false;
        }
      }
    }

    if (targetCell1Ref) {

      if (targetCell1Ref.obstacle.state === true) {
        target.cell1.occupant.type = "obstacle";
        target.cell1.free = false;
      }

      if (targetCell1Ref.barrier.state === true) {

        if (targetCell1Ref.barrier.position === this.getOppositeDirection(direction)) {

          target.cell1.occupant.type = "barrier";
          target.cell1.free = false;
        }


        if (targetCell2Ref) {

          if (targetCell1Ref.barrier.position === direction || targetCell2Ref.barrier.position === this.getOppositeDirection(direction)) {

            target.cell2.occupant.type = "barrier";
            target.cell2.free = false;
          }
        }

        if (!targetCell2Ref && targetCell1Ref.barrier.position === direction) {

          // target.cell1.occupant.type = "barrier";
          // target.cell1.free = false;

          target.cell2.occupant.type = "barrier";
          target.cell2.free = false;

        }


      }

      if (targetCell1Ref.item.name !== "" && target.cell1.occupant.type !== "player") {
        target.cell1.occupant.type = "item";
      }

      if (targetCell1Ref.rubble === true) {
        target.cell1.occupant.type = "rubble";
      }

      if (targetCell1Ref.elevation.number > myCell.elevation.number) {
        target.cell1.occupant.type = "higherElevation";
        target.cell1.free = false;
      }

    }
    if (targetCell2Ref) {
      if (targetCell2Ref.obstacle.state === true) {
        target.cell2.occupant.type = "obstacle";
        target.cell2.free = false;
      }

      if (targetCell2Ref.barrier.position === this.getOppositeDirection(direction)) {

        target.cell2.occupant.type = "barrier";
        target.cell2.free = false;
      }

      if (targetCell2Ref.item.name !== "" && target.cell2.occupant.type !== "player") {
        target.cell2.occupant.type = "item";
      }

      if (targetCell2Ref.rubble === true) {
        target.cell2.occupant.type = "rubble";
      }

      if (targetCell2Ref.elevation.number > myCell.elevation.number) {
        target.cell2.occupant.type = "higherElevation";
        target.cell2.free = false;
      }

    }

    // console.log('target',target);
    player.target = target;
    this.players[player.number-1] = player;

    return target;

  }
  resetTarget = () => {

    return {
      cell1: {
        number: {
          x: 0,
          y: 0,
        },
        center: {
          x: 0,
          y: 0,
        },
        free: true,
        occupant: {
          type: '',
          player: '',
        },
        void: false,
      },
      cell2: {
        number: {
          x: 0,
          y: 0,
        },
        center: {
          x: 0,
          y: 0,
        },
        free: true,
        occupant: {
          type: '',
          player: '',
        },
        void: false,
      },
      myCellBlock: false,
    };
  }
  checkCell = (cell) => {
    // console.log('check cell',cell);

    let cellFree = true;
    let cell2 = this.gridInfo.find(elem => elem.number.x === cell.x && elem.number.y === cell.y);
    if (
      // cell2.levelData.charAt(0) ===  'z' ||
      // cell2.levelData.charAt(0) ===  'y'
      cell2.obstacle.state === true
    ) {
      cellFree = false;
    }
    if (cell2.item.name !== '') {
      cellFree = false;
    }
    if (cell2.void.state === true) {
      cellFree = false;
    }
    if (
      cell2.terrain.type === 'deep' ||
      cell2.terrain.type === 'hazard'||
      cell2.terrain.type === 'void'
    ) {
      cellFree = false;
    }

    // PLAYERS 1&2 ALT RESPAWN POINTS!
    if (this.gridWidth > 6) {
      if (cell.x === this.gridWidth && cell.y === this.gridWidth) {
        cellFree = false;
      }
      if (cell.x === this.gridWidth && cell.y === 0) {
        cellFree = false;
      }
    }



    for (const player of this.players) {

      if (this.init === true) {
        if (
          player.startPosition.cell.number.x === cell.x &&
          player.startPosition.cell.number.y === cell.y
        ) {
          cellFree = false;
        }
      } else {
        if (
          player.currentPosition.cell.number.x === cell.x &&
          player.currentPosition.cell.number.y === cell.y
        ) {
          cellFree = false;
        }
      }
    }

    return cellFree;
  }
  getRandomFreeCell = () => {


    let cell = {
      number: {x: undefined, y: undefined},
      center: {x: undefined, y: undefined}
    };
    let randomFreeCellChosen = false;
    let noMoreCells = false;
    let trashCells = [];

    while (randomFreeCellChosen !== true) {
      cell.number.x = this.rnJesus(0,this.gridWidth)
      cell.number.y = this.rnJesus(0,this.gridWidth)
      randomFreeCellChosen = this.checkCell(cell.number);

      if (randomFreeCellChosen !== true) {
        // console.log('getRandomFreeCell: not free',cell.number);
        trashCells.push(cell);
        if (
          (trashCells.length+this.gridInfo.filter(x => x.obstacle.state === true ||
            x.terrain.type === "deep" ||
            // x.terrain.type === "void" ||
            x.void.state === true).length+this.playerNumber) >= this.gridInfo.length
        ) {
          // console.log('getRandomFreeCell. no more cells!');
          noMoreCells = true
          // randomFreeCellChosen = true
          cell = {
            number: {x: undefined, y: undefined},
            center: {x: undefined, y: undefined}
          };
          break;

        }
      }
      if (randomFreeCellChosen === true) {
        // console.log('getRandomFreeCell: free cell',cell.number);

        break;
      }

    }

    if (noMoreCells === true) {
      // console.log('no more cells 2');
      return null;
    }

    if (randomFreeCellChosen === true) {
      // console.log('getRandomFreeCell: set free cell',cell.number);
      let refCell = this.gridInfo.find(x => x.number.x === cell.number.x && x.number.y === cell.number.y);
      cell.number = refCell.number;
      cell.center = refCell.center;
      return cell;
    }





  }
  getDirectionFromCells = (cell1Number,cell2Number) => {

    let direction = "";

    if (cell2Number.x === cell1Number.x && cell2Number.y === cell1Number.y-1) {
      direction = 'north';
    }
    if (cell2Number.x === cell1Number.x-1 && cell2Number.y === cell1Number.y-1) {
      direction = 'northWest';
    }
    if (cell2Number.x === cell1Number.x-1 && cell2Number.y === cell1Number.y) {
      direction = 'west';
    }
    if (cell2Number.x === cell1Number.x-1 && cell2Number.y === cell1Number.y+1) {
      direction = 'southWest';
    }
    if (cell2Number.x === cell1Number.x && cell2Number.y === cell1Number.y+1) {
      direction = 'south';
    }
    if (cell2Number.x === cell1Number.x+1 && cell2Number.y === cell1Number.y+1) {
      direction = 'southEast';
    }
    if (cell2Number.x === cell1Number.x+1 && cell2Number.y === cell1Number.y) {
      direction = 'east';
    }
    if (cell2Number.x === cell1Number.x+1 && cell2Number.y === cell1Number.y-1) {
      direction = 'northEast';
    }

    return direction;
  }
  getVoidCenter = (range,direction,originCenter) => {

    let voidCenter = {
      x: undefined,
      y: undefined
    };
    let xMod = this.floorImageWidth/2;
    let yMod = this.floorImageHeight/2;
    if (range === 2) {
      xMod = this.floorImageWidth;
      yMod = this.floorImageHeight;
    }
    switch(direction) {
      case 'north' :
        voidCenter = {
          x: originCenter.x+xMod,
          y: originCenter.y-yMod,
        }
      break;
      case 'south' :
        voidCenter = {
          x: originCenter.x-xMod,
          y: originCenter.y+yMod,
        }
      break;
      case 'west' :
        voidCenter = {
          x: originCenter.x-xMod,
          y: originCenter.y-yMod,
        }
      break;
      case 'east' :
        voidCenter = {
          x: originCenter.x+xMod,
          y: originCenter.y+yMod,
        }
      break;
    }


    return voidCenter;
  }
  getCellFromDirection = (range,originCellNumber,direction) => {

    let cellNumber = {
      x: undefined,
      y: undefined,
    };

    switch(direction) {
      case 'north' :
        if (range === 1) {
          cellNumber = {
            x: originCellNumber.x,
            y: originCellNumber.y-1
          }
        }
        if (range === 2) {
          cellNumber = {
            x: originCellNumber.x,
            y: originCellNumber.y-2
          }
        }
      break;
      case 'east' :
        if (range === 1) {
          cellNumber = {
            x: originCellNumber.x+1,
            y: originCellNumber.y
          }
        }
        if (range === 2) {
          cellNumber = {
            x: originCellNumber.x+2,
            y: originCellNumber.y
          }
        }
      break;
      case 'west' :
        if (range === 1) {
          cellNumber = {
            x: originCellNumber.x-1,
            y: originCellNumber.y
          }
        }
        if (range === 2) {
          cellNumber = {
            x: originCellNumber.x-2,
            y: originCellNumber.y
          }
        }
      break;
      case 'south' :
        if (range === 1) {
          cellNumber = {
            x: originCellNumber.x,
            y: originCellNumber.y+1
          }
        }
        if (range === 2) {
          cellNumber = {
            x: originCellNumber.x,
            y: originCellNumber.y+2
          }
        }
      break;
      default:
      break;
    }

    return cellNumber;

  }
  checkForwardBarrier = (direction,cell) => {

    let fwdBarrier = false;
    if (cell.barrier.state === true) {

      if (direction === this.getOppositeDirection(cell.barrier.position)) {
        fwdBarrier = true;
      }

    }
    return fwdBarrier;

  }
  checkMyCellBarrier = (direction,myCell) => {

    let myCellBarrier = false;
    if (myCell.barrier.state === true ) {
      if (myCell.barrier.position === direction) {
          myCellBarrier = true;
      }
    }

    return myCellBarrier;

  }
  getOppositeDirection = (originalDirection) => {
    let oppositeDirection = "";
    switch (originalDirection) {
      case "north":
        oppositeDirection = "south";
        break;
      case "south":
        oppositeDirection = "north";
        break;
      case "east":
        oppositeDirection = "west";
        break;
      case "west":
        oppositeDirection = "east";
        break;
      default:

    }
    return oppositeDirection;
  }
  aiBoltPathCheck = (aiPlayer) => {


    // console.log('aiPlayer.ai.targetPlayer',aiPlayer.ai.targetPlayer);
    let rangeElemCells2 = [];
    let rangeElem = aiPlayer.currentPosition.cell.number;
    let targetPos = aiPlayer.ai.targetPlayer.currentPosition;

    let dirToFire;
    let diff = 0;
    if (rangeElem.x === targetPos.x && rangeElem.y > targetPos.y) {
     dirToFire = 'north';
     diff = rangeElem.y - targetPos.y;
     for (var i = 0; i < diff; i++) {
       rangeElemCells2.push({x:rangeElem.x, y: rangeElem.y - i})
       // this.cellsToHighlight.push({x:rangeElem.x, y: rangeElem.y - i})
     }
    }
    if (rangeElem.x > targetPos.x && rangeElem.y === targetPos.y) {
     dirToFire = 'west';
     diff = rangeElem.x - targetPos.x;
     for (var i = 0; i < diff; i++) {
       rangeElemCells2.push({x:rangeElem.x - i, y: rangeElem.y})
       // this.cellsToHighlight.push({x:rangeElem.x - i, y: rangeElem.y})
     }
    }
    if (rangeElem.x === targetPos.x && rangeElem.y < targetPos.y) {
     dirToFire = 'south';
     diff = targetPos.y - rangeElem.y;
     for (var i = 0; i < diff; i++) {
       rangeElemCells2.push({x:rangeElem.x, y: rangeElem.y + i})
       // this.cellsToHighlight.push({x:rangeElem.x, y: rangeElem.y + i})
     }
    }
    if (rangeElem.x < targetPos.x && rangeElem.y === targetPos.y) {
     dirToFire = 'east';
     diff = targetPos.x - rangeElem.x;
     for (var i = 0; i < diff; i++) {
       rangeElemCells2.push({x:rangeElem.x + i, y: rangeElem.y})
       // this.cellsToHighlight.push({x:rangeElem.x + i, y: rangeElem.y})
     }
    }




    // IS SIGHT OBSTRUCTED?
    // let clearToShoot = true;
    let obstructions = [];
    for (const cellx of rangeElemCells2) {
      // console.log('cellx',cellx);
      let cellRef4 = this.gridInfo.find(elemb => elemb.number.x === cellx.x && elemb.number.y === cellx.y)
      if (
        cellRef4.obstacle.state === true &&
        cellRef4.obstacle.height >= 1
      ) {
        // clearToShoot = false;
        obstructions.push(cellx)
      }
      if (
        cellRef4.barrier.state === true
      ) {
        // clearToShoot = false;
        obstructions.push(cellx)
      }

      if (
        // cellRef4.levelData.charAt(0) !==  'y' &&
        // cellRef4.levelData.charAt(0) !==  'z'
        cellRef4.obstacle.state !== true &&
        cellRef4.barrier.state !== true ||
        cellRef4.obstacle.state === true &&
        cellRef4.obstacle.height < 1
      ) {
        // clearToShoot = true;
        // obstructions.push(cellx)
      }
    }

    // console.log('aiBoltPathCheck obstructions',obstructions);
    if (obstructions.length === 0) {
      return true;
    } else {
      return false;
      console.log('aiBoltPathCheck obstructions',obstructions);
    }

    // return clearToShoot

  }
  getBoltTarget = (bolt) => {
    // console.log('get bolt target');

    let index = this.projectiles.findIndex(blt => blt.id === bolt.id);

    let path = [];
    let originCell = {
      x: bolt.moving.origin.number.x,
      y: bolt.moving.origin.number.y,
    }

    bolt.target.path.push({
      number: {
        x: originCell.x,
        y: originCell.y,
      },
      center: {
        x: 0,
        y: 0,
      },
      vertices: [],
    });

    let nextCell = {
      number: {
        x: 0,
        y: 0,
      },
      center: {
        x: 0,
        y: 0,
      },
      vertices: [],
    }
    while (
      nextCell.number.x >= 0 && nextCell.number.y >= 0 &&
      nextCell.number.x <= this.gridWidth && nextCell.number.y <= this.gridWidth
    ) {
      // console.log(originCell.x,originCell.y);
      let cell = {
        number: {
          x: 0,
          y: 0,
        },
        center: {
          x: 0,
          y: 0,
        },
        vertices: [],
      }


      // cell.number = this.getCellFromDirection(1,originCell.number,this.players[bolt.owner-1].direction);
      cell.number = this.getCellFromDirection(1,originCell,this.players[bolt.owner-1].direction);


      nextCell = cell;
      originCell = nextCell.number;
      bolt.target.path.push(cell);
    }
    if (bolt.target.path.length > 1) {
      bolt.target.path.splice(bolt.target.path.length-1,1)
    }

    // console.log('bolt path',bolt.target.path);

    for (const cell2 of bolt.target.path) {

      let cell = this.gridInfo.find(elem => elem.number.x === cell2.number.x && elem.number.y === cell2.number.y)

      if (cell) {
        cell2.center.x = cell.center.x;
        cell2.center.y = cell.center.y;
        cell2.vertices = cell.vertices;
      }

    }
    if (bolt.target.path.length === 1) {
      bolt.target.path.push({
        number: this.getCellFromDirection(1,bolt.target.path[0].number,bolt.direction),
        center: this.getVoidCenter(1,bolt.direction,bolt.target.path[0].center),
        vertices: [],
      })
    }

    bolt.moving.state = true;

    this.projectiles[index] = bolt;

  }
  isBoltInCell = (cellNumber) => {

    let bolt = false;
    for (const bolt of this.projectiles) {
      if (
        cellNumber.x === bolt.currentPosition.number.x &&
        cellNumber.y === bolt.currentPosition.number.y
      ) {
        bolt = true;
      }
    }

    return bolt;

  }
  checkDestination = (player,checkTerrain) => {
    // console.log('checking for item or enviro effect');

    this.players[player.number-1].terrainMoveSpeed.state = false;
    let pickUp = false;
    let cell = this.gridInfo.find(elem => elem.number.x === player.currentPosition.cell.number.x && elem.number.y === player.currentPosition.cell.number.y);

    let gearAmount = 0;
    for (const weapon of player.items.weapons) {
      if (weapon.name && weapon.name !== '') {
        gearAmount++
      }
    }
    for (const armor of player.items.armor) {
      if (armor.name && armor.name !== '') {
        gearAmount++
      }
    }

    let haveSpace = false;
    if (gearAmount < player.inventorySize) {
      haveSpace = true;
    }
    // console.log('gearAmount', gearAmount, 'inventorySize',player.inventorySize);

    // if (haveSpace === true && ) {

    // console.log('check dest cell',cell);

      // let cell = this.gridInfo.find(elem => elem.number.x === player.currentPosition.cell.number.x && elem.number.y === player.currentPosition.cell.number.y)
      if (cell.item.name !== '') {
        // console.log('picked up an item');
        if (cell.item.type === 'weapon') {

          if (haveSpace === true ) {

            if (player.currentWeapon.name === '' || !player.currentWeapon.name) {

              this.players[player.number-1].currentWeapon = {
                name: cell.item.name,
                type: cell.item.subType,
                effect: cell.item.effect,
              }
              this.players[player.number-1].items.weapons.push({
                name: cell.item.name,
                type: cell.item.subType,
                effect: cell.item.effect,
              })
              if (cell.item.subType === 'crossbow') {
                let ammo = parseInt(cell.item.effect.split('+')[1])
                // console.log('picked up a crossbow checking ammo',ammo);
                if (!this.players[player.number-1].popups.find(x=>x.msg === 'crossbow')) {
                  this.players[player.number-1].popups.push(
                    {
                      state: false,
                      count: 0,
                      limit:25,
                      type: '',
                      position: '',
                      msg: 'crossbow',
                      img: '',

                    }
                  )
                }

                this.players[player.number-1].items.ammo = this.players[player.number-1].items.ammo + ammo;
                // console.log('new ammo amt',this.players[player.number-1].items.ammo);
              }

              if (!this.players[player.number-1].popups.find(x=>x.msg === 'pickupWeapon')) {
                this.players[player.number-1].popups.push(
                  {
                    state: false,
                    count: 0,
                    limit:25,
                    type: '',
                    position: '',
                    msg: 'pickupWeapon',
                    img: '',

                  }
                )
              }

              pickUp = true;
            }
            else {
              if (player.items.weapons.map(weapon => weapon.name).includes(cell.item.name) !== true ) {
                this.players[player.number-1].items.weapons.push({
                  name: cell.item.name,
                  type: cell.item.subType,
                  effect: cell.item.effect,
                })
                if (cell.item.subType === 'crossbow') {
                  let ammo = parseInt(cell.item.effect.split('+')[1])
                  // console.log('picked up a crossbow checking ammo',ammo);
                  if (!this.players[player.number-1].popups.find(x=>x.msg === 'crossbow')) {
                    this.players[player.number-1].popups.push(
                      {
                        state: false,
                        count: 0,
                        limit:25,
                        type: '',
                        position: '',
                        msg: 'crossbow',
                        img: '',

                      }
                    )
                  }
                  this.players[player.number-1].items.ammo = this.players[player.number-1].items.ammo + ammo;
                  // console.log('new ammo amt',this.players[player.number-1].items.ammo);
                }
                pickUp = true;

                this.players[player.number-1].statusDisplay = {
                  state: true,
                  status: 'weapon accquired',
                  count: 1,
                  limit: this.players[player.number-1].statusDisplay.limit,
                }
                if (!this.players[player.number-1].popups.find(x=>x.msg === 'pickupWeapon')) {
                  this.players[player.number-1].popups.push(
                    {
                      state: false,
                      count: 0,
                      limit:25,
                      type: '',
                      position: '',
                      msg: 'pickupWeapon',
                      img: '',

                    }
                  )
                }

              }
              else {

                if (cell.item.subType === 'crossbow') {
                  let ammo = parseInt(cell.item.effect.split('+')[1]);
                  this.players[player.number-1].items.ammo = this.players[player.number-1].items.ammo + ammo;
                  console.log('you already have a crossbow but take the ammo',ammo);
                  cell.item.effect = 'ammo+0';

                  if (!this.players[player.number-1].popups.find(x=>x.msg === 'pickupAmmo')) {
                    this.players[player.number-1].popups.push(
                      {
                        state: false,
                        count: 0,
                        limit:25,
                        type: '',
                        position: '',
                        msg: 'pickupAmmo',
                        img: '',

                      }
                    )
                  }
                }
                else {
                  console.log('you already have this weapon');
                  this.players[player.number-1].statusDisplay = {
                    state: true,
                    status: 'Already have this weapon!',
                    count: 1,
                    limit: this.players[player.number-1].statusDisplay.limit,
                  }

                  if (!this.players[player.number-1].popups.find(x=>x.msg === 'stop')) {
                    this.players[player.number-1].popups.push(
                      {
                        state: false,
                        count: 0,
                        limit:25,
                        type: '',
                        position: '',
                        msg: 'stop',
                        img: '',

                      }
                    )
                  }
                }
              }
            }

          }
          else if (cell.item.name !== '') {
            console.log('Not enough space!!');

            this.players[player.number-1].statusDisplay = {
              state: true,
              status: 'Not enough space!!',
              count: 1,
              limit: this.players[player.number-1].statusDisplay.limit,
            }

            if (!this.players[player.number-1].popups.find(x=>x.msg === 'inventoryFull')) {
              this.players[player.number-1].popups.push(
                {
                  state: false,
                  count: 0,
                  limit:25,
                  type: '',
                  position: '',
                  msg: 'inventoryFull',
                  img: '',

                }
              )
            }

          }

        }
        if (cell.item.type === 'armor') {
          // console.log('picked up armor',player.currentArmor);

          if (haveSpace === true ) {

          if (player.currentArmor.name === '' || !player.currentArmor.name) {
            // console.log('gg',cell.item.effect);
            this.players[player.number-1].currentArmor = {
              name: cell.item.name,
              type: cell.item.subType,
              effect: cell.item.effect,
            }
            this.players[player.number-1].items.armor.push({
              name: cell.item.name,
              type: cell.item.subType,
              effect: cell.item.effect,
            })

            switch(cell.item.effect) {
              case 'hpUp' :
              // console.log('armor pickup buff');
                if (this.players[player.number-1].hp < 3) {
                  // console.log('armor pickup buff hp',this.players[player.number-1].hp);
                  this.players[player.number-1].hp = player.hp + 1
                  // console.log('armor pickup buff hp',this.players[player.number-1].hp);

                  this.players[player.number-1].statusDisplay = {
                    state: true,
                    status: 'hpUp',
                    count: 1,
                    limit: this.players[player.number-1].statusDisplay.limit,
                  }

                  if (!this.players[player.number-1].popups.find(x=>x.msg === 'pickupBuff')) {
                    this.players[player.number-1].popups.push(
                      {
                        state: false,
                        count: 0,
                        limit:25,
                        type: '',
                        position: '',
                        msg: 'pickupBuff',
                        img: '',

                      }
                    )
                  }

                  if (!this.players[player.number-1].popups.find(x=>x.msg.split("_")[0] === "hpUp")) {
                    this.players[player.number-1].popups.push(
                      {
                        state: false,
                        count: 0,
                        limit: 30,
                        type: '',
                        position: '',
                        msg: 'hpUp_'+'+'+1+'',
                        img: '',

                      }
                    )
                  }

                }
              break;
              case 'speedUp' :
              // console.log('armor pickup buff');
                let currentSpd1 = this.players[player.number-1].speed.range.indexOf(this.players[player.number-1].speed.move)
                if (this.players[player.number-1].speed.move < .2) {

                  // console.log('armor pickup buff speed',this.players[player.number-1].speed.move);
                  this.players[player.number-1].speed.move = this.players[player.number-1].speed.range[currentSpd1+1]
                  // console.log('armor pickup buff speed',this.players[player.number-1].speed.move);

                  this.players[player.number-1].statusDisplay = {
                    state: true,
                    status: 'speedUp',
                    count: 1,
                    limit: this.players[player.number-1].statusDisplay.limit,
                  }

                  if (!this.players[player.number-1].popups.find(x=>x.msg === 'pickupBuff')) {
                    this.players[player.number-1].popups.push(
                      {
                        state: false,
                        count: 0,
                        limit: 25,
                        type: '',
                        position: '',
                        msg: 'pickupBuff',
                        img: '',

                      }
                    )
                  }

                }
              break;
            }

            pickUp = true;
          }
          else {
            if (player.items.armor.map(armor => armor.name).includes(cell.item.name) !== true ) {
              this.players[player.number-1].items.armor.push({
                name: cell.item.name,
                type: cell.item.subType,
                effect: cell.item.effect,
              })
              pickUp = true;

              this.players[player.number-1].statusDisplay = {
                state: true,
                status: 'armor accquired',
                count: 1,
                limit: this.players[player.number-1].statusDisplay.limit,
              }

              if (!this.players[player.number-1].popups.find(x=>x.msg === 'pickupArmor')) {
                this.players[player.number-1].popups.push(
                  {
                    state: false,
                    count: 0,
                    limit:25,
                    type: '',
                    position: '',
                    msg: 'pickupArmor',
                    img: '',

                  }
                )
              }

            }
            else {
              console.log('you already have this armor');
              this.players[player.number-1].statusDisplay = {
                state: true,
                status: 'Already have this armor!',
                count: 1,
                limit: this.players[player.number-1].statusDisplay.limit,
              }

              if (!this.players[player.number-1].popups.find(x=>x.msg === 'stop')) {
                this.players[player.number-1].popups.push(
                  {
                    state: false,
                    count: 0,
                    limit:25,
                    type: '',
                    position: '',
                    msg: 'stop',
                    img: '',

                  }
                )
              }


            }
          }

          }
          else if (cell.item.name !== '') {
            console.log('Not enough space!!');

            this.players[player.number-1].statusDisplay = {
              state: true,
              status: 'Not enough space!!',
              count: 1,
              limit: this.players[player.number-1].statusDisplay.limit,
            }

            if (!this.players[player.number-1].popups.find(x=>x.msg === 'inventoryFull')) {
              this.players[player.number-1].popups.push(
                {
                  state: false,
                  count: 0,
                  limit:25,
                  type: '',
                  position: '',
                  msg: 'inventoryFull',
                  img: '',

                }
              )
            }

          }

        }
        else {
          // console.log('item',cell.item);
          let ammo;
          switch(cell.item.name) {
            case 'moveSpeedUp' :
              // console.log('moveSpeedUp');
              let currentSpd1 = this.players[player.number-1].speed.range.indexOf(this.players[player.number-1].speed.move)
              // console.log('dd',currentSpd1,this.players[player.number-1].speed.range[currentSpd1]);
              // console.log('dd2',currentSpd1,this.players[player.number-1].speed.range[currentSpd1+1]);
              if (this.players[player.number-1].speed.move < .2) {
                // console.log('added buff');
                this.players[player.number-1].speed.move = this.players[player.number-1].speed.range[currentSpd1+1]

                this.players[player.number-1].statusDisplay = {
                  state: true,
                  status: cell.item.name,
                  count: 1,
                  limit: this.players[player.number-1].statusDisplay.limit,
                }

                if (!this.players[player.number-1].popups.find(x=>x.msg === 'pickupBuff')) {
                  this.players[player.number-1].popups.push(
                    {
                      state: false,
                      count: 0,
                      limit:25,
                      type: '',
                      position: '',
                      msg: 'pickupBuff',
                      img: '',

                    }
                  )
                }

                pickUp = true;
              }
              else {
                console.log('player '+player.number+' you already have max movement speed');

                this.players[player.number-1].statusDisplay = {
                  state: true,
                  status: 'Already Max Speed!!',
                  count: 1,
                  limit: this.players[player.number-1].statusDisplay.limit,
                }

                if (!this.players[player.number-1].popups.find(x=>x.msg === 'stop')) {
                  this.players[player.number-1].popups.push(
                    {
                      state: false,
                      count: 0,
                      limit:25,
                      type: '',
                      position: '',
                      msg: 'stop',
                      img: '',

                    }
                  )
                }
              }
            break;
            case 'moveSpeedDown' :
              // console.log('moveSpeedDown');
              let currentSpd2 = this.players[player.number-1].speed.range.indexOf(this.players[player.number-1].speed.move)
              // console.log('ff',currentSpd2,this.players[player.number-1].speed.range[currentSpd2]);
              // console.log('ff2',currentSpd2,this.players[player.number-1].speed.range[currentSpd2-1]);
              if (this.players[player.number-1].speed.move > .05) {
                // console.log('added debuff');
                this.players[player.number-1].speed.move = this.players[player.number-1].speed.range[currentSpd2-1]

                this.players[player.number-1].statusDisplay = {
                  state: true,
                  status: cell.item.name,
                  count: 1,
                  limit: this.players[player.number-1].statusDisplay.limit,
                }

                if (!this.players[player.number-1].popups.find(x=>x.msg === 'pickupDebuff')) {
                  this.players[player.number-1].popups.push(
                    {
                      state: false,
                      count: 0,
                      limit:25,
                      type: '',
                      position: '',
                      msg: 'pickupDebuff',
                      img: '',

                    }
                  )
                }

                pickUp = true;
              }
            break;
            case 'hpUp' :
              // console.log('hpUp');
              if (this.players[player.number-1].hp === 1 && this.players[player.number-1].speed.move < .1) {
                this.players[player.number-1].speed.move = .1;
              }
              if (this.players[player.number-1].hp < 3) {
                  this.players[player.number-1].hp ++;

                  this.players[player.number-1].statusDisplay = {
                    state: true,
                    status: cell.item.name,
                    count: 1,
                    limit: this.players[player.number-1].statusDisplay.limit,
                  }

                  if (!this.players[player.number-1].popups.find(x=>x.msg === 'pickupBuff')) {
                    this.players[player.number-1].popups.push(
                      {
                        state: false,
                        count: 0,
                        limit:25,
                        type: '',
                        position: '',
                        msg: 'pickupBuff',
                        img: '',

                      }
                    )
                  }

                  if (!this.players[player.number-1].popups.find(x=>x.msg.split("_")[0] === "hpUp")) {
                    this.players[player.number-1].popups.push(
                      {
                        state: false,
                        count: 0,
                        limit: 30,
                        type: '',
                        position: '',
                        msg: 'hpUp_'+'+'+1+'',
                        img: '',

                      }
                    )
                  }

                  pickUp = true;
              }
              else {
                console.log('player '+player.number+' you already have max hp');

                this.players[player.number-1].statusDisplay = {
                  state: true,
                  status: 'Already Max HP!!',
                  count: 1,
                  limit: this.players[player.number-1].statusDisplay.limit,
                }

                if (!this.players[player.number-1].popups.find(x=>x.msg === 'stop')) {
                  this.players[player.number-1].popups.push(
                    {
                      state: false,
                      count: 0,
                      limit:25,
                      type: '',
                      position: '',
                      msg: 'stop',
                      img: '',

                    }
                  )
                }
              }
            break;
            case 'hpDown' :
              // console.log('hpDown');
              if (player.hp > 1) {
                this.players[player.number-1].hp --;

                this.players[player.number-1].statusDisplay = {
                  state: true,
                  status: cell.item.name,
                  count: 1,
                  limit: this.players[player.number-1].statusDisplay.limit,
                }

                if (!this.players[player.number-1].popups.find(x=>x.msg === 'pickupDebuff')) {
                  this.players[player.number-1].popups.push(
                    {
                      state: false,
                      count: 0,
                      limit:25,
                      type: '',
                      position: '',
                      msg: 'pickupDebuff',
                      img: '',

                    }
                  )
                }
                if (!this.players[player.number-1].popups.find(x=>x.msg === 'alarmed')) {
                  this.players[player.number-1].popups.push(
                    {
                      state: false,
                      count: 0,
                      limit:25,
                      type: '',
                      position: '',
                      msg: 'alarmed',
                      img: '',

                    }
                  )
                }
                pickUp = true;
              }
            break;
            case 'focusUp' :
              if (
                this.players[player.number-1].crits.doubleHit - 2 !== 0
              ) {
                this.players[player.number-1].crits.doubleHit = this.players[player.number-1].crits.doubleHit - 2;

                this.players[player.number-1].statusDisplay = {
                  state: true,
                  status: cell.item.name,
                  count: 1,
                  limit: this.players[player.number-1].statusDisplay.limit,
                }

                if (!this.players[player.number-1].popups.find(x=>x.msg === 'pickupBuff')) {
                  this.players[player.number-1].popups.push(
                    {
                      state: false,
                      count: 0,
                      limit:25,
                      type: '',
                      position: '',
                      msg: 'pickupBuff',
                      img: '',

                    }
                  )
                }

              }
              this.players[player.number-1].crits.guardBreak = this.players[player.number-1].crits.guardBreak + 1;

              pickUp = true;
            break;
            case 'focusDown' :
              this.players[player.number-1].crits.doubleHit = this.players[player.number-1].crits.doubleHit + 2;
              if (this.players[player.number-1].crits.guardBreak - 1 !== 0) {
                this.players[player.number-1].crits.guardBreak = this.players[player.number-1].crits.guardBreak - 1
              }

              this.players[player.number-1].statusDisplay = {
                state: true,
                status: cell.item.name,
                count: 1,
                limit: this.players[player.number-1].statusDisplay.limit,
              }

              if (!this.players[player.number-1].popups.find(x=>x.msg === 'pickupDebuff')) {
                this.players[player.number-1].popups.push(
                  {
                    state: false,
                    count: 0,
                    limit:25,
                    type: '',
                    position: '',
                    msg: 'pickupDebuff',
                    img: '',

                  }
                )
              }

              pickUp = true;
            break;
            case 'strengthUp' :
              this.players[player.number-1].crits.pushBack = this.players[player.number-1].crits.pushBack + 1;

              this.players[player.number-1].crits.guardBreak = this.players[player.number-1].crits.guardBreak + 1;

              this.players[player.number-1].statusDisplay = {
                state: true,
                status: cell.item.name,
                count: 1,
                limit: this.players[player.number-1].statusDisplay.limit,
              }

              if (!this.players[player.number-1].popups.find(x=>x.msg === 'pickupBuff')) {
                this.players[player.number-1].popups.push(
                  {
                    state: false,
                    count: 0,
                    limit:25,
                    type: '',
                    position: '',
                    msg: 'pickupBuff',
                    img: '',

                  }
                )
              }

              pickUp = true;
            break;
            case 'strengthDown' :
              if (
                this.players[player.number-1].crits.pushBack - 1 !== 0
              ) {
                this.players[player.number-1].crits.pushBack = this.players[player.number-1].crits.pushBack - 1;

                this.players[player.number-1].statusDisplay = {
                  state: true,
                  status: cell.item.name,
                  count: 1,
                  limit: this.players[player.number-1].statusDisplay.limit,
                }

                if (!this.players[player.number-1].popups.find(x=>x.msg === 'pickupDebuff')) {
                  this.players[player.number-1].popups.push(
                    {
                      state: false,
                      count: 0,
                      limit:25,
                      type: '',
                      position: '',
                      msg: 'pickupDebuff',
                      img: '',

                    }
                  )
                }

                pickUp = true;
              }
              if (this.players[player.number-1].crits.guardBreak - 1 !== 0) {
                this.players[player.number-1].crits.guardBreak = this.players[player.number-1].crits.guardBreak - 1

                this.players[player.number-1].statusDisplay = {
                  state: true,
                  status: cell.item.name,
                  count: 1,
                  limit: this.players[player.number-1].statusDisplay.limit,
                }

                pickUp = true;
              }
            break;
            case 'ammo5' :
              ammo = parseInt(cell.item.name.split('o')[1])
              this.players[player.number-1].items.ammo = this.players[player.number-1].items.ammo + ammo;

              this.players[player.number-1].statusDisplay = {
                state: true,
                status: cell.item.name,
                count: 1,
                limit: this.players[player.number-1].statusDisplay.limit,
              }

              if (!this.players[player.number-1].popups.find(x=>x.msg === 'pickupAmmo')) {
                this.players[player.number-1].popups.push(
                  {
                    state: false,
                    count: 0,
                    limit:25,
                    type: '',
                    position: '',
                    msg: 'pickupAmmo',
                    img: '',

                  }
                )
              }

              pickUp = true;
            break;
            case 'ammo10' :
              ammo = parseInt(cell.item.name.split('o')[1])
              this.players[player.number-1].items.ammo = this.players[player.number-1].items.ammo + ammo;

              this.players[player.number-1].statusDisplay = {
                state: true,
                status: cell.item.name,
                count: 1,
                limit: this.players[player.number-1].statusDisplay.limit,
              }

              if (!this.players[player.number-1].popups.find(x=>x.msg === 'pickupAmmo')) {
                this.players[player.number-1].popups.push(
                  {
                    state: false,
                    count: 0,
                    limit:25,
                    type: '',
                    position: '',
                    msg: 'pickupAmmo',
                    img: '',

                  }
                )
              }

              pickUp = true;
            break;
          }

        }
        if (pickUp === true) {
          // PICKUP ANIM!!
          // if (cell.item.type === 'item') {
          //   this.players[player.number-1].itemPickup = {
          //     state: true,
          //     count: 0,
          //     limit: 10,
          //     item: {
          //       name: cell.item.name,
          //     },
          //     gear: {
          //       type: '',
          //     }
          //   }
          // }
          // else if (cell.item.type === 'weapon' || cell.item.type === 'armor') {
          //   this.players[player.number-1].itemPickup = {
          //     state: true,
          //     count: 0,
          //     limit: 10,
          //     item: {
          //       name: '',
          //     },
          //     gear: {
          //       type: cell.item.subType,
          //     }
          //   }
          // }

          cell.item = {
            name: '',
            type: '',
            subType: '',
            effect: '',
            initDrawn: false
          }
        }

      }

    // }
    // else if (cell.item.name !== '') {
    //   console.log('Not enough space!!');
    //
    //   this.players[player.number-1].statusDisplay = {
    //     state: true,
    //     status: 'Not enough space!!',
    //     count: 1,
    //     limit: this.players[player.number-1].statusDisplay.limit,
    //   }
    // }


    switch(cell.terrain.type) {
      case 'stone' :
        // console.log('player',player.number,' stepped in',cell.terrain.name,'type',cell.terrain.type);
      break;
      case 'grass' :
        // console.log('player',player.number,' stepped in',cell.terrain.name,'type',cell.terrain.type);
      break;
      case 'deep' :
        this.players[player.number-1].falling.state = true;
        this.players[player.number-1].action = 'falling';
        this.players[player.number-1].drowning = true;

        if (!this.players[player.number-1].popups.find(x=>x.msg === 'drowning')) {
          this.players[player.number-1].popups.push(
            {
              state: false,
              count: 0,
              limit:25,
              type: '',
              position: '',
              msg: 'drowning',
              img: '',

            }
          )
        }

        // this.moveSpeed = plyr.speed.move;
        // this.players[player.number-1].target = this.resetTarget();
        this.players[player.number-1].target.cell1.number = player.currentPosition.cell.number;
        this.players[player.number-1].target.cell1.center = player.currentPosition.cell.center;

        this.players[player.number-1].moving = {
          state: true,
          step: 0,
          course: '',
          origin: {
            number: player.currentPosition.cell.number,
            center: player.currentPosition.cell.center,
          },
          destination: {
            x: player.currentPosition.cell.center.x,
            y: player.currentPosition.cell.center.y,
          }
        }

        let nextPosition = this.lineCrementer(player);
        this.players[player.number-1].nextPosition = nextPosition;

        // console.log('player',player.number,' stepped in',cell.terrain.name,'type',cell.terrain.type);
      break;
      case 'road' :
        // console.log('player',player.number,' stepped in',cell.terrain.name,'type',cell.terrain.type);
      break;
      case 'shallow' :
        // console.log('player',player.number,' stepped in',cell.terrain.name,'type',cell.terrain.type);
        this.players[player.number-1].terrainMoveSpeed.state = true;
        this.players[player.number-1].terrainMoveSpeed.speed = this.terrainMoveSpeedRef[cell.terrain.type]
      break;
      case 'sticky' :
        // console.log('player',player.number,' stepped in',cell.terrain.name,'type',cell.terrain.type);
        this.players[player.number-1].terrainMoveSpeed.state = true;
        this.players[player.number-1].terrainMoveSpeed.speed = this.terrainMoveSpeedRef[cell.terrain.type]

        if (!player.popups.find(x=>x.msg === 'terrainSlowdown')) {
          this.players[player.number-1].popups.push(
            {
              state: false,
              count: 0,
              limit: 25,
              type: '',
              position: '',
              msg: 'terrainSlowdown',
              img: '',

            }
          )
        }

      break;
      case 'slippery' :
        // console.log('player',player.number,' stepped in',cell.terrain.name,'type',cell.terrain.type);
        this.players[player.number-1].terrainMoveSpeed.state = true;
        this.players[player.number-1].terrainMoveSpeed.speed = this.terrainMoveSpeedRef[cell.terrain.type]


        if (!player.popups.find(x=>x.msg === 'terrainSpeedup')) {
          this.players[player.number-1].popups.push(
            {
              state: false,
              count: 0,
              limit: 25,
              type: '',
              position: '',
              msg: 'terrainSpeedup',
              img: '',

            }
          )
        }

      break;
      case 'hazard' :
        // console.log('player',player.number,' stepped in',cell.terrain.name,'type',cell.terrain.type);
        let applyHazard;
        if (cell.terrain.name === 'lava') {
          applyHazard = this.rnJesus(1,2)
        }
        else {
          applyHazard = this.rnJesus(1,3)
        }
        if (applyHazard === 1) {

          // if (!this.players[player.number-1].popups.find(x=>x.msg === 'alarmed')) {
          //   this.players[player.number-1].popups.push(
          //     {
          //       state: false,
          //       count: 0,
          //       limit:25,
          //       type: '',
          //       position: '',
          //       msg: 'alarmed',
          //       img: '',
          //
          //     }
          //   )
          // }

          this.handleMiscPlayerDamage(player,"applyHazard");

        }
      break;
    }

    if(cell.rubble === true ) {
      // console.log('stepped on rubble @ check destination. removing it too');

      let applyHazard = this.rnJesus(1,3);

      if (applyHazard === 1) {

        this.handleMiscPlayerDamage(player,"applyHazard");

      }

      this.gridInfo.find(x => x.number.x === cell.number.x && x.number.y === cell.number.y).rubble = false;
    }

  }
  obstacleCheckDestination = (cell,player) => {

    let targetCell = this.gridInfo.find(x => x.number.x === cell.number.x && x.number.y === cell.number.y);
    let damage = 0;
    if (targetCell.terrain.name === 'lava') {
      damage = targetCell.obstacle.hp;
    }
    if (targetCell.terrain.type === 'hazard' || targetCell.rubble === true) {
      if (targetCell.terrain.name !== 'lava') {
        damage = this.rnJesus(1,targetCell.obstacle.hp-1);
        if (damage === 0) {
          damage = 1;
        }
      }
    }

    // DAMAGE/DESTROY OBSTACLE?
    if (targetCell.obstacle.destructible.state === true && damage > 0) {
      // WEAPON CHECK
      if (targetCell.obstacle.hp - damage > 0) {
        let hp = targetCell.obstacle.hp - damage;

        targetCell.obstacle = {
          state: targetCell.obstacle.state,
          name: targetCell.obstacle.name,
          type: targetCell.obstacle.type,
          hp: hp,
          destructible: targetCell.obstacle.destructible,
          locked: targetCell.obstacle.locked,
          weight: targetCell.obstacle.weight,
          height: targetCell.obstacle.height,
          items: targetCell.obstacle.items,
          effects: targetCell.obstacle.effects,
          moving: targetCell.obstacle.moving
        };
        this.obstacleBarrierToDestroy.push({
          type: 'obstacle',
          action: 'damage',
          count: 0,
          limit: 30,
          complete: false,
          cell: targetCell,
        })
      }

      // DESTROY OBSTACLE W/ OR W/O RUBBLE
      else if (targetCell.obstacle.hp - damage <= 0) {
        let itemsToDrop = [];
        if (targetCell.obstacle.destructible.leaveRubble === true && targetCell.rubble !== true) {
          // console.log('leave rubble on ',targetCell.number,'removing obstacle');
          if (targetCell.obstacle.items[0]) {
            itemsToDrop = targetCell.obstacle.items;
          }
          // let cellRef = this.gridInfo.find(elem => elem.number.x === targetCell.number.x && elem.number.y === targetCell.number.y);
          targetCell.rubble = true;
          // targetCell.terrain.type = 'hazard';

          targetCell.obstacle =
          {
            state: false,
            name: targetCell.obstacle.name,
            type: targetCell.obstacle.type,
            hp: 0,
            destructible: targetCell.obstacle.destructible,
            locked: targetCell.obstacle.locked,
            weight: targetCell.obstacle.weight,
            height: targetCell.obstacle.height,
            items: targetCell.obstacle.items,
            effects: targetCell.obstacle.effects,
            moving: targetCell.obstacle.moving
          };

          this.players[player.number-1].statusDisplay = {
            state: true,
            status: 'Destroyed '+targetCell.obstacle.name+'!',
            count: 1,
            limit: this.players[player.number-1].statusDisplay.limit,
          }

          if (!player.popups.find(x=>x.msg === 'destroyedItem')) {
            player.popups.push(
              {
                state: false,
                count: 0,
                limit: 30,
                type: '',
                position: '',
                msg: 'destroyedItem',
                img: '',

              }
            )
          }

        } else {
          // console.log('no rubble. Just remove obstacle');
          if (targetCell.obstacle.items[0]) {
            itemsToDrop = targetCell.obstacle.items;
          }

          targetCell.obstacle =
          {
            state: false,
            name: targetCell.obstacle.name,
            type: targetCell.obstacle.type,
            hp: 0,
            destructible: targetCell.obstacle.destructible,
            locked: targetCell.obstacle.locked,
            weight: targetCell.obstacle.weight,
            height: targetCell.obstacle.height,
            items: targetCell.obstacle.items,
            effects: targetCell.obstacle.effects,
            moving: targetCell.obstacle.moving
          };

          this.players[player.number-1].statusDisplay = {
            state: true,
            status: 'Destroyed '+targetCell.obstacle.name+'!',
            count: 1,
            limit: this.players[player.number-1].statusDisplay.limit,
          }

          if (!player.popups.find(x=>x.msg === 'destroyedItem')) {
            player.popups.push(
              {
                state: false,
                count: 0,
                limit: 30,
                type: '',
                position: '',
                msg: 'destroyedItem',
                img: '',

              }
            )
          }

        }

        // DROP OBSTACLE ITEMS?
        if (itemsToDrop[0]) {
          // console.log('dropping obstacle items bolt',itemsToDrop);

          this.obstacleItemDrop(targetCell,player);

        }
        this.obstacleBarrierToDestroy.push({
          type: 'obstacle',
          action: 'destroy',
          count: 0,
          limit: 30,
          complete: false,
          cell: targetCell,
        })

      }

    }

    // DESTROY ITEM?
    if (targetCell.item.name !== "") {
      targetCell.item = {
        name: '',
        type: '',
        subType: '',
        effect: '',
        initDrawn: false
      }
    }
    if (targetCell.rubble === true) {
      targetCell.rubble = false;
    }

  }
  customCellToVoid = (cell) => {
    console.log('void specific cell');

    this.cellToVoid.state = true;
    this.cellToVoid.x = cell.x;
    this.cellToVoid.y = cell.y;
    this.cellToVoid.count = 1;

    this.openVoid = true;
    this.voidCustomCell = true;

  }
  voidSummon = (cell) => {
    // console.log('opening void');

      let foundPlayer;
      let player;
      let cl = this.gridInfo.find(elem => elem.number.x === cell.x && elem.number.y === cell.y)

      if (
        cl.number.x === this.gridWidth &&
        cl.number.y === 0
      ) {
        // console.log('dont void this');
      }
      if (
        cl.number.x === this.gridWidth &&
        cl.number.y === this.gridWidth
      ) {
        // console.log('dont void this');
      } else {
        cl.item = {
          name: '',
          type: '',
          subType: '',
          effect: '',
          initDrawn: false
        };
        cl.void.state = true;

        if (this.bloodSacrificeEvent.state === true) {
          // console.log('bloodSacrificeVoidedCells',cl);
          this.bloodSacrificeVoidedCells.push(cl)
        }
        // console.log('voiding',cl.number.x,cl.number.y);

        // if (
        //   cl.levelData.charAt(0) === 'y'
        // ) {
        //   let x = cl.levelData.slice(1,3)
        //   cl.levelData = "x"+x+"";
        // }
        // if (
        //   cl.levelData.charAt(0) === 'z'
        // ) {
        //   let x = cl.levelData.slice(1,3)
        //   cl.levelData = "x"+x+"";
        // }

      }


      for (const plyr of this.players) {
        if (
          plyr.currentPosition.cell.number.x === cell.x &&
          plyr.currentPosition.cell.number.y === cell.y
        ) {
          foundPlayer = true;
          this.players[plyr.number-1].falling.state = true;
          this.players[plyr.number-1].action = 'falling';

          this.players[plyr.number-1].popups.push(
            {
              state: false,
              count: 0,
              limit: 25,
              type: '',
              position: '',
              msg: 'falling',
              img: '',

            }
          )

          this.moveSpeed = plyr.speed.move;
          this.players[plyr.number-1].target = this.resetTarget();

          this.players[plyr.number-1].moving = {
            state: true,
            step: 0,
            course: '',
            origin: {
              number: plyr.currentPosition.cell.number,
              center: plyr.currentPosition.cell.center,
            },
            destination: {
              x: plyr.currentPosition.cell.center.x,
              y: plyr.currentPosition.cell.center.y,
            }
          }

          let nextPosition = this.lineCrementer(plyr);
          this.players[plyr.number-1].nextPosition = nextPosition;

        }
      }

    this.updatePathArray();

    this.easyStar.avoidAdditionalPoint(cell.x, cell.y);

    for (const plyr2 of this.players) {
      if (plyr2.ai.state === true) {
        plyr2.ai.targetAcquired = false;
      }
    }

  }


  meleeAttackPeak = (player) => {
    // console.log('meleeAttackPeak',player.target.myCellBlock);

    if (player.target.myCellBlock !== true) {

      let playerAttackStamType;

      if (player.currentWeapon.name === "") {
        playerAttackStamType = this.staminaCostRef.attack.unarmed.normal;
        if (player.bluntAttack === true) {
          playerAttackStamType = this.staminaCostRef.attack.unarmed.blunt;
        }
      }
      if (player.bluntAttack === true && player.currentWeapon.name !== "") {
        playerAttackStamType = this.staminaCostRef.attack[player.currentWeapon.type].blunt;
      }
      if (player.currentWeapon.name !== "") {
        playerAttackStamType = this.staminaCostRef.attack[player.currentWeapon.type].normal;
      }



      let boltTarget1 = this.isBoltInCell(player.target.cell1.number)
      let boltTarget2 = this.isBoltInCell(player.target.cell2.number)

      if (player.currentWeapon.type === "spear") {

        this.cellsUnderAttack.push(
          {
            number: {
              x: player.target.cell1.number.x,
              y: player.target.cell1.number.y,
            },
            count: 1,
            limit: 8,
          },
          {
            number: {
              x: player.target.cell2.number.x,
              y: player.target.cell2.number.y,
            },
            count: 1,
            limit: 8,
          },
        )

        // TARGET CELL 1 IS NOT FREE, ITEM, BOLT, RUBBLE, ATTACK CELL1
        if (
          player.target.cell1.free !== true ||
          player.target.cell1.occupant.type === "item" ||
          player.target.cell1.occupant.type === "rubble" ||
          boltTarget1 === true
        ) {
          this.meleeAttackParse(player,1)
        }

        // TARGET CELL 1 IS FREE NOT ITEM, BOLT, RUBBLE
        if (
          player.target.cell1.free === true &&
          player.target.cell1.occupant.type !== "item" &&
          player.target.cell1.occupant.type !== "rubble" &&
          boltTarget1 !== true
        ) {

          // TARGET CELL 2 IS NOT FREE HAS ITEM, BOLT, RUBBLE ATTACK
          if (
            player.target.cell2.free !== true ||
            player.target.cell2.occupant.type === "item" ||
            player.target.cell2.occupant.type === "rubble" ||
            boltTarget2 === true
          ) {
            this.meleeAttackParse(player,2)
          }

          // TARGET CELL2 IS FREE AND NOT ITEM, BOLT, RUBBLE, MISS
          if (
            player.target.cell2.free === true &&
            player.target.cell2.occupant.type !== "item" &&
            player.target.cell2.occupant.type !== "rubble" &&
            boltTarget2 !== true
          ) {

            if (!player.popups.find(x => x.msg === "missedAttack2")) {
              player.popups.push(
                {
                  state: false,
                  count: 0,
                  limit: 30,
                  type: '',
                  position: '',
                  msg: 'missedAttack2',
                  img: '',

                }
              )
            }

            player.stamina.current -= playerAttackStamType.pre;

          }

        }
      }

      if (player.currentWeapon.type === "sword") {

        this.cellsUnderAttack.push(
          {
            number: {
              x: player.target.cell1.number.x,
              y: player.target.cell1.number.y,
            },
            count: 1,
            limit: 8,
          },
        )

        // TAGET CELL 1 IS FREE NO ITEM OR BOLT, MISS
        if (
          player.target.cell1.free === true &&
          player.target.cell1.occupant.type !== "item" &&
          player.target.cell1.occupant.type !== "rubble" &&
          boltTarget1 !== true
        ) {

          if (!player.popups.find(x => x.msg === "missedAttack2")) {
            player.popups.push(
              {
                state: false,
                count: 0,
                limit: 30,
                type: '',
                position: '',
                msg: 'missedAttack2',
                img: '',

              }
            )
          }

          player.stamina.current -= playerAttackStamType.pre;

        }

        // TARGET CELL 1 IS NOT FREE OR HAS BOLT OR ITEM, ATTACK
        if (
          player.target.cell1.free !== true ||
          player.target.cell1.occupant.type === "item" ||
          player.target.cell1.occupant.type === "rubble" ||
          boltTarget1 === true
        ) {
          this.meleeAttackParse(player,1)
        }

      }

      if (player.currentWeapon.name === "") {

        this.cellsUnderAttack.push(
          {
            number: {
              x: player.target.cell1.number.x,
              y: player.target.cell1.number.y,
            },
            count: 1,
            limit: 8,
          },
        )

        // TAGET CELL 1 IS FREE NO ITEM OR BOLT, MISS
        if (
          player.target.cell1.free === true &&
          player.target.cell1.occupant.type !== "item" &&
          player.target.cell1.occupant.type !== "rubble" &&
          boltTarget1 !== true
        ) {

          if (!player.popups.find(x => x.msg === "missedAttack2")) {
            player.popups.push(
              {
                state: false,
                count: 0,
                limit: 30,
                type: '',
                position: '',
                msg: 'missedAttack2',
                img: '',

              }
            )
          }

          player.stamina.current -= playerAttackStamType.pre;

        }

        // TARGET CELL 1 IS NOT FREE OR HAS BOLT OR ITEM, ATTACK
        if (
          player.target.cell1.free !== true ||
          player.target.cell1.occupant.type === "item" ||
          player.target.cell1.occupant.type === "rubble" ||
          boltTarget1 === true
        ) {
          this.meleeAttackParse(player,1)
        }

      }

      if (player.currentWeapon.type === "crossbow" || player.currentWeapon.type === "longbow") {

        // CROSSBOW BLUNT ATTACK
        if (player.bluntAttack === true) {

          // TARGET CELL 1 FREE NO ITEM OR BOLT
          if (
            player.target.cell1.free === true &&
            player.target.cell1.occupant.type !== "item" &&
            boltTarget1 !== true
          ) {

            if (!player.popups.find(x => x.msg === "missedAttack2")) {
              player.popups.push(
                {
                  state: false,
                  count: 0,
                  limit: 30,
                  type: '',
                  position: '',
                  msg: 'missedAttack2',
                  img: '',

                }
              )
            }

            player.stamina.current -= playerAttackStamType.pre;

          }

          // TARGET CELL 1 NOT FREE, OR ITEM OR BOLT
          if (player.target.cell1.free !== true || player.target.cell1.occupant.type === "item" || boltTarget1 === true) {
            this.meleeAttackParse(player,1)
          }

        }
      }

    }

    // ATTACK MY CELL BARRIER
    else {

      let targetCell = this.gridInfo.find(elem => elem.number.x === player.target.cell1.number.x && elem.number.y === player.target.cell1.number.y );
      let targetCell2 = this.gridInfo.find(elem => elem.number.x === player.target.cell2.number.x && elem.number.y === player.target.cell2.number.y );
      let myCell = this.gridInfo.find(elem => elem.number.x === player.currentPosition.cell.number.x && elem.number.y === player.currentPosition.cell.number.y );

      this.attackCellContents('melee',player,targetCell,targetCell2,myCell,undefined)

    }

    this.players[player.number-1] = player;

  }
  meleeAttackParse = (player,cellNo) => {
    // console.log('meleeAttackParse',player.target['cell'+cellNo].occupant.type,this.players[player.target['cell'+cellNo].occupant.player-1]);

    let attackerRef = player;
    let targetPlayerRef = undefined;
    let weapon = player.currentWeapon.type;

    // ATTACK STAM UNARMED CHECK & AND POPUPS SET
    let playerAttackStamType;
    if (player.currentWeapon.name !== "") {
      playerAttackStamType = this.staminaCostRef.attack[player.currentWeapon.type].normal;
    }

    if (player.bluntAttack === true && player.currentWeapon.name !== "") {
      playerAttackStamType = this.staminaCostRef.attack[player.currentWeapon.type].blunt;
    }
    if (player.currentWeapon.name === "") {
      playerAttackStamType = this.staminaCostRef.attack.unarmed.normal;
      if (player.bluntAttack === true) {
        playerAttackStamType = this.staminaCostRef.attack.unarmed.blunt;
      }
      weapon = 'unarmed';

      if (player.bluntAttack === true) {

        if (!player.popups.find(x=>x.msg === "attackingBlunt")) {
          player.popups.push(
            {
              state: false,
              count: 0,
              limit: (this.attackAnimRef.limit[weapon]-this.attackAnimRef.peak[weapon]),
              type: '',
              position: '',
              msg: 'attackingBlunt',
              img: '',

            }
          )
        }

      }
      else {

        if (!player.popups.find(x=>x.msg === "attackingUnarmed")) {
          player.popups.push(
            {
              state: false,
              count: 0,
              limit: (this.attackAnimRef.limit.unarmed-this.attackAnimRef.peak.unarmed),
              type: '',
              position: '',
              msg: 'attackingUnarmed',
              img: '',

            }
          )
        }

      }


    }
    else {

      if (player.bluntAttack === true) {

        if (!player.popups.find(x=>x.msg === "attackingBlunt")) {
          player.popups.push(
            {
              state: false,
              count: 0,
              limit: (this.attackAnimRef.limit[weapon]-this.attackAnimRef.peak[weapon]),
              type: '',
              position: '',
              msg: 'attackingBlunt',
              img: '',

            }
          )
        }

      }
      else {

        if (!player.popups.find(x=>x.msg === 'attacking')) {
          player.popups.push(
            {
              state: false,
              count: 0,
              limit: (this.attackAnimRef.limit[player.currentWeapon.type]-this.attackAnimRef.peak[player.currentWeapon.type]),
              type: '',
              position: '',
              msg: 'attacking',
              img: '',

            }
          )
        }

      }

    }


    //TARGET IS PROJECTILE!!
    if (this.isBoltInCell(player.target['cell'+cellNo].number) === true) {
      this.projectiles.find(x=> x.currentPosition.number.x === player.target['cell'+cellNo].number.x && x.currentPosition.number.y === player.target['cell'+cellNo].number.y).kill = true;

      if (!player.popups.find(x=>x.msg === "boltKilled")) {
        player.popups.push(
          {
            state: false,
            count: 0,
            limit: 30,
            type: '',
            position: '',
            msg: 'boltKilled',
            img: '',

          }
        )
      }
      if (this.rnJesus(0,player.crits.pushBack)) {
        this.pushBack(player,this.getOppositeDirection(player.direction));
      }
      console.log('bolt attacked and killed: v1');

    }



    // TARGET IS BARRIER/OBSTACLE/ITEM/RUBBLE
    if (
      player.target['cell'+cellNo].occupant.type === 'item' ||
      player.target['cell'+cellNo].occupant.type === 'obstacle' ||
      player.target['cell'+cellNo].occupant.type === 'barrier' ||
      player.target['cell'+cellNo].occupant.type === 'rubble'
    ) {

      let targetCell = this.gridInfo.find(elem => elem.number.x === player.target.cell1.number.x && elem.number.y === player.target.cell1.number.y );
      let targetCell2 = this.gridInfo.find(elem => elem.number.x === player.target.cell2.number.x && elem.number.y === player.target.cell2.number.y );
      let myCell = this.gridInfo.find(elem => elem.number.x === player.currentPosition.cell.number.x && elem.number.y === player.currentPosition.cell.number.y );

      this.attackCellContents('melee',player,targetCell,targetCell2,myCell,undefined);

    }


    // TARGET IS A PLAYER
    if (player.target['cell'+cellNo].occupant.type === 'player') {

      targetPlayerRef = this.players[player.target['cell'+cellNo].occupant.player-1];

      if (targetPlayerRef) {

        // IS TARGET DEFENDING?
        let targetDefending = false;
        let defendType = targetPlayerRef.currentWeapon.type;
        if (targetPlayerRef.currentWeapon.name === "") {
          defendType  = "unarmed";
        }
        let defendPeak = this.defendAnimRef.peak[defendType];
        if (targetPlayerRef.defending.count === defendPeak || targetPlayerRef.defendDecay.state === true) {
          targetDefending = true;
        }

        let advantage = this.checkCombatAdvantage(player,targetPlayerRef);

        // BACK ATTACK
        if (player.direction === targetPlayerRef.direction) {


          // TARGET DODGING BACK ATTACK
          if (targetPlayerRef.dodging.state === true) {

            console.log('player ',player.number,' just dodged player ',targetPlayerRef.number,' back attack');

            player.stamina.current -= playerAttackStamType.pre;
            targetPlayerRef.stamina.current += this.staminaCostRef.dodge.pre;

            if (!player.popups.find(x => x.msg === "missedAttack2")) {
              player.popups.push(
                {
                  state: false,
                  count: 0,
                  limit: 30,
                  type: '',
                  position: '',
                  msg: 'missedAttack2',
                  img: '',

                }
              )
            }

            if (player.bluntAttack === true) {
              player.bluntAttack = false;
            }

          }


          //TARGET NOT DODGING. VULNERABLE TO BACK ATTACK
          else {

            if (player.bluntAttack === true) {

              this.setDeflection(targetPlayerRef,'bluntAttacked',false);

            }

            else {

              this.handleMeleeDamage(player,targetPlayerRef);

            }

          }

        }

        // SIDE ATTACK
        if (
          targetPlayerRef.direction !== player.direction &&
          targetPlayerRef.direction !== this.getOppositeDirection(player.direction)
        ) {

          // TARGET PLAYER IS DODGING
          if (targetPlayerRef.dodging.state === true) {

            console.log('player ',player.number,' just dodged player ',targetPlayerRef.number,' side attack');

            player.stamina.current -= playerAttackStamType.pre;
            targetPlayerRef.stamina.current += this.staminaCostRef.dodge.pre;

            if (!player.popups.find(x => x.msg === "missedAttack2")) {
              player.popups.push(
                {
                  state: false,
                  count: 0,
                  limit: 30,
                  type: '',
                  position: '',
                  msg: 'missedAttack2',
                  img: '',

                }
              )
            }

            if (player.bluntAttack === true) {
              player.bluntAttack = false;
            }

          }


          // TARGET PLAYER DEFENDING
          if (targetDefending === true) {

            // BLUNT ATTACK IS MADE FOR BREAKING DEFENSE
            if (player.bluntAttack === true) {

              this.setDeflection(targetPlayerRef,'bluntAttacked',false);

            }

            // ATTACKER NON-BLUNT ATTACK
            else {

              // DEFENDER ADVANTAGE
              if (advantage === 2 || advantage === 0) {

                // PEAK DEFEND/PARRY
                if (targetPlayerRef.defendPeak === true) {

                  this.setDeflection(player,'defended',true);

                  targetPlayerRef.stamina.current += this.staminaCostRef.defend.peak;
                  targetPlayerRef.success.defendSuccess = {
                    state: true,
                    count: 1,
                    limit: targetPlayerRef.success.defendSuccess.limit
                  };
                  targetPlayerRef.statusDisplay = {
                    state: true,
                    status: 'Parry!',
                    count: 1,
                    limit: targetPlayerRef.statusDisplay.limit,
                  };
                  if (!targetPlayerRef.popups.find(x=>x.msg === "attackParried")) {
                    targetPlayerRef.popups.push(
                      {
                        state: false,
                        count: 0,
                        limit: 30,
                        type: '',
                        position: '',
                        msg: 'attackParried',
                        img: '',

                      }
                    )
                  }

                }

                // OFF PEAK DEFEND. DEFENSE NOT GUARANTEED
                // if (targetPlayerRef.defendDecay.state === true && targetPlayerRef.defendPeak !== true) {
                if (targetPlayerRef.defendPeak !== true) {


                  // DEFEND SUCCESS
                  if (this.rnJesus(1,targetPlayerRef.crits.guardBreak) === 1) {

                    this.setDeflection(player,'defended',false);
                    targetPlayerRef.success.defendSuccess = {
                      state: true,
                      count: 1,
                      limit: targetPlayerRef.success.defendSuccess.limit
                    };
                    targetPlayerRef.statusDisplay = {
                      state: true,
                      status: 'Defend',
                      count: 1,
                      limit: targetPlayerRef.statusDisplay.limit,
                    }
                    if (!targetPlayerRef.popups.find(x=>x.msg === "defendSuccess")) {
                      targetPlayerRef.popups.push(
                        {
                          state: false,
                          count: 0,
                          limit: 25,
                          type: '',
                          position: '',
                          msg: 'defendSuccess',
                          img: '',

                        }
                      )
                    }

                  }

                  // DEFEND FAILURE
                  else {

                    this.setDeflection(targetPlayerRef,'attacked',false);
                    this.handleMeleeDamage(player,targetPlayerRef);

                  }

                }

              }

              // ATTACKER/PLAYER ADVANTAGE
              else if (advantage === 1) {

                this.handleMeleeDamage(player,targetPlayerRef);
                this.setDeflection(targetPlayerRef,'attacked',false);
                player.success.attackSuccess = {
                  state: true,
                  count: 1,
                  limit: player.success.attackSuccess.limit
                }

              }

            }

          }

          // TARGET PLAYER NOT DODGING OR DEFENDING
          else {

            // PLAYER BLUNT ATK SUCCESS, TARGET DEFLECTED
            if (player.bluntAttack === true) {

              player.bluntAttack = false;
              this.setDeflection(targetPlayerRef,'bluntAttacked',false);
              player.success.attackSuccess = {
                state: true,
                count: 1,
                limit: player.success.attackSuccess.limit
              }

            }

            // PLAYER ATK SUCCESS, TARGET DEFLECTED + DAMAGE
            else {
              this.handleMeleeDamage(player,targetPlayerRef);
              this.setDeflection(targetPlayerRef,'attacked',false);
              player.success.attackSuccess = {
                state: true,
                count: 1,
                limit: player.success.attackSuccess.limit
              }

            }

          }


        }


        // TARGET & PLAYER ARE FACE TO FACE
        if (player.direction === this.getOppositeDirection(targetPlayerRef.direction)) {


          // TARGET DODGING
          if (targetPlayerRef.dodging.state === true) {

            console.log('player ',player.number,' just dodged player ',targetPlayerRef.number,' back attack');


            player.stamina.current -= playerAttackStamType.pre;
            targetPlayerRef.stamina.current += this.staminaCostRef.dodge.pre;

            if (!player.popups.find(x => x.msg === "missedAttack2")) {
              player.popups.push(
                {
                  state: false,
                  count: 0,
                  limit: 30,
                  type: '',
                  position: '',
                  msg: 'missedAttack2',
                  img: '',

                }
              )
            }

            if (player.bluntAttack === true) {
              player.bluntAttack = false;
            }

          }


          // TARGET ALSO ATTACKING
          if (targetPlayerRef.attackPeak === true) {

            // EVENLY MATCHED. CLASHING
            if (advantage === 0) {


              player.clashing.state = true;
              targetPlayerRef.clashing.state = true;

              // PUSHBACK ATTACKER/PLAYER
              if (this.rnJesus(0,2) === 0) {

                this.pushBack(player,this.getOppositeDirection(player.direction));

              }
              // PUSHBACK DEFENDER/TARGET
              if (this.rnJesus(0,2) === 1) {

                this.pushBack(targetPlayerRef,this.getOppositeDirection(targetPlayerRef.direction));

              }
              // PUSHBACK BOTH PLAYERS
              if (this.rnJesus(0,2) === 2) {

                this.pushBack(player,this.getOppositeDirection(player.direction));
                this.pushBack(targetPlayerRef,this.getOppositeDirection(targetPlayerRef.direction));

              }

            }

            // PLAYER ADVANTAGE
            if (advantage === 1) {

              this.handleMeleeDamage(player,targetPlayerRef);
              this.setDeflection(targetPlayerRef,'attacked',false);
              player.success.attackSuccess = {
                state: true,
                count: 1,
                limit: player.success.attackSuccess.limit
              }

            }

            // TARGET ADVANTAGE
            if (advantage === 2) {

              this.handleMeleeDamage(targetPlayerRef,player);
              this.setDeflection(player,'attacked',false);
              targetPlayerRef.success.attackSuccess = {
                state: true,
                count: 1,
                limit: targetPlayerRef.success.attackSuccess.limit
              }

            }

          }

          // TARGET DEFENDING
          if (targetDefending === true) {

            // BLUNT ATTACK IS MADE FOR BREAKING DEFENSE
            if (player.bluntAttack === true) {

              this.setDeflection(targetPlayerRef,'attacked',false);
              player.success.attackSuccess = {
                state: true,
                count: 1,
                limit: player.success.attackSuccess.limit
              }

            }

            // ATTACKER NON-BLUNT ATTACK
            else {

              // TARGET ADVANTAGE/ EVENLY MATCHED
              if (advantage === 0 || advantage === 2) {
                console.log('evenly matched. peak',targetPlayerRef.defendPeak,'defending',targetPlayerRef.defending,'decay',targetPlayerRef.defendDecay);

                // PEAK DEFEND
                if (targetPlayerRef.defendPeak === true) {
                  console.log('yyy');

                  this.setDeflection(player,'parried',true);

                  targetPlayerRef.stamina.current += this.staminaCostRef.defend.peak;
                  targetPlayerRef.success.defendSuccess = {
                    state: true,
                    count: 1,
                    limit: targetPlayerRef.success.defendSuccess.limit
                  };
                  targetPlayerRef.statusDisplay = {
                    state: true,
                    status: 'Parry!',
                    count: 1,
                    limit: targetPlayerRef.statusDisplay.limit,
                  };
                  if (!targetPlayerRef.popups.find(x=>x.msg === "attackParried")) {
                    targetPlayerRef.popups.push(
                      {
                        state: false,
                        count: 0,
                        limit: 30,
                        type: '',
                        position: '',
                        msg: 'attackParried',
                        img: '',

                      }
                    )
                  }


                }

                // OFF PEAK DEFEND
                if (targetPlayerRef.defendPeak !== true) {
                // if (targetPlayerRef.defendDecay.state === true && targetPlayerRef.defendPeak !== true) {

                  // PUSHBACK AND/OR DEFLECT ATTACKER/PLAYER?
                  if (this.rnJesus(1,player.crits.pushBack) === 1) {
                    this.setDeflection(player,'defended',true);
                  }
                  // JUST DEFLECT
                  else {
                    this.setDeflection(player,'defended',false);
                  }


                  targetPlayerRef.success.defendSuccess = {
                      state: true,
                      count: 1,
                      limit: targetPlayerRef.success.defendSuccess.limit
                    };
                  targetPlayerRef.statusDisplay = {
                    state: true,
                    status: 'Defend',
                    count: 1,
                    limit: targetPlayerRef.statusDisplay.limit,
                  }
                  if (!targetPlayerRef.popups.find(x=>x.msg === "defendSuccess")) {
                      targetPlayerRef.popups.push(
                        {
                          state: false,
                          count: 0,
                          limit: 25,
                          type: '',
                          position: '',
                          msg: 'defendSuccess',
                          img: '',

                        }
                      )
                    }

                }

              }

              // PLAYER/ATTACKER ADVANTAGE
              if (advantage === 1) {
                console.log('aaa');
                this.handleMeleeDamage(player,targetPlayerRef);
                this.setDeflection(targetPlayerRef,'attacked',false);
                player.success.attackSuccess = {
                  state: true,
                  count: 1,
                  limit: player.success.attackSuccess.limit
                }

              }

            }

          }

          // TARGET NOT DEFENDING, DODGING OR ATTACKING, DAMAGE
          if (
            targetPlayerRef.dodging.state !== true &&
            targetPlayerRef.attackPeak !== true &&
            targetDefending !== true
          ) {

            this.handleMeleeDamage(player,targetPlayerRef);
            this.setDeflection(targetPlayerRef,'attacked',false);
            player.success.attackSuccess = {
              state: true,
              count: 1,
              limit: player.success.attackSuccess.limit
            }

          }

        }


        this.players[targetPlayerRef.number-1] = targetPlayerRef;

      }

    }

    this.players[player.number-1] = player;
    // this.players[targetPlayerRef.number-1] = targetPlayerRef;


  }
  projectileAttackParse = (bolt,player) => {
    // console.log('projectileAttackParse');

    let weapon = player.currentWeapon.type;

    // ATTACK STAM UNARMED CHECK & AND POPUPS SET
    let playerAttackStamType;


    if (player.currentWeapon.name !== "") {
      playerAttackStamType = this.staminaCostRef.attack[player.currentWeapon.type].normal;
    }

    if (player.bluntAttack === true && player.currentWeapon.name !== "") {
      playerAttackStamType = this.staminaCostRef.attack[player.currentWeapon.type].blunt;
    }
    if (player.currentWeapon.name === "") {
      playerAttackStamType = this.staminaCostRef.attack.unarmed.normal;
      if (player.bluntAttack === true) {
        playerAttackStamType = this.staminaCostRef.attack.unarmed.blunt;
      }
      weapon = 'unarmed';

    }


    // IS TARGET DEFENDING?
    let playerDefending = false;
    let defendType = player.currentWeapon.type;
    if (player.currentWeapon.name === "") {
      defendType  = "unarmed";
    }
    let defendPeak = this.defendAnimRef.peak[defendType];
    if (player.defending.count === defendPeak || player.defendDecay.state === true) {
      playerDefending = true;
    }

    this.cellsUnderAttack.push(
      {
        number: {
          x: player.currentPosition.cell.number.x,
          y: player.currentPosition.cell.number.y,
        },
        count: 1,
        limit: 8,
      },
    )


    //BOLT TARGET DODGING
    if (player.dodging.state === true) {

      console.log('player ',player.number,' just dodged a bolt from ',bolt.owner);
      player.stamina.current += this.staminaCostRef.dodge.pre;

    }
    else {

      // BOLT NOT DODGED MUST HIT PLAYER
      bolt.kill = true;
      // BOLT TARGET NOT DODGING
      // BACK ATTACK
      if (player.direction === bolt.direction) {

        this.handleProjectileDamage(bolt,player);
        this.setDeflection(player,'attacked',false);

      }

      // SIDE ATTACK
      if (
        player.direction !== bolt.direction &&
        player.direction !== this.getOppositeDirection(bolt.direction)
      ) {

        // PLAYER IS ATTACKING ARMED
        if (player.attackPeak === true && weapon !== 'unarmed') {

          // CHANCE TO KILL BOLT & PUSHBACK
          if (this.rnJesus(1,player.crits.pushBack) === 1) {

            if (!player.popups.find(x=>x.msg === "boltKilled")) {
              player.popups.push(
                {
                  state: false,
                  count: 0,
                  limit: 30,
                  type: '',
                  position: '',
                  msg: 'boltKilled',
                  img: '',

                }
              )
            }
            this.pushBack(player,this.getOppositeDirection(player.direction));
            player.success.attackSuccess = {
              state: true,
              count: 1,
              limit: player.success.attackSuccess.limit
            };
            console.log('bolt attacked and killed: v2');

          }

          // OR BE INJURED
          else {

            this.handleProjectileDamage(bolt,player);
            this.setDeflection(player,'attacked',false);

          }

        }

        // UNARMED DEFENSE = DAMAGE. OFF-PEAK HAS CHANCE TO PUSHBACK OR DAMAGE + PB
        if (playerDefending === true) {

          if (weapon === 'unarmed') {

            this.handleProjectileDamage(bolt,player);
            this.setDeflection(player,'attacked',false);

          }

          else {


            if (player.defendPeak === true) {

              player.stamina.current += this.staminaCostRef.defend.peak;
              player.success.defendSuccess = {
                state: true,
                count: 1,
                limit: player.success.defendSuccess.limit
              };
              player.statusDisplay = {
                state: true,
                status: 'Parry!',
                count: 1,
                limit: player.statusDisplay.limit,
              };
              if (!player.popups.find(x=>x.msg === "attackParried")) {
                player.popups.push(
                  {
                    state: false,
                    count: 0,
                    limit: 30,
                    type: '',
                    position: '',
                    msg: 'attackParried',
                    img: '',

                  }
                )
              }

            }

            // if (player.defendDecay.state === true && player.defendPeak !== true) {
            if (player.defendPeak !== true) {

              // CHANCE FOR DEFEND SUCCESS
              if (this.rnJesus(0,player.crits.guardBreak) === 0) {

                player.success.defendSuccess = {
                  state: true,
                  count: 1,
                  limit: player.success.defendSuccess.limit
                };
                player.statusDisplay = {
                  state: true,
                  status: 'Defend',
                  count: 1,
                  limit: player.statusDisplay.limit,
                }
                if (!player.popups.find(x=>x.msg === "defendSuccess")) {
                  player.popups.push(
                    {
                      state: false,
                      count: 0,
                      limit: 25,
                      type: '',
                      position: '',
                      msg: 'defendSuccess',
                      img: '',

                    }
                  )
                }
                if (this.rnJesus(1,player.crits.pushBack) === 1) {
                  this.pushBack(player,this.getOppositeDirection(player.direction))
                }

              }

              // CHANCE TO BE DAMAGED, DEFLECT || DEFLECT + PUSHBACK
              if (this.rnJesus(0,player.crits.guardBreak) === 1) {

                this.handleProjectileDamage(bolt,player);

                if (this.rnJesus(1,player.crits.pushBack) === 1) {
                  this.setDeflection(player,'attacked',true);
                }
                else {
                  this.setDeflection(player,'attacked',false);
                }

              }

            }

          }
        }

        //PLAYER NOT DEFENDING OR ATTACKING, TAKE DAMAGE
        if (playerDefending !== true && player.attackPeak !== true) {

          this.handleProjectileDamage(bolt,player);
          this.setDeflection(player,'attacked',false);

        }

        // PLAYER IS ATTACKING BUT UNARMED, TAKE DAMAGE
        if (player.attackPeak === true && weapon === 'unarmed') {

          this.handleProjectileDamage(bolt,player);
          this.setDeflection(player,'attacked',false);

        }

      }

      // FRONTAL ATTACK
      if (bolt.direction === this.getOppositeDirection(player.direction)) {

        // PLAYER ARMED AND ATTACKING
        if (player.attackPeak === true && weapon !== 'unarmed') {

          if (!player.popups.find(x=>x.msg === "boltKilled")) {
            player.popups.push(
              {
                state: false,
                count: 0,
                limit: 30,
                type: '',
                position: '',
                msg: 'boltKilled',
                img: '',

              }
            )
          }
          if (this.rnJesus(1,player.crits.pushBack) === 1) {
            this.pushBack(player,this.getOppositeDirection(player.direction))
          }
          player.success.attackSuccess = {
            state: true,
            count: 1,
            limit: player.success.attackSuccess.limit
          }
          console.log('bolt attacked and killed: v3');

        }

        // PLAYER DEFENDING
        if (playerDefending === true) {

          if (weapon === 'unarmed') {

            // UNARMED PEAK DEFEND, SUCCESS
            if (player.defendPeak === true) {

              // player.stamina.current += this.staminaCostRef.defend.peak;
              player.success.defendSuccess = {
                state: true,
                count: 1,
                limit: player.success.defendSuccess.limit
              };
              player.statusDisplay = {
                state: true,
                status: 'Parry!',
                count: 1,
                limit: player.statusDisplay.limit,
              };
              if (!player.popups.find(x=>x.msg === "attackParried")) {
                player.popups.push(
                  {
                    state: false,
                    count: 0,
                    limit: 30,
                    type: '',
                    position: '',
                    msg: 'attackParried',
                    img: '',

                  }
                )
              }

            }

            // UNARMED OFF PEAK DEFEND, CHANCE TO DEFEND OR DAMAGE/DEFLECTED
            // if (player.defendDecay.state === true && player.defendPeak !== true) {
            if (player.defendPeak !== true) {

              if (this.rnJesus(0,1) === 0) {

                player.success.defendSuccess = {
                  state: true,
                  count: 1,
                  limit: player.success.defendSuccess.limit
                };
                player.statusDisplay = {
                  state: true,
                  status: 'Defend',
                  count: 1,
                  limit: player.statusDisplay.limit,
                }
                if (!player.popups.find(x=>x.msg === "defendSuccess")) {
                  player.popups.push(
                    {
                      state: false,
                      count: 0,
                      limit: 25,
                      type: '',
                      position: '',
                      msg: 'defendSuccess',
                      img: '',

                    }
                  )
                }

              }

              else {

                this.handleProjectileDamage(bolt,player);
                this.setDeflection(player,'attacked',false);

              }

            }

          }

          // PLAYER DEFENDING AND ARMED, GUARANTEED DEFEND W/ CHANCE TO PUSH BACK
          else {

            if (player.defendPeak === true) {

              player.stamina.current += this.staminaCostRef.defend.peak;
              player.success.defendSuccess = {
                state: true,
                count: 1,
                limit: player.success.defendSuccess.limit
              };
              player.statusDisplay = {
                state: true,
                status: 'Parry!',
                count: 1,
                limit: player.statusDisplay.limit,
              };
              if (!player.popups.find(x=>x.msg === "attackParried")) {
                player.popups.push(
                  {
                    state: false,
                    count: 0,
                    limit: 30,
                    type: '',
                    position: '',
                    msg: 'attackParried',
                    img: '',

                  }
                )
              }

            }

            // if (player.defendDecay.state === true && player.defendPeak !== true) {
            if (player.defendPeak !== true) {

              player.success.defendSuccess = {
                state: true,
                count: 1,
                limit: player.success.defendSuccess.limit
              };
              player.statusDisplay = {
                state: true,
                status: 'Defend',
                count: 1,
                limit: player.statusDisplay.limit,
              }
              if (!player.popups.find(x=>x.msg === "defendSuccess")) {
                player.popups.push(
                  {
                    state: false,
                    count: 0,
                    limit: 25,
                    type: '',
                    position: '',
                    msg: 'defendSuccess',
                    img: '',

                  }
                )
              }
              if (this.rnJesus(1,player.crits.pushBack) === 1) {
                this.pushBack(player,this.getOppositeDirection(player.direction))
              }

            }

          }

        }

        //PLAYER NOT DEFENDING OR ATTACKING, TAKE DAMAGE
        if (playerDefending !== true && player.attackPeak !== true) {

          this.handleProjectileDamage(bolt,player);
          this.setDeflection(player,'attacked',false);

        }

        // PLAYER IS ATTACKING BUT UNARMED, TAKE DAMAGE
        if (player.attackPeak === true && weapon === 'unarmed') {

          this.handleProjectileDamage(bolt,player);
          this.setDeflection(player,'attacked',false);

        }

      }

    }


    this.players[player.number-1] = player;
    let x = this.projectiles.find(x => x.id === bolt.id);
    x = bolt;

  }
  setDeflection = (player,type,pushBack) => {


    // this.deflectedLengthRef = {
    //   outOfStamina: 50,
    //   attacked: 20,
    //   bluntAttacked: 25,
    //   defended: 10,
      // parried: 25
      // knockedOut: 65,
    // };
    this.attackedCancel(player)

    player.action = 'deflected';
    player.success.deflected = {
      state: true,
      count: 0,
      limit: this.deflectedLengthRef[type],
      predeflect: player.success.deflected.predeflect,
      type: type
    }
    player.stamina.current -= this.staminaCostRef.deflected[type];




    if (pushBack === true) {

      player.success.deflected.state = false;
      player.success.deflected.predeflect = true;


      this.pushBack(player,this.getOppositeDirection(player.direction));

    }
    else {

      player.success.deflected.predeflect = false;
      if (this.aiDeflectedCheck.includes(player.number) !== true) {
        this.aiDeflectedCheck.push(player.number)
      }

    }


    this.players[player.number-1] = player;

    if (pushBack !== true) {
      this.setElasticCounter('deflected',"",true,player)
    }


  }
  unsetDeflection = (player) => {

    this.players[player.number-1].success.deflected = {
      state: false,
      count: 0,
      limit: player.success.deflected.limit,
      predeflect: false,
      type: '',
    }

    if (player.ai.state === true) {
      let indx = this.aiDeflectedCheck.indexOf(player.number)
      // this.aiDeflectedCheck.splice(indx,1)
      let newArr = this.aiDeflectedCheck.filter(x=>x !== player.number)
      this.aiDeflectedCheck = newArr;
      console.log('this.aiDeflectedCheck',this.aiDeflectedCheck);
    }

  }
  handleMeleeDamage = (player,targetPlayer) => {
    // console.log('handleMeleeDamage');
    // DAMAGE THE TARGET!!!

    let damage = 0;
    let doubleHitChance = player.crits.doubleHit;
    let singleHitChance = player.crits.singleHit;


    if (targetPlayer.currentArmor.name !== '') {
      // console.log('opponent armour found');
      switch(targetPlayer.currentArmor.effect) {
        case 'dblhit-5' :
          doubleHitChance = player.crits.doubleHit+5;
        break;
        case 'dblhit-10' :
          doubleHitChance = player.crits.doubleHit+10;
        break;
        case 'dblhit-15' :
          doubleHitChance = player.crits.doubleHit+15;
        break;
        // case 'dblhit-30' :
        //   doubleHitChance = player.crits.doubleHit+30;
        // break;
        case 'snghit-5' :
          singleHitChance = player.crits.singleHit+5;
        break;
        case 'snghit-10' :
          singleHitChance = player.crits.singleHit+10;
        break;
      }
    }

    let doubleHit = this.rnJesus(1,doubleHitChance);
    let singleHit = this.rnJesus(1,singleHitChance);


    // BACK ATTACK
    if (player.direction === targetPlayer.direction) {
      damage = 2;
    }
    if (player.currentWeapon.name === "") {
      singleHit = 1;
      doubleHit = 0;
    }

    if (singleHit === 1) {
      damage = 1;
    }
    if (doubleHit === 1) {
      damage = 2;
    }
    if (player.bluntAttack === true) {
      damage = 0;
    }


    player.success.attackSuccess = {
      state: true,
      count: 1,
      limit: player.success.attackSuccess.limit
    }


    if (!targetPlayer.popups.find(x=>x.msg.split("_")[0] === "hpDown")) {
      targetPlayer.popups.push(
        {
          state: false,
          count: 0,
          limit: 30,
          type: '',
          position: '',
          msg: 'hpDown_'+'-'+damage+'',
          img: '',

        }
      )
    }

    targetPlayer.hp -= damage;
    if (targetPlayer.hp === 1) {

      targetPlayer.attackStrength = 1;

      // ADJUST TARGET MOVE SPEED
      let currentMoveSpeedIndx = targetPlayer.speed.range.indexOf(targetPlayer.speed.move)
      if (currentMoveSpeedIndx > 0) {
        targetPlayer.speed.move = targetPlayer.speed.range[currentMoveSpeedIndx-1]
      }
      // player.speed.move = .05;

    }

    if (targetPlayer.hp > 0) {
      this.attackedCancel(targetPlayer)
    }


    // KILL OPPONENT!
    else {

      this.killPlayer(targetPlayer);
      this.placeItems({init: false, item: this.itemList[this.rnJesus(0,this.itemList.length-1)].name})
      player.points++
      this.pointChecker(player)

      if (player.ai.state === true && player.ai.mode === 'aggressive') {
        console.log('check for evidence of retrieval here and resume retrieve if so',player.ai.retrieving,player.ai.mission);

        if (player.ai.retrieving.checkin) {

          player.ai.mission = 'retrieve';

          if (!player.popups.find(x=>x.msg === 'missionRetrieve')) {
            player.popups.push(
              {
                state: false,
                count: 0,
                limit: 30,
                type: '',
                position: '',
                msg: 'missionRetrieve',
                img: '',

              }
            )
          }

          let targetSafeData = this.scanTargetAreaThreat({
            player: player.number,
            point: {
              x: player.ai.retrieving.point.x,
              y: player.ai.retrieving.point.y,
            },
            range: 3,
          })

          player.ai.retrieving.safe = targetSafeData.isSafe;

        }

      }

    }

    this.players[player.number-1] = player;
    this.players[targetPlayer.number-1] = targetPlayer;

  }
  handleProjectileDamage = (bolt,player) => {

    let boltOwner = this.players[bolt.owner-1];
    let damage = 0;
    let doubleHitChance = boltOwner.crits.doubleHit;
    let singleHitChance = boltOwner.crits.singleHit;

    if (player.currentArmor.name !== '') {
      // console.log('opponent armour found');
      switch(player.currentArmor.effect) {
        case 'dblhit-5' :
          doubleHitChance = boltOwner.crits.doubleHit+5;
        break;
        case 'dblhit-10' :
          doubleHitChance = boltOwner.crits.doubleHit+10;
        break;
        case 'dblhit-15' :
          doubleHitChance = boltOwner.crits.doubleHit+15;
        break;
        // case 'dblhit-30' :
        //   doubleHitChance = player.crits.doubleHit+30;
        // break;
        case 'snghit-5' :
          singleHitChance = boltOwner.crits.singleHit+5;
        break;
        case 'snghit-10' :
          singleHitChance = boltOwner.crits.singleHit+10;
        break;
      }
    }

    let doubleHit = this.rnJesus(1,doubleHitChance);
    let singleHit = this.rnJesus(1,singleHitChance);

    // BACK ATTACK
    if (player.direction === bolt.direction) {
      damage = 2;
    }


    if (singleHit === 1) {
      damage = 1;
    }
    if (doubleHit === 1) {
      damage = 2;
    }
    boltOwner.success.attackSuccess = {
      state: true,
      count: 1,
      limit: boltOwner.success.attackSuccess.limit
    }
    if (!player.popups.find(x=>x.msg.split("_")[0] === "hpDown")) {
      player.popups.push(
        {
          state: false,
          count: 0,
          limit: 30,
          type: '',
          position: '',
          msg: 'hpDown_'+'-'+damage+'',
          img: '',

        }
      )
    }
    player.hp -= damage;
    if (player.hp === 1) {

      player.attackStrength = 1;

      // ADJUST TARGET MOVE SPEED
      let currentMoveSpeedIndx = player.speed.range.indexOf(player.speed.move)
      if (currentMoveSpeedIndx > 0) {
        player.speed.move = player.speed.range[currentMoveSpeedIndx-1]
      }
      // player.speed.move = .05;

    }

    if (player.hp > 0) {
      this.attackedCancel(player)
    }


    // KILL OPPONENT!
    else {

      this.killPlayer(player);
      this.placeItems({init: false, item: this.itemList[this.rnJesus(0,this.itemList.length-1)].name})
      boltOwner.points++
      this.pointChecker(boltOwner)

      if (boltOwner.ai.state === true && boltOwner.ai.mode === 'aggressive') {
        console.log('check for evidence of retrieval here and resume retrieve if so',boltOwner.ai.retrieving,boltOwner.ai.mission);

        if (boltOwner.ai.retrieving.checkin) {

          boltOwner.ai.mission = 'retrieve';

          if (!boltOwner.popups.find(x=>x.msg === 'missionRetrieve')) {
            boltOwner.popups.push(
              {
                state: false,
                count: 0,
                limit: 30,
                type: '',
                position: '',
                msg: 'missionRetrieve',
                img: '',

              }
            )
          }

          let targetSafeData = this.scanTargetAreaThreat({
            player: boltOwner.number,
            point: {
              x: boltOwner.ai.retrieving.point.x,
              y: boltOwner.ai.retrieving.point.y,
            },
            range: 3,
          })

          boltOwner.ai.retrieving.safe = targetSafeData.isSafe;

        }

      }

    }


    if (bolt.kill !== true) {
        bolt.kill = true;
    }

    this.players[player.number-1] = player;
    this.players[boltOwner.number-1] = boltOwner;
    // this.projectiles.find(x => x.id === bolt.id) = bolt;
    let x = this.projectiles.find(x => x.id === bolt.id);
    x = bolt;

  }
  handleMiscPlayerDamage = (player,type) => {

    this.attackedCancel(this.players[player.number-1])
    if (type === "obstacleBarrierInvulnurable") {

      if (player.hp - 1 <= 0) {
        this.killPlayer(this.players[player.number-1]);

        let randomItemIndex = this.rnJesus(0,this.itemList.length-1)
        this.placeItems({init: false, item: this.itemList[randomItemIndex].name})

        this.players[player.number-1].points--;

        this.pointChecker(player)
      } else {
        this.players[player.number-1].hp -= 1;

        if (player.hp > 0) {
          this.attackedCancel(player)
        }

        if (!this.players[player.number-1].popups.find(x=>x.msg.split("_")[0] === "hpDown")) {
          this.players[player.number-1].popups.push(
            {
              state: false,
              count: 0,
              limit: 30,
              type: '',
              position: '',
              msg: 'hpDown_'+'-'+1+'',
              img: '',

            }
          )
        }

        if (this.players[player.number-1].hp === 1) {

          // ADJUST TARGET MOVE SPEED
          let currentMoveSpeedIndx = this.players[player.number-1].speed.range.indexOf(this.players[player.number-1].speed.move)
          if (currentMoveSpeedIndx > 0) {
            this.players[player.number-1].speed.move = this.players[player.number-1].speed.range[currentMoveSpeedIndx-1]
          }

        }

      }

    }

    if (type === "applyHazard") {

      if (player.hp - 1 <= 0) {
        this.killPlayer(this.players[player.number-1]);

        let randomItemIndex = this.rnJesus(0,this.itemList.length-1)
        this.placeItems({init: false, item: this.itemList[randomItemIndex].name})

        this.players[player.number-1].points--;

        this.pointChecker(player)
      } else {

        this.players[player.number-1].hp -= 1;

        this.setDeflection(player,'attacked',false);

        if (!this.players[player.number-1].popups.find(x=>x.msg.split("_")[0] === "hpDown")) {
          this.players[player.number-1].popups.push(
            {
              state: false,
              count: 0,
              limit: 30,
              type: '',
              position: '',
              msg: 'hpDown_'+'-'+1+'',
              img: '',

            }
          )
        }
        if (!this.players[player.number-1].popups.find(x=>x.msg === 'terrainInjured')) {
          this.players[player.number-1].popups.push(
            {
              state: false,
              count: 0,
              limit: 25,
              type: '',
              position: '',
              msg: 'terrainInjured',
              img: '',

            }
          )
        }

        if (this.players[player.number-1].hp === 1) {

          // ADJUST TARGET MOVE SPEED
          let currentMoveSpeedIndx = this.players[player.number-1].speed.range.indexOf(this.players[player.number-1].speed.move)
          if (currentMoveSpeedIndx > 0) {
            this.players[player.number-1].speed.move = this.players[player.number-1].speed.range[currentMoveSpeedIndx-1]
          }

        }

      }


    }

    if (type.split("_")[1]) {
      let damage = 1;

      if (type.split("_")[0] === "halfPushBackImpactee") {

        switch (type.split("_")[1]) {
          case "obstacle":

            break;
          case "player":

            break;
          case "barrier":

            break;
          case "higherElevation":

            break;
          default:

        }
      }

      if (type.split("_")[0] === "halfPushBackImpactor") {

        switch (type.split("_")[1]) {
          case "obstacle":

            break;
          case "player":

            break;
          case "barrier":

            break;
          case "higherElevation":

            break;
          default:

        }
      }


      if (player.hp - damage <= 0) {
        this.killPlayer(this.players[player.number-1]);

        let randomItemIndex = this.rnJesus(0,this.itemList.length-1)
        this.placeItems({init: false, item: this.itemList[randomItemIndex].name})

        this.players[player.number-1].points--;

        this.pointChecker(player)
      }
      else {

        this.players[player.number-1].hp -= damage;

        if (player.hp > 0) {
          this.attackedCancel(player)
        }

        if (!this.players[player.number-1].popups.find(x=>x.msg.split("_")[0] === "hpDown")) {
          this.players[player.number-1].popups.push(
            {
              state: false,
              count: 0,
              limit: 30,
              type: '',
              position: '',
              msg: 'hpDown_'+'-'+damage+'',
              img: '',

            }
          )
        }


        if (this.players[player.number-1].hp === 1) {

          // ADJUST TARGET MOVE SPEED
          let currentMoveSpeedIndx = this.players[player.number-1].speed.range.indexOf(this.players[player.number-1].speed.move)
          if (currentMoveSpeedIndx > 0) {
            this.players[player.number-1].speed.move = this.players[player.number-1].speed.range[currentMoveSpeedIndx-1]
          }

        }

      }


    }


  }
  checkCombatAdvantage = (player1,player2) => {

    let advantage = 0;
    let players = [0,0];
    for (const plyr of players) {
      let indx = players.indexOf(plyr);
      if (this.players[indx].currentWeapon !== "") {
        players[indx]+=1;
      }
    }
    if (players[0] === players[1]) {
      advantage = 0;
    }
    else {
      let max = Math.Max(players[0],players[1]);
      advantage = players.indexOf(max)+1;
    }

    return advantage;

  }
  attackedCancel = (player) => {
    // console.log('player', player.number,' attacked. Cancel action!',player.action);

    if (player.elasticCounter.state === true && player.elasticCounter.type === player.action) {

      player.elasticCounter.state = false;
    }

    switch(player.action) {
      case 'attacking':
        if (player.success.deflected.state !== true) {
          player.action = 'idle';
        }

        player.attacking = {
          state: false,
          count: 0,
          limit: 15,
        };
        player.idleAnim = {
          state: false,
          count: 0,
          limit: 4,
        };
        this.players[player.number-1].statusDisplay = {
          state: true,
          status: 'attack break!',
          count: 1,
          limit: this.players[player.number-1].statusDisplay.limit,
        }

        if (!player.popups.find(x=>x.msg === 'attackCancelled')) {
          player.popups.push(
            {
              state: false,
              count: 0,
              limit: 30,
              type: '',
              position: '',
              msg: 'attackCancelled',
              img: '',

            }
          )
        }

        break;
      case 'defending':
        if (player.success.deflected.state !== true) {
          player.action = 'idle';
        }
        player.defending = {
          state: false,
          count: 0,
          limit: 5,
        };
        player.idleAnim = {
          state: false,
          count: 0,
          limit: 4,
        };
        this.players[player.number-1].statusDisplay = {
          state: true,
          status: 'guard break!',
          count: 1,
          limit: this.players[player.number-1].statusDisplay.limit,
        };

        this.players[player.number-1].defendDecay = {
          state: false,
          count: 0,
          limit: player.defendDecay.limit,
        }

        if (!player.popups.find(x=>x.msg === 'attackCancelled')) {
          player.popups.push(
            {
              state: false,
              count: 0,
              limit: 30,
              type: '',
              position: '',
              msg: 'attackCancelled',
              img: '',

            }
          )
        }

        break;
      case 'strafe moving':
        if (player.success.deflected.state !== true) {
          player.action = 'idle';
        }
        player.idleAnim = {
          state: false,
          count: 0,
          limit: 4,
        };
        player.strafing = {
          state: false,
          direction: '',
        };
        this.players[player.number-1].statusDisplay = {
          state: true,
          status: 'strafe break!',
          count: 1,
          limit: this.players[player.number-1].statusDisplay.limit,
        }

        if (!player.popups.find(x=>x.msg === 'attackCancelled')) {
          player.popups.push(
            {
              state: false,
              count: 0,
              limit: 30,
              type: '',
              position: '',
              msg: 'attackCancelled',
              img: '',

            }
          )
        }

      break;
      case 'dodging':
        if (player.success.deflected.state !== true) {
          player.action = 'idle';
        }
        player.idleAnim = {
          state: false,
          count: 0,
          limit: 4,
        };
        player.dodging = {
          countState: false,
          state: false,
          count: 0,
          limit: 20,
          peak: {
            start: 5,
            end: 10,
          }
        };
        player.dodgeDirection = '';
        this.players[player.number-1].statusDisplay = {
          state: true,
          status: 'dodge break!',
          count: 1,
          limit: this.players[player.number-1].statusDisplay.limit,
        }

        if (!player.popups.find(x=>x.msg === 'attackCancelled')) {
          player.popups.push(
            {
              state: false,
              count: 0,
              limit: 30,
              type: '',
              position: '',
              msg: 'attackCancelled',
              img: '',

            }
          )
        }

      break;
      case 'flanking':
        if (player.success.deflected.state !== true) {
          player.action = 'idle';
        }
        player.idleAnim = {
          state: false,
          count: 0,
          limit: 4,
        };
        player.flanking = {
          checking: false,
          preFlankDirection: '',
          direction: '',
          state: false,
          step: 0,
          target1: {x:0 ,y:0},
          target2: {x:0 ,y:0},
        };
        this.players[player.number-1].statusDisplay = {
          state: true,
          status: 'flanking break!',
          count: 1,
          limit: this.players[player.number-1].statusDisplay.limit,
        }

        if (!player.popups.find(x=>x.msg === 'attackCancelled')) {
          player.popups.push(
            {
              state: false,
              count: 0,
              limit: 30,
              type: '',
              position: '',
              msg: 'attackCancelled',
              img: '',

            }
          )
        }

      break;
      case 'jumping':
        if (player.success.deflected.state !== true) {
          player.action = 'idle';
        }
        player.idleAnim = {
          state: false,
          count: 0,
          limit: 4,
        }
        player.jumping = {
          checking: false,
          state: false,
        };
        this.players[player.number-1].statusDisplay = {
          state: true,
          status: 'jumping break!',
          count: 1,
          limit: this.players[player.number-1].statusDisplay.limit,
        }

        if (!player.popups.find(x=>x.msg === 'attackCancelled')) {
          player.popups.push(
            {
              state: false,
              count: 0,
              limit: 30,
              type: '',
              position: '',
              msg: 'attackCancelled',
              img: '',

            }
          )
        }

      break;
      default:
    }

    if (player.prePush.state === true) {
      player.prePush = {
        state: false,
        count: 0,
        limit: player.prePush.limit,
        targetCell: undefined,
        direction: "",
        pusher: undefined,
      }
    }
    if (player.prePull.state === true) {
      player.prePull = {
        state: false,
        count: 0,
        limit: player.prePull.limit,
        targetCell: undefined,
        direction: "",
        puller: undefined,
      }
    }


    if (player.ai.state === true) {
      this.players[player.number-1].ai.currentInstruction = 0
      this.players[player.number-1].ai.instructions = []
    }

  }
  pushBack = (player,hitByPlayerDirection) => {
    // console.log('pushing back?');

    this.attackedCancel(player)

    let canPushBack = false;
    let halfPushBack = false;
    let halfPushBackType = "";
    let myCellBlock = false;
    let myCell = this.gridInfo.find(x=> x.number.x === player.currentPosition.cell.number.x && x.number.y === player.currentPosition.cell.number.y);

    player.pushBack.prePushMoveSpeed = player.speed.move;
    player.speed.move = .125;

    if (player.stamina.current - this.staminaCostRef.pushBack < 0) {
      player.stamina.current = 0;
    } else {
      player.stamina.current = player.stamina.current - this.staminaCostRef.pushBack;
    }



    let pushBackDirection = hitByPlayerDirection;
    player.strafing = {
      state: true,
      direction: pushBackDirection
    }
    let target = this.getTarget(player);
    let targetCell = this.gridInfo.find(x=>x.number.x === target.cell1.number.x && x.number.y === target.cell1.number.y)


    if (myCell.barrier.state === true && myCell.barrier.position === pushBackDirection) {

      canPushBack = false;
      halfPushBack = true;
      myCellBlock = true;

    }


    if (target.cell1.free === false || myCellBlock === true) {
      // console.log('Pushback target is NOT free. Half push back?',myCellBlock);

      if (target.cell1.occupant.type === "obstacle") {

        canPushBack = false;
        halfPushBack = true;
        halfPushBackType = "obstacle";

      }

      if (target.cell1.occupant.type === "player") {

        canPushBack = false;
        halfPushBack = true;
        halfPushBackType = "player";

      }

      if (target.cell1.occupant.type === "higherElevation") {

        canPushBack = false;
        halfPushBack = true;
        halfPushBackType = "higherElevation";

      }

      if (myCellBlock === true || target.cell1.occupant.type === "barrier") {

        canPushBack = false;
        halfPushBack = true;
        halfPushBackType = "barrier";

      }

      player.pushBack.state = false;
      player.strafing = {
        state: false,
        direction: "",
      }

    }
    else {
      canPushBack = true;
    }


    if (player.target.cell1.free === true && canPushBack === true) {
      // console.log('proceed with pushback',player.number,'to',target.cell1.number);

      if (player.target.cell1.void === true) {
          // console.log('pushback target is VOID!!',target.cell1.center.x,target.cell1.center.y);
      }

      player.pushBack.state = true;
      player.action = 'strafe moving';
      player.moving = {
        state: true,
        step: 0,
        course: '',
        origin: {
          number: player.currentPosition.cell.number,
          center: player.currentPosition.cell.center,
        },
        destination: target.cell1.center
      }
      let nextPosition = this.lineCrementer(player);
      player.nextPosition = nextPosition;

      if (!player.popups.find(x=>x.msg === "pushedBack")) {
        player.popups.push(
          {
            state: false,
            count: 0,
            limit: 30,
            type: '',
            position: '',
            msg: 'pushedBack',
            img: '',

          }
        )
      }

    }

    if (halfPushBack === true) {

      let dir = pushBackDirection;

      this.unsetDeflection(player);

      player.success.deflected.predeflect = false;
      this.startHalfPushBack('player',halfPushBackType,dir,player);

    }

    this.getTarget(player);

    this.players[player.number-1] = player;
    return  canPushBack;

  }
  startHalfPushBack = (object,blockType,direction,data) => {
    // console.log('startHalfPushback',object,blockType,direction);


    if (object === 'player') {

      let point = {
        x: data.currentPosition.cell.center.x,
        y: data.currentPosition.cell.center.y,
      };


      data.halfPushBack = {
        state: true,
        direction: direction,
        type: blockType,
        countUp: {
          state: true,
          count: 0,
          limit: 6,
        },
        countDown: {
          state: false,
          count: 0,
          limit: 6,
        },
        coords: {
          x: point.x-(this.playerDrawWidth/2),
          y: point.y-(this.playerDrawHeight/2),
        },
      }

      this.players[data.number-1] = data;

    }

    if (object === "obstacle") {

      this.halfPushBackObstacles.push ({
        state: true,
        myCellNo: data.number,
        blockCellNo: this.getCellFromDirection(1,data.number,direction),
        blockType: blockType,
        direction: direction,
        obstacle: data.obstacle,
        countUp: {
          state: true,
          count: 0,
          limit: 10,
        },
        countDown: {
          state: false,
          count: 0,
          limit: 10,
        },
        coords: {
          x: undefined,
          y: undefined,
        },
      })

    }


  }
  handleHalfPushBackResult = (type,data) => {
    // console.log('handleHalfPushBackResult',type,data);


    let direction = "";
    let impactor = type;
    let impactee = "";
    let impacteePlayerRef;
    let shouldDamageImpactor = false;
    let shouldDamageImpactee = false;
    let shouldDeflectImpactor = false;
    let shouldDeflectImpactee = false;
    let impactorDamage = 0;
    let impacteeDamage = 0;
    let shouldMoveImpactee = false;

    let moveObstacle = false;
    let movePlayer = false;

    let targetCellNumber = undefined;
    let targetCellRef = undefined;
    let myCellRef = undefined;


    let damageObstacle = (args) => {

      let damage = 1;
      if (this.rnJesus(1,2) === 1) {
        damage = this.rnJesus(1,2);
      }

      // IMPACTOR DAMAGE OR DESTROY, DON'T MOVE
      if (args === 'impactor') {

        if (myCellRef.obstacle.destructible.state === true) {

          if (myCellRef.obstacle.hp - damage > 0) {

            let hp = myCellRef.obstacle.hp - damage;

            myCellRef.obstacle = {
              state: myCellRef.obstacle.state,
              name: myCellRef.obstacle.name,
              type: myCellRef.obstacle.type,
              hp: hp,
              destructible: myCellRef.obstacle.destructible,
              locked: myCellRef.obstacle.locked,
              weight: myCellRef.obstacle.weight,
              height: myCellRef.obstacle.height,
              items: myCellRef.obstacle.items,
              effects: myCellRef.obstacle.effects,
              moving: myCellRef.obstacle.moving
            };

            this.obstacleBarrierToDestroy.push({
              type: 'obstacle',
              action: 'damage',
              count: 0,
              limit: 30,
              complete: false,
              cell: myCellRef,
            })


          }

          // DESTROY OBSTACLE W/ OR W/O RUBBLE
          else if (myCellRef.obstacle.hp - damage <= 0) {

            let itemsToDrop = [];

            if (myCellRef.obstacle.destructible.leaveRubble === true) {
              // console.log('leave rubble on ',targetCell.number,'removing obstacle');

              if (myCellRef.obstacle.items[0]) {
                itemsToDrop = myCellRef.obstacle.items;
              }
              myCellRef.rubble = true;
              // targetCell.terrain.type = 'hazard';

              myCellRef.obstacle = {
                state: false,
                name: myCellRef.obstacle.name,
                type: myCellRef.obstacle.type,
                hp: 0,
                destructible: myCellRef.obstacle.destructible,
                locked: myCellRef.obstacle.locked,
                weight: myCellRef.obstacle.weight,
                height: myCellRef.obstacle.height,
                items: myCellRef.obstacle.items,
                effects: myCellRef.obstacle.effects,
                moving: myCellRef.obstacle.moving
              };


            }

            else {
              // console.log('no rubble. Just remove obstacle');
              if (myCellRef.obstacle.items[0]) {
                itemsToDrop = myCellRef.obstacle.items;
              }

              myCellRef.obstacle = {
                state: false,
                name: myCellRef.obstacle.name,
                type: myCellRef.obstacle.type,
                hp: 0,
                destructible: myCellRef.obstacle.destructible,
                locked: myCellRef.obstacle.locked,
                weight: myCellRef.obstacle.weight,
                height: myCellRef.obstacle.height,
                items: myCellRef.obstacle.items,
                effects: myCellRef.obstacle.effects,
                moving: myCellRef.obstacle.moving
              };

            }


            // DROP OBSTACLE ITEMS?
            if (itemsToDrop[0]) {
              // console.log('dropping obstacle items melee',itemsToDrop);
              this.obstacleItemDrop(myCellRef,undefined);

            }

            this.obstacleBarrierToDestroy.push({
              type: 'obstacle',
              action: 'destroy',
              count: 0,
              limit: 30,
              complete: false,
              cell: myCellRef,
            })

            if (!this.cellPopups.find(x => x.msg === 'destroyedItem')) {
              this.cellPopups.push(
                {
                  state: false,
                  count: 0,
                  limit: 35,
                  type: '',
                  position: '',
                  msg: 'destroyedItem',
                  img: '',
                  cell: myCellRef,
                }
              )
            }

          }

        }
        else {
          // moveObstacle = true;
        }

      }

      // IMPACTEE, DAMAGE, DESTROY AND MOVE?
      if (args === 'impactee') {

        if (targetCellRef.obstacle.destructible.state === true) {

          if (targetCellRef.obstacle.hp - damage > 0) {

            let hp = targetCellRef.obstacle.hp - damage;

            targetCellRef.obstacle = {
              state: targetCellRef.obstacle.state,
              name: targetCellRef.obstacle.name,
              type: targetCellRef.obstacle.type,
              hp: hp,
              destructible: targetCellRef.obstacle.destructible,
              locked: targetCellRef.obstacle.locked,
              weight: targetCellRef.obstacle.weight,
              height: targetCellRef.obstacle.height,
              items: targetCellRef.obstacle.items,
              effects: targetCellRef.obstacle.effects,
              moving: targetCellRef.obstacle.moving
            };

            this.obstacleBarrierToDestroy.push({
              type: 'obstacle',
              action: 'damage',
              count: 0,
              limit: 30,
              complete: false,
              cell: targetCellRef,
            })

            if (this.rnJesus(1,4) === 1) {
              moveObstacle = true;
            }

          }

          // DESTROY OBSTACLE W/ OR W/O RUBBLE
          else if (targetCellRef.obstacle.hp - damage <= 0) {
            let itemsToDrop = [];

            if (targetCellRef.obstacle.destructible.leaveRubble === true) {
              // console.log('leave rubble on ',targetCell.number,'removing obstacle');

              if (targetCellRef.obstacle.items[0]) {
                itemsToDrop = targetCellRef.obstacle.items;
              }
              targetCellRef.rubble = true;
              // targetCell.terrain.type = 'hazard';

              targetCellRef.obstacle = {
                state: false,
                name: targetCellRef.obstacle.name,
                type: targetCellRef.obstacle.type,
                hp: 0,
                destructible: targetCellRef.obstacle.destructible,
                locked: targetCellRef.obstacle.locked,
                weight: targetCellRef.obstacle.weight,
                height: targetCellRef.obstacle.height,
                items: targetCellRef.obstacle.items,
                effects: targetCellRef.obstacle.effects,
                moving: targetCellRef.obstacle.moving
              };


            }

            else {
              // console.log('no rubble. Just remove obstacle');
              if (targetCellRef.obstacle.items[0]) {
                itemsToDrop = targetCellRef.obstacle.items;
              }

              targetCellRef.obstacle = {
                state: false,
                name: targetCellRef.obstacle.name,
                type: targetCellRef.obstacle.type,
                hp: 0,
                destructible: targetCellRef.obstacle.destructible,
                locked: targetCellRef.obstacle.locked,
                weight: targetCellRef.obstacle.weight,
                height: targetCellRef.obstacle.height,
                items: targetCellRef.obstacle.items,
                effects: targetCellRef.obstacle.effects,
                moving: targetCellRef.obstacle.moving
              };

            }


            // DROP OBSTACLE ITEMS?
            if (itemsToDrop[0]) {

              this.obstacleItemDrop(targetCellRef,undefined);

            }

            this.obstacleBarrierToDestroy.push({
              type: 'obstacle',
              action: 'destroy',
              count: 0,
              limit: 30,
              complete: false,
              cell: targetCellRef,
            })

            if (!this.cellPopups.find(x => x.msg === 'destroyedItem')) {
              this.cellPopups.push(
                {
                  state: false,
                  count: 0,
                  limit: 35,
                  type: '',
                  position: '',
                  msg: 'destroyedItem',
                  img: '',
                  cell: targetCellRef,
                }
              )
            }

          }

        }
        else {
          moveObstacle = true;
        }

      }

      if (moveObstacle === true) {

        if (args === 'impactee') {
          shouldMoveImpactee = true;
        }

      }

    }

    let damageBarrier = (args,myCell) => {

      let damage = 1;
      if (this.rnJesus(1,2) === 1) {
        damage = this.rnJesus(1,2);
      }

      if (myCell === true) {

        if (myCellRef.barrier.destructible.state === true) {

          if (myCellRef.barrier.hp - damage > 0) {

            let hp = myCellRef.barrier.hp - damage;

            myCellRef.barrier =
            {
              state: myCellRef.barrier.state,
              name: myCellRef.barrier.name,
              type: myCellRef.barrier.type,
              hp: hp,
              destructible: myCellRef.barrier.destructible,
              locked: myCellRef.barrier.locked,
              position: myCellRef.barrier.position,
              height: myCellRef.barrier.height,
            };

            this.obstacleBarrierToDestroy.push({
              type: 'barrier',
              action: 'damage',
              count: 0,
              limit: 30,
              complete: false,
              cell: myCellRef,
            })

          }

          // DESTROY FWD BARRIER W/ OR W/O RUBBLE
          else if (myCellRef.barrier.hp - damage <= 0) {
            if (myCellRef.barrier.destructible.leaveRubble === true && myCellRef.obstacle.state !== true && myCellRef.item.name === "") {

              myCellRef.rubble = true;

              myCellRef.barrier =
              {
                state: false,
                name: myCellRef.barrier.name,
                type: myCellRef.barrier.type,
                hp: 0,
                destructible: myCellRef.barrier.destructible,
                locked: myCellRef.barrier.locked,
                position: myCellRef.barrier.position,
                height: myCellRef.barrier.height,
              };

              if (!this.cellPopups.find(x => x.msg === 'destroyedItem' && x.cell.number.x === myCellRef.number.x && x.cell.number.y === myCellRef.number.y)) {
                this.cellPopups.push(
                  {
                    state: false,
                    count: 0,
                    limit: 35,
                    type: '',
                    position: '',
                    msg: 'destroyedItem',
                    img: '',
                    cell: myCellRef,
                  }
                )
              }


            } else {
              // console.log('no rubble. Just remove barrier');

              myCellRef.barrier =
              {
                state: false,
                name: myCellRef.barrier.name,
                type: myCellRef.barrier.type,
                hp: 0,
                destructible: myCellRef.barrier.destructible,
                locked: myCellRef.barrier.locked,
                position: myCellRef.barrier.position,
                height: myCellRef.barrier.height,
              };

              if (!this.cellPopups.find(x => x.msg === 'destroyedItem' && x.cell.number.x === myCellRef.number.x && x.cell.number.y === myCellRef.number.y)) {
                this.cellPopups.push(
                  {
                    state: false,
                    count: 0,
                    limit: 35,
                    type: '',
                    position: '',
                    msg: 'destroyedItem',
                    img: '',
                    cell: myCellRef,
                  }
                )
              }

            }

            this.obstacleBarrierToDestroy.push({
              type: 'barrier',
              action: 'destroy',
              count: 0,
              limit: 30,
              complete: false,
              cell: myCellRef,
            })

          }


        }

      }
      else {

        if (targetCellRef.barrier.position === this.getOppositeDirection(direction)) {

          if (targetCellRef.barrier.destructible.state === true) {

            if (targetCellRef.barrier.hp - damage > 0) {

              let hp = targetCellRef.barrier.hp - damage;

              targetCellRef.barrier =
              {
                state: targetCellRef.barrier.state,
                name: targetCellRef.barrier.name,
                type: targetCellRef.barrier.type,
                hp: hp,
                destructible: targetCellRef.barrier.destructible,
                locked: targetCellRef.barrier.locked,
                position: targetCellRef.barrier.position,
                height: targetCellRef.barrier.height,
              };

              this.obstacleBarrierToDestroy.push({
                type: 'barrier',
                action: 'damage',
                count: 0,
                limit: 30,
                complete: false,
                cell: targetCellRef,
              })
            }

            // DESTROY FWD BARRIER W/ OR W/O RUBBLE
            else if (targetCellRef.barrier.hp - damage <= 0) {
              if (targetCellRef.barrier.destructible.leaveRubble === true && targetCellRef.obstacle.state !== true && targetCellRef.item.name === "") {

                targetCellRef.rubble = true;

                targetCellRef.barrier =
                {
                  state: false,
                  name: targetCellRef.barrier.name,
                  type: targetCellRef.barrier.type,
                  hp: 0,
                  destructible: targetCellRef.barrier.destructible,
                  locked: targetCellRef.barrier.locked,
                  position: targetCellRef.barrier.position,
                  height: targetCellRef.barrier.height,
                };

                if (!this.cellPopups.find(x => x.msg === 'destroyedItem' && x.cell.number.x === targetCellRef.number.x && x.cell.number.y === targetCellRef.number.y)) {
                  this.cellPopups.push(
                    {
                      state: false,
                      count: 0,
                      limit: 35,
                      type: '',
                      position: '',
                      msg: 'destroyedItem',
                      img: '',
                      cell: targetCellRef,
                    }
                  )
                }


              } else {
                // console.log('no rubble. Just remove barrier');

                targetCellRef.barrier =
                {
                  state: false,
                  name: targetCellRef.barrier.name,
                  type: targetCellRef.barrier.type,
                  hp: 0,
                  destructible: targetCellRef.barrier.destructible,
                  locked: targetCellRef.barrier.locked,
                  position: targetCellRef.barrier.position,
                  height: targetCellRef.barrier.height,
                };

                if (!this.cellPopups.find(x => x.msg === 'destroyedItem' && x.cell.number.x === targetCellRef.number.x && x.cell.number.y === targetCellRef.number.y)) {
                  this.cellPopups.push(
                    {
                      state: false,
                      count: 0,
                      limit: 35,
                      type: '',
                      position: '',
                      msg: 'destroyedItem',
                      img: '',
                      cell: targetCellRef,
                    }
                  )
                }

              }

              this.obstacleBarrierToDestroy.push({
                type: 'barrier',
                action: 'destroy',
                count: 0,
                limit: 30,
                complete: false,
                cell: targetCellRef,
              })

            }


          }

        }

      }

    }


    // PLAYER HALF PUSHED BACK
    if (type === 'player') {

      direction = data.halfPushBack.direction;
      targetCellNumber = this.getCellFromDirection(1,data.currentPosition.cell.number,data.halfPushBack.direction)
      targetCellRef = this.gridInfo.find(x=> x.number.x === targetCellNumber.x && x.number.y === targetCellNumber.y)
      myCellRef = this.gridInfo.find(x=> x.number.x === data.currentPosition.cell.number.x && x.number.y === data.currentPosition.cell.number.y)
      impactee = data.halfPushBack.type;
      shouldDamageImpactor = (this.rnJesus(1,data.crits.guardBreak) === 1);
      shouldDeflectImpactor = (this.rnJesus(1,data.crits.guardBreak) === 1);


        switch (impactee) {
          case "obstacle":

          // IMPACTOR DAMAGE, DEFLECT?
            if (shouldDamageImpactor === true) {
              this.handleMiscPlayerDamage(data,'halfPushBackImpactor_'+impactee+'');
            }

            if (shouldDeflectImpactor === true) {
              this.setDeflection(data,'attacked',false);
            }


            // IMPACTEE DAMAGE?
            shouldDamageImpactee = (this.rnJesus(1,(targetCellRef.obstacle.height+targetCellRef.obstacle.weight+targetCellRef.obstacle.hp)) === 1);
            if (shouldDamageImpactee === true) {
              damageObstacle('impactee');
            }

            if (this.halfPushBackChainingMoveAll === true) {
              moveObstacle = true;
            }


          break;
          case "player":

            // IMPACTOR DAMAGE, DEFLECT?
            if (shouldDamageImpactor === true) {
              this.handleMiscPlayerDamage(data,'halfPushBackImpactor_'+impactee+'');
            }

            if (shouldDeflectImpactor === true) {
              this.setDeflection(data,'attacked',false);
            }


            // IMPACTEE DAMAGE, DEFLECT/ PUSHBACK + DEFLECT?
            impacteePlayerRef = this.players.find(x => x.currentPosition.cell.number.x === targetCellRef.number.x && x.currentPosition.cell.number.y === targetCellRef.number.y);
            shouldDamageImpactee = (this.rnJesus(1,impacteePlayerRef.crits.guardBreak) === 1);

            if (shouldDamageImpactee === true) {
              this.handleMiscPlayerDamage(impacteePlayerRef,'halfPushBackImpactee_'+impactor+'');
            }

            shouldDeflectImpactee = (this.rnJesus(1,impacteePlayerRef.crits.guardBreak) === 1);

            if (this.halfPushBackChainingMoveAll === true) {
              if (impacteePlayerRef.direction === direction) {
                movePlayer = true;
              }
              else {
                this.setDeflection(impacteePlayerRef,'attacked',true);
              }
            }
            else {

              if (shouldDeflectImpactee === true) {

                if (this.rnJesus(1,impacteePlayerRef.crits.pushBack) === 1) {
                    this.setDeflection(impacteePlayerRef,'attacked',false);
                }
                else {
                  if (impacteePlayerRef.direction === direction) {
                    movePlayer = true;
                  }
                  else {
                    this.setDeflection(impacteePlayerRef,'attacked',true);
                  }
                }

              }

            }

            // if (impacteePlayerRef.direction === direction) {
            //   movePlayer = true;
            // }
            //
            // else {
            //   this.setDeflection(impacteePlayerRef,'attacked',true);
            // }



          break;
          case "barrier":

            // IMPACTOR DAMAGE, DEFLECT?
            if (shouldDamageImpactor === true) {
              this.handleMiscPlayerDamage(data,'halfPushBackImpactor_'+impactee+'');
            }

            if (shouldDeflectImpactor === true) {
              this.setDeflection(data,'attacked',false);
            }


            // IMPACTEE DAMAGE?
            let myCell = false;
            if (myCellRef.barrier.state === true && myCellRef.barrier.position === data.halfPushBack.direction) {
              myCell = true;
              shouldDamageImpactee = (this.rnJesus(1,(myCellRef.barrier.height+myCellRef.barrier.hp)) === 1);
            }
            else {
              shouldDamageImpactee = (this.rnJesus(1,(targetCellRef.barrier.height+targetCellRef.barrier.hp)) === 1);
            }

            if (shouldDamageImpactee === true) {
              damageBarrier('impactee',myCell);
            }

          break;
          case "higherElevation":

            // DAMAGE, DEFLECT IMPACTOR?
            if (shouldDamageImpactor === true) {
              this.handleMiscPlayerDamage(data,'halfPushBackImpactor_'+impactee+'');
            }

            if (shouldDeflectImpactor === true) {
              this.setDeflection(data,'attacked',false);
            }

          break;
          default:

        }

    }

    // OBSTACLE HALF PUSHED BACK
    if (type === 'obstacle') {

      direction = data.direction;
      targetCellRef = this.gridInfo.find(x=> x.number.x === data.blockCellNo.x && x.number.y === data.blockCellNo.y);
      myCellRef = this.gridInfo.find(x=> x.number.x === data.myCellNo.x && x.number.y === data.myCellNo.y);
      impactee = data.blockType;
      shouldDamageImpactor = (this.rnJesus(1,(data.obstacle.height+data.obstacle.weight+data.obstacle.hp)) === 1);

      switch (impactee) {
        case "obstacle":

          // IMPACTOR
          if (shouldDamageImpactor === true) {
            damageObstacle('impactor');
          }


          // IMPACTEE
          shouldDamageImpactee = (this.rnJesus(1,(targetCellRef.obstacle.height+targetCellRef.obstacle.weight)) === 1);
          if (shouldDamageImpactee === true) {
            damageObstacle('impactee');
          }

          if (this.halfPushBackChainingMoveAll === true) {
            moveObstacle = true;
          }

        break;
        case "player":

          // IMPACTOR
          if (shouldDamageImpactor === true) {
            damageObstacle('impactor');
          }

          // IMPACTEE
          impacteePlayerRef = this.players.find(x => x.currentPosition.cell.number.x === targetCellRef.number.x && x.currentPosition.cell.number.y === targetCellRef.number.y);
          shouldDamageImpactee = (this.rnJesus(1,impacteePlayerRef.crits.guardBreak) === 1);


          if (shouldDamageImpactee === true) {
            this.handleMiscPlayerDamage(impacteePlayerRef,'halfPushBackImpactee_'+impactor+'');
          }

          shouldDeflectImpactee = (this.rnJesus(1,impacteePlayerRef.crits.guardBreak) === 1);

          if (this.halfPushBackChainingMoveAll === true) {
            if (impacteePlayerRef.direction === direction) {
              movePlayer = true;
            }
            else {
              this.setDeflection(impacteePlayerRef,'attacked',true);
            }
          }
          else {

            if (shouldDeflectImpactee === true) {

              if (this.rnJesus(1,impacteePlayerRef.crits.pushBack) === 1) {
                  this.setDeflection(impacteePlayerRef,'attacked',false);
              }
              else {
                if (impacteePlayerRef.direction === direction) {
                  movePlayer = true;
                }
                else {
                  this.setDeflection(impacteePlayerRef,'attacked',true);
                }
              }

            }

          }

        break;
        case "barrier":

          // IMPACTOR
          if (shouldDamageImpactor === true) {
            damageObstacle('impactor');
          }


          // IMPACTEE
          let myCell = false;
          if (myCellRef.barrier.state === true && myCellRef.barrier.position === data.direction) {
            myCell = true;
            shouldDamageImpactee = (this.rnJesus(1,(myCellRef.barrier.height+myCellRef.barrier.hp)) === 1);
          }
          else {
            shouldDamageImpactee = (this.rnJesus(1,(targetCellRef.barrier.height+targetCellRef.barrier.hp)) === 1);
          }

          if (shouldDamageImpactee === true) {
            damageBarrier('impactee',myCell);
          }


        break;
        case "higherElevation":

          if (shouldDamageImpactor === true) {
            damageObstacle('impactor');
          }

        break;
        default:

      }

    }

    // moveObstacle = true;
    // impactee = "obstacle";

    if (moveObstacle === true && impactee === "obstacle") {

      let destCell = this.getCellFromDirection(1,targetCellRef.number,direction);
      let destCellRef = this.gridInfo.find(x => x.number.x === destCell.x && x.number.y === destCell.y);
      let destCellOccupant = "";
      let preMoveSpeed = this.rnJesus(0,5);
      let moveSpeed = 0;
      if (preMoveSpeed <= 1) {
        moveSpeed = .05;
      }
      if (preMoveSpeed === 2) {
        moveSpeed = .1;
      }
      if (preMoveSpeed > 2 && preMoveSpeed < 4) {
        moveSpeed = .125;
      }
      if (preMoveSpeed > 4) {
        moveSpeed = .2;
      }
      if (this.terrainMoveSpeedRef[targetCellRef.terrain.type]) {
        moveSpeed = this.terrainMoveSpeedRef[targetCellRef.terrain.type];
      }


      let targetFree = true;
      if (targetCellRef.barrier.state === true && targetCellRef.barrier.position === direction) {
        targetFree = false;
      }
      if (destCellRef) {

        if (destCellRef.barrier.state === true && destCellRef.barrier.position === this.getOppositeDirection(direction)) {
          targetFree = false;
        }

        if (destCellRef.obstacle.state === true) {
          targetFree = false;


          if (this.halfPushBackChaining === true) {

            this.startHalfPushBack('obstacle','obstacle',direction,targetCellRef);

          }

        }

        if (this.players.find(x => x.currentPosition.cell.number.x === destCellRef.number.x && x.currentPosition.cell.number.y === destCellRef.number.y)) {
          targetFree = false;


          if (this.halfPushBackChaining === true) {

            this.startHalfPushBack('obstacle','player',direction,targetCellRef);

          }

        }

      }


      if (targetFree === true) {

        if (destCellRef) {

          let obstacleCrementObj = this.obstacleMoveCrementer(targetCellRef,destCellRef);

          targetCellRef.obstacle =
          {
            state: targetCellRef.obstacle.state,
            name: targetCellRef.obstacle.name,
            type: targetCellRef.obstacle.type,
            hp: targetCellRef.obstacle.hp,
            destructible: targetCellRef.obstacle.destructible,
            locked: targetCellRef.obstacle.locked,
            weight: targetCellRef.obstacle.weight,
            height: targetCellRef.obstacle.height,
            items: targetCellRef.obstacle.items,
            effects: targetCellRef.obstacle.effects,
            moving: {
              state: true,
              step: obstacleCrementObj.step,
              origin: {
                number: targetCellRef.number,
                center: targetCellRef.center,
              },
              destination: {
                number: destCellRef.number,
                center: destCellRef.center,
              },
              currentPosition: targetCellRef.center,
              nextPosition: obstacleCrementObj.pos,
              moveSpeed: moveSpeed,
              pushable: true,
              pushed: true,
              pusher: -1,
              falling: targetCellRef.obstacle.moving.falling,
            }
          };


        }

        if (!destCellRef) {

          let voidCenter = this.getVoidCenter(1,direction,targetCellRef.center);

          let obstacleCrementObj = this.obstacleMoveCrementer(targetCellRef,{center:voidCenter});

          targetCellRef.obstacle =
          {
            state: targetCellRef.obstacle.state,
            name: targetCellRef.obstacle.name,
            type: targetCellRef.obstacle.type,
            hp: targetCellRef.obstacle.hp,
            destructible: targetCellRef.obstacle.destructible,
            locked: targetCellRef.obstacle.locked,
            weight: targetCellRef.obstacle.weight,
            height: targetCellRef.obstacle.height,
            items: targetCellRef.obstacle.items,
            effects: targetCellRef.obstacle.effects,
            moving: {
              state: true,
              step: obstacleCrementObj.step,
              origin: {
                number: targetCellRef.number,
                center: targetCellRef.center,
              },
              destination: {
                number: {
                  x: undefined,
                  y: undefined
                },
                center: voidCenter,
              },
              currentPosition: targetCellRef.center,
              nextPosition: obstacleCrementObj.pos,
              moveSpeed: moveSpeed,
              pushable: true,
              pushed: true,
              pusher: -1,
              falling: targetCellRef.obstacle.moving.falling,
            }
          };

        }

      }


    }

    if (movePlayer === true && impactee === "player") {

      let destCell = this.getCellFromDirection(1,targetCellRef.number,direction);
      let destCellRef = this.gridInfo.find(x => x.number.x === destCell.x && x.number.y === destCell.y);
      let destCellOccupant = "";
      let preMoveSpeed = this.rnJesus(0,5);
      let moveSpeed = 0;
      if (preMoveSpeed <= 1) {
        moveSpeed = .05;
      }
      if (preMoveSpeed === 2) {
        moveSpeed = .1;
      }
      if (preMoveSpeed > 2 && preMoveSpeed < 4) {
        moveSpeed = .125;
      }
      if (preMoveSpeed > 4) {
        moveSpeed = .2;
      }
      if (this.terrainMoveSpeedRef[targetCellRef.terrain.type]) {
        moveSpeed = this.terrainMoveSpeedRef[targetCellRef.terrain.type];
      }


      let targetFree = true;
      if (targetCellRef.barrier.state === true && targetCellRef.barrier.position === direction) {
        targetFree = false;
      }
      if (destCellRef) {

        if (destCellRef.barrier.state === true && destCellRef.barrier.position === this.getOppositeDirection(direction)) {
          targetFree = false;
        }

        if (destCellRef.obstacle.state === true) {
          targetFree = false;
          if (this.halfPushBackChaining === true) {
            this.startHalfPushBack('player','obstacle',direction,impacteePlayerRef);
          }

        }

        if (this.players.find(x => x.currentPosition.cell.number.x === destCellRef.number.x && x.currentPosition.cell.number.y === destCellRef.number.y)) {
          targetFree = false;

          if (this.halfPushBackChaining === true) {
            this.startHalfPushBack('player','player',direction,impacteePlayerRef);
          }

        }

      }


      if (targetFree === true) {

        // this.players[targetPlayer.number-1].strafing.direction = impactDirection;
        // this.players[targetPlayer.number-1].strafing.state = true;
        // this.players[targetPlayer.number-1].action = 'strafe moving';
        this.players[impacteePlayerRef.number-1].action = 'moving';

        this.unsetDeflection(impacteePlayerRef);


        this.players[impacteePlayerRef.number-1].pushed = {
          state: true,
          pusher: -1,
          moveSpeed: moveSpeed,
        }
        this.getTarget(impacteePlayerRef);

        if (destCellRef) {

          this.players[impacteePlayerRef.number-1].moving = {
            state: true,
            step: 0,
            course: '',
            origin: {
              number: {
                x: impacteePlayerRef.currentPosition.cell.number.x,
                y: impacteePlayerRef.currentPosition.cell.number.y
              },
              center: {
                x: impacteePlayerRef.currentPosition.cell.center,
                y: impacteePlayerRef.currentPosition.cell.center
              },
            },
            destination: destCellRef.center
          }
          let targetPlyrNextPosition = this.lineCrementer(impacteePlayerRef);
          this.players[impacteePlayerRef.number-1].nextPosition = targetPlyrNextPosition;


        }

        if (!destCellRef) {

          let voidCenter = this.getVoidCenter(1,direction,targetCellRef.center);

          this.players[impacteePlayerRef.number-1].moving = {
            state: true,
            step: 0,
            course: '',
            origin: {
              number: {
                x: impacteePlayerRef.currentPosition.cell.number.x,
                y: impacteePlayerRef.currentPosition.cell.number.y
              },
              center: {
                x: impacteePlayerRef.currentPosition.cell.center,
                y: impacteePlayerRef.currentPosition.cell.center
              },
            },
            destination: voidCenter
          }
          let targetPlyrNextPosition = this.lineCrementer(impacteePlayerRef);
          this.players[impacteePlayerRef.number-1].nextPosition = targetPlyrNextPosition;

        }

      }








    }

  }
  pointChecker = (player) => {

    // console.log('point checker player',player);

    let points = player.points;
    if (points %5 === 0) {
      this.bloodSacrificeEvent.state = true;
      this.bloodSacrificeEvent.limit = 2000;
      this.bloodSacrificeEvent.restore = true;
      this.openVoid = true;
      console.log('the gods have accepted a blood sacrifice. Standby for void tiles');
    }

  }


  placeItems = (args) => {

    if (args.init === true && this.disableInitItems === false) {
      // console.log('placing items init');

      if (this.customItemPlacement.state === true) {
        if (this.initItemList.length > this.customItemPlacement.cells.length) {
          console.log('not enough cells assigned for custom placement please add more');
        }
        else  {
          // console.log('start:',this.initItemList.length,this.customItemPlacement.cells.length);

          for ( const item2 of this.initItemList) {

            let index = this.initItemList.indexOf(item2)
            let cell3 = {
              number: this.customItemPlacement.cells[index],
              center: {x: undefined,y: undefined}
            };
            let cell3Ref = this.gridInfo.find(elem => elem.number.x === cell3.number.x && elem.number.y === cell3.number.y);


            if (!cell3Ref) {
              // console.log('!!original item placement not found!!!',index,'/',this.initItemList.length,this.customItemPlacement.cells[index]);
              cell3 = this.getRandomFreeCell();
              // cell3Ref = this.gridInfo.find(elem => elem.number.x === cell3.number.x && elem.number.y === cell3.number.y);
              // console.log('cell doesnt exist @',this.customItemPlacement.cells[index],'pick new cell',cell3,'item',item2.name);
              if (!cell3) {


                cell3Ref = this.gridInfo.filter(x => x.obstacle.state === true)[0];
                // console.log('no free cells for placement, replace obatcle? @ ',cell3Ref.number);
                if (cell3Ref) {

                  let oldLvlData = cell3Ref.levelData.split("_");
                  oldLvlData[1] = "*";
                  cell3Ref.levelData = oldLvlData.join("_");
                  cell3Ref.obstacle.state = false;


                  // console.log('clearing obstacle cell for placement',cell3Ref.number,'item',cell3Ref.item.name,index);

                  cell3Ref.item.name = item2.name;
                  cell3Ref.item.type = item2.type;
                  cell3Ref.item.subType = item2.subType;
                  cell3Ref.item.effect = item2.effect;

                }
                else {
                  // console.log('init item placement no free cells for this item. skipping');
                  continue;
                }

              }
              else {


                cell3Ref = this.gridInfo.find(elem => elem.number.x === cell3.number.x && elem.number.y === cell3.number.y);
                // console.log('cell for placement exists',cell3Ref.number,this.customItemPlacement.cells[index],'item',item2.name);
                if (this.customItemPlacement.cells.find(x => x.x === cell3.number.x && x.y === cell3.number.y)) {
                  // console.log('b');
                  cell3 = this.getRandomFreeCell();
                  cell3Ref = this.gridInfo.find(elem => elem.number.x === cell3.number.x && elem.number.y === cell3.number.y);

                  if (!cell3) {
                    // console.log('here is where 1');
                    continue;
                  }
                }

                if (cell3Ref.obstacle.state === true) {
                  // console.log('obstacle in original placement cell',cell3Ref.number);
                  cell3 = this.getRandomFreeCell();

                  if (!cell3) {
                    // console.log('here is where 2');
                    continue;
                  }
                  else {

                    cell3Ref = this.gridInfo.find(elem => elem.number.x === cell3.number.x && elem.number.y === cell3.number.y);
                    // console.log('chose another cell',cell3Ref.number);
                  }
                }

                if (cell3Ref) {
                  // console.log('cell is clear for placement2',cell3Ref.number,'item',cell3Ref.item.name,index);

                  cell3Ref.item.name = item2.name;
                  cell3Ref.item.type = item2.type;
                  cell3Ref.item.subType = item2.subType;
                  cell3Ref.item.effect = item2.effect;
                }



              }


            }
            else {

              cell3Ref = this.gridInfo.find(elem => elem.number.x === cell3.number.x && elem.number.y === cell3.number.y);
              // console.log('cell @',this.customItemPlacement.cells[index],cell3Ref.number);
              if (cell3Ref.obstacle.state === true) {

                cell3 = this.getRandomFreeCell();
                // console.log('obstacle found. choose new cell',cell3);

                if (!cell3) {
                  // console.log('here is where');
                  continue;
                }
                else {

                  cell3Ref = this.gridInfo.find(elem => elem.number.x === cell3.number.x && elem.number.y === cell3.number.y);
                  // console.log('cell is clear for placement3',cell3Ref.number,'item',cell3Ref.item.name,index);
                  cell3Ref.item.name = item2.name;
                  cell3Ref.item.type = item2.type;
                  cell3Ref.item.subType = item2.subType;
                  cell3Ref.item.effect = item2.effect;
                }
              }
              else {

                cell3Ref = this.gridInfo.find(elem => elem.number.x === cell3.number.x && elem.number.y === cell3.number.y);
                // console.log('cell is clear for placement4',cell3Ref.number,'item',cell3Ref.item.name,index);

                cell3Ref.item.name = item2.name;
                cell3Ref.item.type = item2.type;
                cell3Ref.item.subType = item2.subType;
                cell3Ref.item.effect = item2.effect;
              }

            }



          }
          // this.customItemPlacement.state = false;
        }
      }

      else {
        for ( const item of this.initItemList) {

          // if (item.amount > item.total-1) {
            // console.log('enough items for distribution');
            let cell = {
              x: 0,
              y: 0
            }
            let checkCell = false;
            while (checkCell === false) {

              cell.x = this.rnJesus(0,this.gridWidth)
              cell.y = this.rnJesus(0,this.gridWidth)
              checkCell = this.checkCell(cell);
              // console.log(checkCell);
            }
            if (checkCell === true) {
              // console.log('cell free');
              let cellRef = this.gridInfo.find(elem => elem.number.x === cell.x && elem.number.y === cell.y);
              cellRef.item.name = item.name;
              cellRef.item.type = item.type;
              cellRef.item.subType = item.subType;
              cellRef.item.effect = item.effect;


              // item.amount--
              // console.log('post item', item, cell2.item,cell2.number);

            }
          // }
          // else {
          //   console.log('item stock empty');
          // }
        }
      }

    }
    else if (args.init !== true) {
      // console.log('placing items mid-game: ',args.item);


      let item = args.item;

      for (const item2 of this.itemList) {
        if (item2.name === item) {
          if (item2.amount > 0) {

            let cell = {
              x: 0,
              y: 0
            }
            let checkCell = false;
            while (checkCell === false) {

              cell.x = this.rnJesus(0,this.gridWidth)
              cell.y = this.rnJesus(0,this.gridWidth)
              checkCell = this.checkCell(cell);
            }
            if (checkCell === true) {
              let cell2 = this.gridInfo.find(elem => elem.number.x === cell.x && elem.number.y === cell.y);
              cell2.item.name = item2.name;
              cell2.item.type = item2.type;
              cell2.item.subType = item2.subType;
              cell2.item.effect = item2.effect;

              item2.amount--;
              // console.log('placed ingame item',item2.name,"@",cell2.number.x,cell2.number.y,'remaining',item2.amount);

              // for (const cell2 of this.gridInfo) {
              //   if (
              //     cell2.number.x === cell.x &&
              //     cell2.number.y === cell.y
              //   ) {
              //     cell2.item.name = item2.name;
              //     cell2.item.type = item2.type;
              //     cell2.item.subType = item2.subType;
              //     cell2.item.effect = item2.effect;
              //
              //     item2.amount--
              //     console.log('placed ingame item',cell2.number.x,cell2.number.y,item2.amount,this.itemList);
              //   }
              // }
            }
            // item2.amount--
          } else {
            console.log('item stock empty');
          }
        }
      }

    }

  }
  deflectDrop = (player) => {
    // console.log('deflected! drop gear?',player.number);
    // console.log('preDropItems', player.items);

    let item = {
      name: '',
      type: '',
      subType: '',
      effect: '',
      initDrawn: false
    };



    let dropWhat = this.rnJesus(1,5);
    dropWhat = 1
    let shouldDrop = false;
    let dropped = false;

    // let dropChance = this.rnJesus(1,1*player.crits.pushBack);

    let dropChance = this.rnJesus(1,player.crits.pushBack+3);
    dropChance = this.rnJesus(1,1);
    if (
      dropChance === 1 &&
      player.falling.state !== true &&
      player.dead.state !== true
    ) {
      shouldDrop = true;

      if (dropWhat === 1) {

        if (player.items.weapons.length > 0 && player.currentWeapon.name !== "") {

          dropped = true;

          let index = player.items.weapons.findIndex(weapon => weapon.name === player.currentWeapon.name);
          // console.log("dropping weapon player ",player.number,this.players[player.number-1].items.weapons[index].name,index,);

          item.name = this.players[player.number-1].items.weapons[index].name;
          item.subType = this.players[player.number-1].items.weapons[index].type;
          item.type = "weapon";
          item.effect = this.players[player.number-1].items.weapons[index].effect;

          this.players[player.number-1].itemDrop = {
            state: true,
            count: 0,
            limit: 10,
            item: {
              name: '',
            },
            gear: {
              type: this.players[player.number-1].items.weapons[index].type,
            }
          }

          this.players[player.number-1].popups.push(
            {
              state: false,
              count: 0,
              limit: 25,
              type: '',
              position: '',
              msg: 'dropWeapon',
              img: '',

            }
          )

          this.players[player.number-1].items.weapons.splice(index,1);
          this.players[player.number-1].items.weaponIndex = 0;
          this.players[player.number-1].currentWeapon = {
            name: '',
            type: '',
            effect: '',
          }


          // CURRENT WEAPON DROPPED, DROP DEFENSE
          // if (player.currentArmor === {} || !player.currentArmor || player.currentArmor.name === '') {
          //
          // }
          if (player.defending.state === true) {
            this.players[player.number-1].defending = {
              state: false,
              count: 0,
              limit: this.players[player.number-1].defending.limit,
            }
            this.players[player.number-1].action = "idle";
          }

          this.players[player.number-1].statusDisplay = {
            state: true,
            status: item.name+'dropped',
            count: 1,
            limit: this.players[player.number-1].statusDisplay.limit,
          }

        }

      }
      else {

        if (player.items.armor.length > 0 && player.currentArmor.name !== "") {

          dropped = true;
          let index = player.items.armor.findIndex(armor => armor.name === player.currentArmor.name);
          // console.log("dropping armor player ",player.number,this.players[player.number-1].items.armor[index].name);
          item.name = this.players[player.number-1].items.armor[index].name;
          item.subType = this.players[player.number-1].items.armor[index].type;
          item.effect = this.players[player.number-1].items.armor[index].effect;
          item.type = "armor";


          this.players[player.number-1].itemDrop = {
            state: true,
            count: 0,
            limit: 10,
            item: {
              name: '',
            },
            gear: {
              type: this.players[player.number-1].items.armor[index].type,
            }
          }

          this.players[player.number-1].popups.push(
            {
              state: false,
              count: 0,
              limit: 25,
              type: '',
              position: '',
              msg: 'dropArmor',
              img: '',

            }
          )


          switch(item.effect) {
            case 'hpUp' :
              if (this.players[player.number-1].hp > 1) {
                console.log('armor drop debuff hp',this.players[player.number-1].hp);
                this.players[player.number-1].hp = this.players[player.number-1].hp - 1;
                console.log('armor drop debuff hp',this.players[player.number-1].hp);
              }
            break;
            case 'speedUp' :
              let currentSpd1 = this.players[player.number-1].speed.range.indexOf(this.players[player.number-1].speed.move);
              if (this.players[player.number-1].speed.move > .05) {
                console.log('armor drop debuff speed',this.players[player.number-1].speed.move);
                this.players[player.number-1].speed.move = this.players[player.number-1].speed.range[currentSpd1-1];
                console.log('armor drop debuff speed',this.players[player.number-1].speed.move);
              }
            break;
          }

          this.players[player.number-1].items.armor.splice(index,1);
          this.players[player.number-1].items.armorIndex = 0;
          this.players[player.number-1].currentArmor = {
            name: '',
            type: '',
            effect: '',
          }

          if (player.currentWeapon === {} || !player.currentWeapon || player.currentWeapon.name === '') {

            this.players[player.number-1].defending = {
              state: false,
              count: 0,
              limit: this.players[player.number-1].defending.limit,
            }
            this.players[player.number-1].action = "idle";
          }

          this.players[player.number-1].statusDisplay = {
            state: true,
            status: item.name+'dropped',
            count: 1,
            limit: this.players[player.number-1].statusDisplay.limit,
          }

        }
      }

      if (player.currentWeapon.name === "" || player.currentArmor.name === "") {
        console.log('currently unarmed and/or unarmored. Nothing to drop');
      }

      // console.log('postDropItems', player.items, player.currentPosition.cell.number.x,player.currentPosition.cell.number.y);

      if (dropped === true) {
        let dropCellIndex = this.gridInfo.findIndex(cell => cell.number.x === player.currentPosition.cell.number.x && cell.number.y === player.currentPosition.cell.number.y);
        this.gridInfo[dropCellIndex].item = item;


        if (player.ai.state === true && item.name !== "" && player.ai.organizing.dropped.state !== true) {
          if (dropWhat === 1) {
            // console.log('ai dropping weapon');
            player.ai.organizing.dropped.state = true;
            player.ai.organizing.dropped.gear = {
              name: item.name,
              type: item.type,
              subType: item.subType,
              effect: item.effect
            };
          }
          else {
            // console.log('ai dropping armor');
            player.ai.organizing.dropped.state = true;
            player.ai.organizing.dropped.gear = {
              name: item.name,
              type: item.type,
              subType: item.subType,
              effect: item.effect
            };
          }

        }
      }



    }
    else {
      // console.log('no gear drop',player.currentPosition.cell.number.x,player.currentPosition.cell.number.y);
    }

    //   if dropped gear remove buff/effect
    // console.log('this.players[player.number-1].itemDrop',this.players[player.number-1].itemDrop);

  }
  discardGear = (player,type) => {
    // console.log('dropping gear');

    let cellToDrop = this.gridInfo.find(elem => elem.number.x === player.currentPosition.cell.number.x && elem.number.y === player.currentPosition.cell.number.y);


    this.players[player.number-1].defending = {
      state: false,
      count: 0,
      limit: player.defending.limit
    }
    this.players[player.number-1].action = 'idle';

    this.players[player.number-1].defendDecay = {
      state: false,
      count: 0,
      limit: player.defendDecay.limit,
    }
    this.players[player.number-1].stamina.current += this.staminaCostRef.defend.pre;


    if (cellToDrop.item.name === '') {

      if (type === 'weapon' && player.items.weapons.length > 0) {


        let index = player.items.weapons.findIndex(weapon => weapon.name === player.currentWeapon.name);

        let weapon = player.currentWeapon;

        cellToDrop.item = {
          name: weapon.name,
          type: 'weapon',
          subType: weapon.type,
          effect: weapon.effect,
          initDrawn: false
        }


        this.players[player.number-1].itemDrop = {
          state: true,
          count: 0,
          limit: 10,
          item: {
            name: '',
          },
          gear: {
            type: this.players[player.number-1].items.weapons[index].type,
          }
        }
        this.players[player.number-1].statusDisplay = {
          state: true,
          status: weapon.name+' discarded!',
          count: 1,
          limit: this.players[player.number-1].statusDisplay.limit,
        }

        this.players[player.number-1].popups.push(
          {
            state: false,
            count: 0,
            limit: 25,
            type: '',
            position: '',
            msg: 'dropWeapon',
            img: '',

          }
        )

        this.players[player.number-1].items.weapons.splice(index,1);
        this.players[player.number-1].currentWeapon = {
          name: "",
          type: "",
          effect: "",
        }

        if (player.currentArmor === {} || !player.currentArmor || player.currentArmor.name === '') {

          this.players[player.number-1].defending = {
            state: false,
            count: 0,
            limit: this.players[player.number-1].defending.limit,
          }
          this.players[player.number-1].action = "idle";
        }


      }
      if (type === 'armor' && player.items.armor.length > 0) {

        let index2 = player.items.armor.findIndex(armor => armor.name === player.currentArmor.name);

        let armor = player.currentArmor;

        cellToDrop.item = {
          name: armor.name,
          type: 'armor',
          subType: armor.type,
          effect: armor.effect,
          initDrawn: false
        }

        this.players[player.number-1].itemDrop = {
          state: true,
          count: 0,
          limit: 10,
          item: {
            name: '',
          },
          gear: {
            type: this.players[player.number-1].items.armor[index2].type,
          }
        }
        this.players[player.number-1].statusDisplay = {
          state: true,
          status: armor.name+' discarded!',
          count: 1,
          limit: this.players[player.number-1].statusDisplay.limit,
        }

        this.players[player.number-1].popups.push(
          {
            state: false,
            count: 0,
            limit: 25,
            type: '',
            position: '',
            msg: 'dropArmor',
            img: '',

          }
        )

        this.players[player.number-1].items.armor.splice(index2,1);
        this.players[player.number-1].currentArmor = {
          name: "",
          type: "",
          effect: "",
        }

        if (player.currentWeapon === {} || !player.currentWeapon || player.currentWeapon.name === '') {

          this.players[player.number-1].defending = {
            state: false,
            count: 0,
            limit: this.players[player.number-1].defending.limit,
          }
          this.players[player.number-1].action = "idle";
        }


      }
    } else {
      console.log('cell occupied. Cant drop gear');

      this.players[player.number-1].statusDisplay = {
        state: true,
        status: 'Cell occupied. Cant drop!',
        count: 1,
        limit: this.players[player.number-1].statusDisplay.limit,
      }

      if (!this.players[player.number-1].popups.find(x=>x.msg === 'stop')) {
        this.players[player.number-1].popups.push(
          {
            state: false,
            count: 0,
            limit: 25,
            type: '',
            position: '',
            msg: 'stop',
            img: '',

          }
        )
      }

    }

  }
  attackCellContents = (type,player,targetCell,targetCell2,myCell,bolt) => {


    if (type === 'melee') {

      let doubleHitChance = player.crits.doubleHit;
      let singleHitChance = player.crits.singleHit;
      let doubleHit = this.rnJesus(1,doubleHitChance);
      let singleHit = this.rnJesus(1,singleHitChance);
      let damage = undefined;
      if (doubleHit === 1) {
        damage = 2;
      } else {
        damage = 1;
      }
      let shouldDamage = 0;
      if (player.bluntAttack === true) {
        shouldDamage = this.rnJesus(1,player.crits.guardBreak)
        if (shouldDamage = 1) {
          damage = 1;
        } else {
          damage = 0
        }
      }
      if (player.currentWeapon.name === '') {
        shouldDamage = this.rnJesus(1,player.crits.guardBreak+3)
        if (shouldDamage = 1) {
          damage = 1;
        } else {
          damage = 0
        }
      }

      // AT ELEVATION
      if (targetCell) {

        if (targetCell.elevation.number < myCell.elevation.number+1) {


          let checkSpearTarget = false;
          // set this false if first target obstacles or barrier industructible or not destroyed

          if (player.currentWeapon.type !== 'spear') {

            // MY CELL BARRIER?
            let myCellBarrier = false;
            if (myCell.barrier.state === true ) {
              if (myCell.barrier.position === player.direction) {
                  myCellBarrier = true;
                  if (myCell.barrier.destructible.state === true) {
                    // WEAPON CHECK
                    if (myCell.barrier.destructible.weapons.find(x => x === player.currentWeapon.name)) {
                      if (myCell.barrier.hp - damage > 0) {

                        let hp = myCell.barrier.hp - damage;

                        myCell.barrier =
                        {
                          state: myCell.barrier.state,
                          name: myCell.barrier.name,
                          type: myCell.barrier.type,
                          hp: hp,
                          destructible: myCell.barrier.destructible,
                          locked: myCell.barrier.locked,
                          position: myCell.barrier.position,
                          height: myCell.barrier.height,
                        };

                        this.obstacleBarrierToDestroy.push({
                          type: 'barrier',
                          action: 'damage',
                          count: 0,
                          limit: 30,
                          complete: false,
                          cell: myCell,
                        })
                      }

                      // DESTROY FWD BARRIER W/ OR W/O RUBBLE
                      else if (myCell.barrier.hp - damage <= 0) {
                        if (myCell.barrier.destructible.leaveRubble === true && myCell.obstacle.state !== true && myCell.item.name === "") {
                          // console.log('leave rubble on ',myCell.number,'removing barrier');
                          myCell.rubble = true;
                          // myCell.terrain.type = 'hazard';

                          myCell.barrier =
                          {
                            state: false,
                            name: myCell.barrier.name,
                            type: myCell.barrier.type,
                            hp: 0,
                            destructible: myCell.barrier.destructible,
                            locked: myCell.barrier.locked,
                            position: myCell.barrier.position,
                            height: myCell.barrier.height,
                          };

                          this.players[player.number-1].statusDisplay = {
                            state: true,
                            status: 'Destroyed '+myCell.barrier.name+'!',
                            count: 1,
                            limit: this.players[player.number-1].statusDisplay.limit,
                          }

                          if (!player.popups.find(x=>x.msg === 'destroyedItem')) {
                            player.popups.push(
                              {
                                state: false,
                                count: 0,
                                limit: 30,
                                type: '',
                                position: '',
                                msg: 'destroyedItem',
                                img: '',

                              }
                            )
                          }

                        } else {
                          // console.log('no rubble. Just remove barrier');


                          myCell.barrier =
                          {
                            state: false,
                            name: myCell.barrier.name,
                            type: myCell.barrier.type,
                            hp: 0,
                            destructible: myCell.barrier.destructible,
                            locked: myCell.barrier.locked,
                            position: myCell.barrier.position,
                            height: myCell.barrier.height,
                          };

                          this.players[player.number-1].statusDisplay = {
                            state: true,
                            status: 'Destroyed '+myCell.barrier.name+'!',
                            count: 1,
                            limit: this.players[player.number-1].statusDisplay.limit,
                          }

                          if (!player.popups.find(x=>x.msg === 'destroyedItem')) {
                            player.popups.push(
                              {
                                state: false,
                                count: 0,
                                limit: 30,
                                type: '',
                                position: '',
                                msg: 'destroyedItem',
                                img: '',

                              }
                            )
                          }

                        }

                        this.obstacleBarrierToDestroy.push({
                          type: 'barrier',
                          action: 'destroy',
                          count: 0,
                          limit: 30,
                          complete: false,
                          cell: myCell,
                        })

                      }
                    }

                    // WEAPON NO GOOD. DEFLECT
                    else {
                      console.log('your current weapon cannot destroy this, you need ',myCell.barrier.destructible.weapons,'. Deflect player?');
                       let shouldDeflect = this.rnJesus(1,player.crits.guardBreak)

                       if (shouldDeflect === 1) {

                         if (this.rnJesus(1,player.crits.pushBack) === 1) {
                           this.setDeflection(player,'defended',true);
                         }
                         else {
                           this.setDeflection(player,'defended',false);
                         }

                         if (player.currentWeapon.name === '') {
                           console.log('this barrier is stronger than your fist. Take damage?');
                           let takeDamage = this.rnJesus(1,player.crits.guardBreak);
                           if (takeDamage === 1) {

                             this.handleMiscPlayerDamage(player,"obstacleBarrierInvulnurable");

                           }
                         }

                       }
                       else {

                            this.pushBack(player,this.getOppositeDirection(player.direction))
                       }

                       if (!this.cellPopups.find(x => x.msg === "unbreakable" && x.cell.number.x === myCell.number.x && x.cell.number.y === myCell.number.y)) {
                         this.cellPopups.push(
                           {
                             state: false,
                             count: 0,
                             limit: 35,
                             type: '',
                             position: '',
                             msg: 'unbreakable',
                             color: '',
                             img: '',
                             cell: this.gridInfo.find(x => x.number.x === myCell.number.x && x.number.y === myCell.number.y)
                           }
                         )
                       }
                    }

                  }

                  // INDESTRUCTIBLE MY CELL BARRIER
                  else {
                    console.log('attacking invurnerable barrier, deflect player?');
                     let shouldDeflect = this.rnJesus(1,player.crits.guardBreak)

                     if (shouldDeflect === 1) {

                       if (this.rnJesus(1,player.crits.pushBack) === 1) {
                         this.setDeflection(player,'defended',true);
                       }
                       else {
                         this.setDeflection(player,'defended',false);
                       }

                       if (player.currentWeapon.name === '') {
                         console.log('this barrier is stronger than your fist. Take damage?');
                         let takeDamage = this.rnJesus(1,player.crits.guardBreak);
                         if (takeDamage === 1) {

                           this.handleMiscPlayerDamage(player,"obstacleBarrierInvulnurable");

                         }
                       }

                     }
                     else {

                          this.pushBack(player,this.getOppositeDirection(player.direction))
                     }

                     if (!this.cellPopups.find(x => x.msg === "unbreakable" && x.cell.number.x === myCell.number.x && x.cell.number.y === myCell.number.y)) {
                       this.cellPopups.push(
                         {
                           state: false,
                           count: 0,
                           limit: 35,
                           type: '',
                           position: '',
                           msg: 'unbreakable',
                           color: '',
                           img: '',
                           cell: this.gridInfo.find(x => x.number.x === myCell.number.x && x.number.y === myCell.number.y)
                         }
                       )
                     }
                  }
              }
            }

            // FWD BARRIER?
            let fwdBarrier = false;
            if (targetCell.barrier.state === true) {
              fwdBarrier = this.checkForwardBarrier(player.direction,targetCell);
            }

            if (fwdBarrier === true) {
              if (targetCell.barrier.destructible.state === true) {
                // WEAPON CHECK
                if (targetCell.barrier.destructible.weapons.find(x => x === player.currentWeapon.name)) {
                  if (targetCell.barrier.hp - damage > 0) {


                    let hp = targetCell.barrier.hp - damage;

                    targetCell.barrier =
                    {
                      state: targetCell.barrier.state,
                      name: targetCell.barrier.name,
                      type: targetCell.barrier.type,
                      hp: hp,
                      destructible: targetCell.barrier.destructible,
                      locked: targetCell.barrier.locked,
                      position: targetCell.barrier.position,
                      height: targetCell.barrier.height,
                    };

                    this.obstacleBarrierToDestroy.push({
                      type: 'barrier',
                      action: 'damage',
                      count: 0,
                      limit: 30,
                      complete: false,
                      cell: targetCell,
                    })
                  }

                  // DESTROY FWD BARRIER W/ OR W/O RUBBLE
                  else if (targetCell.barrier.hp - damage <= 0) {
                    if (targetCell.barrier.destructible.leaveRubble === true && targetCell.obstacle.state !== true && targetCell.item.name === "") {
                      // console.log('leave rubble on ',targetCell.number,'removing barrier');
                      targetCell.rubble = true;
                      // targetCell.terrain.type = 'hazard';

                      targetCell.barrier =
                      {
                        state: false,
                        name: targetCell.barrier.name,
                        type: targetCell.barrier.type,
                        hp: 0,
                        destructible: targetCell.barrier.destructible,
                        locked: targetCell.barrier.locked,
                        position: targetCell.barrier.position,
                        height: targetCell.barrier.height,
                      };

                      this.players[player.number-1].statusDisplay = {
                        state: true,
                        status: 'Destroyed '+targetCell.barrier.name+'!',
                        count: 1,
                        limit: this.players[player.number-1].statusDisplay.limit,
                      }

                      if (!player.popups.find(x=>x.msg === 'destroyedItem')) {
                        player.popups.push(
                          {
                            state: false,
                            count: 0,
                            limit: 30,
                            type: '',
                            position: '',
                            msg: 'destroyedItem',
                            img: '',

                          }
                        )
                      }

                    } else {
                      // console.log('no rubble. Just remove barrier');

                      targetCell.barrier =
                      {
                        state: false,
                        name: targetCell.barrier.name,
                        type: targetCell.barrier.type,
                        hp: 0,
                        destructible: targetCell.barrier.destructible,
                        locked: targetCell.barrier.locked,
                        position: targetCell.barrier.position,
                        height: targetCell.barrier.height,
                      };

                      this.players[player.number-1].statusDisplay = {
                        state: true,
                        status: 'Destroyed '+targetCell.barrier.name+'!',
                        count: 1,
                        limit: this.players[player.number-1].statusDisplay.limit,
                      }

                      if (!player.popups.find(x=>x.msg === 'destroyedItem')) {
                        player.popups.push(
                          {
                            state: false,
                            count: 0,
                            limit: 30,
                            type: '',
                            position: '',
                            msg: 'destroyedItem',
                            img: '',

                          }
                        )
                      }

                    }

                    this.obstacleBarrierToDestroy.push({
                      type: 'barrier',
                      action: 'destroy',
                      count: 0,
                      limit: 30,
                      complete: false,
                      cell: targetCell,
                    })

                  }
                }

                // WEAPON NO GOOD. DEFLECT
                else {
                  console.log('your current weapon cannot destroy this, you need ',targetCell.barrier.destructible.weapons,'. Deflect player?');
                   let shouldDeflect = this.rnJesus(1,player.crits.guardBreak)
                   if (shouldDeflect === 1) {

                     this.attackedCancel(this.players[player.number-1]);

                     this.setDeflection(player,'defended',false);

                     if (player.currentWeapon.name === '') {
                       console.log('this barrier is stronger than your fist. Take damage?');
                       let takeDamage = this.rnJesus(1,player.crits.guardBreak);
                       if (takeDamage === 1) {

                         this.handleMiscPlayerDamage(player,"obstacleBarrierInvulnurable");

                       }
                     }

                   }
                   if (this.rnJesus(1,player.crits.pushBack) === 1) {
                     this.pushBack(player,this.getOppositeDirection(player.direction))
                   }
                   if (!this.cellPopups.find(x => x.msg === "unbreakable" && x.cell.number.x === targetCell.number.x && x.cell.number.y === targetCell.number.y)) {
                     this.cellPopups.push(
                       {
                         state: false,
                         count: 0,
                         limit: 35,
                         type: '',
                         position: '',
                         msg: 'unbreakable',
                         color: '',
                         img: '',
                         cell: this.gridInfo.find(x => x.number.x === targetCell.number.x && x.number.y === targetCell.number.y)
                       }
                     )
                   }
                }

              }

              // INDESTRUCTIBLE FWD BARRIER
              else {
                console.log('attacking invurnerable barrier, deflect player?');
                 let shouldDeflect = this.rnJesus(1,player.crits.guardBreak)
                 if (shouldDeflect === 1) {

                   if (this.rnJesus(1,player.crits.pushBack) === 1) {
                     this.setDeflection(player,'defended',true);
                   }
                   else {
                     this.setDeflection(player,'defended',false);
                   }

                   if (player.currentWeapon.name === '') {
                     console.log('this barrier is stronger than your fist. Take damage?');
                     let takeDamage = this.rnJesus(1,player.crits.guardBreak);
                     if (takeDamage === 1) {

                       this.handleMiscPlayerDamage(player,"obstacleBarrierInvulnurable");

                     }
                   }

                 }
                 else {

                      this.pushBack(player,this.getOppositeDirection(player.direction))
                 }

                 if (!this.cellPopups.find(x => x.msg === "unbreakable" && x.cell.number.x === targetCell.number.x && x.cell.number.y === targetCell.number.y)) {
                   this.cellPopups.push(
                     {
                       state: false,
                       count: 0,
                       limit: 35,
                       type: '',
                       position: '',
                       msg: 'unbreakable',
                       color: '',
                       img: '',
                       cell: this.gridInfo.find(x => x.number.x === targetCell.number.x && x.number.y === targetCell.number.y)
                     }
                   )
                 }
              }
            }

            // NO FWD BARRIER. OBSTACLE, REAR  BARRIER (SPEAR)?
            else if (fwdBarrier !== true && myCellBarrier !== true) {

              if (targetCell.obstacle.state === true) {
                // damage = 1;
                if (targetCell.obstacle.destructible.state === true) {
                  // WEAPON CHECK
                  if (targetCell.obstacle.destructible.weapons.find(x => x === player.currentWeapon.name)) {
                    if (targetCell.obstacle.hp - damage > 0) {

                      let hp = targetCell.obstacle.hp - damage;

                      targetCell.obstacle = {
                        state: targetCell.obstacle.state,
                        name: targetCell.obstacle.name,
                        type: targetCell.obstacle.type,
                        hp: hp,
                        destructible: targetCell.obstacle.destructible,
                        locked: targetCell.obstacle.locked,
                        weight: targetCell.obstacle.weight,
                        height: targetCell.obstacle.height,
                        items: targetCell.obstacle.items,
                        effects: targetCell.obstacle.effects,
                        moving: targetCell.obstacle.moving
                      };

                      this.obstacleBarrierToDestroy.push({
                        type: 'obstacle',
                        action: 'damage',
                        count: 0,
                        limit: 30,
                        complete: false,
                        cell: targetCell,
                      })


                       this.canPushObstacle(player,targetCell,'hitPush');
                    }

                    // DESTROY OBSTACLE W/ OR W/O RUBBLE
                    else if (targetCell.obstacle.hp - damage <= 0) {
                      let itemsToDrop = [];
                      if (targetCell.obstacle.destructible.leaveRubble === true) {
                        // console.log('leave rubble on ',targetCell.number,'removing obstacle');

                        if (targetCell.obstacle.items[0]) {
                          itemsToDrop = targetCell.obstacle.items;
                        }
                        targetCell.rubble = true;
                        // targetCell.terrain.type = 'hazard';

                        targetCell.obstacle = {
                          state: false,
                          name: targetCell.obstacle.name,
                          type: targetCell.obstacle.type,
                          hp: 0,
                          destructible: targetCell.obstacle.destructible,
                          locked: targetCell.obstacle.locked,
                          weight: targetCell.obstacle.weight,
                          height: targetCell.obstacle.height,
                          items: targetCell.obstacle.items,
                          effects: targetCell.obstacle.effects,
                          moving: targetCell.obstacle.moving
                        };

                        this.players[player.number-1].statusDisplay = {
                          state: true,
                          status: 'Destroyed '+targetCell.obstacle.name+'!',
                          count: 1,
                          limit: this.players[player.number-1].statusDisplay.limit,
                        }

                        if (!player.popups.find(x=>x.msg === 'destroyedItem')) {
                          player.popups.push(
                            {
                              state: false,
                              count: 0,
                              limit: 30,
                              type: '',
                              position: '',
                              msg: 'destroyedItem',
                              img: '',

                            }
                          )
                        }


                      } else {
                        // console.log('no rubble. Just remove obstacle');
                        if (targetCell.obstacle.items[0]) {
                          itemsToDrop = targetCell.obstacle.items;
                        }
                        // this.gridInfo.find(elem => elem.number.x === player.target.cell1.number.x && elem.number.y === player.target.cell1.number.y ).obstacle =


                        targetCell.obstacle = {
                          state: false,
                          name: targetCell.obstacle.name,
                          type: targetCell.obstacle.type,
                          hp: 0,
                          destructible: targetCell.obstacle.destructible,
                          locked: targetCell.obstacle.locked,
                          weight: targetCell.obstacle.weight,
                          height: targetCell.obstacle.height,
                          items: targetCell.obstacle.items,
                          effects: targetCell.obstacle.effects,
                          moving: targetCell.obstacle.moving
                        };

                        this.players[player.number-1].statusDisplay = {
                          state: true,
                          status: 'Destroyed '+targetCell.obstacle.name+'!',
                          count: 1,
                          limit: this.players[player.number-1].statusDisplay.limit,
                        }

                        if (!player.popups.find(x=>x.msg === 'destroyedItem')) {
                          player.popups.push(
                            {
                              state: false,
                              count: 0,
                              limit: 30,
                              type: '',
                              position: '',
                              msg: 'destroyedItem',
                              img: '',

                            }
                          )
                        }
                      }


                      // DROP OBSTACLE ITEMS?
                      if (itemsToDrop[0]) {
                        // console.log('dropping obstacle items melee',itemsToDrop);
                        this.obstacleItemDrop(targetCell,player);

                      }
                      this.obstacleBarrierToDestroy.push({
                        type: 'obstacle',
                        action: 'destroy',
                        count: 0,
                        limit: 30,
                        complete: false,
                        cell: targetCell,
                      })

                    }
                  }

                  // WEAPON NO GOOD. DEFLECT
                  else {
                    console.log('your current weapon cannot destroy this, you need ',targetCell.obstacle.destructible.weapons,'. Deflect player?');
                     let shouldDeflect = this.rnJesus(1,player.crits.guardBreak)

                     if (shouldDeflect === 1) {

                       if (this.rnJesus(1,player.crits.pushBack) === 1) {
                         this.setDeflection(player,'defended',true);
                       }
                       else {
                         this.setDeflection(player,'defended',false);
                       }

                       if (player.currentWeapon.name === '') {
                         console.log('this obstacle is stronger than your fist. Take damage?');
                         let takeDamage = this.rnJesus(1,player.crits.guardBreak);
                         if (takeDamage === 1) {

                           this.handleMiscPlayerDamage(player,"obstacleBarrierInvulnurable");

                         }
                       }

                     }
                     else {

                          this.pushBack(player,this.getOppositeDirection(player.direction))
                     }
                     if (this.rnJesus(1,1,player.crits.pushBack === 1)) {
                        this.canPushObstacle(player,targetCell,'hitPush');
                     }

                     if (!this.cellPopups.find(x => x.msg === "unbreakable" && x.cell.number.x === targetCell.number.x && x.cell.number.y === targetCell.number.y)) {
                       this.cellPopups.push(
                         {
                           state: false,
                           count: 0,
                           limit: 35,
                           type: '',
                           position: '',
                           msg: 'unbreakable',
                           color: '',
                           img: '',
                           cell: this.gridInfo.find(x => x.number.x === targetCell.number.x && x.number.y === targetCell.number.y)
                         }
                       )
                     }

                     // this.setDeflection(player,'defended',true);
                  }

                }

                // INDESTRUCTIBLE OBSTACLE
                else {

                  console.log('attacking invurnerable obstacle, deflect player?');

                   let shouldDeflect = this.rnJesus(1,player.crits.guardBreak)

                   if (shouldDeflect === 1) {

                     if (this.rnJesus(1,player.crits.pushBack) === 1) {
                       this.setDeflection(player,'defended',true);
                     }
                     else {
                       this.setDeflection(player,'defended',false);
                     }

                     if (player.currentWeapon.name === '') {
                       console.log('this obstacle is stronger than your fist. Take damage?');
                       let takeDamage = this.rnJesus(1,player.crits.guardBreak);
                       if (takeDamage === 1) {

                         this.handleMiscPlayerDamage(player,"obstacleBarrierInvulnurable");

                       }
                     }

                   }
                   else {

                        this.pushBack(player,this.getOppositeDirection(player.direction))
                   }
                   if (this.rnJesus(1,1,player.crits.pushBack === 1)) {
                      this.canPushObstacle(player,targetCell,'hitPush');
                   }

                   if (!this.cellPopups.find(x => x.msg === "unbreakable" && x.cell.number.x === targetCell.number.x && x.cell.number.y === targetCell.number.y)) {
                     this.cellPopups.push(
                       {
                         state: false,
                         count: 0,
                         limit: 35,
                         type: '',
                         position: '',
                         msg: 'unbreakable',
                         color: '',
                         img: '',
                         cell: this.gridInfo.find(x => x.number.x === targetCell.number.x && x.number.y === targetCell.number.y)
                       }
                     )
                   }


                   // this.setDeflection(player,'defended',false);

                }



              } else {

                // NO OBSTACLE. ITEM ON GROUND? DESTROY
                if (targetCell && targetCell.item.name !== "" && damage > 0 && player.currentWeapon.name !== '') {

                  this.players[player.number-1].statusDisplay = {
                    state: true,
                    status: 'Destroyed '+targetCell.item.name+'!',
                    count: 1,
                    limit: this.players[player.number-1].statusDisplay.limit,
                  }

                  if (!player.popups.find(x=>x.msg === 'destroyedItem')) {
                    player.popups.push(
                      {
                        state: false,
                        count: 0,
                        limit: 30,
                        type: '',
                        position: '',
                        msg: 'destroyedItem',
                        img: '',

                      }
                    )
                  }

                  this.gridInfo.find(elem => elem.number.x === player.target.cell1.number.x && elem.number.y === player.target.cell1.number.y ).item = {
                    name: '',
                    type: '',
                    subType: '',
                    effect: '',
                    initDrawn: false
                  }
                }

                if (targetCell.rubble === true & damage > 0) {
                  // console.log('damage/clear rubble');
                  this.gridInfo.find(elem => elem.number.x === player.target.cell1.number.x && elem.number.y === player.target.cell1.number.y ).rubble = false;

                }

                // NO OBSTACLE. ITEM OR RUBBLE. DESTROY REAR BARRIER

                // else {
                //   // do nothing
                // }
              }

            }

          }


          // CHECK 1ST CELL, TARGET 1
          if (player.currentWeapon.type === 'spear') {

            let myCellBarrier = false;
            if (myCell.barrier.state === true ) {
              if (myCell.barrier.position === player.direction) {
                  myCellBarrier = true;
                  if (myCell.barrier.destructible.state === true) {
                    // WEAPON CHECK
                    if (myCell.barrier.destructible.weapons.find(x => x === player.currentWeapon.name)) {
                      if (myCell.barrier.hp - damage > 0) {

                        let hp = myCell.barrier.hp - damage;

                        myCell.barrier =
                        {
                          state: myCell.barrier.state,
                          name: myCell.barrier.name,
                          type: myCell.barrier.type,
                          hp: hp,
                          destructible: myCell.barrier.destructible,
                          locked: myCell.barrier.locked,
                          position: myCell.barrier.position,
                          height: myCell.barrier.height,
                        };

                        this.obstacleBarrierToDestroy.push({
                          type: 'barrier',
                          action: 'damage',
                          count: 0,
                          limit: 30,
                          complete: false,
                          cell: myCell,
                        })
                      }

                      // DESTROY FWD BARRIER W/ OR W/O RUBBLE
                      else if (myCell.barrier.hp - damage <= 0) {
                        if (myCell.barrier.destructible.leaveRubble === true && myCell.obstacle.state !== true && myCell.item.name === "") {
                          // console.log('leave rubble on ',myCell.number,'removing barrier');
                          myCell.rubble = true;
                          // myCell.terrain.type = 'hazard';
                          myCell.barrier =
                          {
                            state: false,
                            name: myCell.barrier.name,
                            type: myCell.barrier.type,
                            hp: 0,
                            destructible: myCell.barrier.destructible,
                            locked: myCell.barrier.locked,
                            position: myCell.barrier.position,
                            height: myCell.barrier.height,
                          };

                          this.players[player.number-1].statusDisplay = {
                            state: true,
                            status: 'Destroyed '+myCell.barrier.name+'!',
                            count: 1,
                            limit: this.players[player.number-1].statusDisplay.limit,
                          }

                          if (!player.popups.find(x=>x.msg === 'destroyedItem')) {
                            player.popups.push(
                              {
                                state: false,
                                count: 0,
                                limit: 30,
                                type: '',
                                position: '',
                                msg: 'destroyedItem',
                                img: '',

                              }
                            )
                          }
                        } else {
                          // console.log('no rubble. Just remove barrier');

                          myCell.barrier =
                          {
                            state: false,
                            name: myCell.barrier.name,
                            type: myCell.barrier.type,
                            hp: 0,
                            destructible: myCell.barrier.destructible,
                            locked: myCell.barrier.locked,
                            position: myCell.barrier.position,
                            height: myCell.barrier.height,
                          };

                          this.players[player.number-1].statusDisplay = {
                            state: true,
                            status: 'Destroyed '+myCell.barrier.name+'!',
                            count: 1,
                            limit: this.players[player.number-1].statusDisplay.limit,
                          }

                          if (!player.popups.find(x=>x.msg === 'destroyedItem')) {
                            player.popups.push(
                              {
                                state: false,
                                count: 0,
                                limit: 30,
                                type: '',
                                position: '',
                                msg: 'destroyedItem',
                                img: '',

                              }
                            )
                          }

                        }

                        this.obstacleBarrierToDestroy.push({
                          type: 'barrier',
                          action: 'destroy',
                          count: 0,
                          limit: 30,
                          complete: false,
                          cell: myCell,
                        })

                      }
                    }

                    // WEAPON NO GOOD. DEFLECT
                    else {
                      console.log('your current weapon cannot destroy this, you need ',myCell.barrier.destructible.weapons,'. Deflect player?');
                       let shouldDeflect = this.rnJesus(1,player.crits.guardBreak)
                       if (shouldDeflect === 1) {

                         if (this.rnJesus(1,player.crits.pushBack) === 1) {
                           this.setDeflection(player,'defended',true);
                         }
                         else {
                           this.setDeflection(player,'defended',false);
                         }

                         if (player.currentWeapon.name === '') {
                           console.log('this barrier is stronger than your fist. Take damage?');
                           let takeDamage = this.rnJesus(1,player.crits.guardBreak);
                           if (takeDamage === 1) {

                             this.handleMiscPlayerDamage(player,"obstacleBarrierInvulnurable");

                           }
                         }

                       }
                       else {

                            this.pushBack(player,this.getOppositeDirection(player.direction))
                       }

                       if (!this.cellPopups.find(x => x.msg === "unbreakable" && x.cell.number.x === myCell.number.x && x.cell.number.y === myCell.number.y)) {
                         this.cellPopups.push(
                           {
                             state: false,
                             count: 0,
                             limit: 35,
                             type: '',
                             position: '',
                             msg: 'unbreakable',
                             color: '',
                             img: '',
                             cell: this.gridInfo.find(x => x.number.x === myCell.number.x && x.number.y === myCell.number.y)
                           }
                         )
                       }
                    }

                  }

                  // INDESTRUCTIBLE MY CELL BARRIER
                  else {
                    console.log('attacking invurnerable barrier, deflect player?');
                     let shouldDeflect = this.rnJesus(1,player.crits.guardBreak)
                     if (shouldDeflect === 1) {

                       if (this.rnJesus(1,player.crits.pushBack) === 1) {
                         this.setDeflection(player,'defended',true);
                       }
                       else {
                         this.setDeflection(player,'defended',false);
                       }

                       if (player.currentWeapon.name === '') {
                         console.log('this barrier is stronger than your fist. Take damage?');
                         let takeDamage = this.rnJesus(1,player.crits.guardBreak);
                         if (takeDamage === 1) {

                           this.handleMiscPlayerDamage(player,"obstacleBarrierInvulnurable");

                         }
                       }

                     }
                     else {

                          this.pushBack(player,this.getOppositeDirection(player.direction))
                     }

                     if (!this.cellPopups.find(x => x.msg === "unbreakable" && x.cell.number.x === myCell.number.x && x.cell.number.y === myCell.number.y)) {
                       this.cellPopups.push(
                         {
                           state: false,
                           count: 0,
                           limit: 35,
                           type: '',
                           position: '',
                           msg: 'unbreakable',
                           color: '',
                           img: '',
                           cell: this.gridInfo.find(x => x.number.x === myCell.number.x && x.number.y === myCell.number.y)
                         }
                       )
                     }
                  }
              }
            }

            // FWD BARRIER?
            let fwdBarrier = false;
            if (targetCell.barrier.state === true) {
              fwdBarrier = this.checkForwardBarrier(player.direction,targetCell);
            }



            if (myCellBarrier !== true && fwdBarrier === true) {

              if (targetCell.barrier.destructible.state === true) {
                // WEAPON CHECK
                if (targetCell.barrier.destructible.weapons.find(x => x === player.currentWeapon.name)) {

                  if (targetCell.barrier.hp - damage > 0) {
                    // this.gridInfo.find(elem => elem.number.x === player.target.cell1.number.x && elem.number.y === player.target.cell1.number.y ).barrier.hp -= damage;

                    let hp = targetCell.barrier.hp - damage;

                    targetCell.barrier = {
                      state: targetCell.barrier.state,
                      name: targetCell.barrier.name,
                      type: targetCell.barrier.type,
                      hp: hp,
                      destructible: targetCell.barrier.destructible,
                      locked: targetCell.barrier.locked,
                      position: targetCell.barrier.position,
                      height: targetCell.barrier.height,
                    };

                    this.obstacleBarrierToDestroy.push({
                      type: 'barrier',
                      action: 'damage',
                      count: 0,
                      limit: 30,
                      complete: false,
                      cell: targetCell,
                    })
                  }

                  // DESTROY FWD BARRIER W/ OR W/O RUBBLE
                  else if (targetCell.barrier.hp - damage <= 0) {

                    if (targetCell.barrier.destructible.leaveRubble === true && targetCell.obstacle.state !== true && targetCell.item.name === "") {

                      // console.log('leave rubble on ',targetCell2.number,'removing barrier');
                      targetCell.rubble = true;
                      // targetCell2.terrain.type = 'hazard';
                      targetCell.barrier = {
                        state: false,
                        name: targetCell.barrier.name,
                        type: targetCell.barrier.type,
                        hp: 0,
                        destructible: targetCell.barrier.destructible,
                        locked: targetCell.barrier.locked,
                        position: targetCell.barrier.position,
                        height: targetCell.barrier.height,
                      };

                      this.players[player.number-1].statusDisplay = {
                        state: true,
                        status: 'Destroyed '+targetCell.barrier.name+'!',
                        count: 1,
                        limit: this.players[player.number-1].statusDisplay.limit,
                      }

                      if (!player.popups.find(x=>x.msg === 'destroyedItem')) {
                        player.popups.push(
                          {
                            state: false,
                            count: 0,
                            limit: 30,
                            type: '',
                            position: '',
                            msg: 'destroyedItem',
                            img: '',

                          }
                        )
                      }

                    } else {
                      // console.log('no rubble. Just remove barrier');

                      targetCell.barrier = {
                        state: false,
                        name: targetCell.barrier.name,
                        type: targetCell.barrier.type,
                        hp: 0,
                        destructible: targetCell.barrier.destructible,
                        locked: targetCell.barrier.locked,
                        position: targetCell.barrier.position,
                        height: targetCell.barrier.height,
                      };

                      this.players[player.number-1].statusDisplay = {
                        state: true,
                        status: 'Destroyed '+targetCell.barrier.name+'!',
                        count: 1,
                        limit: this.players[player.number-1].statusDisplay.limit,
                      }

                      if (!player.popups.find(x=>x.msg === 'destroyedItem')) {
                        player.popups.push(
                          {
                            state: false,
                            count: 0,
                            limit: 30,
                            type: '',
                            position: '',
                            msg: 'destroyedItem',
                            img: '',

                          }
                        )
                      }

                    }

                    this.obstacleBarrierToDestroy.push({
                      type: 'barrier',
                      action: 'destroy',
                      count: 0,
                      limit: 30,
                      complete: false,
                      cell: targetCell,
                    })

                  }

                }

                // WEAPON NO GOOD. DEFLECT
                else {
                  console.log('your current weapon cannot destroy this, you need ',targetCell2.barrier.destructible.weapons,'. Deflect player?');
                   let shouldDeflect = this.rnJesus(1,player.crits.guardBreak)

                   if (shouldDeflect === 1) {

                     if (this.rnJesus(1,player.crits.pushBack) === 1) {
                       this.setDeflection(player,'defended',true);
                     }
                     else {
                       this.setDeflection(player,'defended',false);
                     }

                     if (player.currentWeapon.name === '') {
                       console.log('this barrier is stronger than your fist. Take damage?');
                       let takeDamage = this.rnJesus(1,player.crits.guardBreak);
                       if (takeDamage === 1) {

                         this.handleMiscPlayerDamage(player,"obstacleBarrierInvulnurable");

                       }
                     }

                   }
                   else {

                        this.pushBack(player,this.getOppositeDirection(player.direction))
                   }

                   if (!this.cellPopups.find(x => x.msg === "unbreakable" && x.cell.number.x === targetCell2.number.x && x.cell.number.y === targetCell2.number.y)) {
                     this.cellPopups.push(
                       {
                         state: false,
                         count: 0,
                         limit: 35,
                         type: '',
                         position: '',
                         msg: 'unbreakable',
                         color: '',
                         img: '',
                         cell: this.gridInfo.find(x => x.number.x === targetCell2.number.x && x.number.y === targetCell2.number.y)
                       }
                     )
                   }
                }

              }

              // INDESTRUCTIBLE FWD BARRIER
              else {

                console.log('attacking invurnerable barrier, deflect player?');
                 let shouldDeflect = this.rnJesus(1,player.crits.guardBreak)
                 if (shouldDeflect === 1) {

                   if (this.rnJesus(1,player.crits.pushBack) === 1) {
                     this.setDeflection(player,'defended',true);
                   }
                   else {
                     this.setDeflection(player,'defended',false);
                   }

                   if (player.currentWeapon.name === '') {
                     console.log('this barrier is stronger than your fist. Take damage?');
                     let takeDamage = this.rnJesus(1,player.crits.guardBreak);
                     if (takeDamage === 1) {

                       this.handleMiscPlayerDamage(player,"obstacleBarrierInvulnurable");

                     }
                   }

                 }
                 else {

                      this.pushBack(player,this.getOppositeDirection(player.direction))
                 }


                 if (!this.cellPopups.find(x => x.msg === "unbreakable" && x.cell.number.x === targetCell2.number.x && x.cell.number.y === targetCell2.number.y)) {
                   this.cellPopups.push(
                     {
                       state: false,
                       count: 0,
                       limit: 35,
                       type: '',
                       position: '',
                       msg: 'unbreakable',
                       color: '',
                       img: '',
                       cell: this.gridInfo.find(x => x.number.x === targetCell2.number.x && x.number.y === targetCell2.number.y)
                     }
                   )
                 }
              }

            }

            // NO FWD BARRIER. OBSTACLE, REAR  BARRIER (SPEAR)?
            else if (myCellBarrier !== true && fwdBarrier !== true) {

              if (targetCell.obstacle.state === true) {

                if (targetCell.obstacle.destructible.state === true) {
                  // WEAPON CHECK
                  if (targetCell.obstacle.destructible.weapons.find(x => x === player.currentWeapon.name)) {
                    if (targetCell.obstacle.hp - damage > 0) {
                      let hp = targetCell.obstacle.hp - damage;
                      targetCell.obstacle = {
                        state: targetCell.obstacle.state,
                        name: targetCell.obstacle.name,
                        type: targetCell.obstacle.type,
                        hp: hp,
                        destructible: targetCell.obstacle.destructible,
                        locked: targetCell.obstacle.locked,
                        weight: targetCell.obstacle.weight,
                        height: targetCell.obstacle.height,
                        items: targetCell.obstacle.items,
                        effects: targetCell.obstacle.effects,
                        moving: targetCell.obstacle.moving
                      };

                      this.obstacleBarrierToDestroy.push({
                        type: 'obstacle',
                        action: 'damage',
                        count: 0,
                        limit: 30,
                        complete: false,
                        cell: targetCell,
                      })

                      this.canPushObstacle(player,targetCell,'hitPush');
                    }

                    // DESTROY OBSTACLE W/ OR W/O RUBBLE
                    else if (targetCell.obstacle.hp - damage <= 0) {
                      let itemsToDrop = [];
                      if (targetCell.obstacle.destructible.leaveRubble === true) {
                        // console.log('leave rubble on ',targetCell2.number,'removing obstacle');

                        if (targetCell.obstacle.items[0]) {
                          itemsToDrop = targetCell.obstacle.items;
                        }
                        targetCell.rubble = true;
                        // targetCell2.terrain.type = 'hazard';

                        targetCell.obstacle = {
                          state: false,
                          name: targetCell.obstacle.name,
                          type: targetCell.obstacle.type,
                          hp: 0,
                          destructible: targetCell.obstacle.destructible,
                          locked: targetCell.obstacle.locked,
                          weight: targetCell.obstacle.weight,
                          height: targetCell.obstacle.height,
                          items: targetCell.obstacle.items,
                          effects: targetCell.obstacle.effects,
                          moving: targetCell.obstacle.moving
                        };

                        this.players[player.number-1].statusDisplay = {
                          state: true,
                          status: 'Destroyed '+targetCell.obstacle.name+'!',
                          count: 1,
                          limit: this.players[player.number-1].statusDisplay.limit,
                        }

                        if (!player.popups.find(x=>x.msg === 'destroyedItem')) {
                          player.popups.push(
                            {
                              state: false,
                              count: 0,
                              limit: 30,
                              type: '',
                              position: '',
                              msg: 'destroyedItem',
                              img: '',

                            }
                          )
                        }


                      } else {
                        // console.log('no rubble. Just remove obstacle');
                        if (targetCell.obstacle.items[0]) {
                          itemsToDrop = targetCell.obstacle.items;
                        }

                        targetCell.obstacle = {
                          state: false,
                          name: targetCell.obstacle.name,
                          type: targetCell.obstacle.type,
                          hp: 0,
                          destructible: targetCell.obstacle.destructible,
                          locked: targetCell.obstacle.locked,
                          weight: targetCell.obstacle.weight,
                          height: targetCell.obstacle.height,
                          items: targetCell.obstacle.items,
                          effects: targetCell.obstacle.effects,
                          moving: targetCell.obstacle.moving
                        };

                        this.players[player.number-1].statusDisplay = {
                          state: true,
                          status: 'Destroyed '+targetCell.obstacle.name+'!',
                          count: 1,
                          limit: this.players[player.number-1].statusDisplay.limit,
                        }

                        if (!player.popups.find(x=>x.msg === 'destroyedItem')) {
                          player.popups.push(
                            {
                              state: false,
                              count: 0,
                              limit: 30,
                              type: '',
                              position: '',
                              msg: 'destroyedItem',
                              img: '',

                            }
                          )
                        }
                      }


                      // DROP OBSTACLE ITEMS?
                      if (itemsToDrop[0]) {
                        // console.log('dropping obstacle items melee',itemsToDrop);

                        this.obstacleItemDrop(targetCell,player);

                      }


                      this.obstacleBarrierToDestroy.push({
                        type: 'obstacle',
                        action: 'destroy',
                        count: 0,
                        limit: 30,
                        complete: false,
                        cell: targetCell,
                      })

                    }
                  }

                  // WEAPON NO GOOD. DEFLECT
                  else {
                    console.log('your current weapon cannot destroy this, you need ',targetCell.obstacle.destructible.weapons,'. Deflect player?');
                     let shouldDeflect = this.rnJesus(1,player.crits.guardBreak)

                     if (shouldDeflect === 1) {

                       if (this.rnJesus(1,player.crits.pushBack) === 1) {
                         this.setDeflection(player,'defended',true);
                       }
                       else {
                         this.setDeflection(player,'defended',false);
                       }

                       if (player.currentWeapon.name === '') {
                         console.log('this obstacle is stronger than your fist. Take damage?');
                         let takeDamage = this.rnJesus(1,player.crits.guardBreak);
                         if (takeDamage === 1) {

                           this.handleMiscPlayerDamage(player,"obstacleBarrierInvulnurable");

                         }
                       }

                     }
                     else {

                          this.pushBack(player,this.getOppositeDirection(player.direction))
                     }

                     if (!this.cellPopups.find(x => x.msg === "unbreakable" && x.cell.number.x === targetCell.number.x && x.cell.number.y === targetCell.number.y)) {
                       this.cellPopups.push(
                         {
                           state: false,
                           count: 0,
                           limit: 35,
                           type: '',
                           position: '',
                           msg: 'unbreakable',
                           color: '',
                           img: '',
                           cell: this.gridInfo.find(x => x.number.x === targetCell.number.x && x.number.y === targetCell.number.y)
                         }
                       )
                     }

                  }

                }

                // INDESTRUCTIBLE OBSTACLE
                else {

                  console.log('attacking invurnerable obstacle, deflect player?');
                   let shouldDeflect = this.rnJesus(1,player.crits.guardBreak)

                   if (shouldDeflect === 1) {

                     if (this.rnJesus(1,player.crits.pushBack) === 1) {
                       this.setDeflection(player,'defended',true);
                     }
                     else {
                       this.setDeflection(player,'defended',false);
                     }

                     if (player.currentWeapon.name === '') {
                       console.log('this obstacle is stronger than your fist. Take damage?');
                       let takeDamage = this.rnJesus(1,player.crits.guardBreak);
                       if (takeDamage === 1) {

                         this.handleMiscPlayerDamage(player,"obstacleBarrierInvulnurable");

                       }
                     }

                   }
                   else {

                        this.pushBack(player,this.getOppositeDirection(player.direction))
                   }
                   if (this.rnJesus(1,1,player.crits.pushBack === 1)) {
                      this.canPushObstacle(player,targetCell,'hitPush');
                   }

                   if (!this.cellPopups.find(x => x.msg === "unbreakable" && x.cell.number.x === targetCell.number.x && x.cell.number.y === targetCell.number.y)) {
                     this.cellPopups.push(
                       {
                         state: false,
                         count: 0,
                         limit: 35,
                         type: '',
                         position: '',
                         msg: 'unbreakable',
                         color: '',
                         img: '',
                         cell: this.gridInfo.find(x => x.number.x === targetCell.number.x && x.number.y === targetCell.number.y)
                       }
                     )
                   }

                   // this.setDeflection(player,'defended',false);
                }



              }
              else {

                // NO OBSTACLE. ITEM ON GROUND? DESTROY
                if (targetCell && targetCell.item.name !== "" && damage > 0 && player.currentWeapon.name !== '') {

                  this.players[player.number-1].statusDisplay = {
                    state: true,
                    status: 'Destroyed '+targetCell.item.name+'!',
                    count: 1,
                    limit: this.players[player.number-1].statusDisplay.limit,
                  }

                  if (!player.popups.find(x=>x.msg === 'destroyedItem')) {
                    player.popups.push(
                      {
                        state: false,
                        count: 0,
                        limit: 30,
                        type: '',
                        position: '',
                        msg: 'destroyedItem',
                        img: '',

                      }
                    )
                  }

                  this.gridInfo.find(elem => elem.number.x === targetCell.number.x && elem.number.y === targetCell.number.y ).item = {
                    name: '',
                    type: '',
                    subType: '',
                    effect: '',
                    initDrawn: false
                  }
                }

                if (targetCell.rubble === true & damage > 0) {
                  // console.log('damage/clear rubble @ ',targetCell2.number);
                  this.gridInfo.find(elem => elem.number.x === targetCell.number.x && elem.number.y === targetCell.number.y ).rubble = false;

                }

                // NO OBSTACLE. ITEM OR RUBBLE. DESTROY REAR BARRIER

                if (player.currentWeapon.type === 'spear' && targetCell.item.name === "" && targetCell.rubble !== true) {
                  let rearBarrier = false;
                  if (targetCell.barrier.state === true) {
                    if (player.direction === targetCell.barrier.position) {
                      rearBarrier = true;
                    }
                  }
                  if (rearBarrier === true) {

                    if (targetCell.barrier.destructible.state === true) {
                      // WEAPON CHECK
                      if (targetCell.barrier.destructible.weapons.find(x => x === player.currentWeapon.name)) {
                        if (targetCell.barrier.hp - damage > 0) {

                          let hp = targetCell.barrier.hp - damage;
                          targetCell.barrier = {
                            state: targetCell.barrier.state,
                            name: targetCell.barrier.name,
                            type: targetCell.barrier.type,
                            hp: hp,
                            destructible: targetCell.barrier.destructible,
                            locked: targetCell.barrier.locked,
                            position: targetCell.barrier.position,
                            height: targetCell.barrier.height,
                          };

                          this.obstacleBarrierToDestroy.push({
                            type: 'barrier',
                            action: 'damage',
                            count: 0,
                            limit: 30,
                            complete: false,
                            cell: targetCell,
                          })
                        }

                        // DESTROY FWD BARRIER W/ OR W/O RUBBLE
                        else if (targetCell.barrier.hp - damage <= 0) {
                          if (targetCell.barrier.destructible.leaveRubble === true && targetCell.obstacle.state !== true && targetCell.item.name === "") {
                            // console.log('leave rubble on ',targetCell2.number,'removing barrier');
                            targetCell.rubble = true;
                            // targetCell2.terrain.type = 'hazard';
                            targetCell.barrier = {
                              state: false,
                              name: targetCell.barrier.name,
                              type: targetCell.barrier.type,
                              hp: 0,
                              destructible: targetCell.barrier.destructible,
                              locked: targetCell.barrier.locked,
                              position: targetCell.barrier.position,
                              height: targetCell.barrier.height,
                            };

                            this.players[player.number-1].statusDisplay = {
                              state: true,
                              status: 'Destroyed '+targetCell.barrier.name+'!',
                              count: 1,
                              limit: this.players[player.number-1].statusDisplay.limit,
                            }

                            if (!player.popups.find(x=>x.msg === 'destroyedItem')) {
                              player.popups.push(
                                {
                                  state: false,
                                  count: 0,
                                  limit: 30,
                                  type: '',
                                  position: '',
                                  msg: 'destroyedItem',
                                  img: '',

                                }
                              )
                            }
                          } else {
                            // console.log('no rubble. Just remove barrier');
                            targetCell.barrier = {
                              state: false,
                              name: targetCell.barrier.name,
                              type: targetCell.barrier.type,
                              hp: 0,
                              destructible: targetCell.barrier.destructible,
                              locked: targetCell.barrier.locked,
                              position: targetCell.barrier.position,
                              height: targetCell.barrier.height,
                            };

                            this.players[player.number-1].statusDisplay = {
                              state: true,
                              status: 'Destroyed '+targetCell.barrier.name+'!',
                              count: 1,
                              limit: this.players[player.number-1].statusDisplay.limit,
                            }

                            if (!player.popups.find(x=>x.msg === 'destroyedItem')) {
                              player.popups.push(
                                {
                                  state: false,
                                  count: 0,
                                  limit: 30,
                                  type: '',
                                  position: '',
                                  msg: 'destroyedItem',
                                  img: '',

                                }
                              )
                            }
                          }

                          this.obstacleBarrierToDestroy.push({
                            type: 'barrier',
                            action: 'destroy',
                            count: 0,
                            limit: 30,
                            complete: false,
                            cell: targetCell,
                          })

                        }
                      }

                      // WEAPON NO GOOD. DEFLECT
                      else {
                        console.log('your current weapon cannot destroy this, you need ',targetCell.barrier.destructible.weapons,'. Deflect player?');
                        if (!this.cellPopups.find(x => x.msg === "unbreakable" && x.cell.number.x === targetCell.number.x && x.cell.number.y === targetCell2.number.y)) {
                          this.cellPopups.push(
                            {
                              state: false,
                              count: 0,
                              limit: 35,
                              type: '',
                              position: '',
                              msg: 'unbreakable',
                              color: '',
                              img: '',
                              cell: this.gridInfo.find(x => x.number.x === targetCell.number.x && x.number.y === targetCell.number.y)
                            }
                          )
                        }
                      }

                    }

                    // INDESTRUCTIBLE FWD BARRIER
                    else {
                      console.log('attacking invurnerable barrier');
                      if (!this.cellPopups.find(x => x.msg === "unbreakable" && x.cell.number.x === targetCell.number.x && x.cell.number.y === targetCell.number.y)) {
                        this.cellPopups.push(
                          {
                            state: false,
                            count: 0,
                            limit: 35,
                            type: '',
                            position: '',
                            msg: 'unbreakable',
                            color: '',
                            img: '',
                            cell: this.gridInfo.find(x => x.number.x === targetCell.number.x && x.number.y === targetCell.number.y)
                          }
                        )
                      }
                    }
                  }
                  else {
                    // console.log('spear target one no obstructions, atk spear target 2');
                    checkSpearTarget = true;
                  }
                }
                // else {
                //   // do nothing
                // }
              }

            }

          }

          // CHECK 2ND CELL TARGET 2
          if (player.currentWeapon.type === 'spear' && checkSpearTarget === true) {

            let targetCell2 = this.gridInfo.find(elem => elem.number.x === player.target.cell2.number.x && elem.number.y === player.target.cell2.number.y)

            let myCellBarrier = false;
            if (myCell.barrier.state === true ) {
              if (myCell.barrier.position === player.direction) {
                  myCellBarrier = true;
                  if (myCell.barrier.destructible.state === true) {
                    // WEAPON CHECK
                    if (myCell.barrier.destructible.weapons.find(x => x === player.currentWeapon.name)) {

                      if (myCell.barrier.hp - damage > 0) {

                        let hp = myCell.barrier.hp - damage;

                        myCell.barrier =
                        {
                          state: myCell.barrier.state,
                          name: myCell.barrier.name,
                          type: myCell.barrier.type,
                          hp: hp,
                          destructible: myCell.barrier.destructible,
                          locked: myCell.barrier.locked,
                          position: myCell.barrier.position,
                          height: myCell.barrier.height,
                        };

                        this.obstacleBarrierToDestroy.push({
                          type: 'barrier',
                          action: 'damage',
                          count: 0,
                          limit: 30,
                          complete: false,
                          cell: myCell,
                        })
                      }

                      // DESTROY FWD BARRIER W/ OR W/O RUBBLE
                      else if (myCell.barrier.hp - damage <= 0) {
                        if (myCell.barrier.destructible.leaveRubble === true && myCell.obstacle.state !== true && myCell.item.name === "") {
                          // console.log('leave rubble on ',myCell.number,'removing barrier');
                          myCell.rubble = true;
                          // myCell.terrain.type = 'hazard';
                          myCell.barrier =
                          {
                            state: false,
                            name: myCell.barrier.name,
                            type: myCell.barrier.type,
                            hp: 0,
                            destructible: myCell.barrier.destructible,
                            locked: myCell.barrier.locked,
                            position: myCell.barrier.position,
                            height: myCell.barrier.height,
                          };

                          this.players[player.number-1].statusDisplay = {
                            state: true,
                            status: 'Destroyed '+myCell.barrier.name+'!',
                            count: 1,
                            limit: this.players[player.number-1].statusDisplay.limit,
                          }

                          if (!player.popups.find(x=>x.msg === 'destroyedItem')) {
                            player.popups.push(
                              {
                                state: false,
                                count: 0,
                                limit: 30,
                                type: '',
                                position: '',
                                msg: 'destroyedItem',
                                img: '',

                              }
                            )
                          }
                        } else {
                          // console.log('no rubble. Just remove barrier');

                          myCell.barrier =
                          {
                            state: false,
                            name: myCell.barrier.name,
                            type: myCell.barrier.type,
                            hp: 0,
                            destructible: myCell.barrier.destructible,
                            locked: myCell.barrier.locked,
                            position: myCell.barrier.position,
                            height: myCell.barrier.height,
                          };

                          this.players[player.number-1].statusDisplay = {
                            state: true,
                            status: 'Destroyed '+myCell.barrier.name+'!',
                            count: 1,
                            limit: this.players[player.number-1].statusDisplay.limit,
                          }

                          if (!player.popups.find(x=>x.msg === 'destroyedItem')) {
                            player.popups.push(
                              {
                                state: false,
                                count: 0,
                                limit: 30,
                                type: '',
                                position: '',
                                msg: 'destroyedItem',
                                img: '',

                              }
                            )
                          }
                        }

                        this.obstacleBarrierToDestroy.push({
                          type: 'barrier',
                          action: 'destroy',
                          count: 0,
                          limit: 30,
                          complete: false,
                          cell: myCell,
                        })

                      }
                    }

                    // WEAPON NO GOOD. DEFLECT
                    else {
                      console.log('your current weapon cannot destroy this, you need ',myCell.barrier.destructible.weapons,'. Deflect player?');
                       let shouldDeflect = this.rnJesus(1,player.crits.guardBreak)


                       if (shouldDeflect === 1) {

                         if (this.rnJesus(1,player.crits.pushBack) === 1) {
                           this.setDeflection(player,'defended',true);
                         }
                         else {
                           this.setDeflection(player,'defended',false);
                         }

                         if (player.currentWeapon.name === '') {
                           console.log('this barrier is stronger than your fist. Take damage?');
                           let takeDamage = this.rnJesus(1,player.crits.guardBreak);
                           if (takeDamage === 1) {

                             this.handleMiscPlayerDamage(player,"obstacleBarrierInvulnurable");

                           }
                         }

                       }
                       else {

                            this.pushBack(player,this.getOppositeDirection(player.direction))
                       }


                       if (!this.cellPopups.find(x => x.msg === "unbreakable" && x.cell.number.x === myCell.number.x && x.cell.number.y === myCell.number.y)) {
                         this.cellPopups.push(
                           {
                             state: false,
                             count: 0,
                             limit: 35,
                             type: '',
                             position: '',
                             msg: 'unbreakable',
                             color: '',
                             img: '',
                             cell: this.gridInfo.find(x => x.number.x === myCell.number.x && x.number.y === myCell.number.y)
                           }
                         )
                       }
                    }

                  }

                  // INDESTRUCTIBLE MY CELL BARRIER
                  else {
                    console.log('attacking invurnerable barrier, deflect player?');
                     let shouldDeflect = this.rnJesus(1,player.crits.guardBreak)

                     if (shouldDeflect === 1) {

                       if (this.rnJesus(1,player.crits.pushBack) === 1) {
                         this.setDeflection(player,'defended',true);
                       }
                       else {
                         this.setDeflection(player,'defended',false);
                       }

                       if (player.currentWeapon.name === '') {
                         console.log('this barrier is stronger than your fist. Take damage?');
                         let takeDamage = this.rnJesus(1,player.crits.guardBreak);
                         if (takeDamage === 1) {

                           this.handleMiscPlayerDamage(player,"obstacleBarrierInvulnurable");

                         }
                       }

                     }
                     else {

                          this.pushBack(player,this.getOppositeDirection(player.direction))
                     }

                     if (!this.cellPopups.find(x => x.msg === "unbreakable" && x.cell.number.x === myCell.number.x && x.cell.number.y === myCell.number.y)) {
                       this.cellPopups.push(
                         {
                           state: false,
                           count: 0,
                           limit: 35,
                           type: '',
                           position: '',
                           msg: 'unbreakable',
                           color: '',
                           img: '',
                           cell: this.gridInfo.find(x => x.number.x === myCell.number.x && x.number.y === myCell.number.y)
                         }
                       )
                     }
                  }
              }
            }

            if (targetCell2) {

              let fwdBarrier = false;
              if (targetCell2.barrier.state === true) {
                fwdBarrier = this.checkForwardBarrier(player.direction,targetCell2);
              }

              if (fwdBarrier === true) {

                if (targetCell2.barrier.destructible.state === true) {

                  // WEAPON CHECK
                  if (targetCell2.barrier.destructible.weapons.find(x => x === player.currentWeapon.name)) {
                    if (targetCell2.barrier.hp - damage > 0) {

                      let hp = targetCell2.barrier.hp - damage;
                      targetCell2.barrier = {
                        state: targetCell2.barrier.state,
                        name: targetCell2.barrier.name,
                        type: targetCell2.barrier.type,
                        hp: hp,
                        destructible: targetCell2.barrier.destructible,
                        locked: targetCell2.barrier.locked,
                        position: targetCell2.barrier.position,
                        height: targetCell2.barrier.height,
                      };

                      this.obstacleBarrierToDestroy.push({
                        type: 'barrier',
                        action: 'damage',
                        count: 0,
                        limit: 30,
                        complete: false,
                        cell: targetCell2,
                      })
                    }

                    // DESTROY FWD BARRIER W/ OR W/O RUBBLE
                    else if (targetCell2.barrier.hp - damage <= 0) {
                      if (targetCell2.barrier.destructible.leaveRubble === true && targetCell2.obstacle.state !== true && targetCell2.item.name === "") {
                        // console.log('leave rubble on ',targetCell2.number,'removing barrier');
                        targetCell2.rubble = true;
                        // targetCell2.terrain.type = 'hazard';
                        targetCell2.barrier = {
                          state: false,
                          name: targetCell2.barrier.name,
                          type: targetCell2.barrier.type,
                          hp: 0,
                          destructible: targetCell2.barrier.destructible,
                          locked: targetCell2.barrier.locked,
                          position: targetCell2.barrier.position,
                          height: targetCell2.barrier.height,
                        };

                        this.players[player.number-1].statusDisplay = {
                          state: true,
                          status: 'Destroyed '+targetCell2.barrier.name+'!',
                          count: 1,
                          limit: this.players[player.number-1].statusDisplay.limit,
                        }

                        if (!player.popups.find(x=>x.msg === 'destroyedItem')) {
                          player.popups.push(
                            {
                              state: false,
                              count: 0,
                              limit: 30,
                              type: '',
                              position: '',
                              msg: 'destroyedItem',
                              img: '',

                            }
                          )
                        }
                      } else {
                        // console.log('no rubble. Just remove barrier');
                        targetCell2.barrier = {
                          state: false,
                          name: targetCell2.barrier.name,
                          type: targetCell2.barrier.type,
                          hp: 0,
                          destructible: targetCell2.barrier.destructible,
                          locked: targetCell2.barrier.locked,
                          position: targetCell2.barrier.position,
                          height: targetCell2.barrier.height,
                        };

                        this.players[player.number-1].statusDisplay = {
                          state: true,
                          status: 'Destroyed '+targetCell2.barrier.name+'!',
                          count: 1,
                          limit: this.players[player.number-1].statusDisplay.limit,
                        }

                        if (!player.popups.find(x=>x.msg === 'destroyedItem')) {
                          player.popups.push(
                            {
                              state: false,
                              count: 0,
                              limit: 30,
                              type: '',
                              position: '',
                              msg: 'destroyedItem',
                              img: '',

                            }
                          )
                        }
                      }

                      this.obstacleBarrierToDestroy.push({
                        type: 'barrier',
                        action: 'destroy',
                        count: 0,
                        limit: 30,
                        complete: false,
                        cell: targetCell2,
                      })

                    }
                  }

                  // WEAPON NO GOOD. DEFLECT
                  else {
                    console.log('your current weapon cannot destroy this, you need ',targetCell2.barrier.destructible.weapons,'. Deflect player?');
                     let shouldDeflect = this.rnJesus(1,player.crits.guardBreak);

                     if (shouldDeflect === 1) {

                       if (this.rnJesus(1,player.crits.pushBack) === 1) {
                         this.setDeflection(player,'defended',true);
                       }
                       else {
                         this.setDeflection(player,'defended',false);
                       }

                       if (player.currentWeapon.name === '') {
                         console.log('this barrier is stronger than your fist. Take damage?');
                         let takeDamage = this.rnJesus(1,player.crits.guardBreak);
                         if (takeDamage === 1) {

                           this.handleMiscPlayerDamage(player,"obstacleBarrierInvulnurable");

                         }
                       }

                     }
                     else {

                          this.pushBack(player,this.getOppositeDirection(player.direction))
                     }

                     if (!this.cellPopups.find(x => x.msg === "unbreakable" && x.cell.number.x === targetCell2.number.x && x.cell.number.y === targetCell2.number.y)) {
                       this.cellPopups.push(
                         {
                           state: false,
                           count: 0,
                           limit: 35,
                           type: '',
                           position: '',
                           msg: 'unbreakable',
                           color: '',
                           img: '',
                           cell: this.gridInfo.find(x => x.number.x === targetCell2.number.x && x.number.y === targetCell2.number.y)
                         }
                       )
                     }
                  }

                }

                // INDESTRUCTIBLE FWD BARRIER
                else {
                  console.log('attacking invurnerable barrier, deflect player?');
                   let shouldDeflect = this.rnJesus(1,player.crits.guardBreak)

                   if (shouldDeflect === 1) {

                     if (this.rnJesus(1,player.crits.pushBack) === 1) {
                       this.setDeflection(player,'defended',true);
                     }
                     else {
                       this.setDeflection(player,'defended',false);
                     }

                     if (player.currentWeapon.name === '') {
                       console.log('this barrier is stronger than your fist. Take damage?');
                       let takeDamage = this.rnJesus(1,player.crits.guardBreak);
                       if (takeDamage === 1) {

                         this.handleMiscPlayerDamage(player,"obstacleBarrierInvulnurable");

                       }
                     }

                   }
                   else {

                        this.pushBack(player,this.getOppositeDirection(player.direction))
                   }

                   if (!this.cellPopups.find(x => x.msg === "unbreakable" && x.cell.number.x === targetCell2.number.x && x.cell.number.y === targetCell2.number.y)) {
                     this.cellPopups.push(
                       {
                         state: false,
                         count: 0,
                         limit: 35,
                         type: '',
                         position: '',
                         msg: 'unbreakable',
                         color: '',
                         img: '',
                         cell: this.gridInfo.find(x => x.number.x === targetCell2.number.x && x.number.y === targetCell2.number.y)
                       }
                     )
                   }
                }
              }

              // NO FWD BARRIER. OBSTACLE?
              else if (myCellBarrier !== true && fwdBarrier !== true) {
                if (targetCell2.obstacle.state === true) {

                  if (targetCell2.obstacle.destructible.state === true) {
                    // WEAPON CHECK
                    if (targetCell2.obstacle.destructible.weapons.find(x => x === player.currentWeapon.name)) {
                      if (targetCell2.obstacle.hp - damage > 0) {

                        let hp = targetCell2.obstacle.hp - damage;
                        targetCell2.obstacle = {
                          state: targetCell2.obstacle.state,
                          name: targetCell2.obstacle.name,
                          type: targetCell2.obstacle.type,
                          hp: hp,
                          destructible: targetCell2.obstacle.destructible,
                          locked: targetCell2.obstacle.locked,
                          weight: targetCell2.obstacle.weight,
                          height: targetCell2.obstacle.height,
                          items: targetCell2.obstacle.items,
                          effects: targetCell2.obstacle.effects,
                          moving: targetCell2.obstacle.moving
                        };

                        this.obstacleBarrierToDestroy.push({
                          type: 'obstacle',
                          action: 'damage',
                          count: 0,
                          limit: 30,
                          complete: false,
                          cell: targetCell2,
                        })

                        this.canPushObstacle(player,targetCell2,'hitPush');
                      }

                      // DESTROY OBSTACLE W/ OR W/O RUBBLE
                      else if (targetCell2.obstacle.hp - damage <= 0) {
                        let itemsToDrop = [];
                        if (targetCell2.obstacle.destructible.leaveRubble === true) {
                          // console.log('leave rubble on ',targetCell2.number,'removing obstacle');

                          if (targetCell2.obstacle.items[0]) {
                            itemsToDrop = targetCell2.obstacle.items;
                          }
                          targetCell2.rubble = true;
                          // targetCell2.terrain.type = 'hazard';
                          targetCell2.obstacle = {
                            state: false,
                            name: targetCell2.obstacle.name,
                            type: targetCell2.obstacle.type,
                            hp: 0,
                            destructible: targetCell2.obstacle.destructible,
                            locked: targetCell2.obstacle.locked,
                            weight: targetCell2.obstacle.weight,
                            height: targetCell2.obstacle.height,
                            items: targetCell2.obstacle.items,
                            effects: targetCell2.obstacle.effects,
                            moving: targetCell2.obstacle.moving
                          };

                          this.players[player.number-1].statusDisplay = {
                            state: true,
                            status: 'Destroyed '+targetCell2.obstacle.name+'!',
                            count: 1,
                            limit: this.players[player.number-1].statusDisplay.limit,
                          }

                          if (!player.popups.find(x=>x.msg === 'destroyedItem')) {
                            player.popups.push(
                              {
                                state: false,
                                count: 0,
                                limit: 30,
                                type: '',
                                position: '',
                                msg: 'destroyedItem',
                                img: '',

                              }
                            )
                          }
                        } else {
                          // console.log('no rubble. Just remove obstacle');
                          if (targetCell2.obstacle.items[0]) {
                            itemsToDrop = targetCell2.obstacle.items;
                          }
                          targetCell2.obstacle = {
                            state: false,
                            name: targetCell2.obstacle.name,
                            type: targetCell2.obstacle.type,
                            hp: 0,
                            destructible: targetCell2.obstacle.destructible,
                            locked: targetCell2.obstacle.locked,
                            weight: targetCell2.obstacle.weight,
                            height: targetCell2.obstacle.height,
                            items: targetCell2.obstacle.items,
                            effects: targetCell2.obstacle.effects,
                            moving: targetCell2.obstacle.moving
                          };

                          this.players[player.number-1].statusDisplay = {
                            state: true,
                            status: 'Destroyed '+targetCell2.obstacle.name+'!',
                            count: 1,
                            limit: this.players[player.number-1].statusDisplay.limit,
                          }

                          if (!player.popups.find(x=>x.msg === 'destroyedItem')) {
                            player.popups.push(
                              {
                                state: false,
                                count: 0,
                                limit: 30,
                                type: '',
                                position: '',
                                msg: 'destroyedItem',
                                img: '',

                              }
                            )
                          }
                        }


                        // DROP OBSTACLE ITEMS?
                        if (itemsToDrop[0]) {
                          // console.log('dropping obstacle items melee',itemsToDrop);

                          this.obstacleItemDrop(targetCell2,player);

                        }

                        this.obstacleBarrierToDestroy.push({
                          type: 'obstacle',
                          action: 'destroy',
                          count: 0,
                          limit: 30,
                          complete: false,
                          cell: targetCell2,
                        })

                      }
                    }

                    // WEAPON NO GOOD. DEFLECT
                    else {
                      console.log('your current weapon cannot destroy this, you need ',targetCell2.obstacle.destructible.weapons,'. Deflect player?');
                       let shouldDeflect = this.rnJesus(1,player.crits.guardBreak)

                       if (shouldDeflect === 1) {

                         if (this.rnJesus(1,player.crits.pushBack) === 1) {
                           this.setDeflection(player,'defended',true);
                         }
                         else {
                           this.setDeflection(player,'defended',false);
                         }

                         if (player.currentWeapon.name === '') {
                           console.log('this obstacle is stronger than your fist. Take damage?');
                           let takeDamage = this.rnJesus(1,player.crits.guardBreak);
                           if (takeDamage === 1) {

                             this.handleMiscPlayerDamage(player,"obstacleBarrierInvulnurable");

                           }
                         }

                       }
                       else {

                            this.pushBack(player,this.getOppositeDirection(player.direction))
                       }

                       if (!this.cellPopups.find(x => x.msg === "unbreakable" && x.cell.number.x === targetCell2.number.x && x.cell.number.y === targetCell2.number.y)) {
                         this.cellPopups.push(
                           {
                             state: false,
                             count: 0,
                             limit: 35,
                             type: '',
                             position: '',
                             msg: 'unbreakable',
                             color: '',
                             img: '',
                             cell: this.gridInfo.find(x => x.number.x === targetCell2.number.x && x.number.y === targetCell2.number.y)
                           }
                         )
                       }

                    }

                  }

                  // INDESTRUCTIBLE OBSTACLE
                  else {
                    console.log('attacking invurnerable obstacle, deflect player?');

                     let shouldDeflect = this.rnJesus(1,player.crits.guardBreak)

                     if (shouldDeflect === 1) {

                       if (this.rnJesus(1,player.crits.pushBack) === 1) {
                         this.setDeflection(player,'defended',true);
                       }
                       else {
                         this.setDeflection(player,'defended',false);
                       }

                       if (player.currentWeapon.name === '') {
                         console.log('this obstacle is stronger than your fist. Take damage?');
                         let takeDamage = this.rnJesus(1,player.crits.guardBreak);
                         if (takeDamage === 1) {

                           this.handleMiscPlayerDamage(player,"obstacleBarrierInvulnurable");

                         }
                       }

                     }
                     else {

                          this.pushBack(player,this.getOppositeDirection(player.direction))
                     }
                     if (this.rnJesus(1,1,player.crits.pushBack === 1)) {
                        this.canPushObstacle(player,targetCell2,'hitPush');
                     }


                     if (!this.cellPopups.find(x => x.msg === "unbreakable" && x.cell.number.x === targetCell2.number.x && x.cell.number.y === targetCell2.number.y)) {
                       this.cellPopups.push(
                         {
                           state: false,
                           count: 0,
                           limit: 35,
                           type: '',
                           position: '',
                           msg: 'unbreakable',
                           color: '',
                           img: '',
                           cell: this.gridInfo.find(x => x.number.x === targetCell2.number.x && x.number.y === targetCell2.number.y)
                         }
                       )
                     }


                     // this.setDeflection(player,'defended',false);
                  }

                } else {

                  // NO OBSTACLE. ITEM ON GROUND? DESTROY
                  if (targetCell2 && targetCell2.item.name !== "" && damage > 0 && player.currentWeapon.name !== '') {
                    this.players[player.number-1].statusDisplay = {
                      state: true,
                      status: 'Destroyed '+targetCell2.item.name+'!',
                      count: 1,
                      limit: this.players[player.number-1].statusDisplay.limit,
                    }

                    if (!player.popups.find(x=>x.msg === 'destroyedItem')) {
                      player.popups.push(
                        {
                          state: false,
                          count: 0,
                          limit: 30,
                          type: '',
                          position: '',
                          msg: 'destroyedItem',
                          img: '',

                        }
                      )
                    }

                    this.gridInfo.find(elem => elem.number.x === player.target.cell2.number.x && elem.number.y === player.target.cell2.number.y ).item = {
                      name: '',
                      type: '',
                      subType: '',
                      effect: '',
                      initDrawn: false
                    }
                  }

                  if (targetCell2.rubble === true & damage > 0) {
                    // console.log('damage/clear rubble');
                    this.gridInfo.find(elem => elem.number.x === player.target.cell2.number.x && elem.number.y === player.target.cell2.number.y ).rubble = false;
                  }

                  // NO OBSTACLE. DESTROY REAR BARRIER

                  if (!player.popups.find(x=>x.msg === 'missedAttack2')) {
                  player.popups.push(
                    {
                      state: false,
                      count: 0,
                      limit: (this.attackAnimRef.limit[player.currentWeapon.type]-this.attackAnimRef.peak[player.currentWeapon.type]),
                      type: '',
                      position: '',
                      msg: 'missedAttack2',
                      img: '',

                    }
                  )}

                  // else {
                  //   // do nothing
                  // }
                }



              }

            }

          }

        }
        if (targetCell.elevation.number > myCell.elevation.number) {
          console.log('target is above your elevation');
        }
      }

      if (!targetCell) {

        if (myCell.barrier.state === true && myCell.barrier.position === player.direction) {

          if (myCell.barrier.destructible.state === true) {
            // WEAPON CHECK
            if (myCell.barrier.destructible.weapons.find(x => x === player.currentWeapon.name)) {
              if (myCell.barrier.hp - damage > 0) {


                let hp = myCell.barrier.hp - damage;

                myCell.barrier =
                {
                  state: myCell.barrier.state,
                  name: myCell.barrier.name,
                  type: myCell.barrier.type,
                  hp: hp,
                  destructible: myCell.barrier.destructible,
                  locked: myCell.barrier.locked,
                  position: myCell.barrier.position,
                  height: myCell.barrier.height,
                };

                this.obstacleBarrierToDestroy.push({
                  type: 'barrier',
                  action: 'damage',
                  count: 0,
                  limit: 30,
                  complete: false,
                  cell: myCell,
                })
              }

              // DESTROY FWD BARRIER W/ OR W/O RUBBLE
              else if (myCell.barrier.hp - damage <= 0) {
                if (myCell.barrier.destructible.leaveRubble === true && myCell.obstacle.state !== true && myCell.item.name === "") {
                  // console.log('leave rubble on ',targetCell.number,'removing barrier');
                  myCell.rubble = true;
                  // targetCell.terrain.type = 'hazard';

                  myCell.barrier =
                  {
                    state: false,
                    name: myCell.barrier.name,
                    type: myCell.barrier.type,
                    hp: 0,
                    destructible: myCell.barrier.destructible,
                    locked: myCell.barrier.locked,
                    position: myCell.barrier.position,
                    height: myCell.barrier.height,
                  };

                  this.players[player.number-1].statusDisplay = {
                    state: true,
                    status: 'Destroyed '+myCell.barrier.name+'!',
                    count: 1,
                    limit: this.players[player.number-1].statusDisplay.limit,
                  }

                  if (!player.popups.find(x=>x.msg === 'destroyedItem')) {
                    player.popups.push(
                      {
                        state: false,
                        count: 0,
                        limit: 30,
                        type: '',
                        position: '',
                        msg: 'destroyedItem',
                        img: '',

                      }
                    )
                  }

                } else {
                  // console.log('no rubble. Just remove barrier');

                  myCell.barrier =
                  {
                    state: false,
                    name: myCell.barrier.name,
                    type: myCell.barrier.type,
                    hp: 0,
                    destructible: myCell.barrier.destructible,
                    locked: myCell.barrier.locked,
                    position: myCell.barrier.position,
                    height: myCell.barrier.height,
                  };

                  this.players[player.number-1].statusDisplay = {
                    state: true,
                    status: 'Destroyed '+myCell.barrier.name+'!',
                    count: 1,
                    limit: this.players[player.number-1].statusDisplay.limit,
                  }

                  if (!player.popups.find(x=>x.msg === 'destroyedItem')) {
                    player.popups.push(
                      {
                        state: false,
                        count: 0,
                        limit: 30,
                        type: '',
                        position: '',
                        msg: 'destroyedItem',
                        img: '',

                      }
                    )
                  }

                }

                this.obstacleBarrierToDestroy.push({
                  type: 'barrier',
                  action: 'destroy',
                  count: 0,
                  limit: 30,
                  complete: false,
                  cell: myCell,
                })

              }
            }

            // WEAPON NO GOOD. DEFLECT
            else {
              console.log('your current weapon cannot destroy this, you need ',myCell.barrier.destructible.weapons,'. Deflect player?');
               let shouldDeflect = this.rnJesus(1,player.crits.guardBreak)
               if (shouldDeflect === 1) {

                 this.attackedCancel(this.players[player.number-1]);

                 this.setDeflection(player,'defended',false);

                 if (player.currentWeapon.name === '') {
                   console.log('this barrier is stronger than your fist. Take damage?');
                   let takeDamage = this.rnJesus(1,player.crits.guardBreak);
                   if (takeDamage === 1) {

                     this.handleMiscPlayerDamage(player,"obstacleBarrierInvulnurable");

                   }
                 }

               }
               if (this.rnJesus(1,player.crits.pushBack) === 1) {
                 this.pushBack(player,this.getOppositeDirection(player.direction))
               }
               if (!this.cellPopups.find(x => x.msg === "unbreakable" && x.cell.number.x === myCell.number.x && x.cell.number.y === myCell.number.y)) {
                 this.cellPopups.push(
                   {
                     state: false,
                     count: 0,
                     limit: 35,
                     type: '',
                     position: '',
                     msg: 'unbreakable',
                     color: '',
                     img: '',
                     cell: this.gridInfo.find(x => x.number.x === myCell.number.x && x.number.y === myCell.number.y)
                   }
                 )
               }
            }

          }

          // INDESTRUCTIBLE FWD BARRIER
          else {
            console.log('attacking invurnerable barrier, deflect player?');
             let shouldDeflect = this.rnJesus(1,player.crits.guardBreak)

             if (shouldDeflect === 1) {

               if (this.rnJesus(1,player.crits.pushBack) === 1) {
                 this.setDeflection(player,'defended',true);
               }
               else {
                 this.setDeflection(player,'defended',false);
               }

               if (player.currentWeapon.name === '') {
                 console.log('this barrier is stronger than your fist. Take damage?');
                 let takeDamage = this.rnJesus(1,player.crits.guardBreak);
                 if (takeDamage === 1) {

                   this.handleMiscPlayerDamage(player,"obstacleBarrierInvulnurable");

                 }
               }

             }
             else {

                  this.pushBack(player,this.getOppositeDirection(player.direction))
             }

             if (!this.cellPopups.find(x => x.msg === "unbreakable" && x.cell.number.x === myCell.number.x && x.cell.number.y === myCell.number.y)) {
               this.cellPopups.push(
                 {
                   state: false,
                   count: 0,
                   limit: 35,
                   type: '',
                   position: '',
                   msg: 'unbreakable',
                   color: '',
                   img: '',
                   cell: this.gridInfo.find(x => x.number.x === myCell.number.x && x.number.y === myCell.number.y)
                 }
               )
             }
          }

        }

      }



    }

    if (type === 'bolt') {


      let doubleHitChance = player.crits.doubleHit;
      let singleHitChance = player.crits.singleHit;
      let doubleHit = this.rnJesus(1,doubleHitChance);
      let singleHit = this.rnJesus(1,singleHitChance);
      let damage = undefined;
      if (doubleHit === 1) {
        damage = 2;
      } else {
        damage = 1;
      }

      // MY CELL BARRIER?


      // FWD BARRIER?
      let fwdBarrier = false;
      if (targetCell.barrier.state === true) {
        fwdBarrier = this.checkForwardBarrier(bolt.direction,targetCell);

      }

      // IF TARGET CELL IS ORIGIN CELL
      if (targetCell.number.x === bolt.origin.number.x && targetCell.number.y === bolt.origin.number.y) {
        fwdBarrier = false;
      }

      if (fwdBarrier === true && targetCell.barrier.height >= 1) {
        // console.log('player ',player.number,'hit fwd barrier ',targetCell.barrier.name,'@ ',targetCell.number,type);
        if (targetCell.barrier.destructible.state === true) {
          // WEAPON CHECK
          if (targetCell.barrier.destructible.weapons.find(x => x === 'bolt')) {
            if (targetCell.barrier.hp - damage > 0) {
              // this.gridInfo.find(elem => elem.number.x === targetCell.number.x && elem.number.y === targetCell.number.y ).barrier.hp -= damage;

              let hp = targetCell.barrier.hp - damage;

              targetCell.barrier =
              {
                state: targetCell.barrier.state,
                name: targetCell.barrier.name,
                type: targetCell.barrier.type,
                hp: hp,
                destructible: targetCell.barrier.destructible,
                locked: targetCell.barrier.locked,
                position: targetCell.barrier.position,
                height: targetCell.barrier.height,
              };

              this.obstacleBarrierToDestroy.push({
                type: 'barrier',
                action: 'damage',
                count: 0,
                limit: 30,
                complete: false,
                cell: targetCell,
              })


            }

            // DESTROY FWD BARRIER W/ OR W/O RUBBLE
            else if (targetCell.barrier.hp - damage <= 0) {

              if (targetCell.barrier.destructible.leaveRubble === true && targetCell.obstacle.state !== true && targetCell.item.name === "") {
                // console.log('leave rubble on ',targetCell.number,'removing barrier');
                targetCell.rubble = true;
                // targetCell.terrain.type = 'hazard';

                targetCell.barrier =
                {
                  state: false,
                  name: targetCell.barrier.name,
                  type: targetCell.barrier.type,
                  hp: 0,
                  destructible: targetCell.barrier.destructible,
                  locked: targetCell.barrier.locked,
                  position: targetCell.barrier.position,
                  height: targetCell.barrier.height,
                };

                this.players[player.number-1].statusDisplay = {
                  state: true,
                  status: 'Destroyed '+targetCell.barrier.name+'!',
                  count: 1,
                  limit: this.players[player.number-1].statusDisplay.limit,
                }

                if (!player.popups.find(x=>x.msg === 'destroyedItem')) {
                  player.popups.push(
                    {
                      state: false,
                      count: 0,
                      limit: 30,
                      type: '',
                      position: '',
                      msg: 'destroyedItem',
                      img: '',

                    }
                  )
                }
              } else {
                // console.log('no rubble. Just remove barrier');
                targetCell.barrier =
                {
                  state: false,
                  name: targetCell.barrier.name,
                  type: targetCell.barrier.type,
                  hp: 0,
                  destructible: targetCell.barrier.destructible,
                  locked: targetCell.barrier.locked,
                  position: targetCell.barrier.position,
                  height: targetCell.barrier.height,
                };

                this.players[player.number-1].statusDisplay = {
                  state: true,
                  status: 'Destroyed '+targetCell.barrier.name+'!',
                  count: 1,
                  limit: this.players[player.number-1].statusDisplay.limit,
                }

                if (!player.popups.find(x=>x.msg === 'destroyedItem')) {
                  player.popups.push(
                    {
                      state: false,
                      count: 0,
                      limit: 30,
                      type: '',
                      position: '',
                      msg: 'destroyedItem',
                      img: '',

                    }
                  )
                }
              }

              this.obstacleBarrierToDestroy.push({
                type: 'barrier',
                action: 'destroy',
                count: 0,
                limit: 30,
                complete: false,
                cell: targetCell,
              })

            }
          }

          // WEAPON NO GOOD. DEFLECT
          else {
            console.log('your current weapon cannot destroy this, you need ',targetCell.obstacle.weapons,'. Deflect player?');
            if (!this.cellPopups.find(x => x.msg === "unbreakable" && x.cell.number.x === targetCell.number.x && x.cell.number.y === targetCell.number.y)) {
              this.cellPopups.push(
                {
                  state: false,
                  count: 0,
                  limit: 35,
                  type: '',
                  position: '',
                  msg: 'unbreakable',
                  color: '',
                  img: '',
                  cell: this.gridInfo.find(x => x.number.x === targetCell.number.x && x.number.y === targetCell.number.y)
                }
              )
            }
          }

        }

        // INDESTRUCTIBLE FWD BARRIER
        else {
          console.log('attacking invurnerable barrier w/ bolt');
          if (!this.cellPopups.find(x => x.msg === "unbreakable" && x.cell.number.x === targetCell.number.x && x.cell.number.y === targetCell.number.y)) {
            this.cellPopups.push(
              {
                state: false,
                count: 0,
                limit: 35,
                type: '',
                position: '',
                msg: 'unbreakable',
                color: '',
                img: '',
                cell: this.gridInfo.find(x => x.number.x === targetCell.number.x && x.number.y === targetCell.number.y)
              }
            )
          }
        }

        // bolt.kill = true;
        this.projectiles.find(blt => blt.id === bolt.id).kill = true;
      }

      // NO FWD BARRIER. OBSTACLE?
      else {

        if (targetCell.obstacle.state === true && targetCell.obstacle.height >= 1) {
          // console.log('player ',player.number,'hit obstacle ',targetCell.obstacle.name,' @ ',targetCell.number,type,' for ',damage,' damage');


          if (targetCell.obstacle.destructible.state === true) {
            // WEAPON CHECK
            if (targetCell.obstacle.destructible.weapons.find(x => x === 'bolt')) {


              if (targetCell.obstacle.hp - damage > 0) {
                let hp = targetCell.obstacle.hp - damage;

                targetCell.obstacle = {
                  state: targetCell.obstacle.state,
                  name: targetCell.obstacle.name,
                  type: targetCell.obstacle.type,
                  hp: hp,
                  destructible: targetCell.obstacle.destructible,
                  locked: targetCell.obstacle.locked,
                  weight: targetCell.obstacle.weight,
                  height: targetCell.obstacle.height,
                  items: targetCell.obstacle.items,
                  effects: targetCell.obstacle.effects,
                  moving: targetCell.obstacle.moving
                };


                this.obstacleBarrierToDestroy.push({
                  type: 'obstacle',
                  action: 'damage',
                  count: 0,
                  limit: 30,
                  complete: false,
                  cell: targetCell,
                })


                // this.canPushObstacle(player,targetCell,'hitPushBolt_'+bolt.direction);
                // this.canPushObstacle(player,targetCell,`hitPushBolt_${bolt.direction}`);

              }



              // DESTROY OBSTACLE W/ OR W/O RUBBLE
              else if (targetCell.obstacle.hp - damage <= 0) {
                let itemsToDrop = [];
                if (targetCell.obstacle.destructible.leaveRubble === true) {
                  // console.log('leave rubble on ',targetCell.number,'removing obstacle');
                  if (targetCell.obstacle.items[0]) {
                    itemsToDrop = targetCell.obstacle.items;
                  }
                  // let cellRef = this.gridInfo.find(elem => elem.number.x === targetCell.number.x && elem.number.y === targetCell.number.y);
                  targetCell.rubble = true;
                  // targetCell.terrain.type = 'hazard';

                  targetCell.obstacle =
                  {
                    state: false,
                    name: targetCell.obstacle.name,
                    type: targetCell.obstacle.type,
                    hp: 0,
                    destructible: targetCell.obstacle.destructible,
                    locked: targetCell.obstacle.locked,
                    weight: targetCell.obstacle.weight,
                    height: targetCell.obstacle.height,
                    items: targetCell.obstacle.items,
                    effects: targetCell.obstacle.effects,
                    moving: targetCell.obstacle.moving
                  };

                  this.players[player.number-1].statusDisplay = {
                    state: true,
                    status: 'Destroyed '+targetCell.obstacle.name+'!',
                    count: 1,
                    limit: this.players[player.number-1].statusDisplay.limit,
                  }

                  if (!player.popups.find(x=>x.msg === 'destroyedItem')) {
                    player.popups.push(
                      {
                        state: false,
                        count: 0,
                        limit: 30,
                        type: '',
                        position: '',
                        msg: 'destroyedItem',
                        img: '',

                      }
                    )
                  }
                } else {
                  // console.log('no rubble. Just remove obstacle');
                  if (targetCell.obstacle.items[0]) {
                    itemsToDrop = targetCell.obstacle.items;
                  }

                  targetCell.obstacle =
                  {
                    state: false,
                    name: targetCell.obstacle.name,
                    type: targetCell.obstacle.type,
                    hp: 0,
                    destructible: targetCell.obstacle.destructible,
                    locked: targetCell.obstacle.locked,
                    weight: targetCell.obstacle.weight,
                    height: targetCell.obstacle.height,
                    items: targetCell.obstacle.items,
                    effects: targetCell.obstacle.effects,
                    moving: targetCell.obstacle.moving
                  };

                  this.players[player.number-1].statusDisplay = {
                    state: true,
                    status: 'Destroyed '+targetCell.obstacle.name+'!',
                    count: 1,
                    limit: this.players[player.number-1].statusDisplay.limit,
                  }

                  if (!player.popups.find(x=>x.msg === 'destroyedItem')) {
                    player.popups.push(
                      {
                        state: false,
                        count: 0,
                        limit: 30,
                        type: '',
                        position: '',
                        msg: 'destroyedItem',
                        img: '',

                      }
                    )
                  }
                }


                // DROP OBSTACLE ITEMS?
                if (itemsToDrop[0]) {
                  // console.log('dropping obstacle items bolt',itemsToDrop);

                  this.obstacleItemDrop(targetCell,player);

                }
                this.obstacleBarrierToDestroy.push({
                  type: 'obstacle',
                  action: 'destroy',
                  count: 0,
                  limit: 30,
                  complete: false,
                  cell: targetCell,
                })

              }



            }

            // WEAPON NO GOOD. DEFLECT
            else {
              console.log('your current weapon cannot destroy this, you need ',targetCell.obstacle.destructible.weapons,'. Deflect player?');
              if (!this.cellPopups.find(x => x.msg === "unbreakable" && x.cell.number.x === targetCell.number.x && x.cell.number.y === targetCell.number.y)) {
                this.cellPopups.push(
                  {
                    state: false,
                    count: 0,
                    limit: 35,
                    type: '',
                    position: '',
                    msg: 'unbreakable',
                    color: '',
                    img: '',
                    cell: this.gridInfo.find(x => x.number.x === targetCell.number.x && x.number.y === targetCell.number.y)
                  }
                )
              }
              this.canPushObstacle(player,targetCell,`hitPushBolt_${bolt.direction}`);
              // this.canPushObstacle(player,targetCell,'hitPushBolt_'+bolt.direction);

            }


          }


          // INDESTRUCTIBLE OBSTACLE
          else {
            console.log('attacking invurnerable obstacle w/ bolt');
            if (!this.cellPopups.find(x => x.msg === "unbreakable" && x.cell.number.x === targetCell.number.x && x.cell.number.y === targetCell.number.y)) {
              this.cellPopups.push(
                {
                  state: false,
                  count: 0,
                  limit: 35,
                  type: '',
                  position: '',
                  msg: 'unbreakable',
                  color: '',
                  img: '',
                  cell: this.gridInfo.find(x => x.number.x === targetCell.number.x && x.number.y === targetCell.number.y)
                }
              )
            }
            this.canPushObstacle(player,targetCell,`hitPushBolt_${bolt.direction}`);

          }

          // bolt.kill = true;
          this.projectiles.find(blt => blt.id === bolt.id).kill = true;

        } else {

          // NO OBSTACLE. ITEM ON GROUND? DESTROY
          // console.log('bolt cant destroy item on ground');

          // NO OBSTACLE. DESTROY REAR BARRIER
          let rearBarrier = false;
          if (targetCell.barrier.state === true) {
            if (bolt.direction === targetCell.barrier.position) {
              rearBarrier = true;
            }
          }
          if (rearBarrier === true && targetCell.barrier.height >= 1) {
            // console.log('player ',player.number,'hit rear barrier ',targetCell.barrier.name,' @ ',targetCell.number,type);
            if (targetCell.barrier.destructible.state === true) {
              // WEAPON CHECK
              if (targetCell.barrier.destructible.weapons.find(x => x === 'bolt')) {
                if (targetCell.barrier.hp - damage > 0) {
                  // this.gridInfo.find(elem => elem.number.x === targetCell.number.x && elem.number.y === targetCell.number.y ).barrier.hp -= damage;

                  let hp = targetCell.barrier.hp - damage;
                  targetCell.barrier =
                  {
                    state: targetCell.barrier.state,
                    name: targetCell.barrier.name,
                    type: targetCell.barrier.type,
                    hp: hp,
                    destructible: targetCell.barrier.destructible,
                    locked: targetCell.barrier.locked,
                    position: targetCell.barrier.position,
                    height: targetCell.barrier.height,
                  };

                  this.obstacleBarrierToDestroy.push({
                    type: 'barrier',
                    action: 'damage',
                    count: 0,
                    limit: 30,
                    complete: false,
                    cell: targetCell,
                  })
                }

                // DESTROY FWD BARRIER W/ OR W/O RUBBLE
                else if (targetCell.barrier.hp - damage <= 0) {
                  if (targetCell.barrier.destructible.leaveRubble === true && targetCell.obstacle.state !== true && targetCell.item.name === "") {
                    // console.log('leave rubble on ',targetCell.number,'removing barrier');
                    targetCell.rubble = true;
                    // targetCell.terrain.type = 'hazard';
                    targetCell.barrier =
                    {
                      state: false,
                      name: targetCell.barrier.name,
                      type: targetCell.barrier.type,
                      hp: 0,
                      destructible: targetCell.barrier.destructible,
                      locked: targetCell.barrier.locked,
                      position: targetCell.barrier.position,
                      height: targetCell.barrier.height,
                    };

                    this.players[player.number-1].statusDisplay = {
                      state: true,
                      status: 'Destroyed '+targetCell.barrier.name+'!',
                      count: 1,
                      limit: this.players[player.number-1].statusDisplay.limit,
                    }

                    if (!player.popups.find(x=>x.msg === 'destroyedItem')) {
                      player.popups.push(
                        {
                          state: false,
                          count: 0,
                          limit: 30,
                          type: '',
                          position: '',
                          msg: 'destroyedItem',
                          img: '',

                        }
                      )
                    }
                  } else {
                    // console.log('no rubble. Just remove barrier');
                    // this.gridInfo.find(elem => elem.number.x === targetCell.number.x && elem.number.y === targetCell.number.y ).barrier =
                    targetCell.barrier =
                    {
                      state: false,
                      name: targetCell.barrier.name,
                      type: targetCell.barrier.type,
                      hp: 0,
                      destructible: targetCell.barrier.destructible,
                      locked: targetCell.barrier.locked,
                      position: targetCell.barrier.position,
                      height: targetCell.barrier.height,
                    };


                    this.players[player.number-1].statusDisplay = {
                      state: true,
                      status: 'Destroyed '+targetCell.barrier.name+'!',
                      count: 1,
                      limit: this.players[player.number-1].statusDisplay.limit,
                    }

                    if (!player.popups.find(x=>x.msg === 'destroyedItem')) {
                      player.popups.push(
                        {
                          state: false,
                          count: 0,
                          limit: 30,
                          type: '',
                          position: '',
                          msg: 'destroyedItem',
                          img: '',

                        }
                      )
                    }
                  }

                  this.obstacleBarrierToDestroy.push({
                    type: 'barrier',
                    action: 'destroy',
                    count: 0,
                    limit: 30,
                    complete: false,
                    cell: targetCell,
                  })

                }
              }

              // WEAPON NO GOOD. DEFLECT
              else {
                console.log('your current weapon cannot destroy this, you need ',targetCell.barrier.destructible.weapons,'. Deflect player?');
                if (!this.cellPopups.find(x => x.msg === "unbreakable" && x.cell.number.x === targetCell.number.x && x.cell.number.y === targetCell.number.y)) {
                  this.cellPopups.push(
                    {
                      state: false,
                      count: 0,
                      limit: 35,
                      type: '',
                      position: '',
                      msg: 'unbreakable',
                      color: '',
                      img: '',
                      cell: this.gridInfo.find(x => x.number.x === targetCell.number.x && x.number.y === targetCell.number.y)
                    }
                  )
                }
              }

            }

            // INDESTRUCTIBLE FWD BARRIER
            else {
              console.log('attacking invurnerable barrier');
              if (!this.cellPopups.find(x => x.msg === "unbreakable" && x.cell.number.x === targetCell.number.x && x.cell.number.y === targetCell.number.y)) {
                this.cellPopups.push(
                  {
                    state: false,
                    count: 0,
                    limit: 35,
                    type: '',
                    position: '',
                    msg: 'unbreakable',
                    color: '',
                    img: '',
                    cell: this.gridInfo.find(x => x.number.x === targetCell.number.x && x.number.y === targetCell.number.y)
                  }
                )
              }
            }

            // bolt.kill = true;
            this.projectiles.find(blt => blt.id === bolt.id).kill = true;
          }

        }
      }

    }

    if (type === 'flyOverBolt') {


      myCell = undefined;
      if (bolt.direction === 'north') {
        myCell = this.gridInfo.find(elem => elem.number.x === targetCell.number.x+1 && elem.number.y === targetCell.number.y)
      }
      if (bolt.direction === 'south') {
        myCell = this.gridInfo.find(elem => elem.number.x === targetCell.number.x-1 && elem.number.y === targetCell.number.y)
      }
      if (bolt.direction === 'east') {
        myCell = this.gridInfo.find(elem => elem.number.x === targetCell.number.x && elem.number.y === targetCell.number.y-1)
      }
      if (bolt.direction === 'east') {
        myCell = this.gridInfo.find(elem => elem.number.x === targetCell.number.x && elem.number.y === targetCell.number.y+1)
      }

      let doubleHitChance = player.crits.doubleHit;
      let singleHitChance = player.crits.singleHit;
      let doubleHit = this.rnJesus(1,doubleHitChance);
      let singleHit = this.rnJesus(1,singleHitChance);
      let damage = undefined;
      if (doubleHit === 1) {
        damage = 2;
      } else {
        damage = 1;
      }

      // (targetCell.obstacle.height + targetCell.elevation.number) < bolt.elevation;
      let obstacleHeightCheck = (targetCell.obstacle.height + targetCell.elevation.number) >= (bolt.elevation+1);
      let barrierHeightCheck = (targetCell.barrier.height + targetCell.elevation.number) >= (bolt.elevation+1);


      // FWD BARRIER?
      let fwdBarrier = false;
      if (targetCell.barrier.state === true) {
        fwdBarrier = this.checkForwardBarrier(bolt.direction,targetCell);
      }

      if (fwdBarrier === true && barrierHeightCheck === true) {

        if (targetCell.barrier.destructible.state === true) {
          // WEAPON CHECK
          if (targetCell.barrier.destructible.weapons.find(x => x === 'bolt')) {
            if (targetCell.barrier.hp - damage > 0) {

              let hp = targetCell.barrier.hp - damage;
              targetCell.barrier = {
                state: targetCell.barrier.state,
                name: targetCell.barrier.name,
                type: targetCell.barrier.type,
                hp: hp,
                destructible: targetCell.barrier.destructible,
                locked: targetCell.barrier.locked,
                position: targetCell.barrier.position,
                height: targetCell.barrier.height,
              };

              this.obstacleBarrierToDestroy.push({
                type: 'barrier',
                action: 'damage',
                count: 0,
                limit: 30,
                complete: false,
                cell: targetCell,
              })
            }

            // DESTROY FWD BARRIER W/ OR W/O RUBBLE
            else if (targetCell.barrier.hp - damage <= 0) {

              if (targetCell.barrier.destructible.leaveRubble === true && targetCell.obstacle.state !== true && targetCell.item.name === "") {
                // console.log('leave rubble on ',targetCell.number,'removing barrier');
                targetCell.rubble = true;
                // targetCell.terrain.type = 'hazard';
                targetCell.barrier = {
                  state: false,
                  name: targetCell.barrier.name,
                  type: targetCell.barrier.type,
                  hp: 0,
                  destructible: targetCell.barrier.destructible,
                  locked: targetCell.barrier.locked,
                  position: targetCell.barrier.position,
                  height: targetCell.barrier.height,
                };

                this.players[player.number-1].statusDisplay = {
                  state: true,
                  status: 'Destroyed '+targetCell.barrier.name+'!',
                  count: 1,
                  limit: this.players[player.number-1].statusDisplay.limit,
                }

                if (!player.popups.find(x=>x.msg === 'destroyedItem')) {
                  player.popups.push(
                    {
                      state: false,
                      count: 0,
                      limit: 30,
                      type: '',
                      position: '',
                      msg: 'destroyedItem',
                      img: '',

                    }
                  )
                }
              } else {
                // console.log('no rubble. Just remove barrier');
                targetCell.barrier = {
                  state: false,
                  name: targetCell.barrier.name,
                  type: targetCell.barrier.type,
                  hp: 0,
                  destructible: targetCell.barrier.destructible,
                  locked: targetCell.barrier.locked,
                  position: targetCell.barrier.position,
                  height: targetCell.barrier.height,
                };

                this.players[player.number-1].statusDisplay = {
                  state: true,
                  status: 'Destroyed '+targetCell.barrier.name+'!',
                  count: 1,
                  limit: this.players[player.number-1].statusDisplay.limit,
                }

                if (!player.popups.find(x=>x.msg === 'destroyedItem')) {
                  player.popups.push(
                    {
                      state: false,
                      count: 0,
                      limit: 30,
                      type: '',
                      position: '',
                      msg: 'destroyedItem',
                      img: '',

                    }
                  )
                }
              }

              this.obstacleBarrierToDestroy.push({
                type: 'barrier',
                action: 'destroy',
                count: 0,
                limit: 30,
                complete: false,
                cell: targetCell,
              })

            }
          }

          // WEAPON NO GOOD. DEFLECT
          else {
            console.log('your current weapon cannot destroy this, you need ',targetCell.obstacle.weapons,'. Deflect player?');
            if (!this.cellPopups.find(x => x.msg === "unbreakable" && x.cell.number.x === targetCell.number.x && x.cell.number.y === targetCell.number.y)) {
              this.cellPopups.push(
                {
                  state: false,
                  count: 0,
                  limit: 35,
                  type: '',
                  position: '',
                  msg: 'unbreakable',
                  color: '',
                  img: '',
                  cell: this.gridInfo.find(x => x.number.x === targetCell.number.x && x.number.y === targetCell.number.y)
                }
              )
            }
          }

        }

        // INDESTRUCTIBLE FWD BARRIER
        else {
          console.log('attacking invurnerable barrier w/ bolt');
          if (!this.cellPopups.find(x => x.msg === "unbreakable" && x.cell.number.x === targetCell.number.x && x.cell.number.y === targetCell.number.y)) {
            this.cellPopups.push(
              {
                state: false,
                count: 0,
                limit: 35,
                type: '',
                position: '',
                msg: 'unbreakable',
                color: '',
                img: '',
                cell: this.gridInfo.find(x => x.number.x === targetCell.number.x && x.number.y === targetCell.number.y)
              }
            )
          }
        }

        this.projectiles.find(blt => blt.id === bolt.id).kill = true;
      }

      // NO FWD BARRIER. OBSTACLE?
      else {
        if (targetCell.obstacle.state === true && obstacleHeightCheck === true) {
          // console.log('targetCell.obstacle.hp',targetCell.obstacle.hp);

          if (targetCell.obstacle.destructible.state === true) {
            // WEAPON CHECK
            if (targetCell.obstacle.destructible.weapons.find(x => x === 'bolt')) {
              if (targetCell.obstacle.hp - damage > 0) {

                let hp = targetCell.obstacle.hp - damage;
                targetCell.obstacle = {
                  state: targetCell.obstacle.state,
                  name: targetCell.obstacle.name,
                  type: targetCell.obstacle.type,
                  hp: hp,
                  destructible: targetCell.obstacle.destructible,
                  locked: targetCell.obstacle.locked,
                  weight: targetCell.obstacle.weight,
                  height: targetCell.obstacle.height,
                  items: targetCell.obstacle.items,
                  effects: targetCell.obstacle.effects,
                  moving: targetCell.obstacle.moving
                };

                this.obstacleBarrierToDestroy.push({
                  type: 'obstacle',
                  action: 'damage',
                  count: 0,
                  limit: 30,
                  complete: false,
                  cell: targetCell,
                })

                this.canPushObstacle(player,targetCell,`hitPushBolt_${bolt.direction}`);
              }

              // DESTROY OBSTACLE W/ OR W/O RUBBLE
              else if (targetCell.obstacle.hp - damage <= 0) {
                let itemsToDrop = [];
                if (targetCell.obstacle.destructible.leaveRubble === true) {
                  // console.log('leave rubble on ',targetCell.number,'removing obstacle');
                  if (targetCell.obstacle.items[0]) {
                    itemsToDrop = targetCell.obstacle.items;
                  }
                  targetCell.rubble = true;
                  // targetCell.terrain.type = 'hazard';
                  targetCell.obstacle = {
                    state: false,
                    name: targetCell.obstacle.name,
                    type: targetCell.obstacle.type,
                    hp: 0,
                    destructible: targetCell.obstacle.destructible,
                    locked: targetCell.obstacle.locked,
                    weight: targetCell.obstacle.weight,
                    height: targetCell.obstacle.height,
                    items: targetCell.obstacle.items,
                    effects: targetCell.obstacle.effects,
                    moving: targetCell.obstacle.moving
                  };

                  this.players[player.number-1].statusDisplay = {
                    state: true,
                    status: 'Destroyed '+targetCell.obstacle.name+'!',
                    count: 1,
                    limit: this.players[player.number-1].statusDisplay.limit,
                  }

                  if (!player.popups.find(x=>x.msg === 'destroyedItem')) {
                    player.popups.push(
                      {
                        state: false,
                        count: 0,
                        limit: 30,
                        type: '',
                        position: '',
                        msg: 'destroyedItem',
                        img: '',

                      }
                    )
                  }
                } else {
                  // console.log('no rubble. Just remove obstacle');
                  if (targetCell.obstacle.items[0]) {
                    itemsToDrop = targetCell.obstacle.items;
                  }

                  targetCell.obstacle = {
                    state: false,
                    name: targetCell.obstacle.name,
                    type: targetCell.obstacle.type,
                    hp: 0,
                    destructible: targetCell.obstacle.destructible,
                    locked: targetCell.obstacle.locked,
                    weight: targetCell.obstacle.weight,
                    height: targetCell.obstacle.height,
                    items: targetCell.obstacle.items,
                    effects: targetCell.obstacle.effects,
                    moving: targetCell.obstacle.moving
                  };

                  this.players[player.number-1].statusDisplay = {
                    state: true,
                    status: 'Destroyed '+targetCell.obstacle.name+'!',
                    count: 1,
                    limit: this.players[player.number-1].statusDisplay.limit,
                  }

                  if (!player.popups.find(x=>x.msg === 'destroyedItem')) {
                    player.popups.push(
                      {
                        state: false,
                        count: 0,
                        limit: 30,
                        type: '',
                        position: '',
                        msg: 'destroyedItem',
                        img: '',

                      }
                    )
                  }
                }


                // DROP OBSTACLE ITEMS?
                if (itemsToDrop[0]) {
                  // console.log('dropping obstacle items bolt',itemsToDrop);
                  this.obstacleItemDrop(targetCell,player);

                }
                this.obstacleBarrierToDestroy.push({
                  type: 'obstacle',
                  action: 'destroy',
                  count: 0,
                  limit: 30,
                  complete: false,
                  cell: targetCell,
                })

              }
            }

            // WEAPON NO GOOD. DEFLECT
            else {
              console.log('your current weapon cannot destroy this, you need ',targetCell.obstacle.destructible.weapons,'. Deflect player?');
              if (!this.cellPopups.find(x => x.msg === "unbreakable" && x.cell.number.x === targetCell.number.x && x.cell.number.y === targetCell.number.y)) {
                this.cellPopups.push(
                  {
                    state: false,
                    count: 0,
                    limit: 35,
                    type: '',
                    position: '',
                    msg: 'unbreakable',
                    color: '',
                    img: '',
                    cell: this.gridInfo.find(x => x.number.x === targetCell.number.x && x.number.y === targetCell.number.y)
                  }
                )
              }
              this.canPushObstacle(player,targetCell,`hitPushBolt_${bolt.direction}`);
            }

          }

          // INDESTRUCTIBLE OBSTACLE
          else {
            console.log('attacking invurnerable obstacle w/ bolt');
            if (!this.cellPopups.find(x => x.msg === "unbreakable" && x.cell.number.x === targetCell.number.x && x.cell.number.y === targetCell.number.y)) {
              this.cellPopups.push(
                {
                  state: false,
                  count: 0,
                  limit: 35,
                  type: '',
                  position: '',
                  msg: 'unbreakable',
                  color: '',
                  img: '',
                  cell: this.gridInfo.find(x => x.number.x === targetCell.number.x && x.number.y === targetCell.number.y)
                }
              )
            }
            this.canPushObstacle(player,targetCell,`hitPushBolt_${bolt.direction}`);
          }

          this.projectiles.find(blt => blt.id === bolt.id).kill = true;
        } else {

          // NO OBSTACLE. ITEM ON GROUND? DESTROY
          // console.log('bolt cant destroy item on ground');

          // NO OBSTACLE. DESTROY REAR BARRIER
          let rearBarrier = false;
          if (targetCell.barrier.state === true) {
            if (bolt.direction === targetCell.barrier.position) {
              rearBarrier = true;
            }
          }
          if (rearBarrier === true && barrierHeightCheck === true) {
            if (targetCell.barrier.destructible.state === true) {
              // WEAPON CHECK
              if (targetCell.barrier.destructible.weapons.find(x => x === 'bolt')) {
                if (targetCell.barrier.hp - damage > 0) {

                  let hp = targetCell.barrier.hp - damage;
                  targetCell.barrier = {
                    state: targetCell.barrier.state,
                    name: targetCell.barrier.name,
                    type: targetCell.barrier.type,
                    hp: hp,
                    destructible: targetCell.barrier.destructible,
                    locked: targetCell.barrier.locked,
                    position: targetCell.barrier.position,
                    height: targetCell.barrier.height,
                  };

                  this.obstacleBarrierToDestroy.push({
                    type: 'barrier',
                    action: 'damage',
                    count: 0,
                    limit: 30,
                    complete: false,
                    cell: targetCell,
                  })
                }

                // DESTROY FWD BARRIER W/ OR W/O RUBBLE
                else if (targetCell.barrier.hp - damage <= 0) {
                  if (targetCell.barrier.destructible.leaveRubble === true && targetCell.obstacle.state !== true && targetCell.item.name === "") {
                    // console.log('leave rubble on ',targetCell.number,'removing barrier');
                    targetCell.rubble = true;
                    // targetCell.terrain.type = 'hazard';

                    targetCell.barrier = {
                      state: false,
                      name: targetCell.barrier.name,
                      type: targetCell.barrier.type,
                      hp: 0,
                      destructible: targetCell.barrier.destructible,
                      locked: targetCell.barrier.locked,
                      position: targetCell.barrier.position,
                      height: targetCell.barrier.height,
                    };

                    this.players[player.number-1].statusDisplay = {
                      state: true,
                      status: 'Destroyed '+targetCell.barrier.name+'!',
                      count: 1,
                      limit: this.players[player.number-1].statusDisplay.limit,
                    }

                    if (!player.popups.find(x=>x.msg === 'destroyedItem')) {
                      player.popups.push(
                        {
                          state: false,
                          count: 0,
                          limit: 30,
                          type: '',
                          position: '',
                          msg: 'destroyedItem',
                          img: '',

                        }
                      )
                    }
                  } else {
                    // console.log('no rubble. Just remove barrier');

                    targetCell.barrier = {
                      state: false,
                      name: targetCell.barrier.name,
                      type: targetCell.barrier.type,
                      hp: 0,
                      destructible: targetCell.barrier.destructible,
                      locked: targetCell.barrier.locked,
                      position: targetCell.barrier.position,
                      height: targetCell.barrier.height,
                    };

                    this.players[player.number-1].statusDisplay = {
                      state: true,
                      status: 'Destroyed '+targetCell.barrier.name+'!',
                      count: 1,
                      limit: this.players[player.number-1].statusDisplay.limit,
                    }

                    if (!player.popups.find(x=>x.msg === 'destroyedItem')) {
                      player.popups.push(
                        {
                          state: false,
                          count: 0,
                          limit: 30,
                          type: '',
                          position: '',
                          msg: 'destroyedItem',
                          img: '',

                        }
                      )
                    }
                  }

                  this.obstacleBarrierToDestroy.push({
                    type: 'barrier',
                    action: 'destroy',
                    count: 0,
                    limit: 30,
                    complete: false,
                    cell: targetCell,
                  })

                }
              }

              // WEAPON NO GOOD. DEFLECT
              else {
                console.log('your current weapon cannot destroy this, you need ',targetCell.barrier.destructible.weapons,'. Deflect player?');
                if (!this.cellPopups.find(x => x.msg === "unbreakable" && x.cell.number.x === targetCell.number.x && x.cell.number.y === targetCell.number.y)) {
                  this.cellPopups.push(
                    {
                      state: false,
                      count: 0,
                      limit: 35,
                      type: '',
                      position: '',
                      msg: 'unbreakable',
                      color: '',
                      img: '',
                      cell: this.gridInfo.find(x => x.number.x === targetCell.number.x && x.number.y === targetCell.number.y)
                    }
                  )
                }
              }

            }

            // INDESTRUCTIBLE FWD BARRIER
            else {
              console.log('attacking invurnerable barrier');
              if (!this.cellPopups.find(x => x.msg === "unbreakable" && x.cell.number.x === targetCell.number.x && x.cell.number.y === targetCell.number.y)) {
                this.cellPopups.push(
                  {
                    state: false,
                    count: 0,
                    limit: 35,
                    type: '',
                    position: '',
                    msg: 'unbreakable',
                    color: '',
                    img: '',
                    cell: this.gridInfo.find(x => x.number.x === targetCell.number.x && x.number.y === targetCell.number.y)
                  }
                )
              }
            }
            this.projectiles.find(blt => blt.id === bolt.id).kill = true;
          }

        }
      }

    }

    if (type === 'arc') {



    }

  }
  obstacleItemDrop = (targetCell,player) => {
    // console.log("obstacleItemDrop");

    let itemCount = targetCell.obstacle.items.length;
    let itemCount2 = itemCount;
    let availibleCells = [];
    let baseDirs = ['south','west','north','east'];
    let multiple = 1;
    let baseDirIndx = 0;
    let refPos = {
      x: targetCell.number.x,
      y: targetCell.number.y,
    };
    let cellToCheck = {
      x: undefined,
      y: undefined,
    };
    let instructions = [];
    let instructionRef = {
      north: {
        x: 0,
        y: -1,
      },
      south: {
        x: 0,
        y: 1,
      },
      east: {
        x: 1,
        y: 0,
      },
      west: {
        x: -1,
        y: 0,
      },
    };
    let stepsA = 0;
    let stepsB = 0;

    while (availibleCells.length < itemCount) {

      for (let i = 0; i < multiple; i++) {
        instructions.push(baseDirs[baseDirIndx])
        // console.log('set instructions baseDirIndx',baseDirIndx,'multiple',multiple,'baseDir',baseDirs[baseDirIndx]);
      }
      // console.log('item drop instructions',instructions);

      for(const instruct of instructions) {

        cellToCheck = {
          x: refPos.x + instructionRef[instruct].x,
          y: refPos.y + instructionRef[instruct].y,
        }
        // console.log('ctc instruct ',instruct,instructionRef[instruct],'cell to check',cellToCheck,'steps',stepsA,stepsB);

        let ctcRef = this.gridInfo.find(x=> x.number.x === cellToCheck.x && x.number.y === cellToCheck.y);

        let  cellFree = true;

        // if (
        //   ctcRef.number.x < 0 ||
        //   ctcRef.number.x > this.gridWidth-1 ||
        //   ctcRef.number.y < 0 ||
        //   ctcRef.number.y > this.gridWidth-1
        // ) {
        //   cellFree = false;
        // }
        if (ctcRef) {
          if (
            ctcRef.obstacle.state === true ||
            ctcRef.void.state === true ||
            ctcRef.terrain.type === 'deep' ||
            ctcRef.terrain.name === 'lava' ||
            ctcRef.item.name !== "" ||
            ctcRef.rubble === true
          ) {
            cellFree = false;
          }

          for(const plyr of this.players) {
            if(plyr.currentPosition.cell.number.x === ctcRef.number.x && plyr.currentPosition.cell.number.y === ctcRef.number.y) {
              cellFree = false;
            }
          }
        }
        else {
          cellFree = false;
        }


        if(cellFree === true) {
          itemCount2--;
          availibleCells.push(cellToCheck);
          // console.log('cell free',cellToCheck,'item count1',itemCount,'item count2',itemCount2,'availibleCells',availibleCells.length,'steps',stepsA,stepsB);
          // console.log('availibleCells',availibleCells.length,availibleCells);
        }
        else {
          // console.log('cell not free',cellToCheck,'availibleCells',availibleCells.length,'steps',stepsA,stepsB);
          // console.log('availibleCells',availibleCells.length,availibleCells);
        }
        refPos = {
          x: cellToCheck.x,
          y: cellToCheck.y
        }
        stepsA++;
        stepsB++;

        if (availibleCells.length === itemCount) {
          break;
        }

      }

      instructions = [];

      // if (steps%2 === 0) {
      //   stepsA = 0;
      //   multiple++;
      // }
      if (stepsB === multiple*2) {
        multiple++;
        stepsB = 0;
      }
      if (baseDirIndx >= 3) {
        // console.log('a');
        baseDirIndx = 0;
      }
      else {
        baseDirIndx++;
      }

    }

    if(availibleCells.length === itemCount ) {
      // console.log('break loop. have free cell for each item');
      for(const cell of availibleCells) {
        let indx = availibleCells.indexOf(cell);
        let item = targetCell.obstacle.items[indx];
        this.gridInfo.find(x=> x.number.x === cell.x && x.number.y === cell.y).item = item;

        this.cellsToHighlight2.push({
          number: {
            x: cell.x,
            y: cell.y,
          },
          count: 0,
          limit: 50,
        });

        this.obstacleItemsToDrop.push({
          origin: targetCell.number,
          target: cell,
          item: item,
          state: true,
          count: 0,
          limit: 30,
          position: {
            x: undefined,
            y: undefined,
          }
        })
      }
    }


  }


  preObstaclePushCheck = (player,target) => {
    // console.log('pre push check');

    let resetPush = false;
    let refCell = this.gridInfo.find(x => x.number.x === target.cell1.number.x && x.number.y === target.cell1.number.y);
    let plyrRefCell = this.gridInfo.find(x => x.number.x === player.currentPosition.cell.number.x && x.number.y === player.currentPosition.cell.number.y);

    let myCellCheck = true;
    if (plyrRefCell.barrier.state === true && plyrRefCell.barrier.position === player.direction) {
      myCellCheck = false
    }
    if (myCellCheck !== true) {
      console.log('a barrier in player cell is blocking a push');
      resetPush = true;
    }

    if(refCell.obstacle.state !== true) {
      console.log('barrier not obstacle. Cant be pushed');
      resetPush = true;
    }
    else if (refCell.obstacle.moving.pushable === true && myCellCheck === true && player.newPushPullDelay.state !== true) {

      if (player.prePush.state !== true && player.prePush.count === 0) {
        // console.log('start pre push');
        player.prePush = {
          state: true,
          count: player.prePush.count++,
          limit: player.prePush.limit,
          targetCell: refCell,
          direction: player.direction,
          pusher: player.number,
        }

      }

      if (player.prePush.state === true) {

        if (player.prePush.count >= player.prePush.limit) {

          // console.log('pre push limit. check can push');
          this.players[player.number-1].prePush = player.prePush;
          this.players[player.number-1].pushing = player.pushing;

          if (player.popups.find(x=>x.msg === 'prePush')) {
            player.popups.splice(player.popups.findIndex(x=>x.msg === 'prePush'),1)
          }
          this.canPushObstacle(player,refCell,'');

        }
        else {

           if (
             player.prePush.targetCell.number.x === refCell.number.x &&
             player.prePush.targetCell.number.y === refCell.number.y &&
             player.prePush.direction === player.direction &&
             player.prePush.pusher === player.number
           ) {

             player.prePush.count++;
             if (!player.popups.find(x=>x.msg === "prePush")) {
               player.popups.push(
                 {
                   state: false,
                   count: 0,
                   limit: player.prePush.limit,
                   type: '',
                   position: '',
                   msg: 'prePush',
                   img: '',
                 }
               )
             }
             // console.log('pre pushing the same obstacle. Continue',player.prePush.count);
           }
           else {
             // console.log('pre push player, target or direction has changed. Reset prepush');
             player.prePush = {
               state: false,
               count: 0,
               limit: player.prePush.limit,
               targetCell: undefined,
               direction: "",
               pusher: undefined,
             };

             resetPush = true;
           }

         }

      }
    }

    if (player.newPushPullDelay.state === true) {
      resetPush = true;
    }

    if (refCell.obstacle.moving.pushable !== true) {
      console.log('obstacle is instrinsically unpushable');
      resetPush = true;
    }


    if (resetPush === true) {
      player.prePush = {
        state: false,
        count: 0,
        limit: player.prePush.limit,
        targetCell: undefined,
        direction: "",
        pusher: undefined,
      };

      if (player.newPushPullDelay.state !== true) {
        player.newPushPullDelay.state = true;
      }
    }


    this.players[player.number-1].prePush = player.prePush;
    this.players[player.number-1].pushing = player.pushing;


  }
  canPushObstacle = (player,obstacleCell,type) => {

    // let pusherCellRef = this.gridInfo.find(x=> x.number.x === player.currentPosition.cell.number.x && x.number.y === player.currentPosition.cell.number.y);
    let resetPush = false;
    let thresholdMultiplier = this.rnJesus(1,3)
    let canPushStrength = false;
    let canPushTargetFree = true;
    let pushStrengthThreshold = (obstacleCell.obstacle.height + obstacleCell.obstacle.weight)*thresholdMultiplier;
    let pushStrengthPlayer = 0;
    let movePlayer = true;
    let impactDirection = "";
    if (type === 'hitPush' || type.split('_')[0] === 'hitPushBolt') {
      movePlayer = false;
      pushStrengthPlayer += 1;
      // console.log('obstacle hit push');
    }

    if (type.split('_')[0] === 'hitPushBolt') {
      impactDirection = type.split('_')[1];
      // console.log('impactDirection',type.split('_')[1]);
    }
    if(type === 'hitPush') {
      impactDirection = player.direction;
    }
    if (type === "") {
      impactDirection = player.prePush.direction;
    }



    let destCell = this.getCellFromDirection(1,obstacleCell.number,impactDirection);
    let destCellRef = this.gridInfo.find(x => x.number.x === destCell.x && x.number.y === destCell.y);
    let destCellOccupant = "";

    if (player.stamina.current - this.staminaCostRef.push >= 0) {

      player.stamina.current = player.stamina.current - this.staminaCostRef.push;


      if (player.hp > 1) {
        pushStrengthPlayer += (player.hp-1)
      }
      pushStrengthPlayer += (player.crits.pushBack-3);
      pushStrengthPlayer += (player.crits.guardBreak-2);
      // pushStrengthPlayer += 5;





      let preMoveSpeed = Math.ceil(pushStrengthPlayer/pushStrengthThreshold);
      let moveSpeed = 0;
      if (preMoveSpeed <= 1) {
        moveSpeed = .05;
      }
      if (preMoveSpeed === 2) {
        moveSpeed = .1;
      }
      if (preMoveSpeed > 2 && preMoveSpeed < 4) {
        moveSpeed = .125;
      }
      if (preMoveSpeed > 4) {
        moveSpeed = .2;
      }

      if (this.terrainMoveSpeedRef[obstacleCell.terrain.type]) {
        moveSpeed = this.terrainMoveSpeedRef[obstacleCell.terrain.type];
      }


      if (destCellRef) {

        if (destCellRef.obstacle.state === true) {
          canPushTargetFree = false;
          destCellOccupant = "obstacle";
          resetPush = true;
        }

        if (destCellRef.barrier.state === true) {

          let barrier = false;
          if (destCellRef.barrier.position === this.getOppositeDirection(impactDirection)) {
            barrier = true;
          }

          if (barrier === true) {
              canPushTargetFree = false;
              destCellOccupant = "barrier";
              resetPush = true;
          }

        }


        if (destCellRef.elevation.number > obstacleCell.elevation.number) {
          canPushTargetFree = false;
          destCellOccupant = "higherElevation";
          resetPush = true;
        }

        if (obstacleCell.barrier.state === true) {

          // --------------
          let barrier = false;
          if (obstacleCell.barrier.position === this.getOppositeDirection(impactDirection)) {
            barrier = true;
          }

          if (barrier === true) {
            console.log('barrier in obstacle cell in front of obstacle');
            canPushTargetFree = false;
            destCellOccupant = "barrier";
            resetPush = true;
          }
          // --------------


          if (obstacleCell.barrier.position === impactDirection) {
            console.log('barrier in obstacle cell behind obstacle');
            canPushTargetFree = false;
            destCellOccupant = "barrier";
            resetPush = true;
          }

        }

        for(const plyr of this.players) {
          if(plyr.currentPosition.cell.number.x === destCell.x && plyr.currentPosition.cell.number.y === destCell.y) {

            canPushTargetFree = false;
            resetPush = true;
            destCellOccupant = `player_${plyr.number}`;

          }
        }

      }
      else {

        if (obstacleCell.barrier.state === true) {

          // --------------
          let barrier = false;
          if (obstacleCell.barrier.position === this.getOppositeDirection(impactDirection)) {
            barrier = true;
          }

          if (barrier === true) {
            console.log('barrier in obstacle cell in front of obstacle2');
            canPushTargetFree = false;
            destCellOccupant = "barrier";
            resetPush = true;
          }
          // --------------


          if (obstacleCell.barrier.position === impactDirection) {
            console.log('barrier in obstacle cell behind obstacle2');
            canPushTargetFree = false;
            destCellOccupant = "barrier";
            resetPush = true;
          }

        }

      }

      let extraPush = 0;
      if (pushStrengthPlayer >= pushStrengthThreshold && obstacleCell.obstacle.moving.pushable === true) {
        canPushStrength = true;
        extraPush = pushStrengthPlayer - pushStrengthThreshold;
        console.log('you are strongh enough to push this obstacle',pushStrengthPlayer,pushStrengthThreshold,player.crits.guardBreak-2,player.crits.pushBack-2,'extra',extraPush);
      }
      else {
        console.log('you are NOT strong enough to push this obstacle',pushStrengthPlayer,pushStrengthThreshold,player.crits.guardBreak-2,player.crits.pushBack-2);
        resetPush = true;
      }
      if (extraPush > 5) {
        console.log('extra push force. Push obstacle w/o plyr move');
        movePlayer = false;
      }



      // if(!destCellRef && pushStrengthPlayer >= pushStrengthThreshold ) {
      if(canPushStrength === true && canPushTargetFree === true && !destCellRef) {


        if (!this.players[player.number-1].popups.find(x=>x.msg === "canPush")) {
          this.players[player.number-1].popups.push(
            {
              state: false,
              count: 0,
              limit: 25,
              type: '',
              position: '',
              msg: 'canPush',
              img: '',
            }
          )
        }

        if (this.players[player.number-1].popups.find(x=>x.msg === 'prePush')) {
          this.players[player.number-1].popups.splice(this.players[player.number-1].popups.findIndex(x=>x.msg === 'prePush'),1)
        }
        if (this.players[player.number-1].popups.find(x=>x.msg === 'noPush')) {
          this.players[player.number-1].popups.splice(this.players[player.number-1].popups.findIndex(x=>x.msg === 'noPush'),1)
        }



        let voidCenter = this.getVoidCenter(1,impactDirection,obstacleCell.center);


        let obstacleCrementObj = this.obstacleMoveCrementer(obstacleCell,{center:voidCenter});

        obstacleCell.obstacle =
        {
          state: obstacleCell.obstacle.state,
          name: obstacleCell.obstacle.name,
          type: obstacleCell.obstacle.type,
          hp: obstacleCell.obstacle.hp,
          destructible: obstacleCell.obstacle.destructible,
          locked: obstacleCell.obstacle.locked,
          weight: obstacleCell.obstacle.weight,
          height: obstacleCell.obstacle.height,
          items: obstacleCell.obstacle.items,
          effects: obstacleCell.obstacle.effects,
          moving: {
            state: true,
            step: obstacleCrementObj.step,
            origin: {
              number: obstacleCell.number,
              center: obstacleCell.center,
            },
            destination: {
              number: {
                x: undefined,
                y: undefined
              },
              center: voidCenter,
            },
            currentPosition: obstacleCell.center,
            nextPosition: obstacleCrementObj.pos,
            moveSpeed: moveSpeed,
            pushable: true,
            pushed: true,
            pusher: player.number,
            falling: obstacleCell.obstacle.moving.falling,
          }
        };


        this.players[player.number-1].prePush = {
            state: false,
            count: 0,
            limit: player.prePush.limit,
            targetCell: undefined,
            direction: "",
            pusher: undefined,
        }


        if (movePlayer === true) {

          this.players[player.number-1].pushing = {
              state: true,
              targetCell: obstacleCell,
              moveSpeed: moveSpeed,
          }

          if (player.turning.delayCount === 0) {
            this.players[player.number-1].action = 'moving';
            this.players[player.number-1].moving = {
              state: true,
              step: 0,
              course: '',
              origin: {
                number: {
                  x: player.currentPosition.cell.number.x,
                  y: player.currentPosition.cell.number.y
                },
                center: {
                  x: player.currentPosition.cell.center,
                  y: player.currentPosition.cell.center
                },
              },
              destination: obstacleCell.center
            }
            let nextPosition = this.lineCrementer(player);
            player.nextPosition = nextPosition;

          }

        }


      }

      // console.log('pushStrengthThreshold/Player',pushStrengthThreshold,pushStrengthPlayer);
      if (!this.players[player.number-1].popups.find(x=>x.msg === "canPush")) {
        this.players[player.number-1].popups.push(
          {
            state: false,
            count: 0,
            limit: 25,
            type: '',
            position: '',
            msg: 'canPush',
            img: '',
          }
        )
      }

      if (this.players[player.number-1].popups.find(x=>x.msg === 'prePush')) {
        this.players[player.number-1].popups.splice(this.players[player.number-1].popups.findIndex(x=>x.msg === 'prePush'),1)
      }
      if (this.players[player.number-1].popups.find(x=>x.msg === 'noPush')) {
        this.players[player.number-1].popups.splice(this.players[player.number-1].popups.findIndex(x=>x.msg === 'noPush'),1)
      }


      if (canPushTargetFree !== true) {
        // console.log('something is in the way of the obstacle to be pushed');
        resetPush = true;
      }

      if (canPushStrength === true && canPushTargetFree === true && destCellRef) {

        // console.log('ready to push');
        if (!this.players[player.number-1].popups.find(x=>x.msg === "canPush")) {
          this.players[player.number-1].popups.push(
            {
              state: false,
              count: 0,
              limit: 25,
              type: '',
              position: '',
              msg: 'canPush',
              img: '',
            }
          )
        }

        if (this.players[player.number-1].popups.find(x=>x.msg === 'prePush')) {
          this.players[player.number-1].popups.splice(this.players[player.number-1].popups.findIndex(x=>x.msg === 'prePush'),1)
        }
        if (this.players[player.number-1].popups.find(x=>x.msg === 'noPush')) {
          this.players[player.number-1].popups.splice(this.players[player.number-1].popups.findIndex(x=>x.msg === 'noPush'),1)
        }


        let obstacleCrementObj = this.obstacleMoveCrementer(obstacleCell,destCellRef);

        obstacleCell.obstacle =
        {
          state: obstacleCell.obstacle.state,
          name: obstacleCell.obstacle.name,
          type: obstacleCell.obstacle.type,
          hp: obstacleCell.obstacle.hp,
          destructible: obstacleCell.obstacle.destructible,
          locked: obstacleCell.obstacle.locked,
          weight: obstacleCell.obstacle.weight,
          height: obstacleCell.obstacle.height,
          items: obstacleCell.obstacle.items,
          effects: obstacleCell.obstacle.effects,
          moving: {
            state: true,
            step: obstacleCrementObj.step,
            origin: {
              number: obstacleCell.number,
              center: obstacleCell.center,
            },
            destination: {
              number: destCellRef.number,
              center: destCellRef.center,
            },
            currentPosition: obstacleCell.center,
            nextPosition: obstacleCrementObj.pos,
            moveSpeed: moveSpeed,
            pushable: true,
            pushed: true,
            pusher: player.number,
            falling: obstacleCell.obstacle.moving.falling,
          }
        };


        this.players[player.number-1].prePush = {
            state: false,
            count: 0,
            limit: player.prePush.limit,
            targetCell: undefined,
            direction: "",
            pusher: undefined,
        }


        if (movePlayer === true) {

          this.players[player.number-1].pushing = {
              state: true,
              targetCell: obstacleCell,
              moveSpeed: moveSpeed,
          }

          if (player.turning.delayCount === 0) {
            this.players[player.number-1].action = 'moving';
            this.players[player.number-1].moving = {
              state: true,
              step: 0,
              course: '',
              origin: {
                number: {
                  x: player.currentPosition.cell.number.x,
                  y: player.currentPosition.cell.number.y
                },
                center: {
                  x: player.currentPosition.cell.center,
                  y: player.currentPosition.cell.center
                },
              },
              destination: obstacleCell.center
            }
            let nextPosition = this.lineCrementer(player);
            player.nextPosition = nextPosition;

          }

        }
        else {
          player.action = 'idle';
        }

      }


    }
    else {

      player.stamina.current = 0;
      resetPush = true;
      player.statusDisplay = {
        state: true,
        status: "Out of Stamina",
        count: 1,
        limit: player.statusDisplay.limit,
      }

      if (!player.popups.find(x => x.msg === 'outOfStamina')) {
        player.popups.push(
          {
            state: false,
            count: 0,
            limit: 20,
            type: '',
            position: '',
            msg: 'outOfStamina',
            img: '',

          }
        )
      }
    }


    if (resetPush === true) {


      this.players[player.number-1].prePush = {
          state: false,
          count: 0,
          limit: player.prePush.limit,
          targetCell: undefined,
          direction: "",
          pusher: undefined,
      }
      this.players[player.number-1].pushing = {
          state: false,
          targetCell: undefined,
          moveSpeed: 0,
      }

      if (this.players[player.number-1].newPushPullDelay.state !== true) {
        this.players[player.number-1].newPushPullDelay.state = true
      }

      if (!this.players[player.number-1].popups.find(x=>x.msg === "noPush")) {
        this.players[player.number-1].popups.push(
          {
            state: false,
            count: 0,
            limit: 25,
            type: '',
            position: '',
            msg: 'noPush',
            img: '',
          }
        )
      }

      if (this.players[player.number-1].popups.find(x=>x.msg === 'prePush')) {
        this.players[player.number-1].popups.splice(this.players[player.number-1].popups.findIndex(x=>x.msg === 'prePush'),1)
      }
      if (this.players[player.number-1].popups.find(x=>x.msg === 'noPush')) {
        this.players[player.number-1].popups.splice(this.players[player.number-1].popups.findIndex(x=>x.msg === 'canPush'),1)
      }


      if (canPushTargetFree !== true && destCellOccupant !== "") {

        let type = destCellOccupant;
        if (type.split("_")[1]) {
          type = "player";
        }
        this.startHalfPushBack('obstacle',type,impactDirection,obstacleCell);

      }


    }

  }
  prePlayerPushCheck = (pusher,target) => {
    // console.log('prePlayerPushCheck');

    let resetPush = false;
    let targetCell = this.gridInfo.find(x => x.number.x === target.cell1.number.x && x.number.y === target.cell1.number.y);
    let plyrRefCell = this.gridInfo.find(x => x.number.x === pusher.currentPosition.cell.number.x && x.number.y === pusher.currentPosition.cell.number.y);

    let myCellCheck = true;
    if (plyrRefCell.barrier.state === true && plyrRefCell.barrier.position === pusher.direction) {
      myCellCheck = false
    }
    if (myCellCheck !== true) {
      console.log('a barrier in player cell is blocking a player push');
      resetPush = true;
    }

    let targetOpen = false;
    let targetPlayer = this.players[target.cell1.occupant.player-1];
    if (targetPlayer.success.deflected.state === true || targetPlayer.action === 'idle') {
      targetOpen = true;
    } else {
      // console.log('target player is no longer deflected or idle');
      resetPush = true;
    }

    if (targetOpen === true && myCellCheck === true && pusher.newPushPullDelay.state !== true) {
      if (pusher.prePush.state !== true && pusher.prePush.count === 0) {
        // console.log('start player pre push');
        pusher.prePush = {
          state: true,
          count: pusher.prePush.count++,
          limit: pusher.prePush.limit,
          targetCell: targetCell,
          direction: pusher.direction,
          pusher: pusher.number,
        }

      }

      if (pusher.prePush.state === true) {

        // if (pusher.prePush.count >= 25) {
        if (pusher.prePush.count >= pusher.prePush.limit) {

          // console.log('pre push limit. check can push player');
          this.players[pusher.number-1].prePush = pusher.prePush;
          this.players[pusher.number-1].pushing = pusher.pushing;
          if (pusher.popups.find(x=>x.msg === 'prePush')) {
            pusher.popups.splice(pusher.popups.findIndex(x=>x.msg === 'prePush'),1)
          }
          this.canPushPlayer(pusher,targetCell,targetPlayer);

        }
        else {

           if (
             pusher.prePush.targetCell.number.x === targetCell.number.x &&
             pusher.prePush.targetCell.number.y === targetCell.number.y &&
             pusher.prePush.direction === pusher.direction &&
             pusher.prePush.pusher === pusher.number
           ) {

             pusher.prePush.count++;
             if (!pusher.popups.find(x=>x.msg === "prePush")) {
               pusher.popups.push(
                 {
                   state: false,
                   count: 0,
                   limit: pusher.prePush.limit,
                   type: '',
                   position: '',
                   msg: 'prePush',
                   img: '',
                 }
               )
             }
             // console.log('pre pushing the same player. Continue',pusher.prePush.count);
           }
           else {
             // console.log('pre push player, target or direction has changed. Reset prepush');
             pusher.prePush = {
               state: false,
               count: 0,
               limit: pusher.prePush.limit,
               targetCell: undefined,
               direction: "",
               pusher: undefined,
             };

             resetPush = true;
           }

         }

      }
    }

    if (pusher.newPushPullDelay.state === true) {
      resetPush = true;
    }

    if (targetOpen !== true) {
      // console.log('player is unpushable');
      resetPush = true;
    }


    if (resetPush === true) {
      pusher.prePush = {
        state: false,
        count: 0,
        limit: pusher.prePush.limit,
        targetCell: undefined,
        direction: "",
        pusher: undefined,
      };

      if (pusher.newPushPullDelay.state !== true) {
        pusher.newPushPullDelay.state = true;
      }
    }


    this.players[pusher.number-1].prePush = pusher.prePush;
    this.players[pusher.number-1].pushing = pusher.pushing;

  }
  canPushPlayer = (pusher,targetCell,targetPlayer) => {


    let resetPush = false;
    let thresholdMultiplier = this.rnJesus(1,3)
    let canPushStrength = false;
    let canPushTargetFree = true;
    let pushStrengthThreshold = (targetPlayer.hp + (targetPlayer.crits.pushBack-3) + (targetPlayer.crits.guardBreak-2))*thresholdMultiplier;
    let pushStrengthPlayer = 0;
    let movePlayer = true;
    let impactDirection = pusher.prePush.direction;


    let destCell = this.getCellFromDirection(1,targetCell.number,impactDirection);

    let destCellRef = this.gridInfo.find(x => x.number.x === destCell.x && x.number.y === destCell.y);
    let destCellOccupant = "";


    if (pusher.stamina.current - this.staminaCostRef.push >= 0) {

      pusher.stamina.current = pusher.stamina.current - this.staminaCostRef.push;

      if (pusher.hp > 1) {
        pushStrengthPlayer += (pusher.hp-1)
      }
      pushStrengthPlayer += (pusher.crits.pushBack-3);
      pushStrengthPlayer += (pusher.crits.guardBreak-2);
      // pushStrengthPlayer += 15;




      let preMoveSpeed = Math.ceil(pushStrengthPlayer/pushStrengthThreshold);
      let moveSpeed = 0;
      if (preMoveSpeed <= 1) {
        moveSpeed = .05;
      }
      if (preMoveSpeed === 2) {
        moveSpeed = .1;
      }
      if (preMoveSpeed > 2 && preMoveSpeed < 4) {
        moveSpeed = .125;
      }
      if (preMoveSpeed > 4) {
        moveSpeed = .2;
      }

      if (destCellRef) {

        if (destCellRef.obstacle.state === true) {
          canPushTargetFree = false;
          destCellOccupant = "obstacle";
          resetPush = true;
        }

        if (destCellRef.barrier.state === true) {
          let barrier = this.checkForwardBarrier(impactDirection,destCellRef);
          let destCell = this.getCellFromDirection(1,targetCell.number,impactDirection);


          if (barrier === true) {
              canPushTargetFree = false;
              destCellOccupant = "barrier";
              resetPush = true;
          }


        }

        if (targetCell.barrier.state === true) {

          // --------------
          let barrier = this.checkForwardBarrier(impactDirection,targetCell);



          if (barrier === true) {
            console.log('barrier in obstacle cell in front of target player');
            canPushTargetFree = false;
            destCellOccupant = "barrier";
            resetPush = true;
          }
          // --------------


          if (targetCell.barrier.position === impactDirection) {
            console.log('barrier in obstacle cell behind target player');
            canPushTargetFree = false;
            destCellOccupant = "barrier";
            resetPush = true;
          }

        }

        if (destCellRef.elevation.number > targetCell.elevation.number) {
          canPushTargetFree = false;
          destCellOccupant = "higherElevation";
          resetPush = true;
        }

        for(const plyr of this.players) {
          if(plyr.currentPosition.cell.number.x === destCell.x && plyr.currentPosition.cell.number.y === destCell.y) {

            // change when implementing push player
            canPushTargetFree = false;
            resetPush = true;
            destCellOccupant = `player_${plyr.number}`;
          }
        }

      }
      else {


        if (targetCell.barrier.state === true) {

          // --------------
          let barrier = this.checkForwardBarrier(impactDirection,targetCell);



          if (barrier === true) {
            console.log('barrier in obstacle cell in front of target player');
            canPushTargetFree = false;
            destCellOccupant = "barrier";
            resetPush = true;
          }
          // --------------


          if (targetCell.barrier.position === impactDirection) {
            console.log('barrier in obstacle cell behind target player');
            canPushTargetFree = false;
            destCellOccupant = "barrier";
            resetPush = true;
          }

        }

      }

      let extraPush = 0;
      if (pushStrengthPlayer >= pushStrengthThreshold) {
        canPushStrength = true;
        extraPush = pushStrengthPlayer - pushStrengthThreshold;
        console.log('you are strongh enough to push this player',pushStrengthPlayer,pushStrengthThreshold,pusher.crits.guardBreak-2,pusher.crits.pushBack-2,'extra',extraPush);
      }
      else {
        console.log('you are NOT strong enough to push this player',pushStrengthPlayer,pushStrengthThreshold,pusher.crits.guardBreak-2,pusher.crits.pushBack-2);
        resetPush = true;
      }
      if (extraPush > 3) {
        console.log('extra push force. Push player w/o plyr move');
        movePlayer = false;
      }


      if(canPushStrength === true && canPushTargetFree === true && !destCellRef) {

        if (!this.players[pusher.number-1].popups.find(x=>x.msg === "canPush")) {
          this.players[pusher.number-1].popups.push(
            {
              state: false,
              count: 0,
              limit: 25,
              type: '',
              position: '',
              msg: 'canPush',
              img: '',
            }
          )
        }

        if (this.players[pusher.number-1].popups.find(x=>x.msg === 'prePush')) {
          this.players[pusher.number-1].popups.splice(this.players[pusher.number-1].popups.findIndex(x=>x.msg === 'prePush'),1)
        }
        if (this.players[pusher.number-1].popups.find(x=>x.msg === 'noPush')) {
          this.players[pusher.number-1].popups.splice(this.players[pusher.number-1].popups.findIndex(x=>x.msg === 'noPush'),1)
        }


        // MOVE TARGET PLAYER
        this.players[targetPlayer.number-1].strafing.direction = impactDirection;
        this.players[targetPlayer.number-1].strafing.state = true;
        this.players[targetPlayer.number-1].action = 'strafe moving';


        this.unsetDeflection(targetPlayer);


        this.players[targetPlayer.number-1].pushed = {
          state: true,
          pusher: pusher.number,
          moveSpeed: moveSpeed,
        }
        this.getTarget(targetPlayer);

        if (!this.players[targetPlayer.number-1].popups.find(x=>x.msg === "pushedPulled")) {
          this.players[targetPlayer.number-1].popups.push(
            {
              state: false,
              count: 0,
              limit: this.players[targetPlayer.number-1].prePull.limit,
              type: '',
              position: '',
              msg: 'pushedPulled',
              img: '',
            }
          )
        }
        this.players[targetPlayer.number-1].moving = {
          state: true,
          step: 0,
          course: '',
          origin: {
            number: {
              x: targetPlayer.currentPosition.cell.number.x,
              y: targetPlayer.currentPosition.cell.number.y
            },
            center: {
              x: targetPlayer.currentPosition.cell.center,
              y: targetPlayer.currentPosition.cell.center
            },
          },
          destination: targetPlayer.target.cell1.center,
        }
        let targetPlyrNextPosition = this.lineCrementer(targetPlayer);
        this.players[targetPlayer.number-1].nextPosition = targetPlyrNextPosition;


        // MOVE PUSHER
        this.players[pusher.number-1].prePush = {
            state: false,
            count: 0,
            limit: pusher.prePush.limit,
            targetCell: undefined,
            direction: "",
            pusher: undefined,
        }

        if (movePlayer === true) {

          this.players[pusher.number-1].pushing = {
              state: true,
              targetCell: targetCell,
              moveSpeed: moveSpeed,
          }

          if (pusher.turning.delayCount === 0) {
            this.players[pusher.number-1].action = 'moving';
            this.players[pusher.number-1].moving = {
              state: true,
              step: 0,
              course: '',
              origin: {
                number: {
                  x: pusher.currentPosition.cell.number.x,
                  y: pusher.currentPosition.cell.number.y
                },
                center: {
                  x: pusher.currentPosition.cell.center,
                  y: pusher.currentPosition.cell.center
                },
              },
              destination: targetCell.center
            }
            let nextPosition = this.lineCrementer(pusher);
            pusher.nextPosition = nextPosition;

          }

        }


      }

      // console.log('pushStrengthThreshold/Player',pushStrengthThreshold,pushStrengthPlayer);



      if (canPushTargetFree !== true) {
        console.log('something is in the way of the player to be pushed');
        resetPush = true;
      }

      if (canPushStrength === true && canPushTargetFree === true && destCellRef) {

        // console.log('ready to push');
        if (!this.players[pusher.number-1].popups.find(x=>x.msg === "canPush")) {
          this.players[pusher.number-1].popups.push(
            {
              state: false,
              count: 0,
              limit: 25,
              type: '',
              position: '',
              msg: 'canPush',
              img: '',
            }
          )
        }

        if (this.players[pusher.number-1].popups.find(x=>x.msg === 'prePush')) {
          this.players[pusher.number-1].popups.splice(this.players[pusher.number-1].popups.findIndex(x=>x.msg === 'prePush'),1)
        }
        if (this.players[pusher.number-1].popups.find(x=>x.msg === 'noPush')) {
          this.players[pusher.number-1].popups.splice(this.players[pusher.number-1].popups.findIndex(x=>x.msg === 'noPush'),1)
        }


        // MOVE TARGET PLAYER
        this.players[targetPlayer.number-1].strafing.direction = impactDirection;
        this.players[targetPlayer.number-1].strafing.state = true;
        this.players[targetPlayer.number-1].action = 'strafe moving';

        this.unsetDeflection(targetPlayer);


        this.players[targetPlayer.number-1].pushed = {
          state: true,
          pusher: pusher.number,
          moveSpeed: moveSpeed,
        }
        this.getTarget(targetPlayer);

        if (!this.players[targetPlayer.number-1].popups.find(x=>x.msg === "pushedPulled")) {
          this.players[targetPlayer.number-1].popups.push(
            {
              state: false,
              count: 0,
              limit: this.players[targetPlayer.number-1].prePull.limit,
              type: '',
              position: '',
              msg: 'pushedPulled',
              img: '',
            }
          )
        }

        this.players[targetPlayer.number-1].moving = {
          state: true,
          step: 0,
          course: '',
          origin: {
            number: {
              x: targetPlayer.currentPosition.cell.number.x,
              y: targetPlayer.currentPosition.cell.number.y
            },
            center: {
              x: targetPlayer.currentPosition.cell.center,
              y: targetPlayer.currentPosition.cell.center
            },
          },
          destination: destCellRef.center
        }
        let targetPlyrNextPosition = this.lineCrementer(targetPlayer);
        this.players[targetPlayer.number-1].nextPosition = targetPlyrNextPosition;


        // MOVE PUSHER
        this.players[pusher.number-1].prePush = {
            state: false,
            count: 0,
            limit: pusher.prePush.limit,
            targetCell: undefined,
            direction: "",
            pusher: undefined,
        }
        if (movePlayer === true) {

          this.players[pusher.number-1].pushing = {
              state: true,
              targetCell: targetCell,
              moveSpeed: moveSpeed,
          }

          if (pusher.turning.delayCount === 0) {
            this.players[pusher.number-1].action = 'moving';
            this.players[pusher.number-1].moving = {
              state: true,
              step: 0,
              course: '',
              origin: {
                number: {
                  x: pusher.currentPosition.cell.number.x,
                  y: pusher.currentPosition.cell.number.y
                },
                center: {
                  x: pusher.currentPosition.cell.center,
                  y: pusher.currentPosition.cell.center
                },
              },
              destination: targetCell.center
            }
            let nextPosition = this.lineCrementer(pusher);
            pusher.nextPosition = nextPosition;

          }

        }
        else {
          pusher.action = 'idle';
        }

      }


    }
    else {

      pusher.stamina.current = 0;
      resetPush = true;
      pusher.statusDisplay = {
        state: true,
        status: "Out of Stamina",
        count: 1,
        limit: pusher.statusDisplay.limit,
      }

      if (!pusher.popups.find(x => x.msg === 'outOfStamina')) {
        pusher.popups.push(
          {
            state: false,
            count: 0,
            limit: 20,
            type: '',
            position: '',
            msg: 'outOfStamina',
            img: '',

          }
        )
      }
    }


    if (resetPush === true) {
      this.players[pusher.number-1].prePush = {
          state: false,
          count: 0,
          limit: pusher.prePush.limit,
          targetCell: undefined,
          direction: "",
          pusher: undefined,
      }
      this.players[pusher.number-1].pushing = {
          state: false,
          targetCell: undefined,
          moveSpeed: 0,
      }
      if (this.players[pusher.number-1].newPushPullDelay.state !== true) {
        this.players[pusher.number-1].newPushPullDelay.state = true;
      }

      if (!this.players[pusher.number-1].popups.find(x=>x.msg === "noPush")) {
        this.players[pusher.number-1].popups.push(
          {
            state: false,
            count: 0,
            limit: 25,
            type: '',
            position: '',
            msg: 'noPush',
            img: '',
          }
        )
      }

      if (this.players[pusher.number-1].popups.find(x=>x.msg === 'prePush')) {
        this.players[pusher.number-1].popups.splice(this.players[pusher.number-1].popups.findIndex(x=>x.msg === 'prePush'),1)
      }
      if (this.players[pusher.number-1].popups.find(x=>x.msg === 'canaPush')) {
        this.players[pusher.number-1].popups.splice(this.players[pusher.number-1].popups.findIndex(x=>x.msg === 'canPush'),1)
      }

      if (canPushTargetFree !== true && destCellOccupant !== "") {

        let type = destCellOccupant;
        if (type.split("_")[1]) {
          type = "player";
        }
        this.startHalfPushBack('player',type,impactDirection,targetPlayer);

      }


    }


  }
  preObstaclePullCheck = (player,target,pullDirection) => {
    // console.log('pre obstacle pull check');

    let resetPull = false;
    let refCell = this.gridInfo.find(x => x.number.x === target.cell1.number.x && x.number.y === target.cell1.number.y);
    let plyrRefCell = this.gridInfo.find(x => x.number.x === player.currentPosition.cell.number.x && x.number.y === player.currentPosition.cell.number.y);
    let limit = player.defending.limit-1;
    let myCellCheck = true;
    if (plyrRefCell.barrier.state === true && plyrRefCell.barrier.position === player.direction) {
      myCellCheck = false
    }
    if (myCellCheck !== true) {
      console.log('a barrier in player cell is blocking a pull');
      resetPull = true;
    }

    if(refCell.obstacle.state !== true) {
      console.log('barrier not obstacle. Cant be pulled');
      resetPull = true;
    }
    else if (refCell.obstacle.moving.pushable === true && myCellCheck === true && player.newPushPullDelay.state !== true) {
      if (player.prePull.state !== true && player.prePull.count === 0) {
        // console.log('start pre pull');
        player.prePull = {
          state: true,
          count: player.prePull.count++,
          limit: player.prePull.limit,
          targetCell: refCell,
          direction: pullDirection,
          puller: player.number,
        }

      }

      if (player.prePull.state === true) {

        if (player.prePull.count >= player.prePull.limit) {
        // if (player.prePull.count >= 25) {
        // if (player.prePull.count >= limit) {

          console.log('pre pull limit. check can pull');
          this.players[player.number-1].prePull = player.prePull;
          this.players[player.number-1].pulling = player.pulling;
          if (player.popups.find(x=>x.msg === 'prePull')) {
            player.popups.splice(player.popups.findIndex(x=>x.msg === 'prePull'),1)
          }
          this.canPullObstacle(player,refCell);

        }
        else {

           if (
             player.prePull.targetCell.number.x === refCell.number.x &&
             player.prePull.targetCell.number.y === refCell.number.y &&
             player.prePull.direction === pullDirection &&
             player.prePull.puller === player.number
           ) {

             player.prePull.count++;
             if (!player.popups.find(x=>x.msg === "prePull")) {
               player.popups.push(
                 {
                   state: false,
                   count: 0,
                   limit: player.prePull.limit,
                   type: '',
                   position: '',
                   msg: 'prePull',
                   img: '',
                 }
               )
             }
             // console.log('pre pulling the same obstacle. Continue',player.prePull.count,limit);
           }
           else {
             // console.log('pre pull player, target or direction has changed. Reset prepull');
             player.action = 'idle';
             player.prePull = {
               state: false,
               count: 0,
               limit: player.prePull.limit,
               targetCell: undefined,
               direction: "",
               puller: undefined,
             };

             resetPull = true;

           }

         }

      }
    }

    if (player.newPushPullDelay.state === true) {
      resetPull = true;
    }

    if (refCell.obstacle.moving.pushable !== true) {
      console.log('obstacle is instrinsically unpullable');
      resetPull = true;
    }


    if (resetPull === true) {
      player.action = 'idle';
      player.prePull = {
        state: false,
        count: 0,
        limit: player.prePull.limit,
        targetCell: undefined,
        direction: "",
        puller: undefined,
      };
      player.postPull = {
        state: true,
        count: 0,
        limit: player.postPull.limit
      }

      this.players[player.number-1].defending = {
        state: false,
        count: 0,
        limit: player.defending.limit,
      };
      this.players[player.number-1].defendDecay = {
        state: false,
        count: 0,
        limit: 25,
      };

      this.keyPressed[player.number-1].defend = false;
      this.keyPressed[player.number-1].north = false;
      this.keyPressed[player.number-1].south = false;
      this.keyPressed[player.number-1].east = false;
      this.keyPressed[player.number-1].west = false;

      if (this.players[player.number-1].newPushPullDelay.state !== true) {
        this.players[player.number-1].newPushPullDelay.state = true
      }


      if (!player.popups.find(x=>x.msg === "noPull")) {
        player.popups.push(
          {
            state: false,
            count: 0,
            limit: player.prePull.limit,
            type: '',
            position: '',
            msg: 'noPull',
            img: '',
          }
        )
      }

      if (player.popups.find(x=>x.msg === 'prePull')) {
        player.popups.splice(player.popups.findIndex(x=>x.msg === 'prePull'),1)
      }
      if (player.popups.find(x=>x.msg === 'canPull')) {
        player.popups.splice(player.popups.findIndex(x=>x.msg === 'canPull'),1)
      }

    }


    this.players[player.number-1].prePull = player.prePull;
    this.players[player.number-1].pulling = player.pulling;


  }
  canPullObstacle = (player,obstacleCell) => {

    let resetPull = false;
    let thresholdMultiplier = this.rnJesus(1,3)
    let canPullStrength = false;
    let canPullTargetFree = true;
    let pullStrengthThreshold = (obstacleCell.obstacle.height + obstacleCell.obstacle.weight)*thresholdMultiplier;
    let pullStrengthPlayer = 0;
    let impactDirection = player.prePull.direction;


    if (player.stamina.current - this.staminaCostRef.pull >= 0) {

      player.stamina.current = player.stamina.current - this.staminaCostRef.pull;

      if (player.hp > 1) {
        pullStrengthPlayer += (player.hp-1)
      }
      pullStrengthPlayer += (player.crits.pushBack-3);
      pullStrengthPlayer += (player.crits.guardBreak-2);
      let playerCellRef = this.gridInfo.find(x => x.number.x === player.currentPosition.cell.number.x && x.number.y === player.currentPosition.cell.number.y)


      let destCell = this.getCellFromDirection(1,player.currentPosition.cell.number,impactDirection);


      let destCellRef = this.gridInfo.find(x => x.number.x === destCell.x && x.number.y === destCell.y);
      let destCellOccupant = "";

      let preMoveSpeed = Math.ceil(pullStrengthPlayer/pullStrengthThreshold);
      let moveSpeed = 0;
      if (preMoveSpeed <= 1) {
        moveSpeed = .05;
      }
      if (preMoveSpeed === 2) {
        moveSpeed = .1;
      }
      if (preMoveSpeed > 2 && preMoveSpeed < 4) {
        moveSpeed = .125;
      }
      if (preMoveSpeed > 4) {
        moveSpeed = .2;
      }
      // pullStrengthThreshold = 100
      if (this.terrainMoveSpeedRef[obstacleCell.terrain.type]) {
        moveSpeed = this.terrainMoveSpeedRef[obstacleCell.terrain.type];
      }

      if (destCellRef) {

        if (destCellRef.obstacle.state === true) {
          canPullTargetFree = false;
          destCellOccupant = "obstacle";
          resetPull = true;
        }

        if (destCellRef.barrier.state === true) {

          let barrier = this.checkForwardBarrier(impactDirection,destCellRef);


          if (barrier === true) {
              canPullTargetFree = false;
              destCellOccupant = "barrier";
              resetPull = true;
          }


        }

        if (obstacleCell.barrier.state === true) {


          if (obstacleCell.barrier.position === impactDirection) {
            console.log('barrier in obstacle cell behind obstacle');
            canPullTargetFree = false;
            destCellOccupant = "barrier";
            resetPull = true;
          }

        }

        for(const plyr of this.players) {
          if(plyr.currentPosition.cell.number.x === destCell.x && plyr.currentPosition.cell.number.y === destCell.y) {


            canPullTargetFree = false;
            resetPull = true;
            destCellOccupant = `player_${plyr.number}`;
          }
        }

      }

      if(!destCellRef && pullStrengthPlayer >= pullStrengthThreshold) {

        // console.log('ready to pull',moveSpeed);
        if (!this.players[player.number-1].popups.find(x=>x.msg === "canPull")) {
          this.players[player.number-1].popups.push(
            {
              state: false,
              count: 0,
              limit: 25,
              type: '',
              position: '',
              msg: 'canPull',
              img: '',
            }
          )
        }

        if (this.players[player.number-1].popups.find(x=>x.msg === 'prePull')) {
          this.players[player.number-1].popups.splice(this.players[player.number-1].popups.findIndex(x=>x.msg === 'prePull'),1)
        }
        if (this.players[player.number-1].popups.find(x=>x.msg === 'noPull')) {
          this.players[player.number-1].popups.splice(this.players[player.number-1].popups.findIndex(x=>x.msg === 'noPull'),1)
        }


        let voidCenter = this.getVoidCenter(1,impactDirection,playerCellRef.center);



        this.players[player.number-1].defending = {
          state: false,
          count: 0,
          limit: player.defending.limit
        };
        this.players[player.number-1].defendDecay = {
          state: false,
          count: 0,
          limit: player.defendDecay.limit,
        };


        let obstacleCrementObj = this.obstacleMoveCrementer(obstacleCell,{center:playerCellRef.center});

        obstacleCell.obstacle =
        {
          state: obstacleCell.obstacle.state,
          name: obstacleCell.obstacle.name,
          type: obstacleCell.obstacle.type,
          hp: obstacleCell.obstacle.hp,
          destructible: obstacleCell.obstacle.destructible,
          locked: obstacleCell.obstacle.locked,
          weight: obstacleCell.obstacle.weight,
          height: obstacleCell.obstacle.height,
          items: obstacleCell.obstacle.items,
          effects: obstacleCell.obstacle.effects,
          moving: {
            state: true,
            step: obstacleCrementObj.step,
            origin: {
              number: obstacleCell.number,
              center: obstacleCell.center,
            },
            destination: {
              number: playerCellRef.number,
              center: playerCellRef.center,
            },
            currentPosition: obstacleCell.center,
            nextPosition: obstacleCrementObj.pos,
            moveSpeed: moveSpeed,
            pushable: true,
            pushed: true,
            pusher: player.number,
            falling: obstacleCell.obstacle.moving.falling,
          }
        };


        this.players[player.number-1].prePull = {
            state: false,
            count: 0,
            limit: player.prePull.limit,
            targetCell: undefined,
            direction: "",
            puller: undefined,
        }
        this.players[player.number-1].pulling = {
            state: true,
            targetCell: obstacleCell,
            moveSpeed: moveSpeed,
        }

        // this.players[player.number-1].postPull = {
        //   state: true,
        //   count: 0,
        //   limit: player.postPull.limit
        // }

        if (player.turning.delayCount === 0) {
          player.target.cell1.void = true;
          this.players[player.number-1].strafing.direction = impactDirection;
          this.players[player.number-1].strafing.state = true;
          this.players[player.number-1].action = 'strafe moving';
          this.players[player.number-1].moving = {
            state: true,
            step: 0,
            course: '',
            origin: {
              number: {
                x: player.currentPosition.cell.number.x,
                y: player.currentPosition.cell.number.y
              },
              center: {
                x: player.currentPosition.cell.center,
                y: player.currentPosition.cell.center
              },
            },
            destination: voidCenter
          }
          let nextPosition = this.lineCrementer(player);
          player.nextPosition = nextPosition;

        }


      }

      // console.log('pushStrengthThreshold/Player',pushStrengthThreshold,pushStrengthPlayer);

      if (pullStrengthPlayer >= pullStrengthThreshold && obstacleCell.obstacle.moving.pushable === true) {
        canPullStrength = true;
        console.log('you are strongh enough to pull this obstacle',pullStrengthPlayer,pullStrengthThreshold,player.crits.guardBreak-2,player.crits.pushBack-2);
      }
      else {
        console.log('you are NOT strong enough to pull this obstacle',pullStrengthPlayer,pullStrengthThreshold,player.crits.guardBreak-2,player.crits.pushBack-2);
        resetPull = true;
      }

      if (canPullTargetFree !== true) {
        console.log('something is in the way of the obstacle to be pulled');
        resetPull = true;
      }

      if (canPullStrength === true && canPullTargetFree === true && destCellRef) {

        // console.log('ready to pull',moveSpeed);
        if (!this.players[player.number-1].popups.find(x=>x.msg === "canPull")) {
          this.players[player.number-1].popups.push(
            {
              state: false,
              count: 0,
              limit: 25,
              type: '',
              position: '',
              msg: 'canPull',
              img: '',
            }
          )
        }

        if (this.players[player.number-1].popups.find(x=>x.msg === 'prePull')) {
          this.players[player.number-1].popups.splice(this.players[player.number-1].popups.findIndex(x=>x.msg === 'prePull'),1)
        }
        if (this.players[player.number-1].popups.find(x=>x.msg === 'noPull')) {
          this.players[player.number-1].popups.splice(this.players[player.number-1].popups.findIndex(x=>x.msg === 'noPull'),1)
        }


        let obstacleCrementObj = this.obstacleMoveCrementer(obstacleCell,playerCellRef);

        obstacleCell.obstacle =
        {
          state: obstacleCell.obstacle.state,
          name: obstacleCell.obstacle.name,
          type: obstacleCell.obstacle.type,
          hp: obstacleCell.obstacle.hp,
          destructible: obstacleCell.obstacle.destructible,
          locked: obstacleCell.obstacle.locked,
          weight: obstacleCell.obstacle.weight,
          height: obstacleCell.obstacle.height,
          items: obstacleCell.obstacle.items,
          effects: obstacleCell.obstacle.effects,
          moving: {
            state: true,
            step: obstacleCrementObj.step,
            origin: {
              number: obstacleCell.number,
              center: obstacleCell.center,
            },
            destination: {
              number: playerCellRef.number,
              center: playerCellRef.center,
            },
            currentPosition: obstacleCell.center,
            nextPosition: obstacleCrementObj.pos,
            moveSpeed: moveSpeed,
            pushable: true,
            pushed: true,
            pusher: player.number,
            falling: obstacleCell.obstacle.moving.falling,
          }
        };


        this.players[player.number-1].prePull = {
            state: false,
            count: 0,
            limit: player.prePull.limit,
            targetCell: undefined,
            direction: "",
            puller: undefined,
        }
        this.players[player.number-1].pulling = {
            state: true,
            targetCell: obstacleCell,
            moveSpeed: moveSpeed,
        }
        this.players[player.number-1].defending = {
          state: false,
          count: 0,
          limit: player.defending.limit
        };
        this.players[player.number-1].defendDecay = {
          state: false,
          count: 0,
          limit: player.defendDecay.limit,
        };

        this.getTarget(player);

        if (player.turning.delayCount === 0) {

          this.players[player.number-1].strafing.direction = impactDirection;
          this.players[player.number-1].strafing.state = true;
          this.players[player.number-1].action = 'strafe moving';
          this.players[player.number-1].moving = {
            state: true,
            step: 0,
            course: '',
            origin: {
              number: {
                x: player.currentPosition.cell.number.x,
                y: player.currentPosition.cell.number.y
              },
              center: {
                x: player.currentPosition.cell.center,
                y: player.currentPosition.cell.center
              },
            },
            destination: destCell.center
          }
          let nextPosition = this.lineCrementer(player);
          player.nextPosition = nextPosition;

        }

      }


    }
    else {

      player.stamina.current = 0;
      resetPull = true;
      player.statusDisplay = {
        state: true,
        status: "Out of Stamina",
        count: 1,
        limit: player.statusDisplay.limit,
      }

      if (!player.popups.find(x => x.msg === 'outOfStamina')) {
        player.popups.push(
          {
            state: false,
            count: 0,
            limit: 20,
            type: '',
            position: '',
            msg: 'outOfStamina',
            img: '',

          }
        )
      };

    }


    if (resetPull === true) {

      this.players[player.number-1].action = 'idle';
      this.players[player.number-1].prePull = {
          state: false,
          count: 0,
          limit: player.prePull.limit,
          targetCell: undefined,
          direction: "",
          puller: undefined,
      }
      this.players[player.number-1].pulling = {
          state: false,
          targetCell: undefined,
          moveSpeed: 0,
      }

      this.players[player.number-1].defending = {
        state: false,
        count: 0,
        limit: player.defending.limit,
      };
      this.players[player.number-1].defendDecay = {
        state: false,
        count: 0,
        limit: 25,
      };
      this.players[player.number-1].postPull = {
        state: true,
        count: 0,
        limit: player.postPull.limit
      }

      this.keyPressed[player.number-1].defend = false;
      this.keyPressed[player.number-1].north = false;
      this.keyPressed[player.number-1].south = false;
      this.keyPressed[player.number-1].east = false;
      this.keyPressed[player.number-1].west = false;

      if (this.players[player.number-1].newPushPullDelay.state !== true) {
        this.players[player.number-1].newPushPullDelay.state = true
      }

      if (!this.players[player.number-1].popups.find(x=>x.msg === "noPull")) {
        this.players[player.number-1].popups.push(
          {
            state: false,
            count: 0,
            limit: 25,
            type: '',
            position: '',
            msg: 'noPull',
            img: '',
          }
        )
      }

      if (this.players[player.number-1].popups.find(x=>x.msg === 'prePull')) {
        this.players[player.number-1].popups.splice(this.players[player.number-1].popups.findIndex(x=>x.msg === 'prePull'),1)
      }
      if (this.players[player.number-1].popups.find(x=>x.msg === 'canPull')) {
        this.players[player.number-1].popups.splice(this.players[player.number-1].popups.findIndex(x=>x.msg === 'canPull'),1)
      }


    }

  }
  prePlayerPullCheck = (puller,target,pullDirection) => {
    // console.log('pre player pull check');

    let resetPull = false;
    let targetCell = this.gridInfo.find(x => x.number.x === target.cell1.number.x && x.number.y === target.cell1.number.y);
    let plyrRefCell = this.gridInfo.find(x => x.number.x === puller.currentPosition.cell.number.x && x.number.y === puller.currentPosition.cell.number.y);
    let limit = puller.defending.limit-1;
    let myCellCheck = true;
    if (plyrRefCell.barrier.state === true && plyrRefCell.barrier.position === puller.direction) {
      myCellCheck = false
    }
    if (myCellCheck !== true) {
      console.log('a barrier in player cell is blocking a player push');
      resetPull = true;
    }

    let targetOpen = false;
    let targetPlayer = this.players[target.cell1.occupant.player-1];
    if (targetPlayer.success.deflected.state === true || targetPlayer.action === 'idle') {
      targetOpen = true;
    } else {
      console.log('target player is no longer deflected or idle');
      resetPull = true;
    }

    if (targetOpen === true && myCellCheck === true && puller.newPushPullDelay.state !== true) {
      if (puller.prePull.state !== true && puller.prePull.count === 0) {
        // console.log('start player pre pull');
        puller.prePull = {
          state: true,
          count: puller.prePull.count++,
          limit: puller.prePull.limit,
          targetCell: targetCell,
          direction: pullDirection,
          puller: puller.number,
        }

      }

      if (puller.prePull.state === true) {

        if (puller.prePull.count >= puller.prePull.limit) {
        // if (puller.prePllh.count >= 25) {
        // if (puller.prePull.count >= limit) {

          // console.log('pre pull limit. check can pull player');
          this.players[puller.number-1].prePull = puller.prePull;
          this.players[puller.number-1].pulling = puller.pulling;
          if (puller.popups.find(x=>x.msg === 'prePull')) {
            puller.popups.splice(puller.popups.findIndex(x=>x.msg === 'prePull'),1)
          }
          this.canPullPlayer(puller,targetCell,targetPlayer);

        }
        else {

           if (
             puller.prePull.targetCell.number.x === targetCell.number.x &&
             puller.prePull.targetCell.number.y === targetCell.number.y &&
             puller.prePull.direction === pullDirection &&
             puller.prePull.puller === puller.number
           ) {

             puller.prePull.count++;
             if (!puller.popups.find(x=>x.msg === "prePull")) {
               puller.popups.push(
                 {
                   state: false,
                   count: 0,
                   limit: puller.prePull.limit,
                   type: '',
                   position: '',
                   msg: 'prePull',
                   img: '',
                 }
               )
             }
             // console.log('pre pulling the same player. Continue',puller.prePull.count);
           }
           else {
             // console.log('pre pull player, target or direction has changed. Reset prepull');
             puller.prePull = {
               state: false,
               count: 0,
               limit: puller.prePull.limit,
               targetCell: undefined,
               direction: "",
               puller: undefined,
             };

             resetPull = true;
           }

         }

      }
    }

    if (puller.newPushPullDelay.state === true) {
      resetPull = true;
    }

    if (targetOpen !== true) {
      // console.log('player is unpullable');
      resetPull = true;
    }


    if (resetPull === true) {
      puller.action = 'idle';
      puller.prePull = {
        state: false,
        count: 0,
        limit: puller.prePull.limit,
        targetCell: undefined,
        direction: "",
        puller: undefined,
      };

      this.players[puller.number-1].defending = {
        state: false,
        count: 0,
        limit: puller.defending.limit,
      };
      this.players[puller.number-1].defendDecay = {
        state: false,
        count: 0,
        limit: 25,
      };

      this.keyPressed[puller.number-1].defend = false;
      this.keyPressed[puller.number-1].north = false;
      this.keyPressed[puller.number-1].south = false;
      this.keyPressed[puller.number-1].east = false;
      this.keyPressed[puller.number-1].west = false;

      if (this.players[puller.number-1].newPushPullDelay.state !== true) {
        this.players[puller.number-1].newPushPullDelay.state = true
      }

      if (!this.players[puller.number-1].popups.find(x=>x.msg === "noPull")) {
        this.players[puller.number-1].popups.push(
          {
            state: false,
            count: 0,
            limit: this.players[puller.number-1].prePull.limit,
            type: '',
            position: '',
            msg: 'noPull',
            img: '',
          }
        )
      }

      if (this.players[puller.number-1].popups.find(x=>x.msg === 'prePull')) {
        this.players[puller.number-1].popups.splice(this.players[puller.number-1].popups.findIndex(x=>x.msg === 'prePull'),1)
      }
      if (this.players[puller.number-1].popups.find(x=>x.msg === 'canPull')) {
        this.players[puller.number-1].popups.splice(this.players[puller.number-1].popups.findIndex(x=>x.msg === 'canPull'),1)
      }

    }


    this.players[puller.number-1].prePull = puller.prePull;
    this.players[puller.number-1].pulling = puller.pulling;


  }
  canPullPlayer = (puller,targetCell,targetPlayer) => {

    let resetPull = false;
    let thresholdMultiplier = this.rnJesus(1,3)
    let canPullStrength = false;
    let canPullTargetFree = true;
    let pullStrengthThreshold = (targetPlayer.hp + (targetPlayer.crits.pushBack-3) + (targetPlayer.crits.guardBreak-2))*thresholdMultiplier;
    let pullStrengthPlayer = 0;
    let movePlayer = true;
    let impactDirection = puller.prePull.direction;
    let pullerCellRef = this.gridInfo.find(x => x.number.x === puller.currentPosition.cell.number.x && x.number.y === puller.currentPosition.cell.number.y);



    if (puller.stamina.current - this.staminaCostRef.pull >= 0) {

      puller.stamina.current = puller.stamina.current - this.staminaCostRef.pull;

      if (puller.hp > 1) {
        pullStrengthPlayer += (puller.hp-1)
      }
      pullStrengthPlayer += (puller.crits.pushBack-3);
      pullStrengthPlayer += (puller.crits.guardBreak-2);
      // pullStrengthPlayer += 15;


      let destCell = this.getCellFromDirection(1,puller.currentPosition.cell.number,impactDirection);

      // console.log('destCell',destCell,'pull pos',puller.currentPosition.cell.number,'impact dir',impactDirection);
      let destCellRef = this.gridInfo.find(x => x.number.x === destCell.x && x.number.y === destCell.y);
      let destCellOccupant = "";

      let preMoveSpeed = Math.ceil(pullStrengthPlayer/pullStrengthThreshold);
      let moveSpeed = 0;
      if (preMoveSpeed <= 1) {
        moveSpeed = .05;
      }
      if (preMoveSpeed === 2) {
        moveSpeed = .1;
      }
      if (preMoveSpeed > 2 && preMoveSpeed < 4) {
        moveSpeed = .125;
      }
      if (preMoveSpeed > 4) {
        moveSpeed = .2;
      }

      if (destCellRef) {

        if (destCellRef.obstacle.state === true) {
          canPullTargetFree = false;
          destCellOccupant = "obstacle";
          resetPull = true;
        }

        if (destCellRef.barrier.state === true) {

          let barrier = this.checkForwardBarrier(impactDirection,destCellRef);


          if (barrier === true) {
              canPullTargetFree = false;
              destCellOccupant = "barrier";
              resetPull = true;
          }


        }

        if (targetCell.barrier.state === true) {

          // --------------
          let barrier = this.checkForwardBarrier(impactDirection,targetCell);

          if (barrier === true) {
            console.log('barrier in obstacle cell in front of target player');
            canPullTargetFree = false;
            destCellOccupant = "barrier";
            resetPull = true;
          }
          // --------------


          if (targetCell.barrier.position === impactDirection) {
            console.log('barrier in target player cell behind target player');
            canPullTargetFree = false;
            destCellOccupant = "barrier";
            resetPull = true;
          }

        }

        for(const plyr of this.players) {
          if(plyr.currentPosition.cell.number.x === destCell.x && plyr.currentPosition.cell.number.y === destCell.y) {

            // change when implementing push player
            canPullTargetFree = false;
            resetPull = true;
            destCellOccupant = `player_${plyr.number}`;
          }
        }

      }


      if (pullStrengthPlayer >= pullStrengthThreshold) {
        canPullStrength = true;
        console.log('you are strongh enough to pull this player',pullStrengthPlayer,pullStrengthThreshold,puller.crits.guardBreak-2,puller.crits.pushBack-2);
      }
      else {
        console.log('you are NOT strong enough to pull this player',pullStrengthPlayer,pullStrengthThreshold,puller.crits.guardBreak-2,puller.crits.pushBack-2);
        resetPull = true;
      }


      // movePlayer = true;

      if(!destCellRef && pullStrengthPlayer >= pullStrengthThreshold) {

        // console.log('ready to pull',moveSpeed);
        if (!this.players[puller.number-1].popups.find(x=>x.msg === "canPull")) {
          this.players[puller.number-1].popups.push(
            {
              state: false,
              count: 0,
              limit: 25,
              type: '',
              position: '',
              msg: 'canPull',
              img: '',
            }
          )
        }

        if (this.players[puller.number-1].popups.find(x=>x.msg === 'prePull')) {
          this.players[puller.number-1].popups.splice(this.players[puller.number-1].popups.findIndex(x=>x.msg === 'prePull'),1)
        }
        if (this.players[puller.number-1].popups.find(x=>x.msg === 'noPull')) {
          this.players[puller.number-1].popups.splice(this.players[puller.number-1].popups.findIndex(x=>x.msg === 'noPull'),1)
        }




        let voidCenter = this.getVoidCenter(1,impactDirection,pullerCellRef.center);



        // MOVE TARGET PLAYER

        if (puller.prePull.direction !== targetPlayer.direction) {
          this.players[targetPlayer.number-1].strafing.direction = impactDirection;
          this.players[targetPlayer.number-1].strafing.state = true;
          this.players[targetPlayer.number-1].action = 'strafe moving';
        }
        else {
          this.players[targetPlayer.number-1].action = 'moving';
        }

        this.unsetDeflection(targetPlayer);


        this.players[targetPlayer.number-1].pulled = {
          state: true,
          puller: puller.number,
          moveSpeed: moveSpeed,
        }
        this.getTarget(targetPlayer);

        if (!this.players[targetPlayer.number-1].popups.find(x=>x.msg === "pushedPulled")) {
          this.players[targetPlayer.number-1].popups.push(
            {
              state: false,
              count: 0,
              limit: this.players[targetPlayer.number-1].prePull.limit,
              type: '',
              position: '',
              msg: 'pushedPulled',
              img: '',
            }
          )
        }

        this.players[targetPlayer.number-1].moving = {
          state: true,
          step: 0,
          course: '',
          origin: {
            number: {
              x: targetPlayer.currentPosition.cell.number.x,
              y: targetPlayer.currentPosition.cell.number.y
            },
            center: {
              x: targetPlayer.currentPosition.cell.center,
              y: targetPlayer.currentPosition.cell.center
            },
          },
          destination: pullerCellRef.center,
        }
        let targetPlyrNextPosition = this.lineCrementer(targetPlayer);
        this.players[targetPlayer.number-1].nextPosition = targetPlyrNextPosition;


        // MOVE PUllER
        this.players[puller.number-1].prePull = {
            state: false,
            count: 0,
            limit: puller.prePull.limit,
            targetCell: undefined,
            direction: "",
            puller: undefined,
        }
        this.players[puller.number-1].defending = {
          state: false,
          count: 0,
          limit: puller.defending.limit
        };
        this.players[puller.number-1].defendDecay = {
          state: false,
          count: 0,
          limit: puller.defendDecay.limit,
        };


        if (movePlayer === true) {


          this.players[puller.number-1].pulling = {
              state: true,
              targetCell: targetCell,
              moveSpeed: moveSpeed,
          }

          if (puller.turning.delayCount === 0) {
            this.players[puller.number-1].strafing.direction = impactDirection;
            this.players[puller.number-1].strafing.state = true;
            this.players[puller.number-1].action = 'strafe moving';
            this.players[puller.number-1].moving = {
              state: true,
              step: 0,
              course: '',
              origin: {
                number: {
                  x: puller.currentPosition.cell.number.x,
                  y: puller.currentPosition.cell.number.y
                },
                center: {
                  x: puller.currentPosition.cell.center,
                  y: puller.currentPosition.cell.center
                },
              },
              destination: voidCenter
            }
            let nextPosition = this.lineCrementer(puller);
            puller.nextPosition = nextPosition;

          }
        }


      }

      // console.log('pullStrengthThreshold/Player',pullStrengthThreshold,pullStrengthPlayer);



      if (canPullTargetFree !== true) {
        console.log('something is in the way of the player to be pulled');
        resetPull = true;
      }

      if (canPullStrength === true && canPullTargetFree === true && destCellRef) {

        // console.log('ready to pull',moveSpeed);
        if (!this.players[puller.number-1].popups.find(x=>x.msg === "canPull")) {
          this.players[puller.number-1].popups.push(
            {
              state: false,
              count: 0,
              limit: 25,
              type: '',
              position: '',
              msg: 'canPull',
              img: '',
            }
          )
        }

        if (this.players[puller.number-1].popups.find(x=>x.msg === 'prePull')) {
          this.players[puller.number-1].popups.splice(this.players[puller.number-1].popups.findIndex(x=>x.msg === 'prePull'),1)
        }
        if (this.players[puller.number-1].popups.find(x=>x.msg === 'noPull')) {
          this.players[puller.number-1].popups.splice(this.players[puller.number-1].popups.findIndex(x=>x.msg === 'noPull'),1)
        }



        // MOVE TARGET PLAYER
        if (impactDirection !== targetPlayer.direction) {
          this.players[targetPlayer.number-1].strafing.direction = impactDirection;
          this.players[targetPlayer.number-1].strafing.state = true;
          this.players[targetPlayer.number-1].action = 'strafe moving';
        }
        else {
          this.players[targetPlayer.number-1].action = 'moving';
        }

        this.unsetDeflection(targetPlayer);

        this.players[targetPlayer.number-1].pulled = {
          state: true,
          puller: puller.number,
          moveSpeed: moveSpeed,
        }
        this.getTarget(targetPlayer);

        if (!this.players[targetPlayer.number-1].popups.find(x=>x.msg === "pushedPulled")) {
          this.players[targetPlayer.number-1].popups.push(
            {
              state: false,
              count: 0,
              limit: this.players[targetPlayer.number-1].prePull.limit,
              type: '',
              position: '',
              msg: 'pushedPulled',
              img: '',
            }
          )
        }

        this.players[targetPlayer.number-1].moving = {
          state: true,
          step: 0,
          course: '',
          origin: {
            number: {
              x: targetPlayer.currentPosition.cell.number.x,
              y: targetPlayer.currentPosition.cell.number.y
            },
            center: {
              x: targetPlayer.currentPosition.cell.center,
              y: targetPlayer.currentPosition.cell.center
            },
          },
          destination: pullerCellRef.center
        }
        let targetPlyrNextPosition = this.lineCrementer(targetPlayer);
        this.players[targetPlayer.number-1].nextPosition = targetPlyrNextPosition;


        // MOVE PULLER
        this.players[puller.number-1].prePull = {
            state: false,
            count: 0,
            limit: puller.prePull.limit,
            targetCell: undefined,
            direction: "",
            puller: undefined,
        }
        this.players[puller.number-1].defending = {
          state: false,
          count: 0,
          limit: puller.defending.limit
        };
        this.players[puller.number-1].defendDecay = {
          state: false,
          count: 0,
          limit: puller.defendDecay.limit,
        };

        if (movePlayer === true) {

          this.players[puller.number-1].pulling = {
              state: true,
              targetCell: targetCell,
              moveSpeed: moveSpeed,
          }

          if (puller.turning.delayCount === 0) {
            this.players[puller.number-1].strafing.direction = impactDirection;
            this.players[puller.number-1].strafing.state = true;
            this.players[puller.number-1].action = 'strafe moving';
            this.players[puller.number-1].moving = {
              state: true,
              step: 0,
              course: '',
              origin: {
                number: {
                  x: puller.currentPosition.cell.number.x,
                  y: puller.currentPosition.cell.number.y
                },
                center: {
                  x: puller.currentPosition.cell.center,
                  y: puller.currentPosition.cell.center
                },
              },
              destination: destCellRef.center
            }
            let nextPosition = this.lineCrementer(puller);
            puller.nextPosition = nextPosition;

          }

        }
        else {
          puller.action = 'idle';
        }

      }

      // if target isn't free, 1/2 pushback

    }
    else {

      puller.stamina.current = 0;
      resetPull = true;
      puller.statusDisplay = {
        state: true,
        status: "Out of Stamina",
        count: 1,
        limit: puller.statusDisplay.limit,
      }

      if (!puller.popups.find(x => x.msg === 'outOfStamina')) {
        puller.popups.push(
          {
            state: false,
            count: 0,
            limit: 20,
            type: '',
            position: '',
            msg: 'outOfStamina',
            img: '',

          }
        )
      }
    }


    if (resetPull === true) {
      this.players[puller.number-1].action = 'idle';
      this.players[puller.number-1].prePull = {
          state: false,
          count: 0,
          limit: puller.prePull.limit,
          targetCell: undefined,
          direction: "",
          puller: undefined,
      }
      this.players[puller.number-1].pulling = {
          state: false,
          targetCell: undefined,
          moveSpeed: 0,
      }

      this.players[puller.number-1].defending = {
        state: false,
        count: 0,
        limit: puller.defending.limit,
      };
      this.players[puller.number-1].defendDecay = {
        state: false,
        count: 0,
        limit: 25,
      };
      this.players[puller.number-1].postPull = {
        state: true,
        count: 0,
        limit: puller.postPull.limit
      }

      this.keyPressed[puller.number-1].defend = false;
      this.keyPressed[puller.number-1].north = false;
      this.keyPressed[puller.number-1].south = false;
      this.keyPressed[puller.number-1].east = false;
      this.keyPressed[puller.number-1].west = false;

      if (this.players[puller.number-1].newPushPullDelay.state !== true) {
        this.players[puller.number-1].newPushPullDelay.state = true
      }


      if (!this.players[puller.number-1].popups.find(x=>x.msg === "noPull")) {
        this.players[puller.number-1].popups.push(
          {
            state: false,
            count: 0,
            limit: 25,
            type: '',
            position: '',
            msg: 'noPull',
            img: '',
          }
        )
      }


      if (this.players[puller.number-1].popups.find(x=>x.msg === 'prePull')) {
        this.players[puller.number-1].popups.splice(this.players[puller.number-1].popups.findIndex(x=>x.msg === 'prePull'),1)
      }
      if (this.players[puller.number-1].popups.find(x=>x.msg === 'canPull')) {
        this.players[puller.number-1].popups.splice(this.players[puller.number-1].popups.findIndex(x=>x.msg === 'canPull'),1)
      }



    }

  }


  respawn = (player) => {
    // console.log('respawning',player.number,player);

    this.resetTarget(player);
    this.unsetDeflection(player);
    player.respawn = true;
    player.action = 'idle';
    player.hp = 2;
    player.speed.move = .1;
    // player.dead = {
    //   state: false,
    //   count: 0,
    //   limit: player.dead.limit
    // }
    player.ghost.state = false;
    player.drowning = false;
    player.dodging = {
      countState: false,
      state: false,
      count: 0,
      limit: 20,
      peak: {
        start: 5,
        end: 10,
      }
    };
    player.crits = {
      singleHit: 1,
      doubleHit: 6,
      pushBack: 3,
      guardBreak: 3,
      dodge: 0,
    };
    player.items = {
      weaponIndex: 0,
      armorIndex: 0,
      weapons: [{
        name: 'sword1',
        type: 'sword',
        effect: '',
      }],
      armor: [],
      ammo: 0,
    };
    player.currentWeapon = {
      name: 'sword1',
      type: 'sword',
      effect: '',
    };
    player.currentArmor = {};
    player.strafing = {
      state: false,
      direction: '',
    };
    player.pushBack = {
      state: false,
      prePushBackMoveSpeed: 0,
    };
    player.flanking = {
      checking: false,
      direction: '',
      preFlankDirection: '',
      state: false,
      step: 0,
      target1: {x:0 ,y:0},
      target2: {x:0 ,y:0},
    }
    player.itemDrop = {
      state: false,
      count: 0,
      limit: 10,
      item: {
        name: '',
      },
      gear: {
        type: '',
      }
    };
    player.itemPickup = {
      state: false,
      count: 0,
      limit: 10,
      item: {
        name: '',
      },
      gear: {
        type: '',
      }
    };
    player.jumping = {
      checking: false,
      state: false,
    };
    player.stamina = {
      current: 20,
      max: 20,
    };
    player.popups = [];
    player.prePush = {
      state: false,
      count: 0,
      limit: 15,
      targetCell: undefined,
      direction: "",
      pusher: undefined,
    };
    player.pushing = {
      state: false,
      targetCell: undefined,
      moveSpeed: 0,
    };
    player.prePull = {
      state: false,
      count: 0,
      limit: 15,
      targetCell: undefined,
      direction: "",
      puller: undefined,
    };
    player.pulling = {
      state: false,
      targetCell: undefined,
      moveSpeed: 0,
    };
    player.postPull = {
      state: false,
      count: 0,
      limit: player.postPull.limit
    }
    player.pushed = {
      state: false,
      pusher: 0,
      moveSpeed: 0,
    };
    player.pulled = {
      state: false,
      puller: 0,
      moveSpeed: 0,
    };
    player.popups = [{
      state: true,
      count: 0,
      limit: 0,
      type: '',
      position: 'northWest',
      msg: '',
      img: '',
    }]

    this.players[player.number-1] = player;

  }
  killPlayer = (player) => {
    // console.log('killing player',player);

    player.ghost.state = true;
    player.ghost.position.cell = player.currentPosition.cell;
    player.currentPosition.cell.number = {x: undefined, y: undefined};
    player.action = 'idle';
    player.direction = 'north';
    this.resetTarget(player);
    this.unsetDeflection(player);
    player.turning = {
      state: false,
      toDirection: '',
      delayCount: 0,
      limit: 5.1,
    };
    player.turnCheckerDirection = '';
    player.moving = {
      state: false,
      step: 0,
      course: '',
      origin: {
        number: {
          x: 0,
          y: 0,
        },
        center: {
          x: 0,
          y: 0,
        },
      },
      destination: {
        x: 0,
        y: 0,
      }
    };
    player.newMoveDelay = {
      state: false,
      count: 0,
      limit: 7,
    };
    player.strafing = {
      state: false,
      direction: '',
    };
    player.strafeReleaseHook = false;
    player.flanking = {
      checking: false,
      preFlankDirection: '',
      direction: '',
      state: false,
      step: 0,
      target1: {x:0 ,y:0},
      target2: {x:0 ,y:0},
    };
    player.drowning = false;
    player.attacking = {
      state: false,
      count: 0,
      limit: 20,
    };
    player.attackPeak = false;
    player.defendPeak = false;
    player.bluntAttack = false;
    player.clashing = {
      state: false,
      count: 0,
      limit: 10,
    };
    player.dodging = {
      countState: false,
      state: false,
      count: 0,
      limit: 20,
      peak: {
        start: 7,
        end: 12,
      }
    };
    player.dodgeDirection = '';
    player.jumping = {
      checking: false,
      state: false,
    };
    player.success = {
      attackSuccess: {
        state: false,
        count: 0,
        limit: 10,
      },
      defendSuccess: {
        state: false,
        count: 0,
        limit: 10,
      },
      deflected: {
        state: false,
        count: 0,
        limit: 20,
        predeflect: false,
        type: '',
      }
    };
    player.pushBack = {
      state: false,
      prePushBackMoveSpeed: 0,
    };
    player.halfPushBack = {
      state: false,
      direction: "",
      type: "",
      countUp: {
        state: true,
        count: 0,
        limit: 0,
      },
      countDown: {
        state: false,
        count: 0,
        limit: 0,
      },
      coords: {
        x: undefined,
        y: undefined,
      },
    };
    player.defending = {
      state: false,
      count: 0,
      limit: 4,
    };
    player.defendDecay = {
      state: false,
      count: 0,
      limit: 25,
    };
    player.falling = {
      state: false,
      count: 0,
      limit: 10,
    };
    player.dead = {
      state: true,
      count: 1,
      limit: player.dead.limit
    }
    player.ghost = {
      state: false,
      position: {
        cell: {
          number: {
            x: 0,
            y: 0,
          },
          center: {
            x: 0,
            y: 0,
          }
        }
      }
    };
    player.respawn = false;
    player.speed = {
      move: .1,
      range: [.05,.1,.125,.2]
    };
    player.terrainMoveSpeed = {
      state: false,
      speed: 0,
    };
    player.hp = 2;
    player.inventorySize = 4;
    player.cycleWeapon = {
      state: false,
      count: 0,
      limit: 3,
    };
    player.cycleArmor = {
      state: false,
      count: 0,
      limit: 3,
    };
    player.crits = {
      singleHit: 1,
      doubleHit: 6,
      pushBack: 4,
      guardBreak: 3,
      dodge: 0,
    };
    player.statusDisplay = {
      state: false,
      status: '',
      count: 0,
      limit: 15,
    };
    player.popups = [{
      state: true,
      count: 0,
      limit: 0,
      type: '',
      position: 'northWest',
      msg: '',
      img: '',
    }];
    player.itemDrop = {
      state: false,
      count: 0,
      limit: 10,
      item: {
        name: '',
      },
      gear: {
        type: '',
      }
    };
    player.itemPickup = {
      state: false,
      count: 0,
      limit: 10,
      item: {
        name: '',
      },
      gear: {
        type: '',
      }
    };
    player.discardGear = {
      state: false,
      count: 0,
      limit: 8,
    };
    player.ai = {
      state: false,
      imgType: '',
      primaryMission: '',
      mission: '',
      prevMission: '',
      currentObjective: '',
      targetSet: false,
      targetAcquired: false,
      safeRange: true,
      pathArray: [],
      targetPlayer: {
        number: 1,
        currentPosition: {
          x: undefined,
          y: undefined,
        },
        target: {
          number1: {
            x: undefined,
            y: undefined,
          },
          number2: {
            x: undefined,
            y: undefined,
          },
        },
        action: '',
      },
      instructions: [],
      currentInstruction: 0,
      resetInstructions: false,
      patrolling: {
        checkin: undefined,
        state: false,
        area: [],
        loopControl: false,
      },
      defending: {
        checkin: undefined,
        state: false,
        area: [],
      },
      persuing: {
        state: false,
      },
      engaging: {
        state: true,
        targetAction: '',
      },
      retrieving: {
        checkin: undefined,
        state: false,
        point: {x: undefined, y: undefined},
        targetItem: {
          name: '',
          type: '',
          subType: '',
          effect: ''
        },
        safe: true,
      },
      retreating: {
        checkin: undefined,
        state: false,
        point: {x: undefined, y: undefined},
        level: 0,
        safe: true,
      },
      organizing: {
        weaponPriorityIndex: 0,
        armorPriorityIndex: 0,
        dropped: {
          state: false,
          gear: {
            name: '',
            type: '',
            subType: '',
            effect: ''
          },
        },
      },
      mode: '',
      upgradeWeapon: false,
      upgradeArmor: false,
      pathfindingRanges: {
        spear: 3,
        crossbow: 5,
      }
    };
    player.stamina = {
      current: 20,
      max: 20,
    };
    player.newPushPullDelay = {
      state: false,
      count: 0,
      limit: 10,
    };
    player.prePush = {
      state: false,
      count: 0,
      limit: 15,
      targetCell: undefined,
      direction: "",
      pusher: undefined,
    };
    player.pushing = {
      state: false,
      targetCell: undefined,
      moveSpeed: 0,
    };
    player.prePull = {
      state: false,
      count: 0,
      limit: 15,
      targetCell: undefined,
      direction: "",
      puller: undefined,
    };
    player.pulling = {
      state: false,
      targetCell: undefined,
      moveSpeed: 0,
    };
    player.postPull = {
      state: false,
      count: 0,
      limit: 10,
    };
    player.pushed = {
      state: false,
      pusher: 0,
      moveSpeed: 0,
    };
    player.pulled = {
      state: false,
      puller: 0,
      moveSpeed: 0,
    };
    player.elasticCounter = {
      preState: false,
      state: false,
      direction: "",
      type: "",
      subType: "",
      countUp: {
        state: false,
        count: 0,
        limit: 6,
      },
      countDown: {
        state: false,
        count: 0,
        limit: 6,
      },
      coords: {
        x: undefined,
        y: undefined,
      },
      pause: {
        preState: false,
        state: false,
        type: "",
        count: 0,
        limit: 6,
      },
    };
    player.points--;
    player.drowning = false;
    this.pointChecker(player)


    // RESET TARGETTING FOR AI TARGETTING ME!!

    if (player.ai.state !== true) {

      this.resetAiTarget.state = true;
      this.resetAiTarget.player = player.number;

    }


    this.players[player.number-1] = player;

    if (player.ai.state === true) {
      // console.log('ai player eliminated');
      this.removeAiPlayer(player.number);

      let newArr = this.aiDeflectedCheck.filter(x=>x !== player.number)
      this.aiDeflectedCheck = newArr;

    }



    for (const player2 of this.players) {
      if (player2.ai.state === true) {
        console.log('player death/item drop. Search for weapon upgrades');
        player2.ai.upgradeWeapon = true;
      }
    }


  }
  gameReset = (type) => {
    // console.log('resetting');

    this.setState({
      loading: true
    })

    this.time = 0;
    this.projectiles = [];
    this.mouseOverCell = {
      state: false,
      cell: undefined,
      count: 0,
      threshold: 40,
    };
    this.mouseOverCellSwitchOff = {
      state: false,
      count: 0,
      limit: 100,
    };
    this.cellInfoMouseOver = false;
    this.cellsUnderAttack = [];
    this.cellsUnderPreAttack = [];
    this.cellsToHighlight = [];
    this.cellsToHighlight2 = [];
    this.gamepadPollCounter = {
          count1: 0,
          count2: 0,
          store1: [],
          store2: [],
        };
    this.movingObstacles = [];
    this.halfPushBackObstacles = [];
    this.obstacleBarrierToDestroy = [];
    this.obstacleItemsToDrop = [];
    this.obstaclesOutOfBoundsFall = [];
    this.cellPopups = [];
    this.aiDeflectedCheck = [];
    this.bloodSacrificeEvent = {
      state: false,
      count: 0,
      limit: 100,
      restore: false,
    };
    this.openVoid = false;
    this.cellToVoid = {
      state: false,
      x: 0,
      y: 0,
      count: 0,
      limit: 35,
    };

    for (const player of this.players) {

      if (player.ai.state !== true) {

        this.resetTarget(player);


        let currentWeapon = {
          name: 'sword1',
          type: 'sword',
          effect: '',
        };
        let currentArmor = {
          name: '',
          type: '',
          effect: '',
        };
        let items = {
          weaponIndex: 0,
          armorIndex: 0,
          weapons: [],
          armor: [],
          ammo: 0,
        }

        for (const weapon of this.settingsFormPlayerData.weapon) {

          if (weapon.plyrNo === player.number) {

            for (const weapon2 of weapon.weapons) {

              let indx = weapon.weapons.indexOf(weapon2)
              let itemRef = this.itemList.find(x => x.subType === weapon2)
              if (indx === 0) {

                currentWeapon = {
                  name: itemRef.name,
                  type: itemRef.subType,
                  effect: itemRef.effect,
                };
                items.weapons.push(currentWeapon)
                if (itemRef.effect.split("+")[0] === 'ammo') {
                  items.ammo = parseInt(itemRef.effect.split('+')[1])
                }

              }
              else {
                let weapon3 = {
                  name: itemRef.name,
                  type: itemRef.subType,
                  effect: itemRef.effect,
                };
                items.weapons.push(weapon3)
                if (itemRef.effect.split("+")[0] === 'ammo') {
                  items.ammo = parseInt(itemRef.effect.split('+')[1])
                }
              }

            }

          }

        }

        for (const armor of this.settingsFormPlayerData.armor) {

          if (armor.plyrNo === player.number) {

            for (const armor2 of armor.armor) {

              let indx = armor.armor.indexOf(armor2)
              let itemRef = this.itemList.find(x => x.subType === armor2)
              if (indx === 0) {

                currentArmor = {
                  name: itemRef.name,
                  type: itemRef.subType,
                  effect: itemRef.effect,
                };
                items.armor.push(currentArmor)

              }
              else {
                let armor3 = {
                  name: itemRef.name,
                  type: itemRef.subType,
                  effect: itemRef.effect,
                };
                items.armor.push(armor3)
              }

            }

          }

        }

        for (const team of this.settingsFormPlayerData.team) {

          if (team.plyrNo === player.number) {

            player.team = team.team;

          }

        }
        player.currentWeapon = currentWeapon;
        player.currentArmor = currentArmor;
        player.items = items;

        player.currentPosition.cell = player.startPosition.cell;

        player.turning = {
          state: false,
          toDirection: '',
          delayCount: 0,
          limit: 5.1,
        };
        player.turnCheckerDirection = '';
        player.action = 'idle';
        player.moving = {
          state: false,
          step: 0,
          course: '',
          origin: {
            number: {
              x: 0,
              y: 0,
            },
            center: {
              x: 0,
              y: 0,
            },
          },
          destination: {
            x: 0,
            y: 0,
          }
        };
        player.newMoveDelay = {
          state: false,
          count: 0,
          limit: 7,
        };
        player.strafing = {
          state: false,
          direction: '',
        };
        player.strafeReleaseHook = false;
        player.flanking = {
          checking: false,
          preFlankDirection: '',
          direction: '',
          state: false,
          step: 0,
          target1: {x:0 ,y:0},
          target2: {x:0 ,y:0},
        };
        player.drowning = false;
        player.attacking = {
          state: false,
          count: 0,
          limit: 20,
        };
        player.attackPeak = false;
        player.defendPeak = false;
        player.bluntAttack = false;
        player.clashing = {
          state: false,
          count: 0,
          limit: 10,
        };
        player.dodging = {
          countState: false,
          state: false,
          count: 0,
          limit: 20,
          peak: {
            start: 7,
            end: 12,
          }
        };
        player.dodgeDirection = '';
        player.jumping = {
          checking: false,
          state: false,
        };
        player.success = {
          attackSuccess: {
            state: false,
            count: 0,
            limit: 10,
          },
          defendSuccess: {
            state: false,
            count: 0,
            limit: 10,
          },
          deflected: {
            state: false,
            count: 0,
            limit: 20,
            predeflect: false,
            type: '',
          }
        };
        player.pushBack = {
          state: false,
          prePushBackMoveSpeed: 0,
        };
        player.halfPushBack = {
          state: false,
          direction: "",
          type: "",
          countUp: {
            state: true,
            count: 0,
            limit: 0,
          },
          countDown: {
            state: false,
            count: 0,
            limit: 0,
          },
          coords: {
            x: undefined,
            y: undefined,
          },
        };
        player.defending = {
          state: false,
          count: 0,
          limit: 4,
        };
        player.defendDecay = {
          state: false,
          count: 0,
          limit: 25,
        };
        player.falling = {
          state: false,
          count: 0,
          limit: 10,
        };
        player.dead = {
          state: false,
          count: 0,
          limit: 10
        };
        player.ghost = {
          state: false,
          position: {
            cell: {
              number: {
                x: 0,
                y: 0,
              },
              center: {
                x: 0,
                y: 0,
              }
            }
          }
        };
        player.respawn = false;
        player.points = 0;
        player.speed = {
          move: .1,
          range: [.05,.1,.125,.2]
        };
        player.terrainMoveSpeed = {
          state: false,
          speed: 0,
        };
        player.hp = 2;
        player.inventorySize = 4;
        player.cycleWeapon = {
          state: false,
          count: 0,
          limit: 3,
        };
        player.cycleArmor = {
          state: false,
          count: 0,
          limit: 3,
        };
        player.crits = {
          singleHit: 1,
          doubleHit: 6,
          pushBack: 4,
          guardBreak: 3,
          dodge: 0,
        };
        player.statusDisplay = {
          state: false,
          status: '',
          count: 0,
          limit: 15,
        };
        player.popups = [{
          state: true,
          count: 0,
          limit: 0,
          type: '',
          position: 'northWest',
          msg: '',
          img: '',
        }];
        player.itemDrop = {
          state: false,
          count: 0,
          limit: 10,
          item: {
            name: '',
          },
          gear: {
            type: '',
          }
        };
        player.itemPickup = {
          state: false,
          count: 0,
          limit: 10,
          item: {
            name: '',
          },
          gear: {
            type: '',
          }
        };
        player.discardGear = {
          state: false,
          count: 0,
          limit: 8,
        };
        player.ai = {
          state: false,
          imgType: '',
          primaryMission: '',
          mission: '',
          prevMission: '',
          currentObjective: '',
          targetSet: false,
          targetAcquired: false,
          safeRange: true,
          pathArray: [],
          targetPlayer: {
            number: 1,
            currentPosition: {
              x: undefined,
              y: undefined,
            },
            target: {
              number1: {
                x: undefined,
                y: undefined,
              },
              number2: {
                x: undefined,
                y: undefined,
              },
            },
            action: '',
          },
          instructions: [],
          currentInstruction: 0,
          resetInstructions: false,
          patrolling: {
            checkin: undefined,
            state: false,
            area: [],
            loopControl: false,
          },
          defending: {
            checkin: undefined,
            state: false,
            area: [],
          },
          persuing: {
            state: false,
          },
          engaging: {
            state: true,
            targetAction: '',
          },
          retrieving: {
            checkin: undefined,
            state: false,
            point: {x: undefined, y: undefined},
            targetItem: {
              name: '',
              type: '',
              subType: '',
              effect: ''
            },
            safe: true,
          },
          retreating: {
            checkin: undefined,
            state: false,
            point: {x: undefined, y: undefined},
            level: 0,
            safe: true,
          },
          organizing: {
            weaponPriorityIndex: 0,
            armorPriorityIndex: 0,
            dropped: {
              state: false,
              gear: {
                name: '',
                type: '',
                subType: '',
                effect: ''
              },
            },
          },
          mode: '',
          upgradeWeapon: false,
          upgradeArmor: false,
          pathfindingRanges: {
            spear: 3,
            crossbow: 5,
          }
        };
        player.stamina = {
          current: 20,
          max: 20,
        };
        player.newPushPullDelay = {
          state: false,
          count: 0,
          limit: 10,
        };
        player.prePush = {
          state: false,
          count: 0,
          limit: 15,
          targetCell: undefined,
          direction: "",
          pusher: undefined,
        };
        player.pushing = {
          state: false,
          targetCell: undefined,
          moveSpeed: 0,
        };
        player.prePull = {
          state: false,
          count: 0,
          limit: 15,
          targetCell: undefined,
          direction: "",
          puller: undefined,
        };
        player.pulling = {
          state: false,
          targetCell: undefined,
          moveSpeed: 0,
        };
        player.postPull = {
          state: false,
          count: 0,
          limit: 10,
        };
        player.pushed = {
          state: false,
          pusher: 0,
          moveSpeed: 0,
        };
        player.pulled = {
          state: false,
          puller: 0,
          moveSpeed: 0,
        };
        player.elasticCounter = {
          preState: false,
          state: false,
          direction: "",
          type: "",
          subType: "",
          countUp: {
            state: false,
            count: 0,
            limit: 6,
          },
          countDown: {
            state: false,
            count: 0,
            limit: 6,
          },
          coords: {
            x: undefined,
            y: undefined,
          },
          pause: {
            preState: false,
            state: false,
            type: "",
            count: 0,
            limit: 6,
          },
        };


      }


    }
    this.aiTarget = 1;



    // this.resetCameraSwitch = true;



    let plyrz = this.players
    for (const plyr of plyrz) {
      if (plyr.ai.state === true ) {
        let indx = plyrz.indexOf(plyr)
        let toRemove1 = this.players[indx];
        this.players = this.players.filter(x=> x !== toRemove1);
      }
    }

    this.drawGridInit(this.state.canvas, this.state.context, this.state.canvas2, this.state.context2, this.state.canvas3, this.state.context3);

    if (type === 'soft') {
      if (Object.keys(this.updateSettingsFormAiDataData).length !== 0) {
        if (this.addAiCount.state !== true) {
          this.loadAiSettings();
        }

      }
    }

  }


  addAiPlayer = () => {

    let newPlayerNumber = this.players.length+1;

    let imgTypeRoll = this.rnJesus(1,2);
    let imgType;
    if (imgTypeRoll === 1) {
      imgType = "A";
    } else {
      imgType = "B";
    }

    if (this.addAiCount.state !== true) {

      if (this.aiInitSettings.randomStart === true) {
        // console.log('random ai mission is',this.aiInitSettings.primaryMission);
      }

      this.addAiCount.state = true;

      let cell = {x: 0, y: 0}
      let cell1 = {x: 0, y: 0}
      let cell3 = {x: 0, y: 0}

      let checkCell = false;
      if (this.aiInitSettings.randomStart === true && this.aiInitSettings.primaryMission === 'pursue') {
        while (checkCell === false) {
          cell.x = this.rnJesus(0,this.gridWidth)
          cell.y = this.rnJesus(0,this.gridWidth)
          checkCell = this.checkCell(cell);
        }
      }
      if (this.aiInitSettings.randomStart === true && this.aiInitSettings.primaryMission === 'patrol') {

        let checkPatrolCell1 = false;
        let checkPatrolCell2 = false;
        let inBounds = false;

        while (checkPatrolCell1 === false) {
          cell1.x = this.rnJesus(0,this.gridWidth)
          cell1.y = this.rnJesus(0,this.gridWidth)
          checkPatrolCell1 = this.checkCell(cell1);
        }

        while (checkPatrolCell2 === false && checkPatrolCell1 === true) {

          // console.log('cell1 chosen',cell1);
          let range = 4;
          let directions = ['north','east','south','west'];
          let whatDir1 = this.rnJesus(1,4)
          let chooseDirection = directions[whatDir1-1];

          switch(chooseDirection) {
            case 'north':
              cell3 = {
                x: cell1.x,
                y: cell1.y-range,
              }
            break;
            case 'south':
              cell3 = cell1.y+range;
              cell3 = {
                x: cell1.x,
                y: cell1.y+range,
              }
            break;
            case 'west':
              cell3 = {
                x: cell1.x-range,
                y: cell1.y,
              }
            break;
            case 'east':
              cell3 = {
                x: cell1.x+range,
                y: cell1.y,
              }
            break;
          }
          // console.log('proposed cell 2',cell3);
          if (
            cell3.x < 0 || cell3.x > this.gridWidth ||
            cell3.y < 0 || cell3.y > this.gridWidth
          ) {
            // console.log('2nd cell is out of bounds');
          } else {
            cell3.x = this.rnJesus(0,this.gridWidth)
            cell3.y = this.rnJesus(0,this.gridWidth)
            checkPatrolCell2 = this.checkCell(cell3);
          }

        }

        if (checkPatrolCell1 === true && checkPatrolCell2 === true) {
          // console.log('patrol cells 1 & 2 chosen',cell1,cell3);
          this.aiInitSettings.partolArea[0] = cell1;
          this.aiInitSettings.partolArea[1] = cell3;
          inBounds = true;
        }
        if (inBounds === true) {
          while (checkCell === false ) {
            cell.x = this.rnJesus(0,this.gridWidth)
            cell.y = this.rnJesus(0,this.gridWidth)
            checkCell = this.checkCell(cell);
            if (cell === cell1 || cell === cell3) {
              checkCell = false
            }
          }
        }
        if (checkCell === true) {
          console.log('random patrol points chosen: start',cell,'patrol points',cell1,cell3);
        }


      }
      if (this.aiInitSettings.randomStart === true && this.aiInitSettings.primaryMission === 'defend') {
        let checkCell2 = false;
        let cell4 = {x:0,y:0}
        while (checkCell2 === false) {
          cell4.x = this.rnJesus(0,this.gridWidth)
          cell4.y = this.rnJesus(0,this.gridWidth)
          checkCell2 = this.checkCell(cell4);
        }
        if (checkCell2 === true) {
          this.aiInitSettings.partolArea[0] = cell4;
        }

        while (checkCell === false && checkCell2 === true) {
          cell.x = this.rnJesus(0,this.gridWidth)
          cell.y = this.rnJesus(0,this.gridWidth)
          checkCell = this.checkCell(cell);
        }
        if (checkCell === true) {
          console.log('random defend points chosen: start',cell,'defend point',cell4);
        }

      }

      if (this.aiInitSettings.randomStart !== true) {
        checkCell = true ;
        cell.x = this.aiInitSettings.startPosition.number.x;
        cell.y = this.aiInitSettings.startPosition.number.y;
      }




      if (checkCell === true) {



        let currentWeapon = {
          name: 'sword1',
          type: 'sword',
          effect: '',
        };
        let currentArmor = {
          name: '',
          type: '',
          effect: '',
        };
        let items = {
          weaponIndex: 0,
          armorIndex: 0,
          weapons: [],
          armor: [],
          ammo: 0,
        }



        for (const weapon of this.aiInitSettings.weapons) {

          let indx = this.aiInitSettings.weapons.indexOf(weapon)
          let itemRef = this.itemList.find(x => x.subType === weapon)
          if (indx === 0) {

            currentWeapon = {
              name: itemRef.name,
              type: itemRef.subType,
              effect: itemRef.effect,
            };
            items.weapons.push(currentWeapon)
            if (itemRef.effect.split("+")[0] === 'ammo') {
              items.ammo = parseInt(itemRef.effect.split('+')[1])
            }


          }
          else {
            let weapon = {
              name: itemRef.name,
              type: itemRef.subType,
              effect: itemRef.effect,
            };
            items.weapons.push(weapon)
            if (itemRef.effect.split("+")[0] === 'ammo') {
              items.ammo = parseInt(itemRef.effect.split('+')[1])
            }
          }

        }
        for (const armor of this.aiInitSettings.armor) {

          let indx = this.aiInitSettings.armor.indexOf(armor)
          let itemRef = this.itemList.find(x => x.subType === armor)
          if (indx === 0) {

            currentArmor = {
              name: itemRef.name,
              type: itemRef.subType,
              effect: itemRef.effect,
            };
            items.armor.push(currentArmor)


          }
          else {
            let armor = {
              name: itemRef.name,
              type: itemRef.subType,
              effect: itemRef.effect,
            };
            items.armor.push(armor)
          }

        }


        let cell2 = this.gridInfo.find(elem => elem.number.x === cell.x && elem.number.y === cell.y)
        let newPlayer = {
          number: newPlayerNumber,
          startPosition: {
            cell: {
              number: {
                x: cell.x,
                y: cell.y,
              },
              center: {
                x: cell2.center.x,
                y: cell2.center.y,
              }
            }
          },
          currentPosition: {
            cell: {
              number: {
                x: cell.x,
                y: cell.y,
              },
              center: {
                x: cell2.center.x,
                y: cell2.center.y,
              }
            }
          },
          nextPosition: {
            x: cell2.center.x,
            y: cell2.center.y,
          },
          target: {
            cell1: {
              number: {
                x: 0,
                y: 0,
              },
              center: {
                x: 0,
                y: 0,
              },
              free: true,
              occupant: {
                type: '',
                player: '',
              },
              void: false,
            },
            cell2: {
              number: {
                x: 0,
                y: 0,
              },
              center: {
                x: 0,
                y: 0,
              },
              free: true,
              occupant: {
                type: '',
                player: '',
              },
              void: false,
            },
            myCellBlock: false,
          },
          direction: 'north',
          turning: {
            state: false,
            toDirection: '',
            delayCount: 0,
            limit: 5.1,
          },
          turnCheckerDirection: '',
          action: 'idle',
          moving: {
            state: false,
            step: 0,
            course: '',
            origin: {
              number: {
                x: cell.x,
                y: cell.y,
              },
              center: {
                x: cell2.center.x,
                y: cell2.center.y,
              }
            },
            destination: {
              x: 0,
              y: 0,
            }
          },
          newMoveDelay: {
            state: false,
            count: 0,
            limit: 7,
          },
          strafing: {
            state: false,
            direction: '',
          },
          strafeReleaseHook: false,
          flanking: {
            checking: false,
            preFlankDirection: '',
            direction: '',
            state: false,
            step: 0,
            target1: {x:0 ,y:0},
            target2: {x:0 ,y:0},
          },
          drowning: false,
          attacking: {
            state: false,
            count: 0,
            limit: 20,
          },
          attackStrength: 0,
          attackPeak: false,
          defendPeak: false,
          bluntAttack: false,
          clashing: {
            state: false,
            count: 0,
            limit: 10,
          },
          dodging: {
            countState: false,
            state: false,
            count: 0,
            limit: 20,
            peak: {
              start: 7,
              end: 12,
            }
          },
          dodgeDirection: '',
          jumping: {
            checking: false,
            state: false,
          },
          success: {
            attackSuccess: {
              state: false,
              count: 0,
              limit: 10,
            },
            defendSuccess: {
              state: false,
              count: 0,
              limit: 10,
            },
            deflected: {
              state: false,
              count: 0,
              limit: 20,
              predeflect: false,
              type: '',
            }
          },
          pushBack: {
            state: false,
            prePushBackMoveSpeed: 0,
          },
          halfPushBack: {
            state: false,
            direction: "",
            type: "",
            countUp: {
              state: true,
              count: 0,
              limit: 0,
            },
            countDown: {
              state: false,
              count: 0,
              limit: 0,
            },
            coords: {
              x: undefined,
              y: undefined,
            },
          },
          defending: {
            state: false,
            count: 0,
            limit: 4,
          },
          defendDecay: {
            state: false,
            count: 0,
            limit: 20,
          },
          defended: {
            state: false
          },
          falling: {
            state: false,
            count: 0,
            limit: 10,
          },
          dead: {
            state: false,
            count: 0,
            limit: 10
          },
          ghost: {
            state: false,
            position: {
              cell: {
                number: {
                  x: 0,
                  y: 0,
                },
                center: {
                  x: 0,
                  y: 0,
                }
              }
            }
          },
          respawn: false,
          points: 0,
          speed: {
            move: .1,
            range: [.05,.1,.125,.2]
          },
          terrainMoveSpeed: {
            state: false,
            speed: 0,
          },
          hp: 2,
          currentWeapon: currentWeapon,
          currentArmor: currentArmor,
          items: items,
          inventorySize: 4,
          cycleWeapon: {
            state: false,
            count: 0,
            limit: 3,
          },
          cycleArmor: {
            state: false,
            count: 0,
            limit: 3,
          },
          crits: {
            singleHit: 1,
            doubleHit: 6,
            pushBack: 4,
            guardBreak: 3,
            dodge: 0,
          },
          statusDisplay: {
            state: false,
            status: '',
            count: 0,
            limit: 15,
          },
          popups: [{
            state: true,
            count: 0,
            limit: 0,
            type: '',
            position: 'northWest',
            msg: '',
            img: '',
          }],
          itemDrop: {
            state: false,
            count: 0,
            limit: 10,
            item: {
              name: '',
            },
            gear: {
              type: '',
            }
          },
          itemPickup: {
            state: false,
            count: 0,
            limit: 10,
            item: {
              name: '',
            },
            gear: {
              type: '',
            }
          },
          discardGear:{
            state: false,
            count: 0,
            limit: 8,
          },
          idleAnim: {
            state: false,
            count: 0,
            limit: 5,
          },
          ai: {
            state: true,
            imgType: imgType,
            mission: '',
            primaryMission: '',
            prevMission: '',
            currentObjective: '',
            currentInstruction: 0,
            resetInstructions: false,
            targetSet: false,
            targetAcquired: false,
            safeRange: true,
            pathArray: [],
            targetPlayer: {
              number: 1,
              currentPosition: {
                x: undefined,
                y: undefined,
              },
              target: {
                number1: {
                  x: undefined,
                  y: undefined,
                },
                number2: {
                  x: undefined,
                  y: undefined,
                },
              },
              action: '',
            },
            instructions: [
            ],
            engaging: {
              state: false,
              targetAction: '',
            },
            patrolling: {
              checkin: undefined,
              state: false,
              area: [],
              loopControl: false,
            },
            defending: {
              checkin: undefined,
              state: false,
              area: [],
            },
            persuing: {
              state: false,
            },
            retrieving: {
              checkin: undefined,
              state: false,
              point: {x: undefined, y: undefined},
              targetItem: {
                name: '',
                type: '',
                subType: '',
                effect: '',
              },
              safe: false,
            },
            retreating: {
              checkin: undefined,
              state: false,
              point: {x: undefined, y: undefined},
              level: 0,
              safe: false,
            },
            organizing: {
              weaponPriorityIndex: 0,
              armorPriorityIndex: 0,
              dropped: {
                state: false,
                gear: {
                  name: '',
                  type: '',
                  subType: '',
                  effect: ''
                },
              },
            },
            mode: this.aiInitSettings.mode,
            upgradeWeapon: false,
            upgradeArmor: false,
            pathfindingRanges: {
              spear: 3,
              crossbow: 5,
            }
          },
          stamina: {
            current: 20,
            max: 20,
          },
          newPushPullDelay: {
            state: false,
            count: 0,
            limit: 10,
          },
          prePush: {
            state: false,
            count: 0,
            limit: 15,
            targetCell: undefined,
            direction: "",
            pusher: undefined,
          },
          pushing: {
            state: false,
            targetCell: undefined,
            moveSpeed: 0,
          },
          prePull: {
            state: false,
            count: 0,
            limit: 15,
            targetCell: undefined,
            direction: "",
            puller: undefined,
          },
          pulling: {
            state: false,
            targetCell: undefined,
            moveSpeed: 0,
          },
          postPull: {
            state: false,
            count: 0,
            limit: 10,
          },
          pushed: {
            state: false,
            pusher: 0,
            moveSpeed: 0,
          },
          pulled: {
            state: false,
            puller: 0,
            moveSpeed: 0,
          },
          elasticCounter: {
            preState: false,
            state: false,
            direction: "",
            type: "",
            subType: "",
            countUp: {
              state: false,
              count: 0,
              limit: 6,
            },
            countDown: {
              state: false,
              count: 0,
              limit: 6,
            },
            coords: {
              x: undefined,
              y: undefined,
            },
            pause: {
              preState: false,
              state: false,
              type: "",
              count: 0,
              limit: 6,
            },
          },
          team: this.aiInitSettings.team,
          input: 'Keyboard',
        }


        this.players.push(newPlayer);
        this.keyPressed.push(
          {
            north: false,
            south: false,
            east: false,
            west: false,
            northEast: false,
            northWest: false,
            southEast: false,
            southWest: false,
            attack: false,
            defend: false,
            strafe: false,
            cycleWeapon: false,
            cycleArmor: false,
            dodge: false,
          }
        )
        this.aiPlayers.push(newPlayerNumber)
        this.getTarget(this.players[newPlayerNumber-1])
        this.updatePathArray();
        this.players[newPlayerNumber-1].ai.primaryMission = this.aiInitSettings.primaryMission;
        if (!this.aiInitSettings.mission) {
          this.players[newPlayerNumber-1].ai.mission = this.aiInitSettings.primaryMission;
        }

        else if (this.aiInitSettings.mission) {
          this.players[newPlayerNumber-1].ai.mission = this.aiInitSettings.mission;
        }

        if (this.aiInitSettings.primaryMission === 'patrol') {
          this.players[newPlayerNumber-1].ai.patrolling = {
            checkin: undefined,
            state: true,
            area: [
              {
                x: this.aiInitSettings.partolArea[0].x,
                y: this.aiInitSettings.partolArea[0].y,
              },
              {
                x: this.aiInitSettings.partolArea[1].x,
                y: this.aiInitSettings.partolArea[1].y,
              }
            ],
            loopControl: false,
          }
        }
        if (this.aiInitSettings.primaryMission === 'defend') {
          this.players[newPlayerNumber-1].ai.defending = {
            checkin: undefined,
            state: true,
            area: [
              {
                x: this.aiInitSettings.partolArea[0].x,
                y: this.aiInitSettings.partolArea[0].y,
              },
            ]
          }
        }


        if (
          this.settingAutoCamera === false &&
          this.camera.preInstructions.length === 0 &&
          this.camera.instructions.length === 0
        ) {
          // this.setAutoCamera('aiSpawnFocus',newPlayer)
        }
        else {
          console.log('no setting auto cam: aiSpawnFocus');
        }

      }

    }

    else if (this.addAiCount.state === true) {
      // console.log('already adding an ai player');
    }
    // console.log('new ai player: settings',this.aiInitSettings);

  }
  addAiRandomPlayer = (mission) => {

    let newMisson = mission;
    let weapon = {
      name: 'sword1',
      type: 'sword'
    };

    if (mission === 'random') {
      let whatMission = this.rnJesus(1,10)
      if (whatMission % 2 === 0 || whatMission % 7 === 0) {
        newMisson = 'pursue'
      }
      if (whatMission % 3 === 0) {
        newMisson = 'patrol'
      }
      if (whatMission % 5 === 0) {
        newMisson = 'defend'
      }

    }


    let whatWeapon = this.rnJesus(1,10)
    if (whatWeapon % 2 === 0 || whatWeapon % 3 === 0) {
      weapon = {
        name: 'sword1',
        type: 'sword'
      }
    }
    if (whatWeapon % 5 === 0) {
      weapon = {
        name: 'spear1',
        type: 'spear'
      }
    }
    if (whatWeapon % 7 === 0) {
      weapon = {
        name: 'crossbow1',
        type: 'crossbow'
      }
    }



    this.aiInitSettings = {
      randomStart: true,
      startPosition: {
        number: {x: undefined, y: undefined}
      },
      primaryMission: newMisson,
      mission: undefined,
      mode: 'careful',
      partolArea: [
        {x: undefined, y: undefined},
        {x: undefined, y: undefined},
      ],
      weapons: [{
        name: weapon.name,
        type: weapon.type,
        effect: '',
      }],
      armor: [],
    }
    this.addAiPlayer();

  }
  removeAiPlayer = (playerNumber) => {
    console.log('removing ai player',playerNumber);


    let index1 = this.players.indexOf(this.players[playerNumber-1])
    let index2 = this.aiPlayers.indexOf(playerNumber);

    // SHIFT AI PLAYER NUMBERS!
    for (let elem of this.players) {
      let indx = this.players.indexOf(elem);
      if (indx > index1) {
        elem.number = elem.number - 1;
      }
    }
    for (let elem2 of this.aiPlayers) {
      let indx2 = this.aiPlayers.indexOf(elem2);
      if (indx2 > index2) {
        elem2 = elem2 - 1;
      }
    }

    this.aiPlayers.splice(index2,1);

    let keyPressedToRemove = this.keyPressed[playerNumber-1];
    this.keyPressed = this.keyPressed.filter(y=> y !== keyPressedToRemove);


    this.removeAi = playerNumber;

    this.addAiCount.state = true;


    // REMOVE DEAD AI FINAL POSITION
    // let indx3;
    // for (const item of this.additionalAvoidArray) {
    //   if (item.player === playerNumber) {
    //     indx3 = this.additionalAvoidArray.indexOf(item)
    //   }
    // }
    // this.additionalAvoidArray.splice(indx3,1)

  }
  toggleAiDisplay = () => {
    let newState = !this.state.showAiStatus;
    this.setState({
      showAiStatus: newState,
    })
  }
  scanTargetAreaThreat = (args) => {
    // console.log('scanning area for threats');

    let point = args.point;
    let range = args.range;
    let playerPositions = [];
    let isSafe = true;
    let threats = []
     for (const player of this.players) {
       if (player.ai.state !== true && player.number !== args.player) {
         playerPositions.push({
           player: player.number,
           position: player.currentPosition.cell.number,
         })
       }
     }
     for (const playerPos of playerPositions) {

       let xDiff;
       let yDiff;
       let largerx = Math.max(point.x, playerPos.position.x);
       // console.log('playerPos.position.x',playerPos.position.x,'point.x',point.x,'largerx',largerx);
       if (largerx === point.x) {
         xDiff = point.x - playerPos.position.x;
       } else {
         xDiff = playerPos.position.x - point.x;
       }
       let largery = Math.max(point.y, playerPos.position.y);
       // console.log('playerPos.position.y',playerPos.position.y,'point.y',point.y,'largery',largery);
       if (largery === point.y) {
         yDiff = point.y - playerPos.position.y;
       } else {
         yDiff = playerPos.position.y - point.y;
       }
       let diffSum = xDiff + yDiff;
       // console.log('vv',playerPos.player,diffSum);

       if (diffSum <= range) {
         threats.push({
           player: playerPos.player,
           position: playerPos.position,
           distValue: diffSum,
           distIndex: undefined,
         })
       }

     }

     if (threats.length > 0) {
       isSafe = false;
     }

     threats.sort((a, b) => (a.distValue > b.distValue) ? 1 : -1);
     for (const threat of threats) {
       let threatIndex = threats.findIndex(x => x.player === threat.player)
       threat.distIndex = threatIndex;
     }
     // console.log('threats',threats);

     return {
       isSafe: isSafe,
       threats: threats
     }

  }
  safeDistanceRetreat = (plyr,cell) => {

    let isSafeDistance = false;
    let safeRetreatDistance = 2;
    if (
      cell.x <= plyr.currentPosition.cell.number.x + safeRetreatDistance ||
      cell.x >= plyr.currentPosition.cell.number.x - safeRetreatDistance ||
      cell.y <= plyr.currentPosition.cell.number.y + safeRetreatDistance ||
      cell.y >= plyr.currentPosition.cell.number.y - safeRetreatDistance
    ) {
      isSafeDistance = false;
    } else {
      isSafeDistance = true;
    }
    return isSafeDistance;
  }
  aiResetRanges = (plyr) => {
    this.players[plyr.number-1].ai.pathfindingRanges = {
      spear: 3,
      crossbow: 5,
    }
    this.players[plyr.number-1].ai.safeRange = true;
  }
  aiEvaluate = (plyr) => {
    // console.log('aiEvaluate',plyr.ai.upgradeWeapon);
    // console.log('aiEvaluate',plyr.ai.organizing.dropped.state);

    // SOMEONE DIED, RESET AI TARGETS
    if (this.resetAiTarget.state === true) {
      console.log('someone died. reset ai targets');
      if (!plyr.popups.find(x=>x.msg === 'thinking')) {
        plyr.popups.push(
          {
            state: false,
            count: 0,
            limit: 30,
            type: '',
            position: '',
            msg: 'thinking',
            img: '',

          }
        )
      }
      for (const plyr of this.players) {

        if (plyr.ai.state === true && plyr.ai.targetSet === true && plyr.ai.targetPlayer.number === this.resetAiTarget.player) {

          this.aiResetRanges(plyr)

          if (plyr.attacking.state === true) {
            plyr.attacking.state = false;
            plyr.action = 'idle';
            // this.attackedCancel(plyr)
            plyr.ai.targetSet = false;
            plyr.ai.targetAcquired = false;
            plyr.ai.mission = plyr.ai.primaryMission;
            plyr.ai.currentInstruction = 0;
            plyr.ai.pathArray = [];
            plyr.ai.instructions = [];

            // if (!plyr.popups.find(x=>x.msg === 'mission'+plyr.ai.mission 1st char upper+'')) {
            //   plyr.popups.push(
            //     {
            //       state: false,
            //       count: 0,
            //       limit: 25,
            //       type: '',
            //       position: '',
            //       msg: 'mission'+plyr.ai.mission 1st char upper+'',
            //       img: '',
            //
            //     }
            //   )
            // }

          }


          plyr.ai.targetSet = false;
          plyr.ai.targetPlayer = {
            number: undefined,
            currentPosition: {
              x: undefined,
              y: undefined,
            },
            target: {
              number1: {
                x: undefined,
                y: undefined,
              },
              number2: {
                x: undefined,
                y: undefined,
              },
            },
            action: '',
          };

          if (plyr.ai.mission === 'pursue') {

            plyr.ai.targetSet = false;
            plyr.ai.targetAcquired = false;
            plyr.ai.mission = plyr.ai.primaryMission;
            plyr.ai.currentInstruction = 0;
            plyr.ai.pathArray = [];
            plyr.ai.instructions = [];

            // if (!plyr.popups.find(x=>x.msg === 'mission'+plyr.ai.mission 1st char upper+'')) {
            //   plyr.popups.push(
            //     {
            //       state: false,
            //       count: 0,
            //       limit: 25,
            //       type: '',
            //       position: '',
            //       msg: 'mission'+plyr.ai.mission 1st char upper+'',
            //       img: '',
            //
            //     }
            //   )
            // }
          }

        }
      }


      if (this.playerNumber > 1) {

        if (this.resetAiTarget.player === 1) {
          if (this.players[1].dead.state !== true && this.players[1].falling.state !== true && this.players[1].respawn !== true) {
            console.log('1');
            this.aiTarget = 2;
            this.resetAiTarget.player = 0;
          } else {
            this.allPlayersDead = true;
          }
        }

        if (this.resetAiTarget.player === 2) {
          if (this.players[0].dead.state !== true && this.players[0].falling.state !== true && this.players[0].respawn !== true) {
            console.log('2');
            this.aiTarget = 1;
            this.resetAiTarget.player = 0;
          } else {
            this.allPlayersDead = true;
          }
        }


      } else {
        this.allPlayersDead = true;
      }

      // this.resetAiTarget.state2 = true;
      this.resetAiTarget.state = false;

    }

    if (this.allPlayersDead === true) {
      for (const plyr2 of this.players) {
        if (plyr2.dead.state !== true && plyr2.respawn !== true && plyr2.ai.state !== true) {
          this.aiTarget = plyr2.number;
          this.allPlayersDead = false;
          this.resetAiTarget.player = 0;

          if (!plyr2.popups.find(x=>x.msg === 'thinking')) {
            plyr2.popups.push(
              {
                state: false,
                count: 0,
                limit: 25,
                type: '',
                position: '',
                msg: 'thinking',
                img: '',

              }
            )
          }
        }
      }
    }

    if (this.allPlayersDead === true) {
      // console.log('still no targets availible for ai!!');
    }

    if (plyr.ai.mission !== 'engage' && this.aiDeflectedCheck.includes(plyr.number === true)) {

      // console.log('!! AI DEFLECTED BUT NOT ENGAGED, CHECK CIRCUMSTANCES AND BEHAVIOR !!');

    }


    // ITEM LOGIC
    let fieldItemScan = []
    for (const cell of this.gridInfo) {
      if (cell.item.name !== '') {
        fieldItemScan.push({
          name: cell.item.name,
          type: cell.item.type,
          subType: cell.item.subType,
          effect: cell.item.effect,
          location: {x: cell.number.x, y: cell.number.y}
        })
      }
    }


    let nerfItemPositions = [];
    for (const item of fieldItemScan) {

      switch(item.name) {
        case 'moveSpeedDown':
          nerfItemPositions.push(item)
        break;
        case 'hpDown':
          nerfItemPositions.push(item)
        break;
        case 'focusDown':
          nerfItemPositions.push(item)
        break;
        case 'strengthDown':
          nerfItemPositions.push(item)
        break;
      }

    };

    // console.log('fieldItemScan',fieldItemScan);
    // console.log('nerfItemPositions',nerfItemPositions);

    let weaponUpgradePriority = [];
    let armorUpgradePriority = [];


    if (plyr.ai.upgradeWeapon === true && plyr.ai.mission !== 'retreat' && plyr.ai.mission !== 'retrieve') {
      console.log('upgrade weapon');

      let weaponPriorityIndex = plyr.ai.organizing.weaponPriorityIndex;
      let havePriorityWeapon = true;
      weaponUpgradePriority = ['crossbow','spear','sword'];
      let inMyInventory = plyr.items.weapons.find(elem => elem.type === weaponUpgradePriority[weaponPriorityIndex]);

      console.log('priority weapon',weaponUpgradePriority[weaponPriorityIndex],'index',weaponPriorityIndex);



      if (plyr.currentWeapon.type === weaponUpgradePriority[weaponPriorityIndex]) {
        console.log('priority weapon is my current');

        if (plyr.currentWeapon.type === 'crossbow' && plyr.items.ammo === 0 && plyr.items.weapons.length < 2) {

          console.log('priority weapon is crossbow but out of ammo!');
          if (plyr.ai.organizing.weaponPriorityIndex === weaponUpgradePriority.length - 1) {
            plyr.ai.upgradeWeapon = false;
            console.log('priority index max w/ nothing to retrieve');
          }
          else {
            console.log('check next priority weapon');
            plyr.ai.organizing.weaponPriorityIndex++;
          }

        } else {

          havePriorityWeapon = true;
          plyr.ai.upgradeWeapon = false;

        }


      } else {
        havePriorityWeapon = false;
      }

      if (inMyInventory && plyr.currentWeapon.type !== weaponUpgradePriority[weaponPriorityIndex]) {
        console.log('priority weapon is in my inventory. Switching to it',plyr.currentWeapon,plyr.items.ammo,plyr.items.weapons);

        if (plyr.currentWeapon.type === 'crossbow' && plyr.items.ammo === 0 && plyr.items.weapons.length === 1) {

          console.log('priority weapon is crossbow but out of ammo!');
          if (plyr.ai.organizing.weaponPriorityIndex === weaponUpgradePriority.length - 1) {
            plyr.ai.upgradeWeapon = false;
            console.log('priority index max w/ nothing to retrieve');
          }
          else {
            console.log('check next priority weapon');
            plyr.ai.organizing.weaponPriorityIndex++;
          }
        } else {
          havePriorityWeapon = true;
          plyr.ai.upgradeWeapon = false;

          plyr.currentWeapon.name = inMyInventory.name;
          plyr.currentWeapon.type = inMyInventory.type;
          plyr.currentWeapon.effect = inMyInventory.effect;
        }
        // plyr.currentWeapon.name = inMyInventory.name;
        // plyr.currentWeapon.type = inMyInventory.type;
        // plyr.currentWeapon.effect = inMyInventory.effect;

        // havePriorityWeapon = true;
        // plyr.ai.upgradeWeapon = false
      } else if (plyr.currentWeapon.type !== weaponUpgradePriority[weaponPriorityIndex]) {
        havePriorityWeapon = false;
      }

      if (havePriorityWeapon === false) {
        console.log('dont have priority weapon');

        let inTheField = fieldItemScan.find(elem => elem.subType === weaponUpgradePriority[weaponPriorityIndex])
        // console.log('inTheField',inTheField);
        if (inTheField) {
          console.log('priority weapon is in the field');

          if (inTheField.subType === 'crossbow') {
            console.log('priority is a crossbow',inTheField.effect.split('+')[1]);


            if (inTheField.effect.split('+')[1] !== 0 && inTheField.effect.split('+')[1] !== '0') {


              let targetSafeData = this.scanTargetAreaThreat({
                player: plyr.number,
                point: {
                  x: inTheField.location.x,
                  y: inTheField.location.y,
                },
                range: 3,
              })

              if (targetSafeData.isSafe === true) {
                console.log('priority weapon target is safe. Retrieve');

                plyr.ai.mission = 'retrieve';
                plyr.ai.retrieving.point = {
                  x: inTheField.location.x,
                  y: inTheField.location.y,
                }
                plyr.ai.retrieving.targetItem = {
                  name: inTheField.name,
                  type: inTheField.type,
                  subType: inTheField.subType,
                  effect: inTheField.effect,
                };
                plyr.ai.retrieving.safe = true;
                plyr.ai.upgradeWeapon = false;

                if (!plyr.popups.find(x=>x.msg === 'missionRetrieve')) {
                  plyr.popups.push(
                    {
                      state: false,
                      count: 0,
                      limit: 30,
                      type: '',
                      position: '',
                      msg: 'missionRetrieve',
                      img: '',

                    }
                  )
                }
              }
              else {
                console.log('priority weapon target is unsafe.');

                if (plyr.ai.organizing.weaponPriorityIndex === weaponUpgradePriority.length - 1) {
                  // plyr.ai.upgradeWeapon = false;
                  console.log('priority index max w/ nothing to retrieve');
                }
                else {
                  console.log('check next priority weapon');
                  plyr.ai.organizing.weaponPriorityIndex++;
                }

              }

            }
            else if (inTheField.effect.split('+')[1] === 0 || inTheField.effect.split('+')[1] === '0') {
              console.log('bow in the field but has no ammo');
              if (plyr.ai.organizing.weaponPriorityIndex === weaponUpgradePriority.length - 1) {
                // plyr.ai.upgradeWeapon = false;
                console.log('priority index max w/ nothing to retrieve');
              }
              else {
                console.log('check next priority weapon');
                plyr.ai.organizing.weaponPriorityIndex++;
              }
            }

          } else {
            console.log('priority is not a crossbow');

            let targetSafeData2 = this.scanTargetAreaThreat({
              player: plyr.number,
              point: {
                x: inTheField.location.x,
                y: inTheField.location.y,
              },
              range: 3,
            })

            if (targetSafeData2.isSafe === true) {

              plyr.ai.mission = 'retrieve';
              plyr.ai.retrieving.point = {
                x: inTheField.location.x,
                y: inTheField.location.y,
              }
              plyr.ai.retrieving.targetItem = {
                name: inTheField.name,
                type: inTheField.type,
                subType: inTheField.subType,
                effect: inTheField.effect,
              };
              plyr.ai.retrieving.safe = true;
              plyr.ai.upgradeWeapon = false;

              if (!plyr.popups.find(x=>x.msg === 'missionRetrieve')) {
                plyr.popups.push(
                  {
                    state: false,
                    count: 0,
                    limit: 30,
                    type: '',
                    position: '',
                    msg: 'missionRetrieve',
                    img: '',

                  }
                )
              }

            }
            else {
              console.log('priority weapon is not in the field');

              if (plyr.ai.organizing.weaponPriorityIndex === weaponUpgradePriority.length - 1) {
                // plyr.ai.upgradeWeapon = false;
                console.log('priority index max w/ nothing to retrieve');
              }
              else {
                console.log('choose next priority weapon');
                plyr.ai.organizing.weaponPriorityIndex++;
              }

            }

          }

        } else {
          console.log('priority weapon is not in the field, nor current nor inventory');
          if (plyr.ai.organizing.weaponPriorityIndex === weaponUpgradePriority.length - 1) {
            // plyr.ai.upgradeWeapon = false;
            console.log('priority index max w/ nothing to retrieve');
          }
          else {
            console.log('check next priority weapon');
            plyr.ai.organizing.weaponPriorityIndex++;
          }

        }

      }

    }
    if (plyr.ai.upgradeArmor === true && plyr.ai.upgradeWeapon !== true && plyr.ai.mission !== 'retreat' && plyr.ai.mission !== 'retrieve') {
      console.log('upgrade armor');

      let armorInTheField;
      if (plyr.hp === 1) {

        armorInTheField = fieldItemScan.find(gear => gear.effect === 'hpUp')[0]
        if (armorInTheField) {


          let targetSafeData2 = this.scanTargetAreaThreat({
            player: plyr.number,
            point: {
              x: armorInTheField.location.x,
              y: armorInTheField.location.y,
            },
            range: 3,
          })

          if (targetSafeData2.isSafe === true) {

            plyr.ai.mission = 'retrieve';
            plyr.ai.retrieving.point = {
              x: armorInTheField.location.x,
              y: armorInTheField.location.y,
            }
            plyr.ai.retrieving.targetItem = {
              name: armorInTheField.name,
              type: armorInTheField.type,
              subType: armorInTheField.subType,
              effect: armorInTheField.effect,
            };
            plyr.ai.retrieving.safe = true;
            plyr.ai.upgradeArmor = false;

            if (!plyr.popups.find(x=>x.msg === 'missionRetrieve')) {
              plyr.popups.push(
                {
                  state: false,
                  count: 0,
                  limit: 30,
                  type: '',
                  position: '',
                  msg: 'missionRetrieve',
                  img: '',

                }
              )
            }
          }

          console.log('found hpup gear in the field. retrieve! @',plyr.ai.retrieving.point);

        }
        else {
          console.log('no hp up gear found in the field',fieldItemScan.find(gear => gear.effect === 'hpUp'));
        }
      }

      if (plyr.speed.move < .1) {

        armorInTheField = fieldItemScan.find(gear => gear.effect === 'speedUp')[0]

        if (armorInTheField) {


          let targetSafeData2 = this.scanTargetAreaThreat({
            player: plyr.number,
            point: {
              x: armorInTheField.location.x,
              y: armorInTheField.location.y,
            },
            range: 3,
          })

          if (targetSafeData2.isSafe === true) {

            plyr.ai.mission = 'retrieve';
            plyr.ai.retrieving.point = {
              x: armorInTheField.location.x,
              y: armorInTheField.location.y,
            }
            plyr.ai.retrieving.targetItem = {
              name: armorInTheField.name,
              type: armorInTheField.type,
              subType: armorInTheField.subType,
              effect: armorInTheField.effect,
            };
            plyr.ai.retrieving.safe = true;
            plyr.ai.upgradeArmor = false;

            if (!plyr.popups.find(x=>x.msg === 'missionRetrieve')) {
              plyr.popups.push(
                {
                  state: false,
                  count: 0,
                  limit: 30,
                  type: '',
                  position: '',
                  msg: 'missionRetrieve',
                  img: '',

                }
              )
            }
          }

          console.log('found speedUp gear in the field. retrieve! @',plyr.ai.retrieving.point);

        }
        else {
          console.log('no spped up gear found in the field',fieldItemScan.find(gear => gear.effect === 'speedUp'));
        }

      }

    }


    // RELOAD BOW AMMO
    if (plyr.currentWeapon.type === 'crossbow' && plyr.ai.mission !== 'retrieve' && plyr.ai.mission !== 'retreat') {

      if (plyr.items.ammo === 0) {
        console.log('my crossbow out of ammo');
        let inTheField = fieldItemScan.find(elem => elem.type === 'crossbow' || elem.name.substr(0,4) === 'ammo')
        if (inTheField) {
          if (inTheField.effect.split('+')[1] !== 0 && inTheField.effect.split('+')[1] !== '0') {

            let targetSafeData2 = this.scanTargetAreaThreat({
              player: plyr.number,
              point: {
                x: inTheField.location.x,
                y: inTheField.location.y,
              },
              range: 3,
            })

            if (targetSafeData2.isSafe === true) {

              plyr.ai.mission = 'retrieve';
              plyr.ai.retrieving.point = {
                x: inTheField.location.x,
                y: inTheField.location.y,
              }
              plyr.ai.retrieving.targetItem = {
                name: inTheField.name,
                type: inTheField.type,
                subType: inTheField.subType,
                effect: inTheField.effect,
              };
              plyr.ai.retrieving.safe = true;
              plyr.ai.upgradeWeapon = false;

              if (!plyr.popups.find(x=>x.msg === 'missionRetrieve')) {
                plyr.popups.push(
                  {
                    state: false,
                    count: 0,
                    limit: 30,
                    type: '',
                    position: '',
                    msg: 'missionRetrieve',
                    img: '',

                  }
                )
              }

            }
            else {
              console.log('unsafe to retrieve. Choose from inventory');

              if (plyr.items.weapons.length > 1) {
                console.log('fallback to other weapon1',plyr.items.weapons);
                plyr.currentWeapon = {
                  name: plyr.items.weapons[1].name,
                  type: plyr.items.weapons[1].type,
                  effect: plyr.items.weapons[1].effect,
                }

                plyr.ai.targetAcquired = false;
              } else {
                console.log('nothing else in inventory. find other in the field1');
                plyr.ai.upgradeWeapon = true
              }

            }

          } else {
            console.log('bow in the field but no ammo');

            if (plyr.items.weapons.length > 1) {
              console.log('fallback to other weapon2',plyr.items.weapons);
              plyr.currentWeapon = {
                name: plyr.items.weapons[1].name,
                type: plyr.items.weapons[1].type,
                effect: plyr.items.weapons[1].effect,
              }

              plyr.ai.targetAcquired = false;
            } else {
              console.log('nothing else in inventory. find other in the field2');
              plyr.ai.upgradeWeapon = true
            }

          }
        } else {
          console.log('no bow or ammo in the field');

          if (plyr.items.weapons.length > 1) {
            console.log('fallback to other weapon3',plyr.items.weapons);
            plyr.currentWeapon = {
              name: plyr.items.weapons[0].name,
              type: plyr.items.weapons[0].type,
              effect: plyr.items.weapons[0].effect,
            }

            plyr.ai.targetAcquired = false;
          } else {
            console.log('nothing else in inventory. find other in the field3');
            plyr.ai.upgradeWeapon = true;

            if (plyr.ai.organizing.weaponPriorityIndex === weaponUpgradePriority.length - 1) {
              console.log('no ammo for bow or alternative weapons to upgrade to. Switch to unarmed');
              plyr.currentWeapon = {
                name: '',
                type: '',
                effect: ''
              }
            }


          }

        }
      }

    }


    // INJURED OR SLOW!
    if (plyr.hp === 1 && plyr.ai.mission !== 'retrieve' && plyr.ai.mission !== 'retrieve') {
      console.log('injured. check for heal item');

        let itemToRetrieve = undefined;
        for (const item2 of fieldItemScan) {
          if (item2.effect === 'hpUp') {
            itemToRetrieve = item2
          }
        }

        if (itemToRetrieve) {

          let targetSafeData2 = this.scanTargetAreaThreat({
            player: plyr.number,
            point: {
              x: itemToRetrieve.location.x,
              y: itemToRetrieve.location.y,
            },
            range: 3,
          })


          if (targetSafeData2.isSafe === true) {

            plyr.ai.mission = 'retrieve';
            plyr.ai.retrieving.point = {
              x: itemToRetrieve.location.x,
              y: itemToRetrieve.location.y,
            }
            plyr.ai.retrieving.targetItem = {
              name: itemToRetrieve.name,
              type: itemToRetrieve.type,
              subType: itemToRetrieve.subType,
              effect: itemToRetrieve.effect,
            };
            plyr.ai.retrieving.safe = true;

            if (!plyr.popups.find(x=>x.msg === 'missionRetrieve')) {
              plyr.popups.push(
                {
                  state: false,
                  count: 0,
                  limit: 30,
                  type: '',
                  position: '',
                  msg: 'missionRetrieve',
                  img: '',

                }
              )
            }

            console.log('found hpup item in the field. retrieve @ ',itemToRetrieve.location);

          } else {

            console.log('no heal item/gear found.');

          }

        }

    }

    if (plyr.speed.move < .1 && plyr.ai.mission !== 'retrieve' && plyr.ai.mission !== 'retrieve') {
      console.log('slow. check for speed up item');


        let itemToRetrieve = undefined;
        for (const item3 of fieldItemScan) {
          if (item3.effect === 'speedUp') {
            itemToRetrieve = item3;
          }
        }

        if (itemToRetrieve) {
          console.log('found speed up item in the field. retrieve');

          let targetSafeData2 = this.scanTargetAreaThreat({
            player: plyr.number,
            point: {
              x: itemToRetrieve.location.x,
              y: itemToRetrieve.location.y,
            },
            range: 3,
          })

          if (targetSafeData2.isSafe === true) {

            plyr.ai.mission = 'retrieve';
            plyr.ai.retrieving.point = {
              x: itemToRetrieve.location.x,
              y: itemToRetrieve.location.y,
            }
            plyr.ai.retrieving.targetItem = {
              name: itemToRetrieve.name,
              type: itemToRetrieve.type,
              subType: itemToRetrieve.subType,
              effect: itemToRetrieve.effect,
            };
            plyr.ai.retrieving.safe = true;
            plyr.ai.upgradeWeapon = false;

            if (!plyr.popups.find(x=>x.msg === 'missionRetrieve')) {
              plyr.popups.push(
                {
                  state: false,
                  count: 0,
                  limit: 30,
                  type: '',
                  position: '',
                  msg: 'missionRetrieve',
                  img: '',

                }
              )
            }

          } else {
            console.log('no speedup item/gear found. Check for armor');
            plyr.ai.upgradeArmor = true;
          }

        }

    }


    // RETRIEVE DROPPED GEAR!
    if (plyr.ai.organizing.dropped.state === true) {
      console.log('ai retrieve dropped gear flow');

      for (const cell of this.gridInfo) {
        if (cell.item.name !== '') {
          fieldItemScan.push({
            name: cell.item.name,
            type: cell.item.type,
            subType: cell.item.subType,
            effect: cell.item.effect,
            location: {x: cell.number.x, y: cell.number.y}
          })
        }
      }


      let droppedGear = fieldItemScan.find(elem => elem.name === plyr.ai.organizing.dropped.gear.name)
      // console.log('droppedGear',droppedGear);

      if (plyr.ai.mission !== 'engage') {
        console.log('gear dropped out of battle');

        if (
          droppedGear.location.x === plyr.currentPosition.cell.number.x &&
          droppedGear.location.y === plyr.currentPosition.cell.number.y
        ) {

          plyr.ai.instructions.push({
            keyword: 'pickup',
            count: 0,
            limit: 1,
          })

          this.players[plyr.number-1].ai.organizing.dropped.state = false;

          console.log('standing over dropped gear',plyr.ai.organizing.dropped.state);

        }
        else {
          console.log('retrieve dropped gear');

          plyr.ai.mission = 'retrieve';
          plyr.ai.retrieving.point = {
            x: droppedGear.location.x,
            y: droppedGear.location.y,
          }
          plyr.ai.retrieving.targetItem = {
            name: droppedGear.name,
            type: droppedGear.type,
            subType: droppedGear.subType,
            effect: droppedGear.effect,
          };
          plyr.ai.retrieving.safe = true;

          // let targetSafeData2 = this.scanTargetAreaThreat({
          //   player: plyr.number,
          //   point: {
          //     x: droppedGear.location.x,
          //     y: droppedGear.location.y,
          //   },
          //   range: 3,
          // })
          //
          // if (targetSafeData2.isSafe === true) {
          //
          //   plyr.ai.mission = 'retrieve';
          //   plyr.ai.retrieving.point = {
          //     x: droppedGear.location.x,
          //     y: droppedGear.location.y,
          //   }
          //   plyr.ai.retrieving.targetItem = {
          //     name: droppedGear.name,
          //     type: droppedGear.type,
          //     subType: droppedGear.subType,
          //     effect: droppedGear.effect,
          //   };
          //   plyr.ai.retrieving.safe = true;
          //
          // }
          // else {
          //   console.log('unsafe to retrieve. check inventory');
          //
          //   if (plyr.items.weapons.length > 1) {
          //     console.log('fallback to other weapon');
          //     plyr.currentWeapon = {
          //       name: plyr.items.weapons[1].name,
          //       type: plyr.items.weapons[1].type,
          //       effect: plyr.items.weapons[1].effect,
          //     }
          //
          //     plyr.ai.organizing.dropped.state = false;
          //   } else {
          //     console.log('nothing else in inventory. find other in the field');
          //     plyr.ai.upgradeWeapon = true;
          //   }
          // }

          if (!plyr.popups.find(x=>x.msg === 'missionRetrieve')) {
            plyr.popups.push(
              {
                state: false,
                count: 0,
                limit: 30,
                type: '',
                position: '',
                msg: 'missionRetrieve',
                img: '',

              }
            )
          }

        }

      }
      else {
        console.log('dropped gear in battle');

        if (
          droppedGear.location.x === plyr.currentPosition.cell.number.x &&
          droppedGear.location.y === plyr.currentPosition.cell.number.y
        ) {

          plyr.ai.instructions.push({
            keyword: 'pickup',
            count: 0,
            limit: 1,
          })

          this.players[plyr.number-1].ai.organizing.dropped.state = false;

          console.log('standing over dropped gear',plyr.ai.organizing.dropped.state);

        }
        else {

          if (plyr.items.weapons.length > 1) {
            console.log('switch to something else from inventory');
            plyr.currentWeapon = {
              name: plyr.items.weapons[0].name,
              type: plyr.items.weapons[0].type,
              effect: plyr.items.weapons[0].effect,
            }
          } else {
            console.log('retrieve dropped gear');

            plyr.ai.mission = 'retrieve';
            plyr.ai.retrieving.point = {
              x: droppedGear.location.x,
              y: droppedGear.location.y,
            }
            plyr.ai.retrieving.targetItem = {
              name: droppedGear.name,
              type: droppedGear.type,
              subType: droppedGear.subType,
              effect: droppedGear.effect,
            };
            plyr.ai.retrieving.safe = true;

            // let targetSafeData2 = this.scanTargetAreaThreat({
            //   player: plyr.number,
            //   point: {
            //     x: droppedGear.location.x,
            //     y: droppedGear.location.y,
            //   },
            //   range: 3,
            // })
            //
            // if (targetSafeData2.isSafe === true) {
            //
            //   plyr.ai.mission = 'retrieve';
            //   plyr.ai.retrieving.point = {
            //     x: droppedGear.location.x,
            //     y: droppedGear.location.y,
            //   }
            //   plyr.ai.retrieving.targetItem = {
            //     name: droppedGear.name,
            //     type: droppedGear.type,
            //     subType: droppedGear.subType,
            //     effect: droppedGear.effect,
            //   };
            //   plyr.ai.retrieving.safe = true;
            //
            // }
            // else {
            //   console.log('unsafe to retrieve. check inventory');
            //
            //   if (plyr.items.weapons.length > 1) {
            //     console.log('fallback to other weapon');
            //     plyr.currentWeapon = {
            //       name: plyr.items.weapons[1].name,
            //       type: plyr.items.weapons[1].type,
            //       effect: plyr.items.weapons[1].effect,
            //     }
            //
            //     plyr.ai.organizing.dropped.state = false;
            //   } else {
            //     console.log('nothing else in inventory. find other in the field');
            //     plyr.ai.upgradeWeapon = true
            //   }
            //
            // }

            if (!plyr.popups.find(x=>x.msg === 'missionRetrieve')) {
              plyr.popups.push(
                {
                  state: false,
                  count: 0,
                  limit: 30,
                  type: '',
                  position: '',
                  msg: 'missionRetrieve',
                  img: '',

                }
              )
            }

          }

        }

      }

      // plyr.ai.organizing.dropped.state = true

    }


    // PATHFIND ERROR/ PREVENT SUICIDE!
    if (plyr.ai.resetInstructions === true ) {
      console.log('pathfinding reset');
      if (!plyr.popups.find(x=>x.msg === 'thinking')) {
        plyr.popups.push(
          {
            state: false,
            count: 0,
            limit: 30,
            type: '',
            position: '',
            msg: 'thinking',
            img: '',

          }
        )
      }
      if (!plyr.popups.find(x=>x.msg === 'pathSwitch')) {
        plyr.popups.push(
          {
            state: false,
            count: 0,
            limit: 30,
            type: '',
            position: '',
            msg: 'pathSwitch',
            img: '',

          }
        )
      }
      // console.log('reset instructions','set',plyr.ai.targetSet,'acquired',plyr.ai.targetAcquired,'mission',plyr.ai.mission);
      plyr.ai.currentInstruction = 0;
      plyr.ai.instructions = [];
      plyr.ai.targetAcquired = false;
      plyr.ai.resetInstructions = false;

      if (plyr.ai.mission === 'retreat') {
        console.log('retreat pathfinding reset');
        plyr.ai.retreating.checkin = undefined
        plyr.ai.retreating.state = false
      }
      if (plyr.ai.mission === 'retrieve') {
        console.log('retrieve pathfinding reset');
        plyr.ai.retrieving.checkin = undefined
        plyr.ai.retrieving.state = false
      }
      if (plyr.ai.mission === 'patrol') {
        console.log('patrol pathfinding reset');
        plyr.ai.patrolling.checkin = undefined
        plyr.ai.patrolling.state = false
      }
    }


    // SET TARGET!!
    // determine who is closer to me
    if (plyr.ai.targetSet !== true) {

      let targetAlive = false;
      let targetPlayer;

      targetPlayer = this.players[this.aiTarget-1];
      if (targetPlayer.dead.state !== true && targetPlayer.falling.state !== true && targetPlayer.respawn !== true) {
        targetAlive = true;
      } else {
        targetAlive = false;
      }


      if (targetAlive === true) {
        console.log('setting ai target... ','this.aiTarget',this.aiTarget);

        plyr.ai.targetPlayer = {
          number: targetPlayer.number,
          currentPosition: {
            x: targetPlayer.currentPosition.cell.number.x,
            y: targetPlayer.currentPosition.cell.number.y,
          },
          target: {
            number1: {
              x: targetPlayer.target.cell1.number.x,
              y: targetPlayer.target.cell1.number.y,
            },
            number2: {
              x: targetPlayer.target.cell2.number.x,
              y: targetPlayer.target.cell2.number.y,
            },
          },
          action: targetPlayer.action,
        };
        plyr.ai.targetSet = true
        // console.log('player',plyr.number,'setting target...player',targetPlayer.number,'my mission',plyr.ai.mission);
        // this.getTarget(plyr)
      }
      else {
        // console.log('no targets availible for ai');
      }

    }


    // TARGET AQUISITION & RANGE FINDING!!
    let targetInRange = false;


    if (plyr.ai.targetSet === true) {
      for (const plyr2 of this.players) {
        if (plyr2.ai.state !== true) {

          // CHECK FOR IN WEAPON RANGE!!
          if (plyr.currentWeapon.type === 'crossbow') {

            let range = plyr.ai.pathfindingRanges.crossbow+2;

            if (plyr.currentPosition.cell.number.x === plyr2.currentPosition.cell.number.x) {
              if (
                plyr2.currentPosition.cell.number.y < plyr.currentPosition.cell.number.y + range &&
                plyr2.currentPosition.cell.number.y > plyr.currentPosition.cell.number.y ||
                plyr2.currentPosition.cell.number.y > plyr.currentPosition.cell.number.y - range &&
                plyr2.currentPosition.cell.number.y < plyr.currentPosition.cell.number.y
              ) {

                let clearToShoot = this.aiBoltPathCheck(plyr)
                if (clearToShoot === true && plyr.ai.targetPlayer.number === plyr2.number && plyr.ai.mission !== 'retrieve' && plyr.ai.mission !== 'retreat') {
                  targetInRange = true;
                  // console.log('target in bow range for player',plyr.number,'@',plyr.currentPosition.cell.number);
                  plyr.ai.currentInstruction = 0;
                }
                if (clearToShoot !== true) {
                  console.log('in-range detection: crossbow target obstructed');
                }
                else if (plyr.ai.mission !== 'pursue' && plyr.ai.mission !== 'engage' && plyr.ai.mission !== 'retrieve' && plyr.ai.mission !== 'retreat') {
                  plyr.ai.currentInstruction = 0;
                  // console.log('alternative target in range. Switching');

                  if (!plyr.popups.find(x=>x.msg === 'alarmed')) {
                    plyr.popups.push(
                      {
                        state: false,
                        count: 0,
                        limit: 30,
                        type: '',
                        position: '',
                        msg: 'alarmed',
                        img: '',

                      }
                    )
                  }

                  plyr.ai.targetPlayer = {
                    number: plyr2.number,
                    currentPosition: {
                      x: plyr2.currentPosition.cell.number.x,
                      y: plyr2.currentPosition.cell.number.y,
                    },
                    target: {
                      number1: {
                        x: plyr2.target.cell1.number.x,
                        y: plyr2.target.cell1.number.y,
                      },
                      number2: {
                        x: plyr2.target.cell2.number.x,
                        y: plyr2.target.cell2.number.y,
                      },
                    },
                    action: plyr2.action,
                  };
                }

              }
            }

            if (plyr.currentPosition.cell.number.y === plyr2.currentPosition.cell.number.y) {
              if (
                 plyr2.currentPosition.cell.number.x < plyr.currentPosition.cell.number.x + range &&
                 plyr2.currentPosition.cell.number.x > plyr.currentPosition.cell.number.x ||
                 plyr2.currentPosition.cell.number.x > plyr.currentPosition.cell.number.x - range &&
                 plyr2.currentPosition.cell.number.x < plyr.currentPosition.cell.number.x
              ) {

                let clearToShoot = this.aiBoltPathCheck(plyr)
                if (clearToShoot === true && plyr.ai.targetPlayer.number === plyr2.number && plyr.ai.mission !== 'retrieve' && plyr.ai.mission !== 'retreat') {
                  targetInRange = true;
                  // console.log('target in bow range for player',plyr.number,'@',plyr.currentPosition.cell.number);
                  plyr.ai.currentInstruction = 0;
                }
                if (clearToShoot !== true) {
                  console.log('in-range detection: crossbow target obstructed');
                }
                else if (plyr.ai.mission !== 'pursue' && plyr.ai.mission !== 'engage' && plyr.ai.mission !== 'retrieve' && plyr.ai.mission !== 'retreat') {
                    plyr.ai.currentInstruction = 0;
                    // console.log('alternative target in range. Switching');

                    if (!plyr.popups.find(x=>x.msg === 'alarmed')) {
                      plyr.popups.push(
                        {
                          state: false,
                          count: 0,
                          limit: 30,
                          type: '',
                          position: '',
                          msg: 'alarmed',
                          img: '',

                        }
                      )
                    }

                    plyr.ai.targetPlayer = {
                      number: plyr2.number,
                      currentPosition: {
                        x: plyr2.currentPosition.cell.number.x,
                        y: plyr2.currentPosition.cell.number.y,
                      },
                      target: {
                        number1: {
                          x: plyr2.target.cell1.number.x,
                          y: plyr2.target.cell1.number.y,
                        },
                        number2: {
                          x: plyr2.target.cell2.number.x,
                          y: plyr2.target.cell2.number.y,
                        },
                      },
                      action: plyr2.action,
                    };
                  }
                }

              }

          }

          if (plyr.currentWeapon.type === 'spear') {
            let range = plyr.ai.pathfindingRanges.spear;
            // if (this.aiCarefulRange === true) {
            //   // console.log('careful range finding');
            //   range = 3;
            // }

            if (plyr.currentPosition.cell.number.x === plyr2.currentPosition.cell.number.x) {
              if (plyr.ai.safeRange === true) {
                if (
                  plyr.currentPosition.cell.number.y === plyr2.currentPosition.cell.number.y + range ||
                  plyr.currentPosition.cell.number.y === plyr2.currentPosition.cell.number.y - range ||
                  plyr.currentPosition.cell.number.y === plyr2.currentPosition.cell.number.y + (range - 1) ||
                  plyr.currentPosition.cell.number.y === plyr2.currentPosition.cell.number.y - (range - 1) ||
                  plyr.currentPosition.cell.number.y === plyr2.currentPosition.cell.number.y + (range - 2) ||
                  plyr.currentPosition.cell.number.y === plyr2.currentPosition.cell.number.y - (range - 2)
                ) {
                  let clearToShoot = this.aiBoltPathCheck(plyr)
                  if (clearToShoot === true && plyr.ai.targetPlayer.number === plyr2.number && plyr.ai.mission !== 'retrieve' && plyr.ai.mission !== 'retreat') {
                  // if (plyr.ai.targetPlayer.number === plyr2.number && plyr.ai.mission !== 'retrieve' && plyr.ai.mission !== 'retreat') {
                    targetInRange = true;
                    // console.log('target in spear range for player',plyr.number,'@',plyr.currentPosition.cell.number);
                  }
                  if (clearToShoot !== true) {
                    console.log('in-range detection: spear target obstructed');
                  }
                  else if (plyr.ai.mission !== 'pursue' && plyr.ai.mission !== 'engage' && plyr.ai.mission !== 'retrieve' && plyr.ai.mission !== 'retreat') {
                    // console.log('alternative target in range. Switching');

                    if (!plyr.popups.find(x=>x.msg === 'alarmed')) {
                      plyr.popups.push(
                        {
                          state: false,
                          count: 0,
                          limit: 30,
                          type: '',
                          position: '',
                          msg: 'alarmed',
                          img: '',

                        }
                      )
                    }

                    plyr.ai.targetPlayer = {
                      number: plyr2.number,
                      currentPosition: {
                        x: plyr2.currentPosition.cell.number.x,
                        y: plyr2.currentPosition.cell.number.y,
                      },
                      target: {
                        number1: {
                          x: plyr2.target.cell1.number.x,
                          y: plyr2.target.cell1.number.y,
                        },
                        number2: {
                          x: plyr2.target.cell2.number.x,
                          y: plyr2.target.cell2.number.y,
                        },
                      },
                      action: plyr2.action,
                    };
                  }
                }
              }
              else {
                if (
                  plyr.currentPosition.cell.number.y === plyr2.currentPosition.cell.number.y + range ||
                  plyr.currentPosition.cell.number.y === plyr2.currentPosition.cell.number.y - range
                ) {
                  let clearToShoot = this.aiBoltPathCheck(plyr)
                  if (clearToShoot === true && plyr.ai.targetPlayer.number === plyr2.number && plyr.ai.mission !== 'retrieve' && plyr.ai.mission !== 'retreat') {
                  // if (plyr.ai.targetPlayer.number === plyr2.number && plyr.ai.mission !== 'retrieve' && plyr.ai.mission !== 'retreat') {
                    targetInRange = true;
                    // console.log('target in spear range for player',plyr.number,'@',plyr.currentPosition.cell.number);
                  }
                  if (clearToShoot !== true) {
                    console.log('in-range detection: spear target obstructed');
                  }
                  else if (plyr.ai.mission !== 'pursue' && plyr.ai.mission !== 'engage' && plyr.ai.mission !== 'retrieve' && plyr.ai.mission !== 'retreat') {
                    // console.log('alternative target in range. Switching');

                    if (!plyr.popups.find(x=>x.msg === 'alarmed')) {
                      plyr.popups.push(
                        {
                          state: false,
                          count: 0,
                          limit: 30,
                          type: '',
                          position: '',
                          msg: 'alarmed',
                          img: '',

                        }
                      )
                    }

                    plyr.ai.targetPlayer = {
                      number: plyr2.number,
                      currentPosition: {
                        x: plyr2.currentPosition.cell.number.x,
                        y: plyr2.currentPosition.cell.number.y,
                      },
                      target: {
                        number1: {
                          x: plyr2.target.cell1.number.x,
                          y: plyr2.target.cell1.number.y,
                        },
                        number2: {
                          x: plyr2.target.cell2.number.x,
                          y: plyr2.target.cell2.number.y,
                        },
                      },
                      action: plyr2.action,
                    };
                  }
                }
              }

            }

            if (plyr.currentPosition.cell.number.y === plyr2.currentPosition.cell.number.y) {
              if (plyr.ai.safeRange === true) {
                if (
                  plyr.currentPosition.cell.number.x === plyr2.currentPosition.cell.number.x + range ||
                  plyr.currentPosition.cell.number.x === plyr2.currentPosition.cell.number.x - range ||
                  plyr.currentPosition.cell.number.x === plyr2.currentPosition.cell.number.x + (range - 1) ||
                  plyr.currentPosition.cell.number.x === plyr2.currentPosition.cell.number.x + (range - 1) ||
                  plyr.currentPosition.cell.number.x === plyr2.currentPosition.cell.number.x - (range - 2) ||
                  plyr.currentPosition.cell.number.x === plyr2.currentPosition.cell.number.x - (range - 2)
                ) {
                  let clearToShoot = this.aiBoltPathCheck(plyr)
                  if (clearToShoot === true && plyr.ai.targetPlayer.number === plyr2.number && plyr.ai.mission !== 'retrieve' && plyr.ai.mission !== 'retreat') {
                  // if (plyr.ai.targetPlayer.number === plyr2.number && plyr.ai.mission !== 'retrieve' && plyr.ai.mission !== 'retreat') {
                    targetInRange = true;
                    // console.log('target in spear range for player',plyr.number,'@',plyr.currentPosition.cell.number);
                  }
                  if (clearToShoot !== true) {
                    console.log('in-range detection: spear target obstructed');
                  }
                  else if (plyr.ai.mission !== 'pursue' && plyr.ai.mission !== 'engage' && plyr.ai.mission !== 'retrieve' && plyr.ai.mission !== 'retreat') {
                    // console.log('alternative target in range. Switching');

                    if (!plyr.popups.find(x=>x.msg === 'alarmed')) {
                      plyr.popups.push(
                        {
                          state: false,
                          count: 0,
                          limit: 30,
                          type: '',
                          position: '',
                          msg: 'alarmed',
                          img: '',

                        }
                      )
                    }

                    plyr.ai.targetPlayer = {
                      number: plyr2.number,
                      currentPosition: {
                        x: plyr2.currentPosition.cell.number.x,
                        y: plyr2.currentPosition.cell.number.y,
                      },
                      target: {
                        number1: {
                          x: plyr2.target.cell1.number.x,
                          y: plyr2.target.cell1.number.y,
                        },
                        number2: {
                          x: plyr2.target.cell2.number.x,
                          y: plyr2.target.cell2.number.y,
                        },
                      },
                      action: plyr2.action,
                    };
                  }
                }
              }
              else {
                if (
                  plyr.currentPosition.cell.number.x === plyr2.currentPosition.cell.number.x + 1 ||
                  plyr.currentPosition.cell.number.x === plyr2.currentPosition.cell.number.x - 1 ||
                  plyr.currentPosition.cell.number.x === plyr2.currentPosition.cell.number.x + 2 ||
                  plyr.currentPosition.cell.number.x === plyr2.currentPosition.cell.number.x - 2
                  // plyr.currentPosition.cell.number.x === plyr2.currentPosition.cell.number.x + range ||
                  // plyr.currentPosition.cell.number.x === plyr2.currentPosition.cell.number.x - range
                ) {
                  let clearToShoot = this.aiBoltPathCheck(plyr)
                  if (clearToShoot === true && plyr.ai.targetPlayer.number === plyr2.number && plyr.ai.mission !== 'retrieve' && plyr.ai.mission !== 'retreat') {
                  // if (plyr.ai.targetPlayer.number === plyr2.number && plyr.ai.mission !== 'retrieve' && plyr.ai.mission !== 'retreat') {
                    targetInRange = true;
                    // console.log('target in spear range for player',plyr.number,'@',plyr.currentPosition.cell.number);
                  }
                  if (clearToShoot !== true) {
                    console.log('in-range detection: spear target obstructed');
                  }
                  else if (plyr.ai.mission !== 'pursue' && plyr.ai.mission !== 'engage' && plyr.ai.mission !== 'retrieve' && plyr.ai.mission !== 'retreat') {
                    // console.log('alternative target in range. Switching');

                    if (!plyr.popups.find(x=>x.msg === 'alarmed')) {
                      plyr.popups.push(
                        {
                          state: false,
                          count: 0,
                          limit: 30,
                          type: '',
                          position: '',
                          msg: 'alarmed',
                          img: '',

                        }
                      )
                    }

                    plyr.ai.targetPlayer = {
                      number: plyr2.number,
                      currentPosition: {
                        x: plyr2.currentPosition.cell.number.x,
                        y: plyr2.currentPosition.cell.number.y,
                      },
                      target: {
                        number1: {
                          x: plyr2.target.cell1.number.x,
                          y: plyr2.target.cell1.number.y,
                        },
                        number2: {
                          x: plyr2.target.cell2.number.x,
                          y: plyr2.target.cell2.number.y,
                        },
                      },
                      action: plyr2.action,
                    };
                  }
                }
              }

            }

          }

          if (plyr.currentWeapon.type === 'sword' || plyr.currentWeapon.type === '') {
            let range2 = 1;
            if (plyr.ai.safeRange === true) {
              // console.log('careful range finding');
              range2 = 2;
            }

            if (plyr.currentPosition.cell.number.x ===  plyr2.currentPosition.cell.number.x) {

              if (plyr.ai.safeRange === true) {
                if (
                  plyr.currentPosition.cell.number.y ===  plyr2.currentPosition.cell.number.y + range2 ||
                  plyr.currentPosition.cell.number.y ===  plyr2.currentPosition.cell.number.y - range2 ||
                  plyr.currentPosition.cell.number.y ===  plyr2.currentPosition.cell.number.y + (range2 - 1) ||
                  plyr.currentPosition.cell.number.y ===  plyr2.currentPosition.cell.number.y - (range2 - 1)
                ) {
                  if (plyr.ai.targetPlayer.number === plyr2.number && plyr.ai.mission !== 'retrieve' && plyr.ai.mission !== 'retreat') {
                    targetInRange = true;
                    // console.log('target in sword range for player',plyr.number,'@',plyr.currentPosition.cell.number);
                  }
                  else if (plyr.ai.mission !== 'pursue' && plyr.ai.mission !== 'engage' && plyr.ai.mission !== 'retrieve' && plyr.ai.mission !== 'retreat') {
                    // console.log('alternative target in range. Switching');

                    if (!plyr.popups.find(x=>x.msg === 'alarmed')) {
                      plyr.popups.push(
                        {
                          state: false,
                          count: 0,
                          limit: 30,
                          type: '',
                          position: '',
                          msg: 'alarmed',
                          img: '',

                        }
                      )
                    }

                    plyr.ai.targetPlayer = {
                      number: plyr2.number,
                      currentPosition: {
                        x: plyr2.currentPosition.cell.number.x,
                        y: plyr2.currentPosition.cell.number.y,
                      },
                      target: {
                        number1: {
                          x: plyr2.target.cell1.number.x,
                          y: plyr2.target.cell1.number.y,
                        },
                        number2: {
                          x: plyr2.target.cell2.number.x,
                          y: plyr2.target.cell2.number.y,
                        },
                      },
                      action: plyr2.action,
                    };
                  }
                }
              }
              else {
                if (
                  plyr.currentPosition.cell.number.y ===  plyr2.currentPosition.cell.number.y + range2 ||
                  plyr.currentPosition.cell.number.y ===  plyr2.currentPosition.cell.number.y - range2
                ) {
                  if (plyr.ai.targetPlayer.number === plyr2.number && plyr.ai.mission !== 'retrieve' && plyr.ai.mission !== 'retreat') {
                    targetInRange = true;
                    // console.log('target in sword range for player',plyr.number,'@',plyr.currentPosition.cell.number);
                  }
                  else if (plyr.ai.mission !== 'pursue' && plyr.ai.mission !== 'engage' && plyr.ai.mission !== 'retrieve' && plyr.ai.mission !== 'retreat') {
                    // console.log('alternative target in range. Switching');

                    if (!plyr.popups.find(x=>x.msg === 'alarmed')) {
                      plyr.popups.push(
                        {
                          state: false,
                          count: 0,
                          limit: 30,
                          type: '',
                          position: '',
                          msg: 'alarmed',
                          img: '',

                        }
                      )
                    }

                    plyr.ai.targetPlayer = {
                      number: plyr2.number,
                      currentPosition: {
                        x: plyr2.currentPosition.cell.number.x,
                        y: plyr2.currentPosition.cell.number.y,
                      },
                      target: {
                        number1: {
                          x: plyr2.target.cell1.number.x,
                          y: plyr2.target.cell1.number.y,
                        },
                        number2: {
                          x: plyr2.target.cell2.number.x,
                          y: plyr2.target.cell2.number.y,
                        },
                      },
                      action: plyr2.action,
                    };
                  }
                }
              }
            }

            if (plyr.currentPosition.cell.number.y ===  plyr2.currentPosition.cell.number.y) {
              if (plyr.ai.safeRange === true) {
                if (
                  plyr.currentPosition.cell.number.x ===  plyr2.currentPosition.cell.number.x + range2 ||
                  plyr.currentPosition.cell.number.x ===  plyr2.currentPosition.cell.number.x - range2 ||
                  plyr.currentPosition.cell.number.x ===  plyr2.currentPosition.cell.number.x + (range2 - 1) ||
                  plyr.currentPosition.cell.number.x ===  plyr2.currentPosition.cell.number.x - (range2 - 1)
                ) {
                  if (plyr.ai.targetPlayer.number === plyr2.number && plyr.ai.mission !== 'retrieve' && plyr.ai.mission !== 'retreat') {
                    targetInRange = true;
                    // console.log('target in sword range for player',plyr.number,'@',plyr.currentPosition.cell.number);
                  }
                  else if (plyr.ai.mission !== 'pursue' && plyr.ai.mission !== 'engage' && plyr.ai.mission !== 'retrieve' && plyr.ai.mission !== 'retreat') {
                    // console.log('alternative target in range. Switching');

                    if (!plyr.popups.find(x=>x.msg === 'alarmed')) {
                      plyr.popups.push(
                        {
                          state: false,
                          count: 0,
                          limit: 30,
                          type: '',
                          position: '',
                          msg: 'alarmed',
                          img: '',

                        }
                      )
                    }

                    plyr.ai.targetPlayer = {
                      number: plyr2.number,
                      currentPosition: {
                        x: plyr2.currentPosition.cell.number.x,
                        y: plyr2.currentPosition.cell.number.y,
                      },
                      target: {
                        number1: {
                          x: plyr2.target.cell1.number.x,
                          y: plyr2.target.cell1.number.y,
                        },
                        number2: {
                          x: plyr2.target.cell2.number.x,
                          y: plyr2.target.cell2.number.y,
                        },
                      },
                      action: plyr2.action,
                    };
                  }
                }
              } else {
                if (
                  plyr.currentPosition.cell.number.x ===  plyr2.currentPosition.cell.number.x + range2 ||
                  plyr.currentPosition.cell.number.x ===  plyr2.currentPosition.cell.number.x - range2
                ) {
                  if (plyr.ai.targetPlayer.number === plyr2.number && plyr.ai.mission !== 'retrieve' && plyr.ai.mission !== 'retreat') {
                    targetInRange = true;
                    // console.log('target in sword range for player',plyr.number,'@',plyr.currentPosition.cell.number);
                  }
                  else if (plyr.ai.mission !== 'pursue' && plyr.ai.mission !== 'engage' && plyr.ai.mission !== 'retrieve' && plyr.ai.mission !== 'retreat') {
                    // console.log('alternative target in range. Switching');

                    if (!plyr.popups.find(x=>x.msg === 'alarmed')) {
                      plyr.popups.push(
                        {
                          state: false,
                          count: 0,
                          limit: 30,
                          type: '',
                          position: '',
                          msg: 'alarmed',
                          img: '',

                        }
                      )
                    }

                    plyr.ai.targetPlayer = {
                      number: plyr2.number,
                      currentPosition: {
                        x: plyr2.currentPosition.cell.number.x,
                        y: plyr2.currentPosition.cell.number.y,
                      },
                      target: {
                        number1: {
                          x: plyr2.target.cell1.number.x,
                          y: plyr2.target.cell1.number.y,
                        },
                        number2: {
                          x: plyr2.target.cell2.number.x,
                          y: plyr2.target.cell2.number.y,
                        },
                      },
                      action: plyr2.action,
                    };
                  }
                }
              }
            }
          }

        }
      }
    }

    // TARGET IN RANGE, SWITCH TO MISSION ENGAGE
    if (targetInRange === true) {
      // console.log('target in range. switch to engage',plyr.ai.targetSet);
      if (plyr.ai.mission === 'patrol') {
        plyr.ai.patrolling.checkin = undefined;
      }

      if (plyr.ai.mission === 'defend') {
        plyr.ai.defending.checkin = undefined;
      }

      plyr.ai.prevMission = plyr.ai.mission;
      if (plyr.ai.mission !== 'retrieve' && plyr.ai.mission !== 'retreat') {
        // console.log('player',plyr.number,'target in range. Engage!');

        plyr.ai.mission = 'engage';

        if (!plyr.popups.find(x=>x.msg === 'missionEngage')) {
          plyr.popups.push(
            {
              state: false,
              count: 0,
              limit: 30,
              type: '',
              position: '',
              msg: 'missionEngage',
              img: '',

            }
          )
        }


      }

      if (plyr.ai.mission === 'retrieve' || plyr.ai.mission === 'retreat') {
        // console.log('...');
      }

      // plyr.ai.engaging.state = true;
    }

    // TARGET OUT OF RANGE, REVERT TO PRIMARY MISSION
    if (plyr.ai.mission === 'engage' && targetInRange !== true) {
      // console.log('target out of range. reverting to primary mission',plyr.ai.primaryMission);

      plyr.ai.mission = plyr.ai.primaryMission;

      if (!plyr.popups.find(x=>x.msg === 'thinking')) {
        plyr.popups.push(
          {
            state: false,
            count: 0,
            limit: 30,
            type: '',
            position: '',
            msg: 'thinking',
            img: '',

          }
        )
      }

      // if (!plyr.popups.find(x=>x.msg === 'mission'+plyr.ai.mission 1st char upper+'')) {
      //   plyr.popups.push(
      //     {
      //       state: false,
      //       count: 0,
      //       limit: 30,
      //       type: '',
      //       position: '',
      //       msg: 'mission'+plyr.ai.mission 1st char upper+'',
      //       img: '',
      //
      //     }
      //   )
      // }

      this.aiResetRanges(plyr)
      if (plyr.ai.primaryMission === 'defend') {
        console.log('defend',plyr.ai.defending.checkin);
        plyr.ai.patrolling.checkin = undefined;
        plyr.ai.defending.state = true;
      }

      if (plyr.ai.primaryMission === 'patrol') {
        // console.log('patrol',plyr.ai.patrolling.checkin);
        plyr.ai.defending.checkin = undefined;
        plyr.ai.patrolling.state = true;
      }
      // plyr.ai.engaging.state = false;

    }


    if (plyr.ai.targetAqcuiredReset === true) {
      plyr.ai.targetAcquired = false;
      plyr.ai.targetAqcuiredReset = false;
    }

    // if (plyr.ai.mission === 'retrieve' && plyr.ai.retrieving.state !== true) {
    if (plyr.ai.mission === 'retrieve') {
      // console.log('retrieve @  ai evaluate', plyr.ai.retrieving);


       let targetSafeData = this.scanTargetAreaThreat({
         player: plyr.number,
         point: {
           x: plyr.ai.retrieving.point.x,
           y: plyr.ai.retrieving.point.y,
         },
         range: 3,
       })

       plyr.ai.retrieving.safe = targetSafeData.isSafe;


       if (targetSafeData.isSafe !== true) {
         // console.log('target area is under threat');
         if (plyr.ai.mode === 'aggressive') {
           // console.log('threats',targetSafeData.threats);
           plyr.ai.mission = 'pursue';

           if (!plyr.popups.find(x=>x.msg === 'missionPursue')) {
             plyr.popups.push(
               {
                 state: false,
                 count: 0,
                 limit: 30,
                 type: '',
                 position: '',
                 msg: 'missionPursue',
                 img: '',

               }
             )
           }
           if (!plyr.popups.find(x=>x.msg === 'aggressiveMode')) {
             plyr.popups.push(
               {
                 state: false,
                 count: 0,
                 limit: 30,
                 type: '',
                 position: '',
                 msg: 'aggressiveMode',
                 img: '',

               }
             )
           }

           for (const threat of targetSafeData.threats) {
             console.log('threat',threat);
             if (threat.distVal === 0) {

               console.log('threats',targetSafeData.threats);

               plyr.ai.targetSet = true;
               plyr.ai.targetAquired = false;
               let threat2 = this.players[threat.player-1];
               plyr.ai.targetPlayer = {
                 number: 1,
                 currentPosition: {
                   x: threat2.currentPosition.cell.number.x,
                   y: threat2.currentPosition.cell.number.y,
                 },
                 target: {
                   number1: {
                     x: threat2.target.cell1.x,
                     y: threat2.target.cell1.y,
                   },
                   number2: {
                     x: threat2.target.cell2.x,
                     y: threat2.target.cell2.y,
                   },
                 },
                 action: threat.action,
               };
             }

           }

         }
         if (plyr.ai.mode === 'careful' && plyr.ai.retrieving.checkin === 'enroute') {
           console.log('was enroute, now retreating');

           if (!plyr.popups.find(x=>x.msg === 'passiveMode')) {
             plyr.popups.push(
               {
                 state: false,
                 count: 0,
                 limit: 30,
                 type: '',
                 position: '',
                 msg: 'passiveMode',
                 img: '',

               }
             )
           }

          plyr.ai.mission = 'retreat';

          if (!plyr.popups.find(x=>x.msg === 'missionRetreat')) {
            plyr.popups.push(
              {
                state: false,
                count: 0,
                limit: 30,
                type: '',
                position: '',
                msg: 'missionRetreat',
                img: '',

              }
            )
          }
         }

       }
       else {
         // console.log('target area clear. proceed w/ retrieval');
         plyr.ai.retrieving.safe = true;
       }

       if (plyr.ai.retrieving.checkin === 'complete') {

         plyr.ai.mission = plyr.ai.primaryMission;
         this.aiResetRanges(plyr)

         if (!plyr.popups.find(x=>x.msg === 'missionComplete')) {
           plyr.popups.push(
             {
               state: false,
               count: 0,
               limit: 30,
               type: '',
               position: '',
               msg: 'missionComplete',
               img: '',

             }
           )
         }

         // if (!plyr.popups.find(x=>x.msg === 'mission'+plyr.ai.mission 1st char upper+'')) {
         //   plyr.popups.push(
         //     {
         //       state: false,
         //       count: 0,
         //       limit: 30,
         //       type: '',
         //       position: '',
         //       msg: 'mission'+plyr.ai.mission 1st char upper+'',
         //       img: '',
         //
         //     }
         //   )
         // }

         plyr.ai.retrieving.checkin = undefined;
         plyr.ai.retrieving.safe = false;
         plyr.ai.targetAcquired = false;
         // console.log('retrieval complete. revert mission',plyr.ai.mission,plyr.ai.targetSet,plyr.ai.targetPlayer.currentPosition,plyr.ai.targetAcquired,plyr.ai.targetPlayer);

         let itemRetrieved;

         if (plyr.ai.retrieving.targetItem.type !== 'item') {
           if (plyr.ai.retrieving.targetItem.type === 'weapon') {
             if (plyr.currentWeapon.name === plyr.ai.retrieving.targetItem.name) {
               itemRetrieved = true
             }
             for (const item of plyr.items.weapons) {
               if (item.name === plyr.ai.retrieving.targetItem.name) {
                 itemRetrieved = true
                 plyr.currentWeapon =  {
                   name: plyr.ai.retrieving.targetItem.name,
                   type: plyr.ai.retrieving.targetItem.subType,
                   effect: plyr.ai.retrieving.targetItem.effect,
                 }
               }
             }
           }
           if (plyr.ai.retrieving.targetItem.type === 'armor') {
             if (plyr.currentArmor.name === plyr.ai.retrieving.targetItem.name) {
               itemRetrieved = true
             }
             for (const item of plyr.items.armor) {
               if (item.name === plyr.ai.retrieving.targetItem.name) {
                 itemRetrieved = true
                 plyr.currentArmor =  {
                   name: plyr.ai.retrieving.targetItem.name,
                   type: plyr.ai.retrieving.targetItem.subType,
                   effect: plyr.ai.retrieving.targetItem.effect,
                 }
               }
             }
           }
         }

         if (itemRetrieved === true) {
           plyr.ai.retrieving = {
             checkin: undefined,
             state: false,
             point: {x: undefined, y: undefined},
             targetItem: {
               name: '',
               type: '',
               subType: '',
               effect: '',
             },
             safe: false,
           };
         }

         if (plyr.ai.organizing.dropped.state === true) {
           plyr.ai.organizing.dropped.state = false;
         }
       }

       if (plyr.ai.retrieving.checkin === 'abort') {
         plyr.ai.retrieving = {
           checkin: undefined,
           state: false,
           point: {x: undefined, y: undefined},
           targetItem: {
             name: '',
             type: '',
             subType: '',
             effect: '',
           },
           safe: false,
         };
       }

    }

    if (plyr.ai.mission === 'retreat') {
      // console.log('retreating @ ai evaluate');

      if (!plyr.ai.retreating.checkin) {


        let isSafeDistance = false;

        let cell = {x: 0,y: 0}
        let checkCell = false;
        let safeTarget = false;
        while (
          checkCell === false &&
          safeTarget !== true &&
          isSafeDistance !== true
        ) {
          cell.x = this.rnJesus(0,this.gridWidth)
          cell.y = this.rnJesus(0,this.gridWidth)
          checkCell = this.checkCell(cell);
          safeTarget = this.scanTargetAreaThreat({
            player: plyr.number,
            point: {
              x: cell.x,
              y: cell.y,
            },
            range: 3,
          }).isSafe;
          isSafeDistance = this.safeDistanceRetreat(plyr,cell)
        }

        if (
          checkCell === true &&
          safeTarget === true &&
          isSafeDistance !== true
        ) {
          plyr.ai.retreating.point = cell;
          plyr.ai.retreating.safe = safeTarget;
          console.log('found a free, safe retreat location',cell);
        }

      }

      if (plyr.ai.retreating.checkin && plyr.ai.retreating.state !== true) {


        let targetSafeData = this.scanTargetAreaThreat({
          player: plyr.number,
          point: {
            x: plyr.ai.retreating.point.x,
            y: plyr.ai.retreating.point.y,
          },
          range: 3,
        })

        plyr.ai.retrieving.safe = targetSafeData.isSafe;


        if (targetSafeData.isSafe !== true) {
          console.log('retreat target area is under threat. Find another target');
          plyr.ai.retreating.checkin = undefined;
          plyr.ai.retreating.safe = false;
        }

        if (plyr.ai.retreating.checkin === 'complete') {
          plyr.ai.retreating.checkin = undefined;
          plyr.ai.retreating.safe = false;
          plyr.ai.mission = plyr.ai.primaryMission;
          this.aiResetRanges(plyr)

          switch (plyr.ai.primaryMission) {
            case 'defend':
              plyr.ai.defending.checkin = undefined;
            break;
            case 'patrol':
              plyr.ai.patrolling.checkin = undefined;
            break;
            default:

          }


          // console.log('gg',plyr.ai.targetPlayer);

          if (!plyr.popups.find(x=>x.msg === 'missionComplete')) {
            plyr.popups.push(
              {
                state: false,
                count: 0,
                limit: 30,
                type: '',
                position: '',
                msg: 'missionComplete',
                img: '',

              }
            )
          }

          // if (!plyr.popups.find(x=>x.msg === 'mission'+plyr.ai.mission 1st char upper+'')) {
          //   plyr.popups.push(
          //     {
          //       state: false,
          //       count: 0,
          //       limit: 30,
          //       type: '',
          //       position: '',
          //       msg: 'mission'+plyr.ai.mission 1st char upper+'',
          //       img: '',
          //
          //     }
          //   )
          // }

          // plyr.ai.targetSet = false
          plyr.ai.targetAcquired = false
        }

      }


      // plyr.ai.retreating.level pick a spot further away depending on levelData


    }


    // AI CAN'T ACT IF FLANKING OR MOVING!

    if (
      plyr.flanking.state !== true &&
      plyr.flanking.step !== 1 &&
      plyr.flanking.step !== 2 &&
      plyr.moving.state !== true &&
      // plyr.attacking.state !== true &&
      plyr.defending.state !== true &&
      plyr.success.deflected.state !== true &&
      plyr.action !== 'deflected' &&
      plyr.pushBack.state !== true &&
      plyr.dead.state !== true &&
      plyr.falling.state !== true
    ) {
      this.aiDecide(plyr)
    }


  }
  aiDecide = (aiPlayer) => {
    // console.log('aiDecide',aiPlayer.number);


    let getPath = false;

    let targetPlayer = this.players[aiPlayer.ai.targetPlayer.number-1];
    let prevTargetPos = aiPlayer.ai.targetPlayer.currentPosition;
    let currentTargetPos;
    if (aiPlayer.ai.targetSet === true) {
      currentTargetPos = targetPlayer.currentPosition.cell.number;
    }


    // CHECK FOR PURSUIT TARGET POSITION CHANGE!!
    if (aiPlayer.ai.mission === 'pursue' && aiPlayer.ai.targetSet === true) {
      // console.log('pursuing');

      if (prevTargetPos.x !== currentTargetPos.x || prevTargetPos.y !== currentTargetPos.y && targetPlayer.dead.state !== true && targetPlayer.falling.state !== true) {
        // console.log('pursuit target location changed! Updating path for player',aiPlayer.number);

        aiPlayer.ai.targetPlayer.currentPosition = {
          x: targetPlayer.currentPosition.cell.number.x,
          y: targetPlayer.currentPosition.cell.number.y,
        }
        getPath = true;
        aiPlayer.ai.targetAcquired = true;
        aiPlayer.ai.currentInstruction = 0;
      }
      if (aiPlayer.ai.targetSet === true && aiPlayer.ai.targetAcquired !== true) {
        getPath = true;
        aiPlayer.ai.targetAcquired = true;
      }
      else if (getPath !== true) {
        // console.log('target position unchanged! Skipping path update!');
        getPath = false;
      }

    }

    let patrolDest;
    if (aiPlayer.ai.mission === 'patrol') {
      // console.log('patrolling',aiPlayer.ai.patrolling.checkin);
      if (targetPlayer) {
        if (prevTargetPos.x !== currentTargetPos.x || prevTargetPos.y !== currentTargetPos.y && targetPlayer.dead.state !== true && targetPlayer.falling.state !== true) {
          // console.log('patrolling but target location changed! Dont update path. Just track target',aiPlayer.number);

          aiPlayer.ai.targetPlayer.currentPosition = {
            x: targetPlayer.currentPosition.cell.number.x,
            y: targetPlayer.currentPosition.cell.number.y,
          }
        }
      }


      if (!aiPlayer.ai.patrolling.checkin) {
        // if (aiPlayer.ai.instructions.length > 0) {
        //   console.log('bloody hell');
        //   aiPlayer.ai.instructions = []
        // }
        // console.log('start out to patrol location @',aiPlayer.ai.patrolling.area[0],aiPlayer.ai.instructions,aiPlayer.ai.currentInstruction,aiPlayer.ai.patrolling.area[0]);


        aiPlayer.ai.patrolling.checkin = 'enroute';

        if (!aiPlayer.popups.find(x=>x.msg === 'missionEnroute')) {
          aiPlayer.popups.push(
            {
              state: false,
              count: 0,
              limit: 30,
              type: '',
              position: '',
              msg: 'missionEnroute',
              img: '',

            }
          )
        }

        patrolDest = aiPlayer.ai.patrolling.area[0]
        getPath = true;
      }
      if (aiPlayer.ai.patrolling.checkin === 'enroute') {

        if (aiPlayer.attacking.state === true) {
          aiPlayer.attacking.state = false;
        }

        if (
          aiPlayer.ai.patrolling.area[0].x === aiPlayer.currentPosition.cell.number.x &&
          aiPlayer.ai.patrolling.area[0].y === aiPlayer.currentPosition.cell.number.y
        ) {
          aiPlayer.ai.patrolling.checkin = 'arrived';
          // console.log('arrived @ patrol point');
        } else {
          // console.log('en route to patrol. do nothing',aiPlayer.ai.patrolling.area[0]);
        }
      }
      if (aiPlayer.ai.patrolling.checkin === 'arrived') {
        aiPlayer.ai.patrolling.checkin = 'checkedIn'
        aiPlayer.ai.currentInstruction = 0;
        aiPlayer.ai.instructions = [];
        patrolDest = aiPlayer.ai.patrolling.area[1]
        getPath = true;
        // console.log('checked in to patrol point. moving to 2nd point @ ',patrolDest);
      }


      if (aiPlayer.ai.patrolling.checkin === 'checkedIn' && aiPlayer.ai.patrolling.loopControl === false) {
        // console.log('currently patrolling');
        let currentPatrolPoint = aiPlayer.ai.patrolling.area.findIndex(elem => elem.x === aiPlayer.currentPosition.cell.number.x && elem.y === aiPlayer.currentPosition.cell.number.y)
        // console.log('currentPatrolPoint 1',currentPatrolPoint, aiPlayer.currentPosition.cell.number);
        if (currentPatrolPoint === 0) {
          patrolDest = aiPlayer.ai.patrolling.area[1];
          getPath = true;
          aiPlayer.ai.patrolling.loopControl = true;
        }
        if (currentPatrolPoint === 1) {
          patrolDest = aiPlayer.ai.patrolling.area[0];
          getPath = true;
          aiPlayer.ai.patrolling.loopControl = true;
        }

      }

    }

    if (aiPlayer.ai.mission === 'engage' && aiPlayer.attacking.state !== true) {
      // console.log('engaging');


      // CHECK FOR TARGET LOCATION CHNAGE!
      if (prevTargetPos.x !== currentTargetPos.x || prevTargetPos.y !== currentTargetPos.y && targetPlayer.dead.state !== true && targetPlayer.falling.state !== true) {
        // console.log('engage target location changed! Updating path for player',aiPlayer.number,targetPlayer.dead.state);

        aiPlayer.ai.targetPlayer.currentPosition = {
          x: targetPlayer.currentPosition.cell.number.x,
          y: targetPlayer.currentPosition.cell.number.y,
        }
        if (aiPlayer.ai.primaryMission === 'pursue') {
          aiPlayer.ai.mission = 'pursue';
          this.aiResetRanges(aiPlayer)

          if (!aiPlayer.popups.find(x=>x.msg === 'missionPursue')) {
            aiPlayer.popups.push(
              {
                state: false,
                count: 0,
                limit: 30,
                type: '',
                position: '',
                msg: 'missionPursue',
                img: '',

              }
            )
          }
        }

        aiPlayer.ai.targetAcquired = false;
      }


      let oppositeDir;
      let engageTargetAction;
      // FACE TARGET!
      if (targetPlayer.currentPosition.cell.number.x === aiPlayer.currentPosition.cell.number.x && targetPlayer.currentPosition.cell.number.y > aiPlayer.currentPosition.cell.number.y) {
        if (aiPlayer.direction !== 'south') {

          aiPlayer.direction = 'south';
          // oppositeDir = 'north';
        }
        oppositeDir = 'north';
      }
      if (targetPlayer.currentPosition.cell.number.x === aiPlayer.currentPosition.cell.number.x && targetPlayer.currentPosition.cell.number.y < aiPlayer.currentPosition.cell.number.y) {
        if (aiPlayer.direction !== 'north') {

          aiPlayer.direction = 'north';
          // oppositeDir = 'south';
        }
        oppositeDir = 'south';
      }
      if (targetPlayer.currentPosition.cell.number.x < aiPlayer.currentPosition.cell.number.x && targetPlayer.currentPosition.cell.number.y === aiPlayer.currentPosition.cell.number.y) {
        if (aiPlayer.direction !== 'west') {

          aiPlayer.direction = 'west';
          // oppositeDir = 'east';
        }
        oppositeDir = 'east';
      }
      if (targetPlayer.currentPosition.cell.number.x > aiPlayer.currentPosition.cell.number.x && targetPlayer.currentPosition.cell.number.y === aiPlayer.currentPosition.cell.number.y) {
        if (aiPlayer.direction !== 'east') {

          aiPlayer.direction = 'east';
          // oppositeDir = 'west';
        }
        oppositeDir = 'west';
      }


      this.getTarget(aiPlayer);
      // if (aiPlayer.ai.engaging.state === true) {
      // if (aiPlayer.ai.engaging.state !== true) {

        if (aiPlayer.currentWeapon.type === 'crossbow' && aiPlayer.action === 'idle' && aiPlayer.success.deflected.state !== true) {
          let instructions3 = [];
          // ENGAGED TARGET IS OPEN TO ATTACK!
          if (targetPlayer.defending.state !== true && targetPlayer.attacking.state !== true && targetPlayer.defendDecay.state !== true && targetPlayer.dodging.state !== true) {
            // console.log('ai #',aiPlayer.number,'target  ',targetPlayer.number,'is neither attacking nor defending');

            if (
              aiPlayer.currentPosition.cell.number.x === targetPlayer.currentPosition.cell.number.x - 3 ||
              aiPlayer.currentPosition.cell.number.x === targetPlayer.currentPosition.cell.number.x + 3 ||
              aiPlayer.currentPosition.cell.number.y === targetPlayer.currentPosition.cell.number.y - 3 ||
              aiPlayer.currentPosition.cell.number.y === targetPlayer.currentPosition.cell.number.y + 3 ||
              aiPlayer.currentPosition.cell.number.x === targetPlayer.currentPosition.cell.number.x - 2 ||
              aiPlayer.currentPosition.cell.number.x === targetPlayer.currentPosition.cell.number.x + 2 ||
              aiPlayer.currentPosition.cell.number.y === targetPlayer.currentPosition.cell.number.y - 2 ||
              aiPlayer.currentPosition.cell.number.y === targetPlayer.currentPosition.cell.number.y + 2 ||
              aiPlayer.currentPosition.cell.number.x === targetPlayer.currentPosition.cell.number.x - 1 ||
              aiPlayer.currentPosition.cell.number.x === targetPlayer.currentPosition.cell.number.x + 1 ||
              aiPlayer.currentPosition.cell.number.y === targetPlayer.currentPosition.cell.number.y - 1 ||
              aiPlayer.currentPosition.cell.number.y === targetPlayer.currentPosition.cell.number.y + 1
            ) {
              console.log('plyr',aiPlayer.number,' engaging w/ crossbow but too close for comfort');
              aiPlayer.ai.retreating.state = false;
              aiPlayer.ai.retreating.checkin = undefined;
              aiPlayer.ai.mission = 'retreat';
              aiPlayer.ai.retreating.safe = false;

              if (!aiPlayer.popups.find(x=>x.msg === 'missionRetreat')) {
                aiPlayer.popups.push(
                  {
                    state: false,
                    count: 0,
                    limit: 30,
                    type: '',
                    position: '',
                    msg: 'missionRetreat',
                    img: '',

                  }
                )
              }
              // aiPlayer.ai.currentInstruction = 0;
            }
            else if (aiPlayer.items.ammo > 0) {


              instructions3.push(
                {
                  keyword: 'attack',
                  count: 0,
                  limit: 1,
                },
              )


            }
            if (aiPlayer.items.ammo === 0) {
              console.log('no ammo!!!');
            }

            engageTargetAction = 'open'
          }
          if (targetPlayer.defending.state === true || targetPlayer.defendDecay.count > targetPlayer.defendDecay.limit - 10) {


          }


          let deflecting = false;
          if (this.aiDeflectedCheck.includes(aiPlayer.number) === true) {
            deflecting = true;
          }
          if (deflecting === true) {
            aiPlayer.ai.instructions = [];
            aiPlayer.ai.currentInstruction = 0;
            aiPlayer.ai.engaging.targetAction = ''
          }


          if (aiPlayer.ai.engaging.targetAction !== engageTargetAction && deflecting !== true) {
            // console.log('target status has changed. switch up the approach');

            aiPlayer.ai.instructions = instructions3;
            aiPlayer.ai.currentInstruction = 0;
            aiPlayer.ai.engaging.state = true;
            aiPlayer.ai.engaging.targetAction = engageTargetAction;
          }


        }
        if (aiPlayer.currentWeapon.type === 'spear' && aiPlayer.action === 'idle' && aiPlayer.success.deflected.state !== true ) {
          let instructions2 = [];


          // ENGAGED TARGET IS OPEN TO ATTAVK!
          if (targetPlayer.defending.state !== true && targetPlayer.attacking.state !== true && targetPlayer.defendDecay.state !== true) {
            // console.log('ai #',aiPlayer.number,'target  ',targetPlayer.number,'is neither attacking nor defending')
            if (aiPlayer.ai.safeRange === true) {
              if (oppositeDir) {

                if (aiPlayer.target.cell2.occupant.type === "player") {
                  // console.log('target is too close! back it up');
                  instructions2.push(
                    {
                      keyword: 'strafe_'+oppositeDir,
                      count: 0,
                      limit: 1,
                    },
                    {
                      keyword: 'strafe_'+oppositeDir,
                      count: 0,
                      limit: 1,
                    },
                  )
                }
                if (
                  aiPlayer.currentPosition.cell.number.x === targetPlayer.currentPosition.cell.number.x - 3 ||
                  aiPlayer.currentPosition.cell.number.x === targetPlayer.currentPosition.cell.number.x + 3 ||
                  aiPlayer.currentPosition.cell.number.y === targetPlayer.currentPosition.cell.number.y - 3 ||
                  aiPlayer.currentPosition.cell.number.y === targetPlayer.currentPosition.cell.number.y + 3
                ) {
                  instructions2.push(
                    {
                      keyword: 'move_'+aiPlayer.direction,
                      count: 0,
                      limit: 1,
                    },
                  )
                }
                instructions2.push(
                  {
                    keyword: 'attack',
                    count: 0,
                    limit: 1,
                  },
                  {
                    keyword: 'strafe_'+oppositeDir,
                    count: 0,
                    limit: 1,
                  },
                  {
                    keyword: 'short_wait',
                    count: 0,
                    limit: 15,
                  },
                )
              }

            }
            else {
              instructions2.push(
                {
                  keyword: 'attack',
                  count: 0,
                  limit: 1,
                },
                {
                  keyword: 'short_wait',
                  count: 0,
                  limit: 1,
                },
              )
            }
            engageTargetAction = 'open';
          }


          // ENGAGED TARGET IS DEFENDING!
          if (targetPlayer.defendDecay.count > targetPlayer.defendDecay.limit - 10) {
            console.log('ai #',aiPlayer.number,'target  ',targetPlayer.number,' is defending',targetPlayer.defendDecay.count);
            if (aiPlayer.ai.safeRange === true) {
              if (oppositeDir) {

                if (aiPlayer.target.cell2.occupant.type === "player") {
                  // console.log('target is too close! back it up');
                  instructions2.push(
                    {
                      keyword: 'strafe_'+oppositeDir,
                      count: 0,
                      limit: 1,
                    },
                    {
                      keyword: 'strafe_'+oppositeDir,
                      count: 0,
                      limit: 1,
                    },
                  )
                }
                if (
                  aiPlayer.currentPosition.cell.number.x === targetPlayer.currentPosition.cell.number.x - 3 ||
                  aiPlayer.currentPosition.cell.number.x === targetPlayer.currentPosition.cell.number.x + 3 ||
                  aiPlayer.currentPosition.cell.number.y === targetPlayer.currentPosition.cell.number.y - 3 ||
                  aiPlayer.currentPosition.cell.number.y === targetPlayer.currentPosition.cell.number.y + 3
                ) {
                  instructions2.push(
                    {
                      keyword: 'move_'+aiPlayer.direction,
                      count: 0,
                      limit: 1,
                    },
                  )
                }
                instructions2.push(
                  {
                    keyword: 'attack',
                    count: 0,
                    limit: 1,
                  },
                  {
                    keyword: 'strafe_'+oppositeDir,
                    count: 0,
                    limit: 1,
                  },
                  {
                    keyword: 'short_wait',
                    count: 0,
                    limit: 15,
                  },
                )
              }

            }
            else {
              instructions2.push(
                {
                  keyword: 'attack',
                  count: 0,
                  limit: 1,
                },
                {
                  keyword: 'short_wait',
                  count: 0,
                  limit: 1,
                },
              )
            }
            engageTargetAction = 'defend';
          }


          // ENGAGED TARGET IS ATTACKING!
          if (targetPlayer.attacking.count > 0) {
            // console.log('ai #',aiPlayer.number,'target  ',targetPlayer.number,' is attacking',targetPlayer.attacking.count);

            // ATTACK IS PEAKING!
            if (targetPlayer.attacking.count < this.attackAnimRef.peak.spear && targetPlayer.attacking.count >= this.attackAnimRef.peak.spear - 4) {
              console.log('almost peak attack');
              let whatDo3 = this.rnJesus(1,2);

              // DEFEND!
              if (whatDo3 === 1) {
                console.log('ai defend');
                instructions2.push(
                  {
                    keyword: 'long_defend',
                    count: 0,
                    limit: 1,
                  },
                )
              }

              // DODGE!
              else {
                console.log('ai dodge');
                instructions2.push(
                  {
                    keyword: 'dodge',
                    count: 0,
                    limit: 1,
                  },
                )
              }

            }


            // ATTACK IS EARLY!
            if (targetPlayer.attacking.count <= 8) {
              console.log('early attack');
              let whatDo4 = this.rnJesus(1,4);
              // whatDo2 = 4

              // DEFEND!
              if (whatDo4 === 1) {
                console.log(' ai defend');
                instructions2.push(
                  {
                    keyword: 'long_defend',
                    count: 0,
                    limit: 1,
                  },
                )
              }

              // FLANK!
              if (whatDo4 === 2) {

                let flankDir3;
                let aiPosCell3 = this.gridInfo.find(elem => elem.number.x === aiPlayer.currentPosition.cell.number.x && elem.number.y === aiPlayer.currentPosition.cell.number.y)

                switch(aiPlayer.direction) {
                  case 'north':
                    if (aiPosCell3.edge.state === true && aiPosCell3.edge.side === 'east') {
                      flankDir3 = 'west';
                    }
                    if (aiPosCell3.edge.state === true && aiPosCell3.edge.side === 'west') {
                      flankDir3 = 'east';
                    }
                    else {
                      flankDir3 = 'west';
                    }
                  break;
                  case 'south':
                    if (aiPosCell3.edge.state === true && aiPosCell3.edge.side === 'east') {
                      flankDir3 = 'west';
                    }
                    if (aiPosCell3.edge.state === true && aiPosCell3.edge.side === 'west') {
                      flankDir3 = 'east';
                    }
                    else {
                      flankDir3 = 'west';
                    }
                  break;
                  case 'east':
                    if (aiPosCell3.edge.state === true && aiPosCell3.edge.side === 'north') {
                      flankDir3 = 'south';
                    }
                    if (aiPosCell3.edge.state === true && aiPosCell3.edge.side === 'south') {
                      flankDir3 = 'north';
                    }
                    else {
                      flankDir3 = 'south';
                    }
                  break;
                  case 'west':
                    if (aiPosCell3.edge.state === true && aiPosCell3.edge.side === 'north') {
                      flankDir3 = 'south';
                    }
                    if (aiPosCell3.edge.state === true && aiPosCell3.edge.side === 'south') {
                      flankDir3 = 'north';
                    }
                    else {
                      flankDir3 = 'south';
                    }
                  break;
                }
                console.log('ai flank',flankDir3);

                instructions2.push(
                  {
                    keyword: 'flank_'+flankDir3,
                    count: 0,
                    limit: 5,
                  },
                )
              }

              // DODGE!
              if ( whatDo4 === 3) {
                console.log('ai dodge');
                instructions2.push(
                  {
                    keyword: 'dodge',
                    count: 0,
                    limit: 1,
                  },
                )
              }

              // STRAFE EVADE!
              if ( whatDo4 === 4) {
                console.log('ai strafe evade');
                let evadeDirection2;
                let cellsToConsider2 = [
                  {x: aiPlayer.currentPosition.cell.number.x+1 ,y: aiPlayer.currentPosition.cell.number.y},
                  {x: aiPlayer.currentPosition.cell.number.x-1 ,y: aiPlayer.currentPosition.cell.number.y},
                  {x: aiPlayer.currentPosition.cell.number.x ,y: aiPlayer.currentPosition.cell.number.y+1},
                  {x: aiPlayer.currentPosition.cell.number.x ,y: aiPlayer.currentPosition.cell.number.y-1},
                ]
                for (const cell2 of cellsToConsider2) {
                  let freeCell2 = true
                  let cellRef2 = this.gridInfo.find(elem=> elem.number.x === cell2.x && elem.number.y === cell2.y);
                  if (cellRef2) {
                    let terrainInfo4 = cellRef2.levelData.length-1;
                    if (
                      cellRef2.levelData.charAt(terrainInfo4) === 'j' ||
                      cellRef2.levelData.charAt(terrainInfo4) === 'h' ||
                      cellRef2.levelData.charAt(terrainInfo4) === 'i' ||
                      cellRef2.levelData.charAt(0) !== 'x' ||
                      cellRef2.void.state === true
                    ) {
                      freeCell2 = false;
                    }
                    for (const plyr6 of this.players) {
                      if (plyr6.currentPosition.cell.number.x === cellRef2.number.x && plyr6.currentPosition.cell.number.y === cellRef2.number.y) {
                        freeCell2 = false;
                      }
                    }
                  }
                  else {
                    freeCell2 = false
                  }
                  if (freeCell2 === true) {
                    if (cell2.x === aiPlayer.currentPosition.cell.number.x+1 && cell2.y === aiPlayer.currentPosition.cell.number.y) {
                      evadeDirection2 = 'east'
                    }
                    if (cell2.x === aiPlayer.currentPosition.cell.number.x-1 && cell2.y === aiPlayer.currentPosition.cell.number.y) {
                      evadeDirection2 = 'west'
                    }
                    if (cell2.x === aiPlayer.currentPosition.cell.number.x && cell2.y === aiPlayer.currentPosition.cell.number.y+1) {
                      evadeDirection2 = 'south'
                    }
                    if (cell2.x === aiPlayer.currentPosition.cell.number.x && cell2.y === aiPlayer.currentPosition.cell.number.y-1) {
                      evadeDirection2 = 'north'
                    }
                  }
                }

                instructions2.push(
                  {
                    keyword: 'strafe_'+evadeDirection2,
                    count: 0,
                    limit: 1,
                  },
                )
                aiPlayer.ai.targetAcquired = false;
              }

            }

            engageTargetAction = 'attack'
          }

          for (const inst of aiPlayer.ai.instructions) {
            if (inst.keyword === 'attack') {
              // console.log('ai '+aiPlayer.number+' decides to attack w/ spear');
            }
          }


          let deflecting = false;
          if (this.aiDeflectedCheck.includes(aiPlayer.number) === true) {
            deflecting = true;
          }
          if (deflecting === true) {
            aiPlayer.ai.instructions = [];
            aiPlayer.ai.currentInstruction = 0;
            aiPlayer.ai.engaging.targetAction = ''
          }


          if (aiPlayer.ai.engaging.targetAction !== engageTargetAction && deflecting !== true) {
            // console.log('target status has changed. switch up the approach');

            aiPlayer.ai.instructions = instructions2;
            aiPlayer.ai.currentInstruction = 0;
            aiPlayer.ai.engaging.state = true;
            aiPlayer.ai.engaging.targetAction = engageTargetAction;

          }

          // console.log('aiPlayer.instructions',aiPlayer.ai.instructions);

        }
        if (aiPlayer.currentWeapon.type === 'sword' && aiPlayer.action === 'idle' && aiPlayer.success.deflected.state !== true ) {
          // console.log('ai decide sword engagement');

            let instructions1 = [];


            // ENGAGED TARGET IS OPEN TO ATTACK!
            if (targetPlayer.defending.state !== true && targetPlayer.attacking.state !== true && targetPlayer.defendDecay.state !== true && targetPlayer.dodging.state !== true) {
              // console.log('ai #',aiPlayer.number,'target  ',targetPlayer.number,'is neither attacking nor defending');
              if (aiPlayer.ai.safeRange === true) {
                if (oppositeDir) {
                  // console.log('safe sword range attack flow');

                  if (aiPlayer.target.cell1.occupant.type === "player") {
                    // console.log('target is too close! back it up');
                    instructions1.push(
                      {
                        keyword: 'strafe_'+oppositeDir,
                        count: 0,
                        limit: 1,
                      },
                    )
                  }
                  instructions1.push(
                    {
                      keyword: 'move_'+aiPlayer.direction,
                      count: 0,
                      limit: 1,
                    },
                    {
                      keyword: 'attack',
                      count: 0,
                      limit: 1,
                    },
                    {
                      keyword: 'strafe_'+oppositeDir,
                      count: 0,
                      limit: 1,
                    },
                    {
                      keyword: 'short_wait',
                      count: 0,
                      limit: 15,
                    },
                  )
                }
              }
              else {
                instructions1.push(
                  {
                    keyword: 'attack',
                    count: 0,
                    limit: 1,
                  },
                  {
                    keyword: 'short_wait',
                    count: 0,
                    limit: 1,
                  },
                )
              }
              engageTargetAction = 'open';
            }


            // ENGAGED TARGET DEFENDING!
            if (targetPlayer.defending.state === true || targetPlayer.defendDecay.count > targetPlayer.defendDecay.limit - 10) {
              // console.log('ai #',aiPlayer.number,'target  ',targetPlayer.number,' is defending',targetPlayer.defendDecay.count);

              if (aiPlayer.ai.safeRange === true) {
                if (oppositeDir) {
                  // console.log('safe range attack flow');

                  if (aiPlayer.target.cell1.occupant.type === "player") {
                    // console.log('target is too close! back it up');
                    instructions1.push(
                      {
                        keyword: 'strafe_'+oppositeDir,
                        count: 0,
                        limit: 1,
                      },
                    )
                  }
                  instructions1.push(
                    {
                      keyword: 'move_'+aiPlayer.direction,
                      count: 0,
                      limit: 1,
                    },
                    {
                      keyword: 'attack',
                      count: 0,
                      limit: 1,
                    },
                    {
                      keyword: 'strafe_'+oppositeDir,
                      count: 0,
                      limit: 1,
                    },
                    {
                      keyword: 'short_wait',
                      count: 0,
                      limit: 15,
                    },
                  )
                }
              }
              else {
                instructions1.push(
                  {
                    keyword: 'attack',
                    count: 0,
                    limit: 1,
                  },
                  {
                    keyword: 'short_wait',
                    count: 0,
                    limit: 1,
                  },
                )
              }
              engageTargetAction = 'defend';
            }


            // ENGAGED TARGET ATTACKING!
            if (targetPlayer.attacking.count > 0) {
               // console.log('ai #',aiPlayer.number,'target  ',targetPlayer.number,' is attacking',targetPlayer.attacking.count);


              // ATTACK IS PEAKING!
              if (targetPlayer.attacking.count < this.attackAnimRef.peak.sword && targetPlayer.attacking.count >= this.attackAnimRef.peak.sword - 4) {
                console.log('almost peak attack');
                let whatDo = this.rnJesus(1,2);
                whatDo = 1

                // DEFEND!
                if (whatDo === 1) {
                  console.log('ai defend');
                  instructions1.push(
                    {
                      keyword: 'long_defend',
                      count: 0,
                      limit: 1,
                    },
                  )
                }

                // DODGE!
                else {
                  console.log('ai dodge');
                  instructions1.push(
                    {
                      keyword: 'dodge',
                      count: 0,
                      limit: 1,
                    },
                  )
                }

              }


              // ATTACK IS EARLY!
              if (targetPlayer.attacking.count <= 6) {
                console.log('early attack');
                let whatDo2 = this.rnJesus(1,4);
                whatDo2 = 1

                // DEFEND!
                if (whatDo2 === 1) {
                  console.log(' ai defend');
                  instructions1.push(
                    {
                      keyword: 'long_defend',
                      count: 0,
                      limit: 1,
                    },
                  )
                }

                // FLANK!
                if (whatDo2 === 2) {

                  let flankDir2;
                  let aiPosCell2 = this.gridInfo.find(elem => elem.number.x === aiPlayer.currentPosition.cell.number.x && elem.number.y === aiPlayer.currentPosition.cell.number.y)

                  switch(aiPlayer.direction) {
                    case 'north':
                      if (aiPosCell2.edge.state === true && aiPosCell2.edge.side === 'east') {
                        flankDir2 = 'west';
                      }
                      if (aiPosCell2.edge.state === true && aiPosCell2.edge.side === 'west') {
                        flankDir2 = 'east';
                      }
                      else {
                        flankDir2 = 'west';
                      }
                    break;
                    case 'south':
                      if (aiPosCell2.edge.state === true && aiPosCell2.edge.side === 'east') {
                        flankDir2 = 'west';
                      }
                      if (aiPosCell2.edge.state === true && aiPosCell2.edge.side === 'west') {
                        flankDir2 = 'east';
                      }
                      else {
                        flankDir2 = 'west';
                      }
                    break;
                    case 'east':
                      if (aiPosCell2.edge.state === true && aiPosCell2.edge.side === 'north') {
                        flankDir2 = 'south';
                      }
                      if (aiPosCell2.edge.state === true && aiPosCell2.edge.side === 'south') {
                        flankDir2 = 'north';
                      }
                      else {
                        flankDir2 = 'south';
                      }
                    break;
                    case 'west':
                      if (aiPosCell2.edge.state === true && aiPosCell2.edge.side === 'north') {
                        flankDir2 = 'south';
                      }
                      if (aiPosCell2.edge.state === true && aiPosCell2.edge.side === 'south') {
                        flankDir2 = 'north';
                      }
                      else {
                        flankDir2 = 'south';
                      }
                    break;
                  }
                  console.log('ai flank',flankDir2);

                  instructions1.push(
                    {
                      keyword: 'flank_'+flankDir2,
                      count: 0,
                      limit: 5,
                    },
                  )
                }

                // DODGE!
                if ( whatDo2 === 3) {
                  console.log('ai dodge');
                  instructions1.push(
                    {
                      keyword: 'dodge',
                      count: 0,
                      limit: 1,
                    },
                  )
                }

                // STRAFE EVADE!
                if ( whatDo2 === 4) {
                  console.log('ai strafe evade');
                  let evadeDirection;
                  let cellsToConsider = [
                    {x: aiPlayer.currentPosition.cell.number.x+1 ,y: aiPlayer.currentPosition.cell.number.y},
                    {x: aiPlayer.currentPosition.cell.number.x-1 ,y: aiPlayer.currentPosition.cell.number.y},
                    {x: aiPlayer.currentPosition.cell.number.x ,y: aiPlayer.currentPosition.cell.number.y+1},
                    {x: aiPlayer.currentPosition.cell.number.x ,y: aiPlayer.currentPosition.cell.number.y-1},
                  ]
                  for (const cell of cellsToConsider) {
                    let freeCell = true
                    let cellRef = this.gridInfo.find(elem=> elem.number.x === cell.x && elem.number.y === cell.y);
                    if (cellRef) {
                      let terrainInfo3 = cellRef.levelData.length-1;
                      if (
                        cellRef.levelData.charAt(terrainInfo3) === 'j' ||
                        cellRef.levelData.charAt(terrainInfo3) === 'h' ||
                        cellRef.levelData.charAt(terrainInfo3) === 'i' ||
                        cellRef.levelData.charAt(0) !== 'x' ||
                        cellRef.void.state === true
                      ) {
                        freeCell = false;
                      }
                      for (const plyr5 of this.players) {
                        if (plyr5.currentPosition.cell.number.x === cellRef.number.x && plyr5.currentPosition.cell.number.y === cellRef.number.y) {
                          freeCell = false;
                        }
                      }
                    }
                    else {
                      freeCell = false
                    }
                    if (freeCell === true) {
                      if (cell.x === aiPlayer.currentPosition.cell.number.x+1 && cell.y === aiPlayer.currentPosition.cell.number.y) {
                        evadeDirection = 'east'
                      }
                      if (cell.x === aiPlayer.currentPosition.cell.number.x-1 && cell.y === aiPlayer.currentPosition.cell.number.y) {
                        evadeDirection = 'west'
                      }
                      if (cell.x === aiPlayer.currentPosition.cell.number.x && cell.y === aiPlayer.currentPosition.cell.number.y+1) {
                        evadeDirection = 'south'
                      }
                      if (cell.x === aiPlayer.currentPosition.cell.number.x && cell.y === aiPlayer.currentPosition.cell.number.y-1) {
                        evadeDirection = 'north'
                      }
                    }
                  }

                  instructions1.push(
                    {
                      keyword: 'strafe_'+evadeDirection,
                      count: 0,
                      limit: 1,
                    },
                  )
                  aiPlayer.ai.targetAcquired = false;
                }

              }


              engageTargetAction = 'attack';
            }



            let deflecting = false;
            if (this.aiDeflectedCheck.includes(aiPlayer.number) === true) {
              deflecting = true;
            }
            if (deflecting === true) {
              aiPlayer.ai.instructions = [];
              aiPlayer.ai.currentInstruction = 0;
              aiPlayer.ai.engaging.targetAction = ''
            }

            // target status has changed. switch up the approach
            if (aiPlayer.ai.engaging.targetAction !== engageTargetAction && deflecting !== true ) {
            // if (aiPlayer.ai.engaging.targetAction !== engageTargetAction ) {

              // console.log('target status has changed. switch up the approach');

              aiPlayer.ai.instructions = instructions1;
              aiPlayer.ai.currentInstruction = 0;
              aiPlayer.ai.engaging.state = true;
              aiPlayer.ai.engaging.targetAction = engageTargetAction;

            }

            // console.log('aiPlayer.instructions',aiPlayer.ai.instructions);
        }
        if (aiPlayer.currentWeapon.type === '' && aiPlayer.action === 'idle' && aiPlayer.success.deflected.state !== true && aiPlayer.ai.organizing.dropped.state !== true) {
          // console.log('unarmed engagement');

          let instructions4 = [];


          // ENGAGED TARGET IS OPEN TO ATTACK!
          if (targetPlayer.defending.state !== true && targetPlayer.attacking.state !== true && targetPlayer.defendDecay.state !== true && targetPlayer.dodging.state !== true) {
            // console.log('ai #',aiPlayer.number,'target  ',targetPlayer.number,'is neither attacking nor defending');
            if (aiPlayer.ai.safeRange === true) {
              if (oppositeDir) {
                // console.log('safe sword range attack flow');

                if (aiPlayer.target.cell1.occupant.type === "player") {
                  // console.log('target is too close! back it up');
                  instructions4.push(
                    {
                      keyword: 'strafe_'+oppositeDir,
                      count: 0,
                      limit: 1,
                    },
                  )
                }
                instructions4.push(
                  {
                    keyword: 'move_'+aiPlayer.direction,
                    count: 0,
                    limit: 1,
                  },
                  {
                    keyword: 'attack',
                    count: 0,
                    limit: 1,
                  },
                  {
                    keyword: 'strafe_'+oppositeDir,
                    count: 0,
                    limit: 1,
                  },
                  {
                    keyword: 'short_wait',
                    count: 0,
                    limit: 15,
                  },
                )
              }
            }
            else {
              instructions4.push(
                {
                  keyword: 'attack',
                  count: 0,
                  limit: 1,
                },
                {
                  keyword: 'short_wait',
                  count: 0,
                  limit: 1,
                },
              )
            }

            engageTargetAction = 'open';
          }


          // ENGAGED TARGET DEFENDING!
          if (targetPlayer.defending.state === true || targetPlayer.defendDecay.count > targetPlayer.defendDecay.limit - 10) {
            console.log('ai #',aiPlayer.number,'target  ',targetPlayer.number,' is defending',targetPlayer.defendDecay.count);

            if (aiPlayer.ai.safeRange === true) {
              if (oppositeDir) {
                // console.log('safe range attack flow');

                if (aiPlayer.target.cell1.occupant.type === "player") {
                  // console.log('target is too close! back it up');
                  instructions4.push(
                    {
                      keyword: 'strafe_'+oppositeDir,
                      count: 0,
                      limit: 1,
                    },
                  )
                }
                instructions4.push(
                  {
                    keyword: 'move_'+aiPlayer.direction,
                    count: 0,
                    limit: 1,
                  },
                  {
                    keyword: 'attack',
                    count: 0,
                    limit: 1,
                  },
                  {
                    keyword: 'strafe_'+oppositeDir,
                    count: 0,
                    limit: 1,
                  },
                  {
                    keyword: 'short_wait',
                    count: 0,
                    limit: 15,
                  },
                )
              }
            }
            else {
              instructions4.push(
                {
                  keyword: 'attack',
                  count: 0,
                  limit: 1,
                },
                {
                  keyword: 'short_wait',
                  count: 0,
                  limit: 1,
                },
              )
            }

            engageTargetAction = 'defend';
          }


          // ENGAGED TARGET ATTACKING!
          if (targetPlayer.attacking.count > 0) {
             // console.log('ai #',aiPlayer.number,'target  ',targetPlayer.number,' is attacking',targetPlayer.attacking.count);


            // ATTACK IS PEAKING!
            if (targetPlayer.attacking.count < this.attackAnimRef.peak.sword && targetPlayer.attacking.count >= this.attackAnimRef.peak.sword - 4) {
              console.log('almost peak attack');
              let whatDo5 = this.rnJesus(1,2);

              // DEFEND!
              if (whatDo5 === 1) {
                console.log('ai defend');
                instructions4.push(
                  {
                    keyword: 'long_defend',
                    count: 0,
                    limit: 1,
                  },
                )
              }

              // DODGE!
              else {
                console.log('ai dodge');
                instructions4.push(
                  {
                    keyword: 'dodge',
                    count: 0,
                    limit: 1,
                  },
                )
              }

            }


            // ATTACK IS EARLY!
            if (targetPlayer.attacking.count <= 6) {
              console.log('early attack');
              let whatDo6 = this.rnJesus(1,4);
              // whatDo2 = 4

              // DEFEND!
              if (whatDo6 === 1) {
                console.log(' ai defend');
                instructions4.push(
                  {
                    keyword: 'long_defend',
                    count: 0,
                    limit: 1,
                  },
                )
              }

              // FLANK!
              if (whatDo6 === 2) {

                let flankDir3;
                let aiPosCell3 = this.gridInfo.find(elem => elem.number.x === aiPlayer.currentPosition.cell.number.x && elem.number.y === aiPlayer.currentPosition.cell.number.y)

                switch(aiPlayer.direction) {
                  case 'north':
                    if (aiPosCell3.edge.state === true && aiPosCell3.edge.side === 'east') {
                      flankDir3 = 'west';
                    }
                    if (aiPosCell3.edge.state === true && aiPosCell3.edge.side === 'west') {
                      flankDir3 = 'east';
                    }
                    else {
                      flankDir3 = 'west';
                    }
                  break;
                  case 'south':
                    if (aiPosCell3.edge.state === true && aiPosCell3.edge.side === 'east') {
                      flankDir3 = 'west';
                    }
                    if (aiPosCell3.edge.state === true && aiPosCell3.edge.side === 'west') {
                      flankDir3 = 'east';
                    }
                    else {
                      flankDir3 = 'west';
                    }
                  break;
                  case 'east':
                    if (aiPosCell3.edge.state === true && aiPosCell3.edge.side === 'north') {
                      flankDir3 = 'south';
                    }
                    if (aiPosCell3.edge.state === true && aiPosCell3.edge.side === 'south') {
                      flankDir3 = 'north';
                    }
                    else {
                      flankDir3 = 'south';
                    }
                  break;
                  case 'west':
                    if (aiPosCell3.edge.state === true && aiPosCell3.edge.side === 'north') {
                      flankDir3 = 'south';
                    }
                    if (aiPosCell3.edge.state === true && aiPosCell3.edge.side === 'south') {
                      flankDir3 = 'north';
                    }
                    else {
                      flankDir3 = 'south';
                    }
                  break;
                }
                console.log('ai flank',flankDir3);

                instructions4.push(
                  {
                    keyword: 'flank_'+flankDir3,
                    count: 0,
                    limit: 5,
                  },
                )
              }

              // DODGE!
              if ( whatDo6 === 3) {
                console.log('ai dodge');
                instructions4.push(
                  {
                    keyword: 'dodge',
                    count: 0,
                    limit: 1,
                  },
                )
              }

              // STRAFE EVADE!
              if ( whatDo6 === 4) {
                console.log('ai strafe evade');
                let evadeDirection3;
                let cellsToConsider3 = [
                  {x: aiPlayer.currentPosition.cell.number.x+1 ,y: aiPlayer.currentPosition.cell.number.y},
                  {x: aiPlayer.currentPosition.cell.number.x-1 ,y: aiPlayer.currentPosition.cell.number.y},
                  {x: aiPlayer.currentPosition.cell.number.x ,y: aiPlayer.currentPosition.cell.number.y+1},
                  {x: aiPlayer.currentPosition.cell.number.x ,y: aiPlayer.currentPosition.cell.number.y-1},
                ]
                for (const cell3 of cellsToConsider3) {
                  let freeCell3 = true
                  let cellRef3 = this.gridInfo.find(elem=> elem.number.x === cell3.x && elem.number.y === cell3.y);
                  if (cellRef3) {
                    let terrainInfo5 = cellRef3.levelData.length-1;
                    if (
                      cellRef3.levelData.charAt(terrainInfo5) === 'j' ||
                      cellRef3.levelData.charAt(terrainInfo5) === 'h' ||
                      cellRef3.levelData.charAt(terrainInfo5) === 'i' ||
                      cellRef3.levelData.charAt(0) !== 'x' ||
                      cellRef3.void.state === true
                    ) {
                      freeCell3 = false;
                    }
                    for (const plyr7 of this.players) {
                      if (plyr7.currentPosition.cell.number.x === cellRef3.number.x && plyr7.currentPosition.cell.number.y === cellRef3.number.y) {
                        freeCell3 = false;
                      }
                    }
                  }
                  else {
                    freeCell3 = false
                  }
                  if (freeCell3 === true) {
                    if (cell3.x === aiPlayer.currentPosition.cell.number.x+1 && cell3.y === aiPlayer.currentPosition.cell.number.y) {
                      evadeDirection3 = 'east'
                    }
                    if (cell3.x === aiPlayer.currentPosition.cell.number.x-1 && cell3.y === aiPlayer.currentPosition.cell.number.y) {
                      evadeDirection3 = 'west'
                    }
                    if (cell3.x === aiPlayer.currentPosition.cell.number.x && cell3.y === aiPlayer.currentPosition.cell.number.y+1) {
                      evadeDirection3 = 'south'
                    }
                    if (cell3.x === aiPlayer.currentPosition.cell.number.x && cell3.y === aiPlayer.currentPosition.cell.number.y-1) {
                      evadeDirection3 = 'north'
                    }
                  }
                }

                instructions4.push(
                  {
                    keyword: 'strafe_'+evadeDirection3,
                    count: 0,
                    limit: 1,
                  },
                )
                aiPlayer.ai.targetAcquired = false;
              }

            }

            engageTargetAction = 'attack';
          }


          let deflecting = false;
          if (this.aiDeflectedCheck.includes(aiPlayer.number) === true) {
            deflecting = true;
          }
          if (deflecting === true) {
            aiPlayer.ai.instructions = [];
            aiPlayer.ai.currentInstruction = 0;
            aiPlayer.ai.engaging.targetAction = ''
          }


          if (aiPlayer.ai.engaging.targetAction !== engageTargetAction && deflecting !== true) {
            // console.log('target status has changed. switch up the approach');

            aiPlayer.ai.instructions = instructions4;
            aiPlayer.ai.currentInstruction = 0;
            aiPlayer.ai.engaging.state = true;
            aiPlayer.ai.engaging.targetAction = engageTargetAction;
          }

          // console.log('aiPlayer.instructions',aiPlayer.ai.instructions);

        }


      // }


    }

    let defendDest;
    if (aiPlayer.ai.mission === 'defend') {
      // console.log('defending',aiPlayer.ai.defending);
      // console.log('aiDecide mission: defend - prevTargetPos',prevTargetPos,'currentTargetPos',currentTargetPos);

      // TARGET LOCATION CHANGED!!
      if (prevTargetPos.x && currentTargetPos.x) {
        if (prevTargetPos.x !== currentTargetPos.x || prevTargetPos.y !== currentTargetPos.y && targetPlayer.dead.state !== true && targetPlayer.falling.state !== true) {
          // console.log('defending but target location changed! Dont update path. Just track target',aiPlayer.number);

          aiPlayer.ai.targetPlayer.currentPosition = {
            x: targetPlayer.currentPosition.cell.number.x,
            y: targetPlayer.currentPosition.cell.number.y,
          }
        }
      }


      // SET OUT TO DEFEND POINT
      if (!aiPlayer.ai.defending.checkin) {
        console.log('start out to defend location',aiPlayer.ai.defending.area[0]);
        aiPlayer.ai.defending.checkin = 'enroute';

        if (!aiPlayer.popups.find(x=>x.msg === 'missionEnroute')) {
          aiPlayer.popups.push(
            {
              state: false,
              count: 0,
              limit: 30,
              type: '',
              position: '',
              msg: 'missionEnroute',
              img: '',

            }
          )
        }

        let cellsToConsider2 = [
          {x: aiPlayer.ai.defending.area[0].x+1 ,y: aiPlayer.ai.defending.area[0].y},
          {x: aiPlayer.ai.defending.area[0].x-1 ,y: aiPlayer.ai.defending.area[0].y},
          {x: aiPlayer.ai.defending.area[0].x ,y: aiPlayer.ai.defending.area[0].y+1},
          {x: aiPlayer.ai.defending.area[0].x ,y: aiPlayer.ai.defending.area[0].y-1},
        ]
        let freeCell2 = true
        let freeCellNo;
        let freeCells = [];
        for (const cell2 of cellsToConsider2) {
          // console.log('cell2a',cell2);
          freeCell2 = true
          let cellRef2 = this.gridInfo.find(elem=> elem.number.x === cell2.x && elem.number.y === cell2.y);
          if (cellRef2) {


            if (
              cellRef2.levelData.split('_')[1] !== '*' ||
              cellRef2.terrain.type === 'deep' ||
              cellRef2.terrain.type === 'hazard' ||
              // cellRef2.barrier.state === true ||
              cellRef2.void.state === true
            ) {
              freeCell2 = false;
            }
            for (const plyr6 of this.players) {
              if (plyr6.currentPosition.cell.number.x === cellRef2.number.x && plyr6.currentPosition.cell.number.y === cellRef2.number.y) {
                freeCell2 = false;
              }
            }
          }
          else {
            freeCell2 = false
          }
          if (freeCell2 === true) {
            freeCells.push(cell2)
            // console.log('freeCellNo',cell2);
          }
        }
        let whatCell = this.rnJesus(1,freeCells.length)


        defendDest = freeCells[whatCell-1]
        console.log('defendDest',defendDest);
        if (aiPlayer.ai.defending.area.length > 1) {
          aiPlayer.ai.defending.area[1] = defendDest
        }
        if (aiPlayer.ai.defending.area.length === 1) {
          aiPlayer.ai.defending.area.push(defendDest)
        }

        getPath = true;

      }

      // EN ROUTE TO DEFEND POINT
      if (aiPlayer.ai.defending.checkin === 'enroute') {
        // console.log('en route to defend point');

        if (aiPlayer.attacking.state === true) {
          aiPlayer.attacking.state = false;
        }

        if (
          aiPlayer.ai.defending.area[1].x === aiPlayer.currentPosition.cell.number.x &&
          aiPlayer.ai.defending.area[1].y === aiPlayer.currentPosition.cell.number.y
        ) {
          aiPlayer.ai.defending.checkin = 'checkedIn';
          aiPlayer.ai.instructions = []
          aiPlayer.ai.currentInstruction = 0;
          // console.log('arrived @ defend point',aiPlayer.ai.instructions);
        } else {
          // console.log('en route to defend post. do nothing',aiPlayer.ai.defending.area[0]);
        }
      }

      // ARRIVED AT DEFEND POINT
      if (aiPlayer.ai.defending.checkin === 'checkedIn' && aiPlayer.ai.instructions.length === 0) {
        // console.log('defend post checkedIn');
        let instructions = [];
        switch(aiPlayer.direction) {
          case 'north':
            instructions = [
              {keyword: 'long_wait',count: 0,limit: 25,},
              {keyword: 'move_east',count: 0,limit: 1,},
              {keyword: 'long_wait',count: 0,limit: 25,},
              {keyword: 'long_wait',count: 0,limit: 25,},
              {keyword: 'move_south',count: 0,limit: 1,},
              {keyword: 'long_wait',count: 0,limit: 25,},
              {keyword: 'long_wait',count: 0,limit: 25,},
              {keyword: 'move_west',count: 0,limit: 1,},
              {keyword: 'long_wait',count: 0,limit: 25,},
              {keyword: 'long_wait',count: 0,limit: 25,},
              {keyword: 'move_north',count: 0,limit: 1,},
              {keyword: 'long_wait',count: 0,limit: 25,},
            ]
          break;
          case 'east':
            instructions = [
              {keyword: 'long_wait',count: 0,limit: 25,},
              {keyword: 'move_south',count: 0,limit: 1,},
              {keyword: 'long_wait',count: 0,limit: 25,},
              {keyword: 'long_wait',count: 0,limit: 25,},
              {keyword: 'move_west',count: 0,limit: 1,},
              {keyword: 'long_wait',count: 0,limit: 25,},
              {keyword: 'long_wait',count: 0,limit: 25,},
              {keyword: 'move_north',count: 0,limit: 1,},
              {keyword: 'long_wait',count: 0,limit: 25,},
              {keyword: 'long_wait',count: 0,limit: 25,},
              {keyword: 'move_east',count: 0,limit: 1,},
              {keyword: 'long_wait',count: 0,limit: 25,},
            ]
          break;
          case 'south':
            instructions = [
              {keyword: 'long_wait',count: 0,limit: 25,},
              {keyword: 'move_west',count: 0,limit: 1,},
              {keyword: 'long_wait',count: 0,limit: 25,},
              {keyword: 'long_wait',count: 0,limit: 25,},
              {keyword: 'move_north',count: 0,limit: 1,},
              {keyword: 'long_wait',count: 0,limit: 25,},
              {keyword: 'long_wait',count: 0,limit: 25,},
              {keyword: 'move_east',count: 0,limit: 1,},
              {keyword: 'long_wait',count: 0,limit: 25,},
              {keyword: 'long_wait',count: 0,limit: 25,},
              {keyword: 'move_south',count: 0,limit: 1,},
              {keyword: 'long_wait',count: 0,limit: 25,},
            ]
          break;
          case 'west':
            instructions = [
              {keyword: 'long_wait',count: 0,limit: 25,},
              {keyword: 'move_north',count: 0,limit: 1,},
              {keyword: 'long_wait',count: 0,limit: 25,},
              {keyword: 'long_wait',count: 0,limit: 25,},
              {keyword: 'move_east',count: 0,limit: 1,},
              {keyword: 'long_wait',count: 0,limit: 25,},
              {keyword: 'long_wait',count: 0,limit: 25,},
              {keyword: 'move_south',count: 0,limit: 1,},
              {keyword: 'long_wait',count: 0,limit: 25,},
              {keyword: 'long_wait',count: 0,limit: 25,},
              {keyword: 'move_west',count: 0,limit: 1,},
              {keyword: 'long_wait',count: 0,limit: 25,},
            ]
          break;
        }
        aiPlayer.ai.instructions = instructions;
        aiPlayer.ai.currentInstruction = 0;
        // console.log('aiPlayer.ai.instructions',aiPlayer.ai.instructions);

      }


    }

    if (aiPlayer.ai.mission === 'retrieve') {

      // SET OUT
      if (aiPlayer.ai.retrieving.state !== true && aiPlayer.ai.retrieving.safe === true) {
        // console.log('retrive mission start: target item ',aiPlayer.ai.retrieving.targetItem.name,targetPlayer,aiPlayer.ai.retrieving);
        aiPlayer.ai.retrieving.state = true;
        aiPlayer.ai.retrieving.checkin = 'enroute';
        getPath = true;

        if (!aiPlayer.popups.find(x=>x.msg === 'missionEnroute')) {
          aiPlayer.popups.push(
            {
              state: false,
              count: 0,
              limit: 30,
              type: '',
              position: '',
              msg: 'missionEnroute',
              img: '',

            }
          )
        }
      }

      // EN ROUTE
      if (aiPlayer.ai.retrieving.state === true) {

        if (aiPlayer.ai.retrieving.checkin === 'enroute') {
          // console.log('en route to retrieve point',aiPlayer.ai.retrieving.point);

          let targetCell = this.gridInfo.find(elem => elem.number.x === aiPlayer.ai.retrieving.point.x && elem.number.y === aiPlayer.ai.retrieving.point.y);
          if (targetCell.item.name === '' || aiPlayer.ai.retrieving.targetItem.name !== targetCell.item.name) {
            console.log('item to retrieve is no longer there. abort');
            aiPlayer.ai.retrieving.checkin = 'abort';
          }

          if (
            aiPlayer.currentPosition.cell.number.x === aiPlayer.ai.retrieving.point.x &&
            aiPlayer.currentPosition.cell.number.y === aiPlayer.ai.retrieving.point.y
          ) {
            console.log('arrived at retrieval location');
            aiPlayer.ai.retrieving.checkin = 'complete';
            aiPlayer.ai.retrieving.state = false;
          }
        }

      }

    }

    if (aiPlayer.ai.mission === 'retreat') {

      // SET OUT
      if (aiPlayer.ai.retreating.state !== true && aiPlayer.ai.retreating.safe === true) {
        // console.log('start retreating to',aiPlayer.ai.retreating.point);
        aiPlayer.ai.retreating.state = true;
        aiPlayer.ai.retreating.checkin = 'enroute';
        getPath = true;

        if (!aiPlayer.popups.find(x=>x.msg === 'missionEnroute')) {
          aiPlayer.popups.push(
            {
              state: false,
              count: 0,
              limit: 30,
              type: '',
              position: '',
              msg: 'missionEnroute',
              img: '',

            }
          )
        }
      }

      // EN ROUTE
      if (aiPlayer.ai.retreating.state === true) {

        if (aiPlayer.ai.retreating.checkin === 'enroute') {
          // console.log('enroute to retreat point @',aiPlayer.ai.retreating.point,'instructions',aiPlayer.ai.instructions,aiPlayer.ai.currentInstruction);
          if (
            aiPlayer.currentPosition.cell.number.x === aiPlayer.ai.retreating.point.x &&
            aiPlayer.currentPosition.cell.number.y === aiPlayer.ai.retreating.point.y
          ) {
            // console.log('arrived at retreat location');
            aiPlayer.ai.instructions.push({keyword: 'long_wait',count: 0,limit: 25,},)
            aiPlayer.ai.retreating.checkin = 'resting';

          }

        }

        if (aiPlayer.ai.retreating.checkin === 'resting') {
          if (aiPlayer.stamina.current >= aiPlayer.stamina.max) {
            console.log('plyr is well rested. retreat complete');
            aiPlayer.ai.retreating.checkin = 'complete';
            aiPlayer.ai.retreating.state = false;
          }

        }
      }

    }

    // if player cycling and path set not true add cycle gear to plyr instructions

    let cancelPath = false

    // SET PATH !!
    let pathSet = [];

    if (getPath === true && !targetPlayer && aiPlayer.ai.mission === 'retrieve' && aiPlayer.ai.retrieving.state === true) {
      console.log('pathfinding...retrieve');
      this.updatePathArray();
      this.easyStar = new Easystar.js();

      let aiPos;
      let targetPos;

      // console.log('get retrive path',aiPlayer.ai.retrieving.point);
      aiPos = aiPlayer.currentPosition.cell.number;
      targetPos = {
        x: aiPlayer.ai.retrieving.point.x,
        y: aiPlayer.ai.retrieving.point.y,
      }


      this.easyStar.setGrid(this.pathArray);
      this.easyStar.setAcceptableTiles([0]);


      // PLAYER CELLS TO AVOID
      for (const plyr of this.players) {
        // console.log('building pathfind obstacles checking plyr',plyr.number);
        if (plyr.dead.state !== true && plyr.falling.state !== true && plyr.respawn !== true && plyr.number !== aiPlayer.number && plyr.number !== targetPlayer.number) {
          // console.log('avoid plyr',plyr.number,'@',plyr.currentPosition.cell.number.x, plyr.currentPosition.cell.number.y);
          this.easyStar.avoidAdditionalPoint(plyr.currentPosition.cell.number.x, plyr.currentPosition.cell.number.y);
        }
      }

      // AVOID PATHS THAT GO CLOSE TO ENEMY PLAYERS IF ALIVE
      for (const plyr of this.players) {
        if (plyr.ai.state !== true && plyr.dead.state !== true && plyr.falling.state !== true) {
          console.log(aiPlayer.ai.mission,' careful pathfinding. enemy is plyr #',plyr.number);
          let rng;
          let span;

          if (plyr.currentWeapon.type === "sword" || plyr.currentWeapon.name === "") {
            rng = 1;
          }
          else {
            rng = 2;
          }
          span = (rng*2)+1;
          let cornerCell = undefined;
          let whichCorner;

          while (!cornerCell) {

            let whichCorner2 = this.rnJesus(1,4)

            switch(whichCorner2) {
              case 1:
                cornerCell = this.gridInfo.find(elem=> elem.number.x === plyr.currentPosition.cell.number.x+rng && elem.number.y === plyr.currentPosition.cell.number.y+rng)
                whichCorner = 'southEast';
              break;
              case 2:
                cornerCell = this.gridInfo.find(elem=> elem.number.x === plyr.currentPosition.cell.number.x-rng && elem.number.y === plyr.currentPosition.cell.number.y-rng)
                whichCorner = 'northWest';
              break;
              case 3:
                cornerCell = this.gridInfo.find(elem=> elem.number.x === plyr.currentPosition.cell.number.x-rng && elem.number.y === plyr.currentPosition.cell.number.y+rng)
                whichCorner = 'southWest';
              break;
              case 4:
                cornerCell = this.gridInfo.find(elem=> elem.number.x === plyr.currentPosition.cell.number.x+rng && elem.number.y === plyr.currentPosition.cell.number.y-rng)
                whichCorner = 'northEast';
              break;
            }

          }

          if (cornerCell) {
            // console.log('cornerCell',cornerCell.number);

            for (var i = 0; i < span; i++) {

              let startCell;
              switch(whichCorner) {
                case 'southEast':
                  startCell = {
                    x: cornerCell.number.x-i,
                    y: cornerCell.number.y
                  }
                break;
                case 'northEast':
                  startCell = {
                    x: cornerCell.number.x-i,
                    y: cornerCell.number.y
                  }
                break;
                case 'southWest':
                  startCell = {
                    x: cornerCell.number.x+i,
                    y: cornerCell.number.y
                  }
                break;
                case 'northWest':
                  startCell = {
                    x: cornerCell.number.x+i,
                    y: cornerCell.number.y
                  }
                break;
              }
              // console.log('startCell',startCell,i);

              for (var j = 0; j < span; j++) {
                let cell;

                switch(whichCorner) {
                  case 'southEast':
                    cell = {
                      x: startCell.x,
                      y: startCell.y-j,
                    }
                  break;
                  case 'northEast':
                    cell = {
                      x: startCell.x,
                      y: startCell.y+j,
                    }
                  break;
                  case 'southWest':
                    cell = {
                      x: startCell.x,
                      y: startCell.y-j,
                    }
                  break;
                  case 'northWest':
                    cell = {
                      x: startCell.x,
                      y: startCell.y+j,
                    }
                  break;
                }
                // console.log('cell',cell,j);


                if (
                  cell.x <= this.gridWidth && cell.x >= 0 &&
                  cell.y <= this.gridWidth && cell.y >= 0
                ) {
                  // console.log(aiPlayer.ai.mission,'avoid cell ',cell);
                  this.easyStar.avoidAdditionalPoint(cell.x, cell.y);
                }

              }
            }

          }

        }
      }

       // AVOID DEBUFFS!!
       if (aiPlayer.ai.mission === 'retrieve') {


         let fieldItemScan = []
         for (const cell of this.gridInfo) {
           if (cell.item.name !== '') {
             fieldItemScan.push({
               name: cell.item.name,
               type: cell.item.type,
               subType: cell.item.subType,
               effect: cell.item.effect,
               location: {x: cell.number.x, y: cell.number.y}
             })
           }
         }


         let nerfItemPositions = [];
         for (const item of fieldItemScan) {

           switch(item.name) {
             case 'moveSpeedDown':
               nerfItemPositions.push(item)
             break;
             case 'hpDown':
               nerfItemPositions.push(item)
             break;
             case 'focusDown':
               nerfItemPositions.push(item)
             break;
             case 'strengthDown':
               nerfItemPositions.push(item)
             break;
           }

         };

         for (const nerf of nerfItemPositions) {

           this.easyStar.avoidAdditionalPoint(nerf.location.x, nerf.location.y);

         }

       }

       // TERRAIN & OBSTACLE CELLS TO AVOID
       for (const cell2 of this.gridInfo) {
         let terrainInfo3 = cell2.levelData.length-1;
         if (
           cell2.levelData.split('_')[1] !== '*' ||
           cell2.terrain.type === 'deep' ||
           cell2.terrain.type === 'hazard' ||
           // cell2.barrier.state === true ||
           cell2.void.state === true
         ) {
           this.easyStar.avoidAdditionalPoint(cell2.number.x, cell2.number.y);
         }
       }


       // FIND PATH!
       this.players[aiPlayer.number-1].ai.easyStarPath = this.easyStar.findPath(aiPos.x, aiPos.y, targetPos.x, targetPos.y, function( path ) {
         if (path === null) {
           cancelPath = true;
           console.log("Path was not found...for player",aiPlayer.number);
         } else {
           pathSet = path;
         }
       });

       this.easyStar.setIterationsPerCalculation(4000)
       this.easyStar.calculate();
       setTimeout(()=>{
         // console.log('plyr',aiPlayer.number,'pathSet',pathSet,this.players[aiPlayer.number-1].ai.easyStarPath);

         if (cancelPath === true) {
           console.log('cancel path');
           this.easyStar = new Easystar.js();
           this.players[aiPlayer.number-1].ai.targetAcquired = false;
         }
         this.aiParsePath(pathSet,aiPlayer.number);
       }, 50);


    }

    if (targetPlayer) {
      if (getPath === true && targetPlayer.dead.state !== true && targetPlayer.falling.state !== true) {
        console.log('pathfinding...');
        this.updatePathArray();
        this.easyStar = new Easystar.js();

        let aiPos;
        let targetPos;

        if (aiPlayer.ai.mission === 'pursue') {
          aiPos = aiPlayer.currentPosition.cell.number;
          targetPos = this.players[aiPlayer.ai.targetPlayer.number-1].currentPosition.cell.number;
          console.log('pursuit target ',targetPos);

          if (aiPlayer.ai.safeRange === true) {


            let candidateTargets = [
              {x: 0, y: 0},
              {x: 0, y: 0},
              {x: 0, y: 0},
              {x: 0, y: 0},
            ]

            if (aiPlayer.currentWeapon.type === "crossbow") {
               // candidateTargets = [
               //   {x: targetPos.x-6, y: targetPos.y},
               //   {x: targetPos.x+6, y: targetPos.y},
               //   {x: targetPos.x, y: targetPos.y+6},
               //   {x: targetPos.x, y: targetPos.y-6},
               // ]
               let range = aiPlayer.ai.pathfindingRanges.crossbow
               candidateTargets = [
                 {x: targetPos.x-range, y: targetPos.y},
                 {x: targetPos.x+range, y: targetPos.y},
                 {x: targetPos.x, y: targetPos.y+range},
                 {x: targetPos.x, y: targetPos.y-range},
               ]

               // console.log('candidateTargets',candidateTargets);

               let freeSpaces = [];

               for (const rangeElem of candidateTargets)  {
                 let indx = candidateTargets.findIndex(rng => rng.x === rangeElem.x && rng.y === rangeElem.y)

                 let pursuitTargetRef = this.gridInfo.find(elem => elem.number.x === rangeElem.x && elem.number.y === rangeElem.y)

                 if (!pursuitTargetRef) {
                  // console.log('range element is  out of bounds',rangeElem,'indx',indx);
                 } else {

                   let rangeElemCells2 = [];

                   // DON'T fire from obstructed position
                   // this.cellsToHighlight.push(rangeElem)


                   let dirToFire;
                   let diff = 0;
                   if (rangeElem.x === targetPos.x && rangeElem.y > targetPos.y) {
                    dirToFire = 'north';
                    diff = rangeElem.y - targetPos.y;
                    for (var i = 0; i < diff; i++) {
                      rangeElemCells2.push({x:rangeElem.x, y: rangeElem.y - i})
                      // this.cellsToHighlight.push({x:rangeElem.x, y: rangeElem.y - i})
                    }
                   }
                   if (rangeElem.x > targetPos.x && rangeElem.y === targetPos.y) {
                    dirToFire = 'west';
                    diff = rangeElem.x - targetPos.x;
                    for (var i = 0; i < diff; i++) {
                      rangeElemCells2.push({x:rangeElem.x - i, y: rangeElem.y})
                      // this.cellsToHighlight.push({x:rangeElem.x - i, y: rangeElem.y})
                    }
                   }
                   if (rangeElem.x === targetPos.x && rangeElem.y < targetPos.y) {
                    dirToFire = 'south';
                    diff = targetPos.y - rangeElem.y;
                    for (var i = 0; i < diff; i++) {
                      rangeElemCells2.push({x:rangeElem.x, y: rangeElem.y + i})
                      // this.cellsToHighlight.push({x:rangeElem.x, y: rangeElem.y + i})
                    }
                   }
                   if (rangeElem.x < targetPos.x && rangeElem.y === targetPos.y) {
                    dirToFire = 'east';
                    diff = targetPos.x - rangeElem.x;
                    for (var i = 0; i < diff; i++) {
                      rangeElemCells2.push({x:rangeElem.x + i, y: rangeElem.y})
                      // this.cellsToHighlight.push({x:rangeElem.x + i, y: rangeElem.y})
                    }
                   }
                   else {
                     // console.log('exception! rangeElem,targetPos',rangeElem,targetPos);
                   }


                   // let rangeElemCells = [];
                   // switch(indx) {
                   //   case 0:
                   //     rangeElemCells = [
                   //       // {x:rangeElem - 5, y: rangeElem.y },
                   //       {x:rangeElem.x - 4, y: rangeElem.y },
                   //       {x:rangeElem.x - 3, y: rangeElem.y },
                   //       {x:rangeElem.x - 2, y: rangeElem.y },
                   //       {x:rangeElem.x - 1, y: rangeElem.y },
                   //     ]
                   //   break;
                   //   case 1:
                   //     rangeElemCells = [
                   //       // {x:rangeElem + 5, y: rangeElem.y },
                   //       {x:rangeElem.x + 4, y: rangeElem.y },
                   //       {x:rangeElem.x + 3, y: rangeElem.y },
                   //       {x:rangeElem.x + 2, y: rangeElem.y },
                   //       {x:rangeElem.x + 1, y: rangeElem.y },
                   //     ]
                   //   break;
                   //   case 2:
                   //     rangeElemCells = [
                   //       // {x:rangeElem, y: rangeElem.y + 5},
                   //       {x:rangeElem.x, y: rangeElem.y + 4},
                   //       {x:rangeElem.x, y: rangeElem.y + 3},
                   //       {x:rangeElem.x, y: rangeElem.y + 2},
                   //       {x:rangeElem.x, y: rangeElem.y + 1},
                   //     ]
                   //   break;
                   //   case 3:
                   //     rangeElemCells = [
                   //       // {x:rangeElem, y: rangeElem.y - 5},
                   //       {x:rangeElem.x, y: rangeElem.y - 4},
                   //       {x:rangeElem.x, y: rangeElem.y - 3},
                   //       {x:rangeElem.x, y: rangeElem.y - 2},
                   //       {x:rangeElem.x, y: rangeElem.y - 1},
                   //     ]
                   //   break;
                   //   // case 4:
                   //   //   rangeElemCells = [
                   //   //     {x:rangeElem, y: rangeElem.y - 5},
                   //   //     {x:rangeElem, y: rangeElem.y - 4},
                   //   //     {x:rangeElem, y: rangeElem.y - 3},
                   //   //     {x:rangeElem, y: rangeElem.y - 2},
                   //   //     {x:rangeElem, y: rangeElem.y - 1},
                   //   //   ]
                   //   // break;
                   // }

                   // IS FIRE POSITION FREE?
                   let rngElCellFree = true;
                   let cellRef3 = this.gridInfo.find(elema => elema.number.x === rangeElem.x && elema.number.y === rangeElem.y)
                   if (cellRef3) {
                     if (
                       cellRef3.levelData.charAt(0) ===  'z' ||
                       cellRef3.levelData.charAt(0) ===  'y' ||
                       cellRef3.terrain.type ===  'deep' ||
                       cellRef3.terrain.type ===  'hazard'
                     ) {
                       rngElCellFree = false;
                     } else {

                     }
                   } else if (!cellRef3) {
                     rngElCellFree = false;
                   }


                   let clearToShoot = false;
                   // IS SIGHT OBSTRUCTED?
                   if (rngElCellFree === true) {


                     let obstructions = [];
                     for (const cellx of rangeElemCells2) {

                       let cellRef4 = this.gridInfo.find(elemb => elemb.number.x === cellx.x && elemb.number.y === cellx.y)

                       if (
                         cellRef4.levelData.charAt(0) ===  'y' ||
                         cellRef4.levelData.charAt(0) ===  'z'
                       ) {
                         // clearToShoot = false;
                         obstructions.push(cellx)
                       }
                       if (
                         cellRef4.levelData.charAt(0) !==  'y' &&
                         cellRef4.levelData.charAt(0) !==  'z'
                       ) {
                         // clearToShoot = true;
                         // obstructions.push(cellx)
                       }
                     }

                     // if (clearToShoot === true) {
                     if (obstructions.length === 0) {

                       freeSpaces.push(rangeElem)
                       // this.cellsToHighlight = rangeElemCells2;
                       // console.log('rangeElemCells2',rangeElemCells2);
                       // console.log('found path to safe bow range',targetPos);
                     } else {
                       // console.log('target obstructed @',obstructions);
                     }
                   } else {
                     console.log('your safe path is blocked');
                   }

                 }
               }

               if (freeSpaces[0]) {
                 // console.log('freeSpaces',freeSpaces);
                 targetPos = freeSpaces[0];
                 // console.log('found path to safe bow range',targetPos);
               } else {
                 console.log('No free or unobstructed firing positions at this distance for crossbow');
                 if (aiPlayer.ai.pathfindingRanges.crossbow > 1) {
                   aiPlayer.ai.pathfindingRanges.crossbow--
                 }
                 aiPlayer.ai.safeRange = false;
                 aiPlayer.ai.targetAcquired = false;


                 let fieldItemScan = []
                 for (const cell of this.gridInfo) {
                   if (cell.item.name !== '') {
                     fieldItemScan.push({
                       name: cell.item.name,
                       type: cell.item.type,
                       subType: cell.item.subType,
                       effect: cell.item.effect,
                       location: {x: cell.number.x, y: cell.number.y}
                     })
                   }
                 }
                 if (
                   fieldItemScan.find(x=>x.type === 'spear') ||
                   fieldItemScan.find(x=>x.type === 'sword')
                 ) {
                   aiPlayer.ai.upgradeWeapon = true;
                   aiPlayer.ai.organizing.weaponPriorityIndex = 1;
                 } else {
                   aiPlayer.currentWeapon = {
                     name: '',
                     type: '',
                     effect: ''
                   }
                   console.log('no crossbow fire position or other gear in the field. switching to unarmed');
                 }

               }

            }

            if (aiPlayer.currentWeapon.type === "spear") {

              let range = aiPlayer.ai.pathfindingRanges.spear
              candidateTargets = [
                {x: targetPos.x-range, y: targetPos.y},
                {x: targetPos.x+range, y: targetPos.y},
                {x: targetPos.x, y: targetPos.y+range},
                {x: targetPos.x, y: targetPos.y-range},
              ]

              // for (const rangeElem of candidateTargets)  {
              //   let indx = candidateTargets.findIndex(rng => rng.x === rangeElem.x && rng.y === rangeElem.y)
              //
              //   let pursuitTargetRef = this.gridInfo.find(elem => elem.number.x === rangeElem.x && elem.number.y === rangeElem.y)
              //
              //   if (!pursuitTargetRef) {
              //    // console.log('range element is out of bounds');
              //   } else {
              //
              //
              //     let rangeElemCells;
              //
              //     switch(indx) {
              //       case 0:
              //         rangeElemCells = [
              //           {x:rangeElem - 2, y: rangeElem.y },
              //           {x:rangeElem - 1, y: rangeElem.y },
              //         ]
              //       break;
              //       case 1:
              //         rangeElemCells = [
              //           {x:rangeElem + 2, y: rangeElem.y },
              //           {x:rangeElem + 1, y: rangeElem.y },
              //         ]
              //       break;
              //       case 2:
              //         rangeElemCells = [
              //           {x:rangeElem, y: rangeElem.y + 2},
              //           {x:rangeElem, y: rangeElem.y + 1},
              //         ]
              //       break;
              //       case 3:
              //         rangeElemCells = [
              //           {x:rangeElem, y: rangeElem.y - 2},
              //           {x:rangeElem, y: rangeElem.y - 1},
              //         ]
              //       break;
              //     }
              //
              //     let rngElCellFree = true;
              //     for (const rngElCell of rangeElemCells) {
              //
              //       for (const plyr of this.players) {
              //         if (plyr.currentPosition.cell.number.x === rngElCell.x && plyr.currentPosition.cell.number.y === rngElCell.y) {
              //           rngElCellFree = false;
              //         }
              //         let cellRef3 = this.gridInfo.find(elema => elema.number.x === rngElCell.x && elema.number.y === rngElCell.y)
              //         if (cellRef3) {
              //           if (
              //             cellRef3.levelData.charAt(0) ===  'z' ||
              //             cellRef3.levelData.charAt(0) ===  'y' ||
              //             cellRef3.terrain.type ===  'deep' ||
              //             cellRef3.terrain.type ===  'hazard'
              //           ) {
              //             rngElCellFree = false;
              //           }
              //         }
              //
              //       }
              //     }
              //     if (rngElCellFree === true) {
              //       targetPos = rangeElem;
              //       // console.log('found path to safe spear range');
              //     } else {
              //       console.log('your safe path is blocked');
              //     }
              //   }
              // }

              let freeSpaces = [];

              for (const rangeElem of candidateTargets)  {
                // this.cellsToHighlight.push({x:rangeElem.x, y: rangeElem.y})
                let indx = candidateTargets.findIndex(rng => rng.x === rangeElem.x && rng.y === rangeElem.y)

                let pursuitTargetRef = this.gridInfo.find(elem => elem.number.x === rangeElem.x && elem.number.y === rangeElem.y)

                if (!pursuitTargetRef) {
                 // console.log('range element is  out of bounds',rangeElem,'indx',indx);
                } else {

                  let rangeElemCells2 = [];


                  let dirToFire;
                  let diff = 0;
                  if (rangeElem.x === targetPos.x && rangeElem.y > targetPos.y) {
                   dirToFire = 'north';
                   diff = rangeElem.y - targetPos.y;
                   for (var i = 0; i < diff; i++) {
                     rangeElemCells2.push({x:rangeElem.x, y: rangeElem.y - i})
                     // this.cellsToHighlight.push({x:rangeElem.x, y: rangeElem.y - i})
                   }
                  }
                  if (rangeElem.x > targetPos.x && rangeElem.y === targetPos.y) {
                   dirToFire = 'west';
                   diff = rangeElem.x - targetPos.x;
                   for (var i = 0; i < diff; i++) {
                     rangeElemCells2.push({x:rangeElem.x - i, y: rangeElem.y})
                     // this.cellsToHighlight.push({x:rangeElem.x - i, y: rangeElem.y})
                   }
                  }
                  if (rangeElem.x === targetPos.x && rangeElem.y < targetPos.y) {
                   dirToFire = 'south';
                   diff = targetPos.y - rangeElem.y;
                   for (var i = 0; i < diff; i++) {
                     rangeElemCells2.push({x:rangeElem.x, y: rangeElem.y + i})
                     // this.cellsToHighlight.push({x:rangeElem.x, y: rangeElem.y + i})
                   }
                  }
                  if (rangeElem.x < targetPos.x && rangeElem.y === targetPos.y) {
                   dirToFire = 'east';
                   diff = targetPos.x - rangeElem.x;
                   for (var i = 0; i < diff; i++) {
                     rangeElemCells2.push({x:rangeElem.x + i, y: rangeElem.y})
                     // this.cellsToHighlight.push({x:rangeElem.x + i, y: rangeElem.y})
                   }
                  }
                  else {
                    // console.log('exception! rangeElem,targetPos',rangeElem,targetPos);
                  }

                  // IS attack POSITION FREE?
                  let rngElCellFree = true;
                  let cellRef3 = this.gridInfo.find(elema => elema.number.x === rangeElem.x && elema.number.y === rangeElem.y)
                  if (cellRef3) {
                    if (
                      cellRef3.levelData.charAt(0) ===  'z' ||
                      cellRef3.levelData.charAt(0) ===  'y' ||
                      cellRef3.terrain.type ===  'deep' ||
                      cellRef3.terrain.type ===  'hazard'
                    ) {
                      rngElCellFree = false;
                    } else {

                    }
                  } else if (!cellRef3) {
                    rngElCellFree = false;
                  }


                  let clearToShoot = false;
                  // IS SIGHT OBSTRUCTED?
                  if (rngElCellFree === true) {


                    let obstructions = [];
                    for (const cellx of rangeElemCells2) {

                      let cellRef4 = this.gridInfo.find(elemb => elemb.number.x === cellx.x && elemb.number.y === cellx.y)

                      if (
                        cellRef4.levelData.charAt(0) ===  'y' ||
                        cellRef4.levelData.charAt(0) ===  'z'
                      ) {
                        // clearToShoot = false;
                        obstructions.push(cellx)
                      }
                      if (
                        cellRef4.levelData.charAt(0) !==  'y' &&
                        cellRef4.levelData.charAt(0) !==  'z'
                      ) {
                        // clearToShoot = true;
                        // obstructions.push(cellx)
                      }
                    }

                    // if (clearToShoot === true) {
                    if (obstructions.length === 0) {

                      freeSpaces.push(rangeElem)
                      // this.cellsToHighlight = rangeElemCells2;
                      // console.log('rangeElemCells2',rangeElemCells2);
                      // console.log('found path to safe bow range',targetPos);
                    } else {
                      console.log('target obstructed @',obstructions);
                    }
                  } else {
                    console.log('your safe path is blocked');
                  }

                }
              }

              if (freeSpaces[0]) {
                // console.log('freeSpaces',freeSpaces);
                targetPos = freeSpaces[0];
                // console.log('found path to safe spear range',targetPos);
              } else {
                console.log('No free or unobstructed firing positions at this distance for spear');
                if (aiPlayer.ai.pathfindingRanges.spear > 1) {
                  aiPlayer.ai.pathfindingRanges.spear--
                }
                aiPlayer.ai.safeRange = false;
                aiPlayer.ai.targetAcquired = false;
              }

            }
            if (aiPlayer.currentWeapon.type === "sword" || aiPlayer.currentWeapon.name === "") {
              candidateTargets = [
                {x: targetPos.x-2, y: targetPos.y},
                {x: targetPos.x+2, y: targetPos.y},
                {x: targetPos.x, y: targetPos.y+2},
                {x: targetPos.x, y: targetPos.y-2},
              ]

              for (const rangeElem of candidateTargets)  {
                let indx = candidateTargets.findIndex(rng => rng.x === rangeElem.x && rng.y === rangeElem.y)

                let pursuitTargetRef = this.gridInfo.find(elem => elem.number.x === rangeElem.x && elem.number.y === rangeElem.y)

                if (!pursuitTargetRef) {
                 // console.log('range element is out of bounds');
                } else {
                  let rangeElemCells;

                  switch(indx) {
                    case 0:
                      rangeElemCells = [
                        {x:rangeElem - 1, y: rangeElem.y },
                      ]
                    break;
                    case 1:
                      rangeElemCells = [
                        {x:rangeElem + 1, y: rangeElem.y },
                      ]
                    break;
                    case 2:
                      rangeElemCells = [
                        {x:rangeElem, y: rangeElem.y + 1},
                      ]
                    break;
                    case 3:
                      rangeElemCells = [
                        {x:rangeElem, y: rangeElem.y - 1},
                      ]
                    break;
                  }

                  let rngElCellFree = true;
                  for (const rngElCell of rangeElemCells) {

                    for (const plyr of this.players) {
                      if (plyr.currentPosition.cell.number.x === rngElCell.x && plyr.currentPosition.cell.number.y === rngElCell.y) {
                        rngElCellFree = false;
                      }
                      let cellRef3 = this.gridInfo.find(elema => elema.number.x === rngElCell.x && elema.number.y === rngElCell.y)
                      if (cellRef3) {
                        if (
                          cellRef3.levelData.charAt(0) ===  'z' ||
                          cellRef3.levelData.charAt(0) ===  'y' ||
                          cellRef3.terrain.type ===  'deep' ||
                          cellRef3.terrain.type ===  'hazard'
                        ) {
                          rngElCellFree = false;
                        }
                      }

                    }
                  }
                  if (rngElCellFree === true) {
                    targetPos = rangeElem;
                    // console.log('found path to safe sword range',targetPos);
                  } else {
                    console.log('your safe path is blocked');
                  }
                }
              }

            }

          }

          // this.pathArray[targetPos.x][targetPos.y] = 0;
          // this.pathArray[aiPos.x][aiPos.y] = 0;
        }
        if (aiPlayer.ai.mission === 'patrol') {

          aiPos = aiPlayer.currentPosition.cell.number;
          targetPos = patrolDest;

          // this.pathArray[targetPos.x][targetPos.y] = 0;
        }
        if (aiPlayer.ai.mission === 'engage') {

        }
        if (aiPlayer.ai.mission === 'defend') {

          aiPos = aiPlayer.currentPosition.cell.number;
          targetPos = defendDest;

          console.log('pathfinding targetPos',targetPos);
          // this.pathArray[targetPos.x][targetPos.y] = 0;
        }
        if (aiPlayer.ai.mission === 'retreat') {
          // console.log('get retreat path',aiPlayer.ai.retreating.point);
          aiPos = aiPlayer.currentPosition.cell.number;
          targetPos = {
            x: aiPlayer.ai.retreating.point.x,
            y: aiPlayer.ai.retreating.point.y,
          }
        }
        if (aiPlayer.ai.mission === 'retrieve') {
          console.log('get retrive path',aiPlayer.ai.retrieving.point);
          aiPos = aiPlayer.currentPosition.cell.number;
          targetPos = {
            x: aiPlayer.ai.retrieving.point.x,
            y: aiPlayer.ai.retrieving.point.y,
          }
        }


        this.easyStar.setGrid(this.pathArray);
        this.easyStar.setAcceptableTiles([0]);


        // PLAYER CELLS TO AVOID
        for (const plyr of this.players) {
          // console.log('building pathfind obstacles checking plyr',plyr.number);
          if (plyr.dead.state !== true && plyr.falling.state !== true && plyr.respawn !== true && plyr.number !== aiPlayer.number && plyr.number !== targetPlayer.number) {
            // console.log('avoid plyr',plyr.number,'@',plyr.currentPosition.cell.number.x, plyr.currentPosition.cell.number.y);
            this.easyStar.avoidAdditionalPoint(plyr.currentPosition.cell.number.x, plyr.currentPosition.cell.number.y);
          }
        }

        // AVOID PATHS THAT GO CLOSE TO ENEMY PLAYERS
        if (aiPlayer.ai.mission === 'retreat' || aiPlayer.ai.mission === 'retrieve') {

          for (const plyr of this.players) {
            if (plyr.ai.state !== true) {
              console.log(aiPlayer.ai.mission,' careful pathfinding. enemy is plyr #',plyr.number);
              let rng;
              let span;

              if (plyr.currentWeapon.type === "sword" || plyr.currentWeapon.name === "") {
                rng = 1;
              }
              else {
                rng = 2;
              }
              span = (rng*2)+1;
              let cornerCell = undefined;
              let whichCorner;

              while (!cornerCell) {

                let whichCorner2 = this.rnJesus(1,4)

                switch(whichCorner2) {
                  case 1:
                    cornerCell = this.gridInfo.find(elem=> elem.number.x === plyr.currentPosition.cell.number.x+rng && elem.number.y === plyr.currentPosition.cell.number.y+rng)
                    whichCorner = 'southEast';
                  break;
                  case 2:
                    cornerCell = this.gridInfo.find(elem=> elem.number.x === plyr.currentPosition.cell.number.x-rng && elem.number.y === plyr.currentPosition.cell.number.y-rng)
                    whichCorner = 'northWest';
                  break;
                  case 3:
                    cornerCell = this.gridInfo.find(elem=> elem.number.x === plyr.currentPosition.cell.number.x-rng && elem.number.y === plyr.currentPosition.cell.number.y+rng)
                    whichCorner = 'southWest';
                  break;
                  case 4:
                    cornerCell = this.gridInfo.find(elem=> elem.number.x === plyr.currentPosition.cell.number.x+rng && elem.number.y === plyr.currentPosition.cell.number.y-rng)
                    whichCorner = 'northEast';
                  break;
                }

              }


              if (cornerCell) {
                // console.log('cornerCell',cornerCell.number);

                for (var i = 0; i < span; i++) {

                  let startCell;
                  switch(whichCorner) {
                    case 'southEast':
                      startCell = {
                        x: cornerCell.number.x-i,
                        y: cornerCell.number.y
                      }
                    break;
                    case 'northEast':
                      startCell = {
                        x: cornerCell.number.x-i,
                        y: cornerCell.number.y
                      }
                    break;
                    case 'southWest':
                      startCell = {
                        x: cornerCell.number.x+i,
                        y: cornerCell.number.y
                      }
                    break;
                    case 'northWest':
                      startCell = {
                        x: cornerCell.number.x+i,
                        y: cornerCell.number.y
                      }
                    break;
                  }
                  // console.log('startCell',startCell,i);

                  for (var j = 0; j < span; j++) {
                    let cell;

                    switch(whichCorner) {
                      case 'southEast':
                        cell = {
                          x: startCell.x,
                          y: startCell.y-j,
                        }
                      break;
                      case 'northEast':
                        cell = {
                          x: startCell.x,
                          y: startCell.y+j,
                        }
                      break;
                      case 'southWest':
                        cell = {
                          x: startCell.x,
                          y: startCell.y-j,
                        }
                      break;
                      case 'northWest':
                        cell = {
                          x: startCell.x,
                          y: startCell.y+j,
                        }
                      break;
                    }
                    // console.log('cell',cell,j);


                    if (
                      cell.x <= this.gridWidth && cell.x >= 0 &&
                      cell.y <= this.gridWidth && cell.y >= 0
                    ) {
                      // console.log(aiPlayer.ai.mission,'avoid cell ',cell);
                      this.easyStar.avoidAdditionalPoint(cell.x, cell.y);
                    }

                  }
                }

              }

            }
          }



         // AVOID DEBUFFS!!
         if (aiPlayer.ai.mission === 'retrive') {


           let fieldItemScan = []
           for (const cell of this.gridInfo) {
             if (cell.item.name !== '') {
               fieldItemScan.push({
                 name: cell.item.name,
                 type: cell.item.type,
                 subType: cell.item.subType,
                 effect: cell.item.effect,
                 location: {x: cell.number.x, y: cell.number.y}
               })
             }
           }


           let nerfItemPositions = [];
           for (const item of fieldItemScan) {

             switch(item.name) {
               case 'moveSpeedDown':
                 nerfItemPositions.push(item)
               break;
               case 'hpDown':
                 nerfItemPositions.push(item)
               break;
               case 'focusDown':
                 nerfItemPositions.push(item)
               break;
               case 'strengthDown':
                 nerfItemPositions.push(item)
               break;
             }

           };

           for (const nerf of nerfItemPositions) {

             this.easyStar.avoidAdditionalPoint(nerf.location.x, nerf.location.y);

           }

         }

        }


        // '**_*_0.0_a_0**'
        // barrierType(a,b,c)BarrierPosition(n,s,e,w)_obstacle_x.y_terrain_elevationNumber(0,1,2)ElevationType(a,b,c)ElevationPosition(n,s,e,w)


        // TERRAIN & OBSTACLE CELLS TO AVOID
        for (const cell2 of this.gridInfo) {
          let terrainInfo3 = cell2.levelData.length-1;
          if (
            cell2.levelData.split('_')[1] !== '*' ||
            cell2.terrain.type === 'deep' ||
            cell2.terrain.type === 'hazard' ||
            // cell2.barrier.state === true ||
            cell2.void.state === true
          ) {
            this.easyStar.avoidAdditionalPoint(cell2.number.x, cell2.number.y);
          }
        }


        // FIND PATH!
        this.players[aiPlayer.number-1].ai.easyStarPath = this.easyStar.findPath(aiPos.x, aiPos.y, targetPos.x, targetPos.y, function( path ) {
          if (path === null) {
            cancelPath = true;
            console.log("Path was not found...for player",aiPlayer.number);
          } else {
            pathSet = path;
          }
        });

        this.easyStar.setIterationsPerCalculation(4000)
        this.easyStar.calculate();
        setTimeout(()=>{
          // console.log('plyr',aiPlayer.number,'pathSet',pathSet,this.players[aiPlayer.number-1].ai.easyStarPath);

          if (cancelPath === true) {
            console.log('cancel path');
            this.easyStar = new Easystar.js();
            this.players[aiPlayer.number-1].ai.targetAcquired = false;
          }
          this.aiParsePath(pathSet,aiPlayer.number);
        }, 50);

      }
    }


    this.players[aiPlayer.number-1] = aiPlayer;

    this.aiAct(aiPlayer);

  }
  aiParsePath = (path,aiPlayer) => {
    // console.log('parsing path',path);


    let instructions = [];
    let init = true;
    let initDirection = this.players[aiPlayer-1].direction;
    let direction;

    if (this.players[aiPlayer-1].ai.mission !== 'patrol' && this.players[aiPlayer-1].ai.mission !== 'defend') {
      if (this.players[aiPlayer-1].ai.safeRange !== true) {
        path.pop();
      }

      // if (path.length > 1) {
      //   path.pop();
      // }
    }
    if (this.players[aiPlayer-1].ai.mission === 'patrol') {
      // if (path.length > 2) {
      //   path.pop();
      // }
    }
    // if (path.length > 1) {
    //   path.pop();
    // }
    // path.pop();

    for (const [key, value] of Object.entries(path)) {

        let currentCell = path[key-1];
        let nextCell = path[key];
        // console.log(key-1,'currentCell',currentCell,'nextCell',nextCell);
        if (currentCell) {

          let oldDirection = direction;
          let newDirection;
          if (init === true) {
            oldDirection = initDirection;
            init = false;
          }

          if (
            nextCell.x === currentCell.x &&
            nextCell.y === currentCell.y-1
          ) {
            newDirection = 'north'
          }
          if (
            nextCell.x === currentCell.x &&
            nextCell.y === currentCell.y+1
          ) {
            newDirection = 'south'
          }
          if (
            nextCell.x === currentCell.x-1 &&
            nextCell.y === currentCell.y
          ) {
            newDirection = 'west'
          }
          if (
            nextCell.x === currentCell.x+1 &&
            nextCell.y === currentCell.y
          ) {
            newDirection = 'east'
          }

          if (oldDirection === newDirection) {

            if (this.players[aiPlayer-1].ai.mission === 'patrol' && this.players[aiPlayer-1].ai.patrolling.checkin !== 'enroute') {
              instructions.push(
                {
                  keyword: 'move_'+newDirection,
                  count: 0,
                  limit: 1,
                },
                {
                  keyword: 'long_wait',
                  count: 0,
                  limit: 25,
                }
              )
            } else {
              instructions.push(
                {
                  keyword: 'move_'+newDirection,
                  count: 0,
                  limit: 1,
                }
              )
            }
          }
          if (oldDirection !== newDirection) {
            if (this.players[aiPlayer-1].ai.mission === 'patrol' && this.players[aiPlayer-1].ai.patrolling.checkin !== 'enroute') {
              instructions.push(
                {
                  keyword: 'move_'+newDirection,
                  count: 0,
                  limit: 1,
                },
                {
                  keyword: 'long_wait',
                  count: 0,
                  limit: 25,
                },
                {
                  keyword: 'move_'+newDirection,
                  count: 0,
                  limit: 1,
                },
                {
                  keyword: 'long_wait',
                  count: 0,
                  limit: 25,
                },
              )
            }
            else {
              instructions.push(
                {
                  keyword: 'move_'+newDirection,
                  count: 0,
                  limit: 1,
                },
                {
                  keyword: 'move_'+newDirection,
                  count: 0,
                  limit: 1,
                }
              )
            }
          }

          direction = newDirection;

        }

    }
    // instructions.shift();
    // instructions.pop();

    // console.log('this.pathArray',this.pathArray);
    // console.log('path',path,'player',aiPlayer);
    // console.log('parse path instructions',instructions);

    // console.log('player',aiPlayer,this.players[aiPlayer-1].ai.currentInstruction,'mission',this.players[aiPlayer-1].ai.mission,'instructions',instructions);
    // if (this.players[aiPlayer-1].ai.mission === 'retreat') {
    //   console.log('retreat instructions',instructions,'player',aiPlayer,this.players[aiPlayer-1].ai.currentInstruction,'path',path);
    // }
    if (this.players[aiPlayer-1].ai.mission === 'retrieve') {
      console.log('retrieve instructions',instructions,'player',aiPlayer,this.players[aiPlayer-1].ai.currentInstruction,'path',path);
    }


    this.players[aiPlayer-1].ai.pathArray = path;
    this.players[aiPlayer-1].ai.instructions = instructions;
    this.players[aiPlayer-1].ai.currentInstruction = 0;

  }
  aiAct = (plyr) => {


    let currentInstruction = plyr.ai.instructions[plyr.ai.currentInstruction];

    if (currentInstruction) {
      let targetCell = this.gridInfo.find(elem => elem.number.x === plyr.target.cell1.number.x && elem.number.y === plyr.target.cell1.number.y)
      let playerCell = this.gridInfo.find(elem => elem.number.x === plyr.currentPosition.cell.number.x && elem.number.y === plyr.currentPosition.cell.number.y)

      let pathIndx = plyr.ai.pathArray.findIndex(elem => elem.x === plyr.currentPosition.cell.number.x && elem.y === plyr.currentPosition.cell.number.y);
      let currentPathStep = plyr.ai.pathArray[pathIndx]
      let nextPathStep = plyr.ai.pathArray[pathIndx+1]
      let nextPathStepCell = undefined;
      if (nextPathStep) {
        nextPathStepCell = this.gridInfo.find(elem => elem.number.x === nextPathStep.x && elem.number.y === nextPathStep.y)
      }

      // console.log('total instructions',plyr.ai.instructions.length,'currentInstruction',plyr.ai.currentInstruction,plyr.moving.state, !plyr.turning.state,'keyword',currentInstruction.keyword,'limit',currentInstruction.limit,'instructions',plyr.ai.instructions,'deflected',plyr.success.deflected.state);
      // console.log('ai act',plyr.ai.currentInstruction,currentInstruction,'mission',plyr.ai.mission,'instructions',plyr.ai.instructions,'newMoveDelay.state',plyr.newMoveDelay.state);


      this.keyPressed[plyr.number-1] = {
        north: false,
        south: false,
        east: false,
        west: false,
        northEast: false,
        northWest: false,
        southEast: false,
        southWest: false,
        attack: false,
        defend: false,
        strafe: false,
        cycleWeapon: false,
        cycleArmor: false,
        dodge: false,
        menu: false,
      };

      switch(currentInstruction.keyword) {

        case 'short_wait':
        // console.log('ai act -- short_wait');
          currentInstruction.limit = 15;
          if (currentInstruction.count < currentInstruction.limit) {
            currentInstruction.count++;
          } else if (currentInstruction.count >= currentInstruction.limit) {
            plyr.ai.currentInstruction++;
          }
        break;
        case 'long_wait':
        // console.log('ai act -- long_wait');
          currentInstruction.limit = 25;
          if (currentInstruction.count < currentInstruction.limit) {
            currentInstruction.count++;
          } else if (currentInstruction.count >= currentInstruction.limit) {
            plyr.ai.currentInstruction++;
          }
        break;
        case 'move_north':
        // console.log('ai act -- move_north');
          if (plyr.newMoveDelay.state !== true && plyr.moving.state !== true && !plyr.turning.state && plyr.success.deflected.state !== true && plyr.action === 'idle') {

            let inDanger = false;
            if (plyr.direction === 'north') {
              if (!targetCell) {
                // console.log('heading off the edge');
                inDanger = true;
              } else {
                if (targetCell.void.state === true || targetCell.terrain.type === 'deep' || targetCell.terrain.type === 'hazard') {
                  // console.log('heading for mid-grid danger',targetCell.number);
                  inDanger = true;
                }
              }
            }

            if (inDanger === false) {
              // console.log('safe: move_north');
              // currentInstruction.limit = 1;
              this.keyPressed[plyr.number-1].north = true;
              this.players[plyr.number-1].turnCheckerDirection = 'north';
              // plyr.ai.currentInstruction++;
              if (currentInstruction.limit === 1) {

                plyr.ai.currentInstruction++;
              } else {
                if (currentInstruction.count < currentInstruction.limit) {
                  currentInstruction.count++;
                } else if (currentInstruction.count >= currentInstruction.limit) {
                  plyr.ai.currentInstruction++;
                }
              }

            } else {
              // console.log('danger: move_north');
              plyr.ai.currentInstruction++;
              plyr.ai.resetInstructions = true;
            }
            // console.log('inDanger',inDanger);

          }
        break;
        case 'move_south':
        // console.log('ai act -- move_south');

          if (plyr.newMoveDelay.state !== true && plyr.moving.state !== true && !plyr.turning.state && plyr.success.deflected.state !== true && plyr.action === 'idle') {

            let inDanger = false;
            if (plyr.direction === 'south') {
              if (!targetCell) {
                // console.log('heading off the edge');
                inDanger = true;
              } else {
                if (targetCell.void.state === true || targetCell.terrain.type === 'deep' || targetCell.terrain.type === 'hazard') {
                  // console.log('heading for mid-grid danger',targetCell.number);
                  inDanger = true;
                }
              }
            }

            if (inDanger === false) {
              // console.log('safe: move_south');

              // currentInstruction.limit = 1;
              this.keyPressed[plyr.number-1].south = true;
              this.players[plyr.number-1].turnCheckerDirection = 'south';
              // plyr.ai.currentInstruction++;
              if (currentInstruction.limit === 1) {

                plyr.ai.currentInstruction++;
              } else {
                if (currentInstruction.count < currentInstruction.limit) {
                  currentInstruction.count++;
                } else if (currentInstruction.count >= currentInstruction.limit) {
                  plyr.ai.currentInstruction++;
                }
              }

            } else {
              // console.log('danger: move_south');
              plyr.ai.currentInstruction++;
              plyr.ai.resetInstructions = true;
            }

          }
        break;
        case 'move_east':
        // console.log('ai act -- move_east');
          if (plyr.newMoveDelay.state !== true && plyr.moving.state !== true && !plyr.turning.state && plyr.success.deflected.state !== true && plyr.action === 'idle') {

            let inDanger = false;
            if (plyr.direction === 'east') {
              if (!targetCell) {
                // console.log('heading off the edge');
                inDanger = true;
              } else {
                if (targetCell.void.state === true || targetCell.terrain.type === 'deep' || targetCell.terrain.type === 'hazard') {
                  // console.log('heading for mid-grid danger',targetCell.number);
                  inDanger = true;
                }
              }
            }

            if (inDanger === false) {
              // console.log('safe: move_east');
              // currentInstruction.limit = 1;
              this.keyPressed[plyr.number-1].east = true;
              this.players[plyr.number-1].turnCheckerDirection = 'east';
              // plyr.ai.currentInstruction++;
              if (currentInstruction.limit === 1) {

                plyr.ai.currentInstruction++;
              } else {
                if (currentInstruction.count < currentInstruction.limit) {
                  currentInstruction.count++;
                } else if (currentInstruction.count >= currentInstruction.limit) {
                  plyr.ai.currentInstruction++;
                }
              }

            } else {
              // console.log('danger: : move_east');
              plyr.ai.currentInstruction++;
              plyr.ai.resetInstructions = true;
            }

          }
        break;
        case 'move_west':
        // console.log('ai act -- move_west');
          if (plyr.newMoveDelay.state !== true && plyr.moving.state !== true && !plyr.turning.state && plyr.success.deflected.state !== true && plyr.action === 'idle') {

            let inDanger = false;
            if (plyr.direction === 'west') {
              if (!targetCell) {
                // console.log('heading off the edge');
                inDanger = true;
              } else {
                if (targetCell.void.state === true || targetCell.terrain.type === 'deep' || targetCell.terrain.type === 'hazard') {
                  // console.log('heading for mid-grid danger',targetCell.number);
                  inDanger = true;
                }
              }
            }

            if (inDanger === false) {
              // console.log('safe: move_west');
              // currentInstruction.limit = 1;
              this.keyPressed[plyr.number-1].west = true;
              this.players[plyr.number-1].turnCheckerDirection = 'west';
              // plyr.ai.currentInstruction++;
              if (currentInstruction.limit === 1) {

                plyr.ai.currentInstruction++;
              } else {
                if (currentInstruction.count < currentInstruction.limit) {
                  currentInstruction.count++;
                } else if (currentInstruction.count >= currentInstruction.limit) {
                  plyr.ai.currentInstruction++;
                }
              }

            } else {
              // console.log('danger: move_west');
              plyr.ai.currentInstruction++;
              plyr.ai.resetInstructions = true;
            }

          }
        break;
        case 'strafe_south':

        // console.log('ai act -- strafe_south');
        if (plyr.newMoveDelay.state !== true && plyr.moving.state !== true && !plyr.turning.state && plyr.success.deflected.state !== true && plyr.action === 'idle') {
          let inDanger = false;
          // if (plyr.direction === 'south') {
            if (!targetCell) {
              // console.log('heading off the edge');
              inDanger = true;
            } else {
              if (targetCell.void.state === true || targetCell.terrain.type === 'deep' || targetCell.terrain.type === 'hazard') {
                // console.log('heading for mid-grid danger');
                inDanger = true;
              }
            }
          // }

          if (inDanger === false) {

            // currentInstruction.limit = 1;
            this.keyPressed[plyr.number-1].strafe = true;
            this.keyPressed[plyr.number-1].south = true;

            // this.players[plyr.number-1].turnCheckerDirection = 'south';
            // plyr.ai.currentInstruction++;
            if (currentInstruction.limit === 1) {
              plyr.ai.currentInstruction++;
            } else {
              if (currentInstruction.count < currentInstruction.limit) {
                currentInstruction.count++;
              } else if (currentInstruction.count >= currentInstruction.limit) {
                plyr.ai.currentInstruction++;
              }
            }

          } else {
            // console.log('danger');
            plyr.ai.currentInstruction++;
            plyr.ai.resetInstructions = true;
          }

        }
        break;
        case 'strafe_north':
        // console.log('ai act -- strafe_north');
        if (plyr.newMoveDelay.state !== true && plyr.moving.state !== true && !plyr.turning.state && plyr.success.deflected.state !== true && plyr.action === 'idle') {
          let inDanger = false;
          // if (plyr.direction === 'north') {
            if (!targetCell) {
              // console.log('heading off the edge');
              inDanger = true;
            } else {
              if (targetCell.void.state === true || targetCell.terrain.type === 'deep' || targetCell.terrain.type === 'hazard') {
                // console.log('heading for mid-grid danger');
                inDanger = true;
              }
            }
          // }

          if (inDanger === false) {

            // currentInstruction.limit = 1;
            this.keyPressed[plyr.number-1].strafe = true;
            this.keyPressed[plyr.number-1].north = true;

            // this.players[plyr.number-1].turnCheckerDirection = 'north';
            // plyr.ai.currentInstruction++;
            if (currentInstruction.limit === 1) {
              plyr.ai.currentInstruction++;
            } else {
              if (currentInstruction.count < currentInstruction.limit) {
                currentInstruction.count++;
              } else if (currentInstruction.count >= currentInstruction.limit) {
                plyr.ai.currentInstruction++;
              }
            }

          } else {
            // console.log('danger');
            plyr.ai.currentInstruction++;
            plyr.ai.resetInstructions = true;
          }

        }
        break;
        case 'strafe_east':
        // console.log('ai act -- strafe_east');
        if (plyr.newMoveDelay.state !== true && plyr.moving.state !== true && !plyr.turning.state && plyr.success.deflected.state !== true && plyr.action === 'idle') {
          let inDanger = false;
          // if (plyr.direction === 'east') {
            if (!targetCell) {
              // console.log('heading off the edge');
              inDanger = true;
            } else {
              if (targetCell.void.state === true || targetCell.terrain.type === 'deep' || targetCell.terrain.type === 'hazard') {
                // console.log('heading for mid-grid danger');
                inDanger = true;
              }
            }
          // }

          if (inDanger === false) {

            // currentInstruction.limit = 1;
            this.keyPressed[plyr.number-1].strafe = true;
            this.keyPressed[plyr.number-1].east = true;

            // this.players[plyr.number-1].turnCheckerDirection = 'east';
            // plyr.ai.currentInstruction++;
            if (currentInstruction.limit === 1) {
              plyr.ai.currentInstruction++;
            } else {
              if (currentInstruction.count < currentInstruction.limit) {
                currentInstruction.count++;
              } else if (currentInstruction.count >= currentInstruction.limit) {
                plyr.ai.currentInstruction++;
              }
            }

          } else {
            // console.log('danger');
            plyr.ai.currentInstruction++;
            plyr.ai.resetInstructions = true;
          }

        }
        break;
        case 'strafe_west':
        // console.log('ai act -- strafe_west');
        if (plyr.newMoveDelay.state !== true && plyr.moving.state !== true && !plyr.turning.state && plyr.success.deflected.state !== true && plyr.action === 'idle') {
          let inDanger = false;
          // if (plyr.direction === 'west') {
            if (!targetCell) {
              // console.log('heading off the edge');
              inDanger = true;
            } else {
              if (targetCell.void.state === true || targetCell.terrain.type === 'deep' || targetCell.terrain.type === 'hazard') {
                // console.log('heading for mid-grid danger');
                inDanger = true;
              }
            }
          // }

          if (inDanger === false) {

            // currentInstruction.limit = 1;
            this.keyPressed[plyr.number-1].strafe = true;
            this.keyPressed[plyr.number-1].west = true;

            // this.players[plyr.number-1].turnCheckerDirection = 'west';
            // plyr.ai.currentInstruction++;
            if (currentInstruction.limit === 1) {
              plyr.ai.currentInstruction++;
            } else {
              if (currentInstruction.count < currentInstruction.limit) {
                currentInstruction.count++;
              } else if (currentInstruction.count >= currentInstruction.limit) {
                plyr.ai.currentInstruction++;
              }
            }

          } else {
            // console.log('danger');
            plyr.ai.currentInstruction++;
            plyr.ai.resetInstructions = true;
          }

        }
        break;
        case 'flank_north':
        // console.log('ai act -- flank_north');
          if (plyr.flanking.state !== true && plyr.action !== 'flanking') {
            // console.log('flanking north @ ai act');
            // currentInstruction.limit = 1;
            this.keyPressed[plyr.number-1].dodge = true;
            this.keyPressed[plyr.number-1].north = true;
            if (currentInstruction.count < currentInstruction.limit) {
              currentInstruction.count++;
            } else if (currentInstruction.count >= currentInstruction.limit) {
              plyr.ai.currentInstruction++;
            }
          }
        break;
        case 'flank_south':
        // console.log('ai act -- flank_south');
          if (plyr.flanking.state !== true && plyr.action !== 'flanking') {
            // console.log('flanking south @ ai act');
            // currentInstruction.limit = 1;
            this.keyPressed[plyr.number-1].dodge = true;
            this.keyPressed[plyr.number-1].south = true;
            if (currentInstruction.count < currentInstruction.limit) {
              currentInstruction.count++;
            } else if (currentInstruction.count >= currentInstruction.limit) {
              plyr.ai.currentInstruction++;
            }
          }
        break;
        case 'flank_east':
        // console.log('ai act -- flank_east');
          if (plyr.flanking.state !== true && plyr.action !== 'flanking') {
            // console.log('flanking east @ ai act');
            // currentInstruction.limit = 1;
            this.keyPressed[plyr.number-1].dodge = true;
            this.keyPressed[plyr.number-1].east = true;
            if (currentInstruction.count < currentInstruction.limit) {
              currentInstruction.count++;
            } else if (currentInstruction.count >= currentInstruction.limit) {
              plyr.ai.currentInstruction++;
            }
          }
        break;
        case 'flank_west':
        // console.log('ai act -- flank_west');
          if (plyr.flanking.state !== true && plyr.action !== 'flanking') {
            // console.log('flanking west @ ai act');
            // currentInstruction.limit = 1;
            this.keyPressed[plyr.number-1].dodge = true;
            this.keyPressed[plyr.number-1].west = true;
            if (currentInstruction.count < currentInstruction.limit) {
              currentInstruction.count++;
            } else if (currentInstruction.count >= currentInstruction.limit) {
              plyr.ai.currentInstruction++;
            }
          }
        break;
        case 'attack':
        // console.log('ai act -- attack');
        let atkPeak;
        if (plyr.currentWeapon.name === "") {
          atkPeak = this.attackAnimRef.peak.unarmed;
        }
        else {
          atkPeak = this.attackAnimRef.peak[plyr.currentWeapon.type];
        }
        currentInstruction.limit = atkPeak+2;
        this.keyPressed[plyr.number-1].attack = true;
        if (plyr.moving.state !== true) {

            if (currentInstruction.count < currentInstruction.limit) {
              currentInstruction.count++;
            } else if (currentInstruction.count >= currentInstruction.limit) {
              plyr.ai.currentInstruction++;
            }

        }
        break;
        case 'long_defend':
        // console.log('ai act -- long defend');
          currentInstruction.limit = 25;
          this.keyPressed[plyr.number-1].defend = true;
          if (currentInstruction.count < currentInstruction.limit) {
            currentInstruction.count++;
          } else if (currentInstruction.count >= currentInstruction.limit) {
            plyr.ai.currentInstruction++;
          }
        break;
        case 'short_defend':
        // console.log('ai act -- short defend');
          currentInstruction.limit = 15;
          this.keyPressed[plyr.number-1].defend = true;
          if (currentInstruction.count < currentInstruction.limit) {
            currentInstruction.count++;
          } else if (currentInstruction.count >= currentInstruction.limit) {
            plyr.ai.currentInstruction++;
          }
        break;
        case 'dodge':
        // console.log('ai act -- dodge');
          currentInstruction.limit = 1;
          this.keyPressed[plyr.number-1].dodge = true;
          if (currentInstruction.count < currentInstruction.limit) {
            currentInstruction.count++;
          } else if (currentInstruction.count >= currentInstruction.limit) {
            plyr.ai.currentInstruction++;
          }
        break;
        case 'pickup':
        console.log('ai act -- pickup',currentInstruction.limit);
          // currentInstruction.limit = 10;
          // this.keyPressed[plyr.number-1].defend = true;
          this.keyPressed[plyr.number-1].cycleWeapon = true;

          if (currentInstruction.count < currentInstruction.limit) {
            currentInstruction.count++;
          } else if (currentInstruction.count >= currentInstruction.limit) {
            plyr.ai.currentInstruction++;
          }
        break;
        case 'drop_weapon':
        console.log('ai act -- drop_weapon');
          // currentInstruction.limit = 10;
          this.keyPressed[plyr.number-1].defend = true;
          if (currentInstruction.count > 3) {
            this.keyPressed[plyr.number-1].cycleWeapon = true;
          }

          if (currentInstruction.count < currentInstruction.limit) {
            currentInstruction.count++;
          } else if (currentInstruction.count >= currentInstruction.limit) {
            plyr.ai.currentInstruction++;
          }
        break;

      }


      if (plyr.ai.currentInstruction === plyr.ai.instructions.length) {
        // console.log('NO MORE INSTRUCTIONS!!');
        if (plyr.ai.engaging.state === true) {
          plyr.ai.engaging.state = false;
          plyr.ai.engaging.targetAction = '';
        }
      }
      if (plyr.ai.mission === 'engage' && plyr.currentWeapon.type === 'crossbow') {
        if (plyr.ai.currentInstruction === plyr.ai.instructions.length-1) {
          if (plyr.ai.engaging.state === true) {
            plyr.ai.engaging.state = false;
            plyr.ai.engaging.targetAction = ''
          }
        }
      }

      let index = plyr.ai.instructions.indexOf(currentInstruction);
      if (index >= plyr.ai.instructions.length-1 && plyr.ai.mission === "patrol" && plyr.ai.patrolling.checkin === 'checkedIn') {
        // console.log('patrol instructions complete');
        plyr.ai.instructions = [];
        this.players[plyr.number-1].ai.patrolling.loopControl = false;
      }
      if (index >= plyr.ai.instructions.length-1 && plyr.ai.mission === "defend" && plyr.ai.defending.checkin === 'checkedIn') {
        // console.log('defend instructions complete');
        plyr.ai.instructions = [];
      }

    } else {
      this.keyPressed[plyr.number-1] = {
        north: false,
        south: false,
        east: false,
        west: false,
        northEast: false,
        northWest: false,
        southEast: false,
        southWest: false,
        attack: false,
        defend: false,
        strafe: false,
        cycleWeapon: false,
        cycleArmor: false,
        dodge: false,
        menu: false,
      }
    }

  }
  updatePathArray = () => {
    // console.log('updating pathArray');

    let pathArray = []

    for (const [key, value] of Object.entries(this['levelData'+this.gridWidth])) {
      let row = [];
      for (const elem3 of value) {
        // let terrainInfo2 = elem3.length-1;
        // let cell = this.gridInfo.find(elem2 => elem2.levelData === elem3)
        //
        // if (cell) {
        //   let playerCell = false;
        //   for (const plyr of this.players) {
        //     if (
        //       plyr.currentPosition.cell.number.x === cell.number.x &&
        //       plyr.currentPosition.cell.number.y === cell.number.y
        //     ) {
        //       playerCell = true;
        //     }
        //   }
        //   if (playerCell === true) {
        //     row.push(0)
        //     // row.push(1)
        //   } else {
        //     if (
        //       elem3.charAt(terrainInfo2) === 'j' ||
        //       elem3.charAt(terrainInfo2) === 'h' ||
        //       elem3.charAt(terrainInfo2) === 'i' ||
        //       elem3.charAt(0) !== 'x' ||
        //       cell.void.state === true
        //     ) {
        //       row.push(1)
        //     } else {
        //       row.push(0)
        //     }
        //     // row.push(0)
        //   }
        // }

        row.push(0)
      }
      pathArray.push(row)
    }
    this.pathArray = pathArray;

  }


  gameLoop = () => {

    // IF PRESSED SETTINGS KEY, COUNT
    // PAUSE GAME IF SETTINGS OPENED
    if (this.showSettingsKeyPress.state === true) {
      if (this.showSettingsKeyPress.count < this.showSettingsKeyPress.limit) {
        this.showSettingsKeyPress.count++;
      }
      if (this.showSettingsKeyPress.count >= this.showSettingsKeyPress.limit) {
        if (this.state.showSettings !== true) {
          this.setState({
            showSettings: true
          })
          if (this.showSettingsCanvasData.state === true) {
            this.settingsFormGridWidthUpdate(this.settingsGridWidth)
          }

          // this.redrawSettingsGrid();
        } else {

          // this.updateSettingsFormAiDataData = {};
          this.settingsFormAiStartPosList = [];
          this.setState({
            showSettings: false
          })
        }
        this.showSettingsKeyPress = {
          state: false,
          count: 0,
          limit: this.showSettingsKeyPress.limit,
        }
      }

    }

    if (this.state.showSettings !== true) {

      // let ts = window.performance && window.performance.now ? window.performance.now() : new Date().getTime();
      this.stepper.currentTime = (new Date()).getTime();
      this.stepper.deltaTime = (this.stepper.currentTime-this.stepper.lastTime);

      if(this.stepper.deltaTime > this.stepper.interval) {

        this.time++;

        if (this.time === 300) {
        //   this.openVoid = true;
        // OR
        //   this.customCellToVoid({x:2,y:2})

        // this.players[1].ai.retreating.state = false;
        // this.players[1].ai.retreating.checkin = undefined;
        // this.players[1].ai.mission = 'retreat';
        // this.players[1].ai.retreating.safe = false;
        }


        this.setState({
          stateUpdater: '..'
        })


        if (this.gamepad === true) {
          this.pollGamepads();
        }


        // REMOVE AI PLAYER!
        if (this.removeAi && this.addAiCount.state !== true) {

          let aiPlayer = this.players[this.removeAi-1]
          let newArray = this.players.filter(x=> x !== aiPlayer);
          this.players = [];
          this.players = newArray;
          this.removeAi = undefined;
        }


        for (const player of this.players) {

          this.playerUpdate(player, this.state.canvas, this.state.context, this.state.canvas2, this.state.context2, this.state.canvas3, this.state.context3);
        }


        this.stepper.lastTime = this.stepper.currentTime - (this.stepper.deltaTime % this.stepper.interval);
      }

    }

    requestAnimationFrame(this.gameLoop);

  }
  playerUpdate = (player, canvas, context, canvas2, context2, canvas3, context3) => {
    // console.log('updating player',player.number,this.currentPlayer);

    let keyPressedDirection;
    if (player.ai.state === true && player.dead.state === true) {

    }
    else {
      for (const [key, value] of Object.entries(this.keyPressed[player.number-1])) {
        // console.log(`${key}: ${value} ....${player.number}`);

        if (
          key !== 'strafe' &&
          key !== 'attack' &&
          key !== 'defend' &&
          key !== 'dodge' &&
          key !== 'menu' &&
          value === true
        ) {
          // if (player.ai.state === true) {
          //   console.log('ai pressed',key,'plyr',player.number);
          // }
          // console.log('pressed1',key,'plyr',player.number);

          keyPressedDirection = key;
        }
        if (
          key !== 'east' &&
          key !== 'west' &&
          key !== 'east' &&
          key !== 'west' &&
          value === true
        ) {
          // console.log('pressed2',key,'plyr',player.number);
        }


      }
    }

    let nextPosition;


    if (player.dead.state === true) {

      if (player.dead.count > 0 && player.dead.count < player.dead.limit+1) {
        player.dead.count++
        // console.log('player',player.number,'dying',player.dead.count);
      }
      else if (player.dead.count >= player.dead.limit) {
        player.dead.count = 0;
      }

    }
    if (player.dead.state === true && player.dead.count === 0) {
      // console.log('done dying remove from board');
      player.nextPosition = {
        x: -30,
        y: -30,
      }
    }


    // OPEN VOID!!???
    if (this.openVoid === true) {

      if (this.cellToVoid.state !== true) {
        // console.log('set a new cell to void');

        let cell = {
          x: 0,
          y: 0
        }

        let voidChance = Math.round(1000/this.gridWidth)
        let openVoid = this.rnJesus(1,voidChance);

        if (openVoid === 1) {
          // console.log('boom');
          cell.x = this.rnJesus(0,this.gridWidth)
          cell.y = this.rnJesus(0,this.gridWidth)

          this.cellToVoid.state = true;
          this.cellToVoid.x = cell.x;
          this.cellToVoid.y = cell.y;
          this.cellToVoid.count = 1;
        }

      }
      else if (this.cellToVoid.state === true) {
        // console.log('already voiding a cell');
        if (this.cellToVoid.count < this.cellToVoid.limit) {
          this.cellToVoid.count++
          // console.log('cv',this.cellToVoid.count);
        }
        else if (this.cellToVoid.count >= this.cellToVoid.limit) {
          // console.log('summon void now',this.cellToVoid.x,this.cellToVoid.y);

          let cell = {
            x: this.cellToVoid.x,
            y: this.cellToVoid.y,
          }

          this.voidSummon(cell);

          this.cellToVoid = {
            state: false,
            x: 0,
            y: 0,
            count: 0,
            limit: this.cellToVoid.limit,
          }



          if (this.voidCustomCell === true) {
            // console.log('void custom cell switch off');
            this.openVoid = false
            this.voidCustomCell = false;
          }

        }

      }

    }
    // LIMIT CELL VOID EVENT!!
    if (this.voidTimer.count < this.voidTimer.limit) {
      this.voidTimer.count++
      // console.log('void count',this.voidTimer.count);
    }
    if (this.voidTimer.count >= this.voidTimer.limit) {
      this.openVoid = false;
      // console.log('void off');
    }


    // BLOOD SACRIFICE!!
    if (this.bloodSacrificeEvent.state === true) {

      if (this.bloodSacrificeEvent.count < this.bloodSacrificeEvent.limit) {
        this.bloodSacrificeEvent.count++;
      } else if (this.bloodSacrificeEvent.count >= this.bloodSacrificeEvent.limit) {
        if (this.cellToVoid.state !== true) {
          this.bloodSacrificeEvent.state = false;
          this.openVoid = false;
          console.log('Blood Sacrifice event is now over.');
          if (this.bloodSacrificeEvent.restore === true) {


            for (const cell of this.bloodSacrificeVoidedCells) {
              // console.log('restoring cells after blood Sacrifice',cell);
              if (cell.terrain.name !== 'void') {
                cell.void.state = false;
              }
            }

            this.bloodSacrificeVoidedCells = [];
            this.bloodSacrificeEvent.restore = false;
          }
        }

      }
    }


    // STAMINA!!
    if (player.stamina.current < player.stamina.max) {

      player.stamina.current += .05;
      player.stamina.current = +(Math.round((player.stamina.current) + "e+" + 3)  + "e-" + 3);

      if (player.stamina.current >= player.stamina.max) {
        player.stamina.current = player.stamina.max;
      }
      if (player.stamina.current < 0) {
        // console.log('stamina lower limit reset for player ',player.number);
        player.stamina.current = 0;
      }
      if (player.stamina.current === 1) {
        // console.log('OUT OF STAMINA @ player update');
        player.flanking = {
          checking: false,
          preFlankDirection: '',
          direction: '',
          state: false,
          step: 0,
          target1: {x:0 ,y:0},
          target2: {x:0 ,y:0},
        }
        player.dodging = {
          countState: false,
          state: false,
          count: 0,
          limit: 20,
          peak: {
            start: 5,
            end: 10,
          }
        }

        this.attackedCancel(player);

        if (player.success.deflected.state !== true) {

          this.setDeflection(player,'outOfStamina',false);

        }

        if (!player.popups.find(x => x.msg === 'outOfStamina')) {
          player.popups.push(
            {
              state: false,
              count: 0,
              limit: 20,
              type: '',
              position: '',
              msg: 'outOfStamina',
              img: '',

            }
          )
        }


      }

      // AI RETREAT ON LOW STAMINA
      if (player.stamina.current <= 4) {
        if (player.ai.state === true) {
          console.log('ai player',player.number,' almost out of stamina. Retreat');
          player.ai.mission = 'retreat';

          if (!player.popups.find(x=>x.msg === 'missionRetreat')) {
            player.popups.push(
              {
                state: false,
                count: 0,
                limit: 30,
                type: '',
                position: '',
                msg: 'missionRetreat',
                img: '',

              }
            )
          }

        }
      }
    }


    // CHECK AND SET DEFLECTION!!
    // if (player.success.deflected.state === true && player.success.deflected.count < player.success.deflected.limit && player.success.deflected.predeflect !== true) {
    if (player.success.deflected.state === true && player.success.deflected.count < player.success.deflected.limit ) {

      player.action = 'deflected';
      player.success.deflected.count++;

      if (player.success.deflected.count === 2) {
        // console.log('count',player.success.deflected.count,'limit',player.success.deflected.limit,'type',player.success.deflected.type);

        if (
          player.success.deflected.type === 'bluntAttacked' ||
          player.success.deflected.type === 'defended'
        ) {

          if (!player.popups.find(x=>x.msg === "guardBroken")) {
            player.popups.push(
              {
                state: false,
                count: 0,
                limit: player.success.deflected.limit,
                type: '',
                position: '',
                msg: 'guardBroken',
                img: '',

              }
            )
          }

        }

        if (player.success.deflected.type === 'parried') {
          if (!player.popups.find(x=>x.msg === "attackParried")) {
            player.popups.push(
              {
                state: false,
                count: 0,
                limit: player.success.deflected.limit,
                type: '',
                position: '',
                msg: 'attackParried',
                img: '',

              }
            )
          }

        }
        if (player.success.deflected.type === 'attacked') {
          if (!player.popups.find(x=>x.msg === "injured")) {
            player.popups.push(
              {
                state: false,
                count: 0,
                limit: player.success.deflected.limit,
                type: '',
                position: '',
                msg: 'injured',
                img: '',

              }
            )
          }
        }
        if (player.success.deflected.type === 'outOfStamina') {

          if (!player.popups.find(x=>x.msg === player.success.deflected.type)) {
            player.popups.push(
              {
                state: false,
                count: 0,
                limit: player.success.deflected.limit,
                type: '',
                position: '',
                msg: player.success.deflected.type,
                img: '',

              }
            )
          }
        }

      }


      // if (player.ai.state === true) {
      //   player.ai.instructions = []
      //   player.ai.currentInstruction = 0
      //   if (player.ai.mission === 'engage') {
      //     player.ai.engaging.targetAction = ''
      //   }
      // }

    }
    //END DEFLECTION, SPIN & DROP
    else if (player.success.deflected.state === true && player.success.deflected.count >= player.success.deflected.limit) {
      // console.log('deflect end',player.success.deflected.type);
      // DEFLECT SPIN!
      let shouldSpin;
      if (player.success.deflected.type === "attacked") {
        shouldSpin = this.rnJesus(1,5);
      }
      if (player.success.deflected.type === "defended") {
        shouldSpin = this.rnJesus(1,10);
      }

      if (player.success.deflected.type === "outOfStamina") {
        shouldSpin = this.rnJesus(1,2)
      }
      if (player.success.deflected.type === "parried") {
        shouldSpin = 1;
      }
      let newDirection;
      if (shouldSpin === 1) {
        switch(player.direction) {
          case 'north':
            if (shouldSpin === 1) {
              newDirection = 'east';
            } else {
              newDirection = 'west';
            }
          break;
          case 'south':
            if (shouldSpin === 1) {
              newDirection = 'east';
            } else {
              newDirection = 'west';
            }
          break;
          case 'east':
            if (shouldSpin === 1) {
              newDirection = 'north';
            } else {
              newDirection = 'south';
            }
          break;
          case 'west':
            if (shouldSpin === 1) {
              newDirection = 'north';
            } else {
              newDirection = 'south';
            }
          break;
        }
        player.direction = newDirection;
      }

      player.action = 'idle';

      this.unsetDeflection(player);


      // CANCEL AI ATTACK, DEFEND!!
      if (player.ai.state === true) {
        if (player.ai.state === true) {
          player.attacking = {
            state: false,
            count: 0,
            limit: 15,
          };
        }

        player.defending = {
          state: false,
          count: 0,
          limit: player.defending.limit,
        }

        player.ai.targetAqcuiredReset = true

      }


      if (player.dead.state !== true && player.falling.state !== true) {
        let shouldDeflectDrop = this.rnJesus(1,player.crits.guardBreak)
        if (shouldDeflectDrop === 1) {
          this.deflectDrop(player)
        }

      }


    }


    // CELLS TO HIGHLIGHT V2!!
    for (const cell3 of this.cellsToHighlight2) {
      if (cell3.limit > 0) {
        if (cell3.count < cell3.limit) {
          cell3.count++
        }
        else if (cell3.count >= cell3.limit) {
          let index = this.cellsToHighlight2.indexOf(cell3)
          this.cellsToHighlight2.splice(index,1)
        }
      }
    };


    // MOUSED OVER CELL
    if (this.mouseOverCell.cell && this.mouseOverCell.state === false && this.mouseMoving !== true) {

      if (this.mouseOverCell.count < this.mouseOverCell.threshold) {
        this.mouseOverCell.count++;
        // console.log('mouse not moving but moused over cell is counting',this.mouseOverCell.count);
      }
      if (this.mouseOverCell.count >= this.mouseOverCell.threshold) {
        this.mouseOverCell.count = 0;
        this.mouseOverCell.state = true;
        this.clicked.cell = this.mouseOverCell.cell;
        let plyrPresent = false;
        for(const plyr of this.players) {
          if (plyr.currentPosition.cell.number.x === this.mouseOverCell.cell.number.x && plyr.currentPosition.cell.number.y === this.mouseOverCell.cell.number.y) {
            this.clicked.player = plyr;
            plyrPresent = true;
          }
        }
        if (plyrPresent !== true) {
          this.clicked.player = undefined;
        }
        this.showCellInfoBox = true;
      }
    };
    // SWITCH OFF ATER TIME IF MOUSE MOVED OUT OF GRID
    if (this.mouseOverCellSwitchOff.state === true) {
      if (this.mouseOverCellSwitchOff.count < this.mouseOverCellSwitchOff.limit) {
        this.mouseOverCellSwitchOff.count++;
      }
      if (this.mouseOverCellSwitchOff.count >= this.mouseOverCellSwitchOff.limit) {
        this.mouseOverCellSwitchOff = {
          state: false,
          count: 0,
          limit: this.mouseOverCellSwitchOff.limit,
        }
        this.showCellInfoBox = false;
        this.mouseOverCell = {
          state: false,
          cell: undefined,
          count: 0,
          threshold: this.mouseOverCell.threshold,
        };
      }
    };
    this.mouseMoving = false;


    // DEFLECTED PLAYER CAN'T DO ANYTHING!!
    if (player.success.deflected.state === false && player.dead.state !== true && this.camera.state !== true) {


      // AI STRAFE SWITCH ON!!
      if (player.ai.state === true && this.keyPressed[player.number-1]) {
        if (this.keyPressed[player.number-1].strafe === true) {
          this.players[player.number-1].strafing.state = true;
        }
      }


      // DON'T READ INPUTS. JUST MOVE!!
      if (player.moving.state === true) {

        // console.log('player',player.number,player.action);
        nextPosition = this.lineCrementer(player);
        player.nextPosition = nextPosition;


        let atDestRanges = [false,false,false,false];

        if (player.target.cell1.void === true) {
          if (player.falling.state === true) {
            // console.log('...');
          }
          else {
            player.action = 'moving';
            // console.log('stepping into the void',player.action,player.moving.step);
          }

        }

        if (player.jumping.state !== true) {


          let destRngIndx = undefined;
          if (
            nextPosition.x >= player.target.cell1.center.x-1 &&
            nextPosition.x <= player.target.cell1.center.x+1 &&
            nextPosition.y >= player.target.cell1.center.y-1 &&
            nextPosition.y <= player.target.cell1.center.y+1
          ) {
            atDestRanges[0] = true;
            destRngIndx = 0;
          }
          if (
            nextPosition.x === player.target.cell1.center.x-0.25 &&
            nextPosition.y === player.target.cell1.center.y+0.5
          ) {
            atDestRanges[1] = true;
            destRngIndx = 1;
          }
          if (
            nextPosition.x === player.target.cell1.center.x &&
            nextPosition.y === player.target.cell1.center.y
          ) {
            atDestRanges[2] = true;
            destRngIndx = 2;
          }
          if (
            nextPosition.x === player.target.cell1.center.x-5 &&
            nextPosition.y === player.target.cell1.center.y-5
          ) {
            atDestRanges[3] = true;
            destRngIndx = 3;
          }

          // FLANKING POPUP 1
          if (player.flanking.state === true || player.action === "flanking" ) {
            // console.log('flanking moving');
            if (!player.popups.find(x=>x.msg === "flanking2")) {
              player.popups.push(
                {
                  state: false,
                  count: 0,
                  limit: 20,
                  type: '',
                  position: '',
                  msg: 'flanking2',
                  img: '',
                }
              )
            }
          }
          if (player.popups.find(x=>x.msg === 'dodging')) {
            player.popups.splice(player.popups.findIndex(x=>x.msg === 'dodging'),1)
          }

          // if (player.strafing.state === true) {
          //   console.log('midmove strafe hold',player.strafing.direction);
          // }
          // if (player.strafing.state !== true) {
          //   console.log('midmove strafe release',player.strafing.direction);
          // }


          for (const el of atDestRanges) {
            if (el === true) {

              let indx = atDestRanges.indexOf(el);

              player.newMoveDelay.state = true;

              if (player.target.cell1.void === false) {

                player.currentPosition.cell.number = player.target.cell1.number;
                player.currentPosition.cell.center = player.target.cell1.center;
                player.action = 'idle';
                player.moving = {
                  state: false,
                  step: 0,
                  course: '',
                  origin: {
                    number: {
                      x: player.target.cell1.number.x,
                      y: player.target.cell1.number.y
                    },
                    center: {
                      x: player.target.cell1.center.x,
                      y: player.target.cell1.center.y
                    },
                  },
                  destination: {
                    x: 0,
                    y: 0,
                  }
                }

                if (player.strafing.state === true) {

                  if (
                    player.pulling.state === true ||
                    player.pushed.state === true ||
                    player.pulled.state === true
                  ) {
                    // player.strafing.direction = '';
                    player.strafeReleaseHook = true;
                  }

                  // CONTINUOUS STRAFING CHECK
                  if (this.keyPressed[player.number-1].strafe !== true) {
                    // console.log('continuous strafe check');
                    player.strafing.state = false;
                    player.strafing.direction = '';
                  }
                  else {
                    // console.log('continuous strafe check 2');
                    player.strafing.direction = '';
                  }

                }


                // PULLED, PUSHED PLAYERS
                if (player.pushing.state === true) {
                  player.pushing = {
                    state: false,
                    targetCell: undefined,
                    moveSpeed: 0,
                  }
                }
                if (player.pulling.state === true) {
                  player.pulling = {
                    state: false,
                    targetCell: undefined,
                    moveSpeed: 0,
                  }
                  player.postPull.state = true;

                }
                let deflectPullPushedPlayer = false;
                if (player.pulled.state === true) {
                  player.pulled = {
                    state: false,
                    puller: 0,
                    moveSpeed: 0,
                  }
                  deflectPullPushedPlayer = true;
                }
                if (player.pushed.state === true) {
                  player.pushed = {
                    state: false,
                    pusher: 0,
                    moveSpeed: 0,
                  }
                  deflectPullPushedPlayer = true;
                }


                if (
                  deflectPullPushedPlayer === true &&
                  this.gridInfo.find(x => x.number.x === player.currentPosition.cell.number.x && x.number.y === player.currentPosition.cell.number.y).terrain.type !== "deep"
                ) {
                  // console.log('pulled pushed player at destination. deflect?');

                  if (this.rnJesus(1,player.crits.guardBreak) === 1) {

                    this.setDeflection(player,'bluntAttacked',false);

                  }

                }


                this.checkDestination(player);
                if (player.drowning !== true && player.pushBack.state !== true && player.dead.state !== true) {
                  this.getTarget(player);
                }


              }

              // PUSHBACK MOVEMENT
              if (player.pushBack.state === true && player.target.cell1.void !== true) {
                // console.log('player',player.number,'finished moving pushed back',player.flanking.state);

                // CANCEL AI ATTACK, DEFEND!!
                if (player.ai.state === true) {
                  if (player.ai.state === true) {
                    player.attacking = {
                      state: false,
                      count: 0,
                      limit: 15,
                    };
                  }

                  player.defending = {
                    state: false,
                    count: 0,
                    limit: player.defending.limit,
                  }

                  player.ai.targetAqcuiredReset = true
                }


                player.pushBack.state = false;
                player.strafing = {
                  state: false,
                  direction: ''
                }
                player.moving.state = false;
                player.speed.move = player.pushBack.prePushMoveSpeed;
                this.getTarget(player);



              }


              // TARGET IS VOID, START FALLING!
              if (
                nextPosition.x === player.target.cell1.center.x &&
                nextPosition.y === player.target.cell1.center.y ||
                nextPosition.x === player.target.cell1.center.x-5 &&
                nextPosition.y === player.target.cell1.center.y-5 ||
                nextPosition.x === player.target.cell1.center.x-0.25 &&
                nextPosition.y === player.target.cell1.center.y+0.5 ||
                nextPosition.x >= player.target.cell1.center.x-1 &&
                nextPosition.x <= player.target.cell1.center.x+1 &&
                nextPosition.y >= player.target.cell1.center.y-1 &&
                nextPosition.y <= player.target.cell1.center.y+1 &&
                player.target.cell1.void === true
              ) {
                // console.log('falling....');
                player.falling.state = true;
                player.action = 'falling';

                if (!player.popups.find(x=>x.msg === "falling")) {
                  player.popups.push(
                    {
                      state: false,
                      count: 0,
                      limit: 30,
                      type: '',
                      position: '',
                      msg: 'falling',
                      img: '',

                    }
                  )
                }

              }
              break;

            }
          }

        }

        if (player.jumping.state === true) {
          // console.log('mid jump');


          if (
            nextPosition.x >= player.target.cell2.center.x-1 &&
            nextPosition.x <= player.target.cell2.center.x+1 &&
            nextPosition.y >= player.target.cell2.center.y-1 &&
            nextPosition.y <= player.target.cell2.center.y+1
          ) {
            atDestRanges[0] = true;
          }

          if (
            nextPosition.x === player.target.cell2.center.x-0.25 &&
            nextPosition.y === player.target.cell2.center.y+0.5
          ) {
            atDestRanges[1] = true;
          }

          if (
            nextPosition.x === player.target.cell2.center.x &&
            nextPosition.y === player.target.cell2.center.y
          ) {
            atDestRanges[2] = true;
          }

          if (
            nextPosition.x === player.target.cell2.center.x-5 &&
            nextPosition.y === player.target.cell2.center.y-5
          ) {
            atDestRanges[3] = true;
          }


          for (const el of atDestRanges) {
            if (el === true) {

              // console.log('at jump destination',player.target.cell2.number);
              // console.log('next position is destination a',player.number);
              player.newMoveDelay.state = true;


              let pushBack = false;
              let opp;

              for (const plyr of this.players) {
                if (
                  // plyr.currentPosition.cell.number.x === player.currentPosition.cell.number.x &&
                  // plyr.currentPosition.cell.number.y === player.currentPosition.cell.number.y
                  // plyr.currentPosition.cell.number.x === player.target.cell2.number.x &&
                  // plyr.currentPosition.cell.number.y === player.target.cell2.number.y
                  plyr.target.cell1.number.x === player.target.cell2.number.x &&
                  plyr.target.cell1.number.y === player.target.cell2.number.y &&
                  plyr.moving.state === true
                ) {

                  // console.log('jump destination occupied, fall into target 1',player.direction);

                  pushBack = true;
                  opp = plyr;
                }
              }

              // Jump dest cell not void
              if (player.target.cell2.void === false) {


                player.jumping.state = false;
                player.currentPosition.cell.number = player.target.cell2.number;
                player.currentPosition.cell.center = player.target.cell2.center;
                player.strafing.state = false;
                player.action = 'idle';
                player.moving = {
                  state: false,
                  step: 0,
                  course: '',
                  origin: {
                    number: {
                      x: player.target.cell2.number.x,
                      y: player.target.cell2.number.y
                    },
                    center: {
                      x: player.target.cell2.center.x,
                      y: player.target.cell2.center.y
                    },
                  },
                  destination: {
                    x: 0,
                    y: 0,
                  }
                }

                this.checkDestination(player);
                // let trgt = this.getTarget(player);

                if (pushBack === true ) {

                  let playerAPushDir = this.getOppositeDirection(opp.direction);
                  let playerBPushDir = this.getOppositeDirection(player.direction);


                  player.strafing = {
                    state: true,
                    direction: playerAPushDir
                  }
                  player.action = 'strafe moving';
                  player.moving = {
                    state: true,
                    step: 0,
                    course: '',
                    origin: {
                      number: {
                        x: player.currentPosition.cell.number.x,
                        y: player.currentPosition.cell.number.y
                      },
                      center: {
                        x: player.currentPosition.cell.center,
                        y: player.currentPosition.cell.center
                      },
                    },
                    destination: player.target.cell2.center
                  }
                  // player.target.void = true;
                  let nextPosition = this.lineCrementer(player);
                  player.nextPosition = nextPosition;



                }

              }

              // let targetCell = this.gridInfo.find(elem => elem.number.x === player.target.cell2.number.x && elem.number.y === player.target.cell2.number.y)
              if (player.target.cell2.void === true) {
                player.falling.state = true;
                player.action = 'falling';

                if (!player.popups.find(x=>x.msg === "falling")) {
                  player.popups.push(
                    {
                      state: false,
                      count: 0,
                      limit: 30,
                      type: '',
                      position: '',
                      msg: 'falling',
                      img: '',

                    }
                  )
                }

              }

              break;

            }
          }

        }

      }


      // CAN READ INPUTS
      else if (player.moving.state === false) {


        // COLLISION/ MOVEMENT OVERLAP PUSHBACK!!
          // if neither is pulling/pushng or pulled/pushed
        for (const plyr4 of this.players) {

          if (
            player.number !== plyr4.number &&
            player.currentPosition.cell.number.x === plyr4.currentPosition.cell.number.x &&
            player.currentPosition.cell.number.y === plyr4.currentPosition.cell.number.y &&
            player.pushBack.state !== true &&
            plyr4.pushBack.state !== true
          ) {

            let nopushpull = true;
            if (
              player.pulled.state === true ||
              player.pushed.state === true ||
              player.pulling.state === true ||
              player.pushing.state === true ||
              plyr4.pulled.state === true ||
              plyr4.pushed.state === true ||
              plyr4.pulling.state === true ||
              plyr4.pushing.state === true
            ) {
              nopushpull = false;
              console.log('player cell overlap but 1 is pushing/pulling the other');
            }
            console.log('buck up btwn plyrs',player.number,plyr4.number,"@",player.currentPosition.cell.number,plyr4.currentPosition.cell.number);
            // console.log('plyrs pushed back?',player.pushBack.state,plyr4.pushBack.state);
            // console.log('plyrs moving?',player.moving.state,plyr4.moving.state);
            if (nopushpull === true) {
              let playerAPushDir2 = this.getOppositeDirection(plyr4.direction);
              let playerBPushDir2 = this.getOppositeDirection(player.direction);


              if (player.flanking.state === true || player.action === "flanking") {
                player.flanking = {
                  checking: false,
                  direction: '',
                  state: false,
                  step: 0,
                  target1: {x:0 ,y:0},
                  target2: {x:0 ,y:0},
                }
                player.action = "idle";
              };
              if (plyr4.flanking.state === true || plyr4.action === "flanking") {
                plyr4.flanking = {
                  checking: false,
                  direction: '',
                  state: false,
                  step: 0,
                  target1: {x:0 ,y:0},
                  target2: {x:0 ,y:0},
                }
                plyr4.action = "idle";
              };
              // playerAPushDir2 = "north";
              if (playerAPushDir2 === playerBPushDir2) {
                playerBPushDir2 = ['north','south','east','west'].filter(x=>x !== playerAPushDir2)[0];
              }
              let canPush = this.pushBack(plyr4,playerAPushDir2)
              let canPush2 = this.pushBack(player,playerBPushDir2)
            }


          }
        }


        // CHECK CELL UNDER ATTACK & PRE ATTACK!!
        for (const cell of this.cellsUnderAttack) {
          if (cell.limit > 0) {
            if (cell.count < cell.limit) {
              cell.count++
            }
            else if (cell.count >= cell.limit) {
              let index = this.cellsUnderAttack.indexOf(cell)
              this.cellsUnderAttack.splice(index,1)
            }
          }

        };
        for (const cell2 of this.cellsUnderPreAttack) {
          if (cell2.limit > 0) {
            if (cell2.count < cell2.limit) {
              cell2.count++
            }
            else if (cell2.count >= cell2.limit) {
              let index = this.cellsUnderPreAttack.indexOf(cell2)
              this.cellsUnderPreAttack.splice(index,1)
            }
          }
        };



        // // IDLE ANIM STEPPER!
        if (player.action === 'idle') {
          // player.idleAnim.state = true
          if (player.idleAnim.count < player.idleAnim.limit) {
            // console.log('player.idleAnim.count',player.idleAnim.count);
            player.idleAnim.count++

          }
          if (player.idleAnim.count >= player.idleAnim.limit) {
            player.idleAnim.count = 0;
            player.idleAnim.state = false;
          }
        }
        else if (player.action !== 'idle') {
          // player.idleAnim.state = false;
          player.idleAnim.count = 0;
        }



        // TURNER!!
        if (player.turning.state === true && player.flanking.state !== true ) {
          if (player.turning.delayCount < player.turning.limit) {
            player.turning.delayCount++;
            // console.log('turning...',player.turning.delayCount);
          }
          if (player.turning.delayCount >= player.turning.limit) {
            player.direction = player.turning.toDirection;
            player.turnCheckerDirection = "";
            player.turning = {
              state: false,
              toDirection: '',
              delayCount: 0,
              limit: player.turning.limit,
            }


            this.getTarget(player);
            // console.log('turned/ turn complete');
          }


        }


        // KEY PRESS RELEASE CHECKS!!

        // DEFEND/PRE PULL FEINT
        if (this.keyPressed[player.number-1].defend === false && player.defending.state === true) {
          // console.log('player',player.number,' defend key release');
          player.defending = {
            state: false,
            count: 0,
            limit: player.defending.limit
          }
          player.action = 'idle';

          player.defendDecay = {
            state: false,
            count: 0,
            limit: player.defendDecay.limit,
          }
          player.stamina.current += this.staminaCostRef.defend.pre;

          if (player.prePull.state === true) {
            console.log('player was pre pulling. reset');
            player.prePull = {
              state: false,
              count: 0,
              limit: player.prePull.limit,
              targetCell: undefined,
              direction: '',
              puller: 0,
            }


            if (player.newPushPullDelay.state !== true) {
              player.newPushPullDelay.state = true
            }


          }



          if (player.popups.find(x=>x.msg === 'defending')) {
            player.popups.splice(player.popups.findIndex(x=>x.msg === 'defending'),1)
          }
          if (player.falling.state !== true && player.moving.state !== true) {
            player.action = 'idle';
          }
          // if (!player.popups.find(x=>x.msg === 'defendFeint3')) {
          //   player.popups.push(
          //     {
          //       state: false,
          //       count: 0,
          //       limit: 15,
          //       type: '',
          //       position: '',
          //       msg: 'defendFeint3',
          //       img: '',
          //
          //     }
          //   )
          // }

        }


        // ATTACK FEINT
        if (this.keyPressed[player.number-1].attack === false && player.attacking.state === true) {

            let atkPeak;
            let atkType = player.currentWeapon.type;
            let blunt = 'normal';
            if (player.currentWeapon.name === "") {
              atkPeak = this.attackAnimRef.peak.unarmed;
              atkType = "unarmed";
            }
            else {
              atkPeak = this.attackAnimRef.peak[player.currentWeapon.type];
            }
            if (player.bluntAttack === true) {
              blunt = 'blunt';
            }

            if (player.attacking.count < atkPeak) {
                // console.log('attack windup key release before peak. feinting. refund stamina part');
                player.bluntAttack = false
                player.action = 'idle';
                player.attacking = {
                  state: false,
                  count: 0,
                  limit: player.attacking.limit,
                }
                player.attackStrength = 0;
                player.stamina.current += this.staminaCostRef.attack[atkType][blunt].pre;

                if (player.elasticCounter.state === true && player.elasticCounter.type === "attacking") {

                  player.elasticCounter.state = false;
                }
            }
            let popup = player.popups.find(x=>x.msg === 'attacking')
            if (popup) {
              player.popups.splice(player.popups.findIndex(x=>x.msg === 'attacking'),1)
            }

            // if (!player.popups.find(x=>x.msg === 'attackFeint3')) {
            //   player.popups.push(
            //     {
            //       state: false,
            //       count: 0,
            //       limit: 15,
            //       type: '',
            //       position: '',
            //       msg: 'attackFeint3',
            //       img: '',
            //
            //     }
            //   )
            // }

        }


        // DODGE RELEASE/FEINT
        if (player.dodging.countState === true && player.dodging.count <= (player.dodging.peak.start - player.crits.dodge) && this.keyPressed[player.number-1].dodge !== true && player.flanking.state !== true) {
          // console.log('released dodge key while winding up. cancel dodge.');
          player.stamina.current += this.staminaCostRef.dodge.pre;
          player.action = 'idle';
          player.dodging = {
            countState: false,
            state: false,
            count: 0,
            limit: player.dodging.limit,
            peak: {
              start: player.dodging.peak.start,
              end: player.dodging.peak.end,
            }
          }
          if (player.elasticCounter.state === true && player.elasticCounter.type === "dodging") {

            player.elasticCounter.state = false;
          }

          if (player.popups.find(x=>x.msg === 'dodging')) {
            player.popups.splice(player.popups.findIndex(x=>x.msg === 'dodging'),1)
          }
          // if (!player.popups.find(x=>x.msg === 'dodgeFeint')) {
          //   player.popups.push(
          //     {
          //       state: false,
          //       count: 0,
          //       limit: 15,
          //       type: '',
          //       position: '',
          //       msg: 'dodgeFeint',
          //       img: '',
          //
          //     }
          //   )
          // }
        }


        // STRAFE RELEASE
        if (player.strafeReleaseHook === true ) {
          player.strafing.state = false;
          player.strafeReleaseHook = false;
          this.getTarget(player);
          // console.log('strafe release hook');
        }


        // ITEM PICKUP/DROP ANIM COUNTER!
        if (player.itemDrop.state === true) {
          if (player.itemDrop.count < player.itemDrop.limit) {
            player.itemDrop.count++
            // console.log('dropping item anim');
          }
          else if (player.itemDrop.count >= player.itemDrop.limit) {
            player.itemDrop = {
              state: false,
              count: 0,
              limit: 10,
              item: {
                name: '',
              },
              gear: {
                type: '',
              }
            }
          }
        }
        if (player.itemPickup.state === true) {
          if (player.itemPickup.count < player.itemPickup.limit) {
            player.itemPickup.count++
            // console.log('picking item anim');
          }
          else if (player.itemPickup.count >= player.itemPickup.limit) {
            player.itemPickup = {
              state: false,
              count: 0,
              limit: 10,
              item: {
                name: '',
              },
              gear: {
                type: '',
              }
            };
          }
        }


        // CELL BY CELL MOVEMENT DELAY COUNTER!
        if (player.newMoveDelay.state === true) {
          if (player.newMoveDelay.count < player.newMoveDelay.limit) {
            player.newMoveDelay.count++;
            // console.log('newMoveDelay.count',player.newMoveDelay.count);
          }
          if (player.newMoveDelay.count >= player.newMoveDelay.limit) {
            player.newMoveDelay = {
              state: false,
              count: 0,
              limit: player.newMoveDelay.limit,
            }
          }
        }


        // ATTACKING!
        if (player.attacking.state === true) {

          let attackPeak = this.attackAnimRef.peak[player.currentWeapon.type];
          let stamAtkType = player.currentWeapon.type;

          if (player.currentWeapon.type === '') {
            this.players[player.number-1].attacking.limit = this.attackAnimRef.limit.unarmed;
            attackPeak = this.attackAnimRef.peak.unarmed;
            stamAtkType = 'unarmed';
          }
          let blunt = 'normal';
          if (player.bluntAttack === true) {
            blunt = 'blunt';
          }
          player.attacking.limit = this.attackAnimRef.limit[stamAtkType];


          // STEP ATTACK COUNT & CELLS UDER PRE-ATTACK
          if (player.attacking.count < this.attackAnimRef.limit[stamAtkType]) {
            if (player.attacking.count < attackPeak) {
              // console.log('attack wind up',player.attacking.count,'player',player.number);
            }
            player.attackPeak = false;
            player.action = 'attacking';
            player.attacking.count++;

            // APPLY BLUNT ATTACK
            if (player.dodging.countState === true || player.dodging.state === true || this.keyPressed[player.number-1].dodge === true) {
              console.log('was attacking then pressed dodging. blunt attack');
              player.dodging = {
                countState: false,
                state: false,
                count: 0,
                limit: 20,
                peak: {
                  start: 5,
                  end: 10,
                }
              };
              this.keyPressed[player.number-1].dodge = false;
              player.bluntAttack = true;
              if (player.elasticCounter.state === true && player.elasticCounter.type === "dodging") {
                player.elasticCounter.state = false;
              }
            }



            if (player.attacking.count <= 2) {

              // if (player.attacking.count === 1) {
              //   this.setElasticCounter('attacking',"",false,player);
              // }

              if (!player.popups.find(x => x.msg === 'attackStart')) {
                player.popups.push(
                  {
                    state: false,
                    count: 0,
                    limit: 5,
                    type: '',
                    position: '',
                    msg: 'attackStart',
                    img: '',

                  }
                )
              }


                this.getTarget(player)
                // CELLS UNDER PRE ATTACK!
                let cellUnderPreAttack1 = this.gridInfo.find(elem => elem.number.x === player.target.cell1.number.x && elem.number.y === player.target.cell1.number.y)
                let cellUnderPreAttack2;
                if (player.currentWeapon.type === 'spear') {
                  cellUnderPreAttack2 = this.gridInfo.find(elem => elem.number.x === player.target.cell2.number.x && elem.number.y === player.target.cell2.number.y)
                }
                if (player.currentWeapon.type === 'spear') {

                  this.cellsUnderPreAttack.push(
                    {
                      number: {
                        x: player.target.cell1.number.x,
                        y: player.target.cell1.number.y,
                      },
                      count: 1,
                      limit: 8,
                    },
                  )
                  this.cellsUnderPreAttack.push(
                    {
                      number: {
                        x: player.target.cell2.number.x,
                        y: player.target.cell2.number.y,
                      },
                      count: 1,
                      limit: 8,
                    },
                  )


                }
                else if (player.currentWeapon.type === 'sword' || player.currentWeapon.type === '') {
                  // console.log('sword target',player.target);

                  this.cellsUnderPreAttack.push({
                    number: {
                      x: player.target.cell1.number.x,
                      y: player.target.cell1.number.y,
                    },
                    count: 1,
                    limit: 8,
                  })

                }

                // console.log('this.cellsUnderPreAttack',this.cellsUnderPreAttack[0],this.cellsUnderPreAttack[1]);

                // CAMERA ATTACK FOCUS
                if (
                  this.settingAutoCamera === false &&
                  player.ai.state !== true &&
                  this.camera.preInstructions.length === 0 &&
                  this.camera.instructions.length === 0
                ) {
                  // this.setAutoCamera('attackFocus',player)
                }
                else {
                  console.log('no setting auto cam: attackFocus');
                }

            }
            if (player.attacking.count > 2) {

              if (!player.popups.find(x => x.msg === "attacking")) {
                let limit = this.attackAnimRef.limit[stamAtkType]-player.attacking.count;
                if (limit === 0) {
                  limit = 5;
                }
                if (!player.popups.find(x=>x.msg === "attacking")) {
                  player.popups.push(
                    {
                      state: false,
                      count: 0,
                      limit: limit,
                      type: '',
                      position: '',
                      msg: 'attacking',
                      img: '',

                    }
                  )
                }

              }
              // else {
              //   console.log('beep2',this.attackAnimRef.limit[stamAtkType]-player.attacking.count);
              //   player.popups.find(x => x.msg === "attacking").limit = this.attackAnimRef.limit[stamAtkType]-player.attacking.count
              // }
            }

          }


          // TIME TO ATTACK IS NOW!
          if (player.attacking.count === attackPeak) {

            this.setElasticCounter('attacking',"",false,player);

            // console.log('attack peak',player.attacking.count,'plyr',player.number);

            // WEAPON STAMINA COST!!
            if (player.stamina.current - this.staminaCostRef.attack[stamAtkType][blunt].peak >= 0) {
                player.stamina.current -= this.staminaCostRef.attack[stamAtkType][blunt].peak;
                player.attackPeak = true;

              let melee = true;
              // CREATE NEW PROJECTILE
              if (player.currentWeapon.type === 'crossbow' && player.bluntAttack !== true && player.items.ammo > 0) {
                // console.log('firing crossbow');
                melee = false;
                let plyrX = player;
                let origin = plyrX.currentPosition.cell;
                let currentPosition = plyrX.currentPosition.cell;
                let nextPosition = plyrX.currentPosition.cell.center;
                let elevation = this.gridInfo.find(elem => elem.number.x === player.currentPosition.cell.number.x && elem.number.y === player.currentPosition.cell.number.y).elevation.number;


                let projectileId = this.projectiles.length;
                let boltx = {
                  id: '000'+projectileId+'',
                  type: 'bolt',
                  owner: plyrX.number,
                  origin: origin,
                  direction: plyrX.direction,
                  moving: {
                    state: false,
                    step: 0,
                    course: '',
                    origin: {
                      number: currentPosition.number,
                      center: currentPosition.center,
                    },
                    destination: {
                      x: 0,
                      y: 0,
                    }
                  },
                  currentPosition: {
                    number: currentPosition.number,
                    center: currentPosition.center
                  },
                  nextPosition: {
                    x: nextPosition.x,
                    y: nextPosition.y,
                  },
                  target: {
                    path: [],
                    free: true,
                    occupant: {
                      type: '',
                      player: '',
                    },
                    void: false,
                  },
                  speed: this.projectileSpeed,
                  elevation: elevation,
                  kill: false,
                }
                this.projectiles.push(boltx)
                player.items.ammo--
                player.currentWeapon.effect = 'ammo+0';

                this.getBoltTarget(boltx)

                if (!player.popups.find(x=>x.msg === 'attacking')) {
                  player.popups.push(
                    {
                      state: false,
                      count: 0,
                      limit: (this.attackAnimRef.limit[player.currentWeapon.type]-this.attackAnimRef.peak[player.currentWeapon.type]),
                      type: '',
                      position: '',
                      msg: 'attacking',
                      img: '',

                    }
                  )
                }

                // STAMINA COST!!

                // this.players[player.number-1].stamina.current = this.players[player.number-1].stamina.current - this.staminaCostRef.attack.crossbow;
                // console.log('start projectile',boltx.currentPosition.number, this.players[boltx.owner-1].currentPosition.cell.number,this.projectiles);

                // this.boltCrementer(bolt)
              }
              // NO PROJECTILE AMMO
              if (player.currentWeapon.type === 'crossbow' && player.bluntAttack !== true && player.items.ammo <= 0) {
                // console.log('no ammo!');
                this.players[player.number-1].statusDisplay = {
                  state: true,
                  status: 'out of ammo',
                  count: 1,
                  limit: this.players[player.number-1].statusDisplay.limit,
                }
                player.currentWeapon.effect = 'ammo+0'

                if (!player.popups.find(x=>x.msg === 'outOfAmmo')) {
                  player.popups.push(
                    {
                      state: false,
                      count: 0,
                      limit: 30,
                      type: '',
                      position: '',
                      msg: 'outOfAmmo',
                      img: '',

                    }
                  )
                }

              }


              if (melee === true ) {

                this.getTarget(player);
                this.meleeAttackPeak(player);

              }


            }

            // OUT OF STAMINA
            else {
              player.attacking.count = attackPeak+1;
              player.stamina.current = 0;
              player.statusDisplay = {
                state: true,
                status: "Out of Stamina",
                count: 1,
                limit: player.statusDisplay.limit,
              }
            }

          }


          // ATTACK COOLDOWN AND END!
          if (player.attacking.count > attackPeak && player.attacking.count < this.attackAnimRef.limit[stamAtkType]) {
            // console.log('attack cooldown',player.attacking.count);
            player.attackPeak = false;
            player.bluntAttack = false;
          }
          if (player.attacking.count >= this.attackAnimRef.limit[stamAtkType]) {
            // console.log('attack end',player.attacking.count);

            player.attacking = {
              state: false,
              count: 0,
              limit: player.attacking.limit
            }
            player.attackStrength = 0;
            player.bluntAttack = false;
            player.action = 'idle';

            if (
              this.settingAutoCamera === false &&
              player.ai.state !== true &&
              this.camera.preInstructions.length === 0 &&
              this.camera.instructions.length === 0
            ) {
              // this.setAutoCamera('attackFocusBreak',player)
            }

            else {
              console.log('no setting auto cam: attackFocusBreak');
            }

            // if (player.popups.find(x=>x.msg === 'attacking')) {
            //   player.popups.splice(player.popups.findIndex(x=>x.msg === 'attacking'),1)
            // }

            // console.log('attack end');

          }

        }
        // CLASHING
        if (player.clashing.state === true) {
          if (player.clashing.count < player.clashing.limit) {
            player.clashing.count++;
          }
          if (player.clashing.count >= player.clashing.limit) {
            player.clashing = {
              state: false,
              count: 0,
              limit: 10,
            }
          }

        }



        // DEFENDING!!
        if (player.defending.state === true) {

          let defendType = player.currentWeapon.type;
          if ( player.currentWeapon.name === "") {
            defendType  = "unarmed";
          }
          let defendPeak = this.defendAnimRef.peak[defendType];
          player.defending.limit = this.defendAnimRef.limit[defendType];

          if (player.defending.count < defendPeak && player.defendDecay.state !== true) {
            player.defending.count++;
            player.action = 'defending';
            player.defendPeak = false;
            // console.log('defend winding up',player.defending.count, 'player',player.number,defendPeak);
            if (!player.popups.find(x=>x.msg === 'defending')) {
              player.popups.push(
                {
                  state: false,
                  count: 0,
                  limit: player.defending.limit,
                  type: '',
                  position: '',
                  msg: 'defending',
                  img: '',

                }
              )

            }
          }

          // PEAK, START DECAY
          else if (player.defending.count >= defendPeak && player.defendDecay.state !== true) {
           // console.log('peak defend player',player.number);

           if (player.stamina.current - this.staminaCostRef.defend.peak >= 0) {
             player.action = 'defending';
             player.defending = {
               state: true,
               count: 0,
               limit: player.defending.limit,
             }
             player.defendPeak = true;
             player.stamina.current = player.stamina.current - this.staminaCostRef.defend.peak;
             player.defendDecay = {
               state: true,
               count: 0,
               limit: player.defending.limit-defendPeak,
             }

             if (!player.popups.find(x=>x.msg === 'defending')) {
               player.popups.push(
                 {
                   state: false,
                   count: 0,
                   limit: player.defending.limit,
                   type: '',
                   position: '',
                   msg: 'defending',
                   img: '',

                 }
               )

             }

           }
           else {

             console.log('not enough stamina for peak defend. reset stamina');
             player.action = "idle";
             player.defending = {
               state: false,
               count: 0,
               limit: player.defending.limit,
             }
             player.defendDecay = {
               state: true,
               count: player.defendDecay.limit-7,
               limit: player.defendDecay.limit,
             }
             player.stamina.current = 0;
             player.statusDisplay = {
               state: true,
               status: "Out of Stamina",
               count: 1,
               limit: player.statusDisplay.limit,
             }

             // player.popups.push(
             //   {
             //     state: false,
             //     count: 0,
             //     limit: 10,
             //     type: '',
             //     position: '',
             //     msg: 'outOfStamina',
             //     img: '',
             //
             //   }
             // )
           }

         };

          // DECAY!!
          if (player.defendDecay.state === true) {
            if (player.defendDecay.count < player.defendDecay.limit) {
              player.action = 'defending';
              player.defendDecay.count++;
              if (player.defendDecay.count === 5 ) {
                player.defendPeak = false;
              }

              if (!player.popups.find(x=>x.msg === 'defending')) {
                player.popups.push(
                  {
                    state: false,
                    count: 0,
                    limit: player.defendDecay.limit,
                    type: '',
                    position: '',
                    msg: 'defending',
                    img: '',

                  }
                )

              }
              // console.log('defend decay count',player.defendDecay.count,player.defending.state,player.action);
            }


            if (player.defendDecay.count >= player.defendDecay.limit) {
              player.defending = {
                state: false,
                count: 0,
                limit: player.defending.limit,
              }
              player.action = 'idle';
              // console.log('defend decay limit. drop defense',player.defending.state);
              player.defendDecay = {
                state: false,
                count: 0,
                limit: player.defendDecay.limit,
              }

              if (player.popups.find(x=>x.msg === 'defending')) {
                player.popups.splice(player.popups.findIndex(x=>x.msg === 'defending'),1)
              }
            }

          }


        }



        // PUSHING/PULLING
        // NEW PUSH/PULL DELAY AFTER LAST ATTEMPT
        if (player.newPushPullDelay.state === true) {
          if (player.newPushPullDelay.count < player.newPushPullDelay.limit) {
            player.newPushPullDelay.count++;
            // console.log('new push pull delay');
          }
          if (player.newPushPullDelay.count >= player.newPushPullDelay.limit) {
            player.newPushPullDelay.state = false;
            player.newPushPullDelay.count = 0;

          }
        }
        // PUSH KEY RELEASE
        if (player.prePush.state === true && this.keyPressed[player.number-1][player.prePush.direction] !== true) {
          // console.log('mid prePush but key released. reset prePush');
          player.prePush = {
            state: false,
            count: 0,
            limit: player.prePush.limit,
            targetCell: undefined,
            direction: "",
            pusher: undefined,
          }

          if (player.newPushPullDelay.state !== true) {
            player.newPushPullDelay.state = true
          }
        }
        // key release prepull check??
        // if (player.prePull.state === true && this.keyPressed[player.number-1][player.prePush.direction] !== true) {
        //   console.log('mid prePull but key released. reset prePull');
        //   player.prePull = {
        //     state: false,
        //     count: 0,
        //     limit: player.prePull.limit,
        //     targetCell: undefined,
        //     direction: "",
        //     puller: undefined,
        //   }
        // }


        // PULL CHECK
        if (this.keyPressed[player.number-1].defend === true && player.pulling.state !== true && player.turning.state !== true && player.postPull.state !== true) {
          this.getTarget(player);

          if (player.direction === 'south' && this.keyPressed[player.number-1].north === true) {
            if (player.target.cell1.occupant.type === "obstacle" && player.pulling.state !== true) {
              // console.log('pulling obstacle trigger north',player.prePull.state,player.prePull.count);
              this.preObstaclePullCheck(player,player.target,'north')
            }
            if (player.target.cell1.occupant.type === "player" && player.pulling.state !== true) {
              // console.log('pulling player trigger north',player.prePull.state,player.prePull.count);
              this.prePlayerPullCheck(player,player.target,'north')
            }
          }
          if (player.direction === 'north' && this.keyPressed[player.number-1].south === true) {

            if (player.target.cell1.occupant.type === "obstacle" && player.pulling.state !== true) {
              // console.log('pulling obstacle trigger south',player.prePull.state,player.prePull.count);
              this.preObstaclePullCheck(player,player.target,'south')
            }
            if (player.target.cell1.occupant.type === "player" && player.pulling.state !== true) {
              // console.log('pulling player trigger south',player.prePull.state,player.prePull.count);
              this.prePlayerPullCheck(player,player.target,'south')
            }
          }
          if (player.direction === 'west' && this.keyPressed[player.number-1].east === true) {

            if (player.target.cell1.occupant.type === "obstacle" && player.pulling.state !== true) {
              // console.log('pulling obstacle trigger east',player.prePull.state,player.prePull.count);
              this.preObstaclePullCheck(player,player.target,'east')
            }
            if (player.target.cell1.occupant.type === "player" && player.pulling.state !== true) {
              // console.log('pulling player trigger east',player.prePull.state,player.prePull.count);
              this.prePlayerPullCheck(player,player.target,'east')
            }
          }
          if (player.direction === 'east' && this.keyPressed[player.number-1].west === true) {

            if (player.target.cell1.occupant.type === "obstacle" && player.pulling.state !== true) {
              // console.log('pulling obstacle trigger west',player.prePull.state,player.prePull.count);
              this.preObstaclePullCheck(player,player.target,'west')
            }
            if (player.target.cell1.occupant.type === "player" && player.pulling.state !== true) {
              // console.log('pulling player trigger west',player.prePull.state,player.prePull.count);
              this.prePlayerPullCheck(player,player.target,'west')
            }
          }

        }
        if (player.postPull.state === true) {
          if (player.postPull.count < player.postPull.limit) {
            player.postPull.count++;
            // console.log('post pull count',player.postPull.count);
          }
          if (player.postPull.count >= player.postPull.limit) {
            // console.log('post pull limit');
            player.postPull = {
              state: false,
              count: 0,
              limit: player.postPull.limit
            };
          }
        }


        // // DODGE STEPPER!
        let dodgeCondition = false;
        if (player.crits.dodge > 4) {
          player.crits.dodge = 4;
        }
        if (player.dodging.countState === true && player.dodging.count <= (player.dodging.peak.start - player.crits.dodge) && this.keyPressed[player.number-1].dodge === true) {
          dodgeCondition = true;
        }
        if (player.dodging.countState === true && player.dodging.count > (player.dodging.peak.start - player.crits.dodge)) {
          dodgeCondition = true;
        }
        if (dodgeCondition === true && player.flanking.state !== true) {

          let startMod = player.crits.dodge;
          let endMod = player.crits.dodge;
          if (player.crits.dodge > 5) {
            player.crits.dodge = 5;
          }
          // START & ENDMODS CAN'T MAKE DODGE WIND UP & COOLDOWN < 2
          if (player.dodging.peak.start - startMod < 2) {
            startMod = player.dodging.peak.start-2;
          }
          if ((player.dodging.peak.end + endMod) > player.dodging.limit-2) {
            endMod = player.dodging.limit-(2+player.dodging.peak.end);
          }

          // HAVE STAMIN FOR DODGE
          if (player.dodging.count === 0) {

            if (player.stamina.current - this.staminaCostRef.dodge.peak >= 0) {
              player.stamina.current = player.stamina.current - this.staminaCostRef.dodge.peak;
              player.dodging.count++;
              player.action = 'dodging';

              // CHOOSE DODGE DIRECTION
              let whichDirection = this.rnJesus(1,2);
              let dodgeDirection;
              switch(player.direction) {
                  case 'north':
                  if (whichDirection === 1) {
                    dodgeDirection = 'east';
                  } else {
                    dodgeDirection = 'west';
                  }
                  break;
                  case 'south':
                  if (whichDirection === 1) {
                    dodgeDirection = 'east';
                  } else {
                    dodgeDirection = 'west';
                  }
                  break;
                  case 'east':
                  if (whichDirection === 1) {
                    dodgeDirection = 'north';
                  } else {
                    dodgeDirection = 'south';
                  }
                  break;
                  case 'west':
                  if (whichDirection === 1) {
                    dodgeDirection = 'north';
                  } else {
                    dodgeDirection = 'south';
                  }
                  break;
              }
              player.dodgeDirection = dodgeDirection;


              if (!player.popups.find(x => x.msg === "dodgeStart")) {
                player.popups.push(
                  {
                    state: false,
                    count: 0,
                    limit: 5,
                    type: '',
                    position: '',
                    msg: 'dodgeStart',
                    img: '',

                  }
                )
              }

              this.setElasticCounter('dodging',"",true,player);

            }


            else {

              player.stamina.current = 0;
              player.dodging = {
                countState: false,
                state: false,
                count: 0,
                limit: player.dodging.limit,
                peak: {
                  start: player.dodging.peak.start,
                  end: player.dodging.peak.end,
                }
              }
              player.action = 'idle';
              player.statusDisplay = {
                state: true,
                status: "Out of Stamina",
                count: 1,
                limit: player.statusDisplay.limit,
              }
            }


          }
          if (player.dodging.count >= 1 && player.dodging.count < player.dodging.limit) {
            player.dodging.count++
            player.action = 'dodging';
            // console.log('dodge count',player.dodging.count);


            if (!player.popups.find(x => x.msg === "dodging")) {
              player.popups.push(
                {
                  state: false,
                  count: 0,
                  limit: player.dodging.limit,
                  type: '',
                  position: '',
                  msg: 'dodging',
                  img: '',

                }
              )
            }

          }
          // PEAK START
          if (player.dodging.count === (player.dodging.peak.start - startMod)) {

            // player.popups.push(
            //   {
            //     state: false,
            //     count: 0,
            //     limit: (player.dodging.peak.end + endMod)-(player.dodging.peak.start + startMod),
            //     type: '',
            //     position: '',
            //     msg: 'dodgeSuccess',
            //     img: '',
            //
            //   }
            // )

          }

          // PEAK DURATION
          if (player.dodging.count > (player.dodging.peak.start - startMod) && player.dodging.count < (player.dodging.peak.end + endMod)) {
            player.dodging.state = true;

            // console.log('dodge peak',player.dodging.count);
          }



          // IF DODGE IS BEFORE OR AFTER PEAK, STATE OFF
          if (player.dodging.count < (player.dodging.peak.start - startMod) || player.dodging.count > (player.dodging.peak.end + endMod)) {
            player.dodging.state = false;
            player.dodgeDirection = '';
            // console.log('dodge peak off');
          }
          if (player.dodging.count >= player.dodging.limit) {
            player.action = 'idle';
            player.dodging = {
              countState: false,
              state: false,
              count: 0,
              limit: player.dodging.limit,
              peak: {
                start: player.dodging.peak.start,
                end: player.dodging.peak.end,
              }
            }
          }



        }


        // RESET MOVE SPEED POST PUSHBACK
        if (player.pushBack.state !== true && player.pushBack.prePushBackMoveSpeed !== 0) {

          player.speed.move = player.player.pushBack.prePushBackMoveSpeed;
          player.player.pushBack.prePushBackMoveSpeed = 0;
        }

        // COMPLETE PUSHBACK DEFLECT FLOW!
        if (player.pushBack.state === false && player.success.deflected.predeflect === true && player.moving.state === false) {
          // console.log('predefelct --> pushback ---> deflect');

          this.setDeflection(player,player.success.deflected.type,false);

        }

        // CONTINUE, COMPLETE PLAYER HALF PUSHBACK
        if (player.halfPushBack.state === true) {


          if (player.halfPushBack.countUp.state === true) {
            player.action = "deflected";

            if (player.halfPushBack.countUp.count < player.halfPushBack.countUp.limit) {

              if (player.halfPushBack.countUp.count === 1) {
                // console.log('player 1/2 pushback start');
              }

              player.halfPushBack.countUp.count++;
              // console.log('player 1/2 pushback count up',player.halfPushBack.countUp.count);
            }

            if (player.halfPushBack.countUp.count >= player.halfPushBack.countUp.limit) {
              player.halfPushBack.countUp = {
                state: false,
                count: 0,
                limit: player.halfPushBack.countUp.limit,
              }
              // console.log('player 1/2 pushback peak');
              // this.handleHalfPushBackResult('player',player);
              player.halfPushBack.countDown.state = true;
            }

          }

          if (player.halfPushBack.countDown.state === true) {

            if (player.halfPushBack.countDown.count < player.halfPushBack.countDown.limit) {
              player.halfPushBack.countDown.count++;
              // console.log('player 1/2 pushback count down',player.halfPushBack.countDown.count);
            }

            if (player.halfPushBack.countDown.count >= player.halfPushBack.countDown.limit) {
              player.halfPushBack.countDown = {
                state: false,
                count: 0,
                limit: player.halfPushBack.countDown.limit,
              }

              // console.log('player 1/2 pushback end');
              this.handleHalfPushBackResult('player',player);
              player.halfPushBack.state = false;
              player.action = "idle";
            }

          }


        }



        // ELASTIC COUNTER
        if (player.elasticCounter.state === true && player.elasticCounter.type !== "deflected") {
          player.action = player.elasticCounter.type;

          // IF PAUSE IS START, COUNT PAUSE 1ST
          if (player.elasticCounter.pause.preState === true && player.elasticCounter.pause.type === "start") {
            player.elasticCounter.pause.preState = false;
            player.elasticCounter.pause.state = true;
            // console.log('start pause, turn on pause');
          }

          // IF PAUSE IS NOT START, COUNT UP
          if (
            player.elasticCounter.pause.type !== "start" &&
            player.elasticCounter.countUp.state !== true &&
            player.elasticCounter.countDown.state !== true &&
            player.elasticCounter.pause.state !== true
          ) {
            player.elasticCounter.countUp.state = true
            // console.log('pause is not start. count up');
          }


          // COUNT UP
          if (player.elasticCounter.countUp.state === true) {

            if (player.elasticCounter.countUp.count < player.elasticCounter.countUp.limit) {

              if (player.elasticCounter.countUp.count === 0) {
                // console.log('elastic count up start');
              }

              player.elasticCounter.countUp.count++;
              // console.log('elastic counting up: ',player.elasticCounter.countUp.count);

            }

            // FINISH COUNT UP
            if (player.elasticCounter.countUp.count >= player.elasticCounter.countUp.limit) {

              // RESET COUNT UP
              player.elasticCounter.countUp = {
                state: false,
                count: 0,
                limit: player.elasticCounter.countUp.limit,
              }
              // console.log('finished count up. elastic counter peak');

              // IF PAUSE IS PEAK, COUNT PAUSE AT PEAK
              if (
                player.elasticCounter.pause.preState === true &&
                player.elasticCounter.pause.type === "peak") {
                player.elasticCounter.pause.preState = false;
                player.elasticCounter.pause.state = true;
                // console.log('peak pause. turn on pause');
              }

              // IF PAUSE IS NOT PEAK, COUNT DOWM
              if (
                player.elasticCounter.pause.type !== "peak"
              ) {
                player.elasticCounter.countDown.state = true;
                // console.log('pause is not peak. count down');
              }

            }

          }

          // COUNT PAUSE
          if (player.elasticCounter.pause.state === true) {
            // console.log('pause count. type: ',player.elasticCounter.pause.type);

            // COUNT PAUSE
            if (player.elasticCounter.pause.count < player.elasticCounter.pause.limit) {

              if (player.elasticCounter.pause.count === 0) {
                // console.log('pause count start');
              }

              player.elasticCounter.pause.count++;
              // console.log('pause counting: ',player.elasticCounter.pause.count);
            }

            // FINISH PAUSE
            if (player.elasticCounter.pause.count >= player.elasticCounter.pause.limit) {
              // console.log('pause count finished');

              // IF PAUSE IS START, COUNT UP
              if (player.elasticCounter.pause.type === "start") {
                player.elasticCounter.countUp.state = true;
                // console.log('start pause count finished. count up');
              }

              // IF PAUSE IS PEAK, COUNT DOWN
              if (player.elasticCounter.pause.type === "peak") {
                player.elasticCounter.countDown.state = true;
                // console.log('peak pause count finished. count down');
              }

              // IF PAUSE IS END, TURN OFF ELASTIC COUNT
              if (player.elasticCounter.pause.type === "end") {
                player.elasticCounter.state = false;
                // console.log('end pause count finished. turn off elastic count');
              }

              // RESET PAUSE COUNT
              player.elasticCounter.pause.state = false;
              player.elasticCounter.pause.count = 0;

            }
          }

          // COUNT DOWN
          if (player.elasticCounter.countDown.state === true) {

            // COUNT DOWN
            if (player.elasticCounter.countDown.count < player.elasticCounter.countDown.limit) {

              if (player.elasticCounter.countDown.count === 1) {
                // console.log('elastic count down start',player.elasticCounter.countDown.limit);
              }

              player.elasticCounter.countDown.count++;
              // console.log('elastic counting down: ',player.elasticCounter.countDown.count);
            }

            // FINISH COUNT DOWN
            if (player.elasticCounter.countDown.count >= player.elasticCounter.countDown.limit) {
              player.elasticCounter.countDown = {
                state: false,
                count: 0,
                limit: player.elasticCounter.countDown.limit,
              }
              // console.log('finished count down.');

              // IF PAUSE IS END, COUNT PAUSE
              if (player.elasticCounter.pause.preState === true && player.elasticCounter.pause.type === "end") {
                player.elasticCounter.pause.preState = false;
                player.elasticCounter.pause.state = true;
                // console.log('end pause. turn on pause');
              }


              // IF PAUSE IS NOT END, TURN OFF ELASTIC COUNTER
              if (
                player.elasticCounter.pause.type !== "end"
              ) {
                player.elasticCounter.state = false;
                // console.log('pause is not end. turn off elastic count');
              }

              if (player.elasticCounter !== "dodging") {
                player.action = "idle";
              }

            }

          }

        }



        // DISCARD GEAR!!
        if (
          this.keyPressed[player.number-1].defend === true &&
          this.keyPressed[player.number-1].cycleWeapon === true &&
          player.discardGear.state !== true
        ) {

            this.discardGear(player,"weapon")
            player.discardGear.state = true;
        }
        if (
          this.keyPressed[player.number-1].defend === true &&
          this.keyPressed[player.number-1].cycleArmor === true &&
          player.discardGear.state !== true
        ) {

            this.discardGear(player,"armor")
            player.discardGear.state = true;
        }
        // DISCARD GEAR STEPPER!!
        if (player.discardGear.state === true) {
          if (player.discardGear.count < player.discardGear.limit) {
            player.discardGear.count++
          }
          else if (player.discardGear.count >= player.discardGear.limit) {
            player.discardGear = {
              state: false,
              count: 0,
              limit: player.discardGear.limit,
            }
          }
        }


        // WEAPON/ARMOR CYCLE CHECK!!
        if (this.keyPressed[player.number-1].cycleWeapon === true && player.cycleWeapon.state === false && player.defending.state !== true && this.keyPressed[player.number-1].defend === false) {


          if (player.cycleWeapon.count < player.cycleWeapon.limit) {
            player.cycleWeapon.count++
            // console.log('player.cycleWeapon.count',player.cycleWeapon.count);
          }
          if (player.cycleWeapon.count >= player.cycleWeapon.limit) {

            if (
              this.keyPressed[player.number-1].cycleWeapon === true &&
              player.items.weapons.length > 1
            ) {
              // console.log('cycling weapon',player.items);

              // let currentIndex = player.items.weapons.indexOf(player.currentWeapon);
              let currentIndex = player.items.weaponIndex;
              let newIndex;
              // console.log(player.items.weapons,player.currentWeapon,currentIndex,player.items.weapons[currentIndex]);
              if (currentIndex + 1 > player.items.weapons.length - 1) {
                newIndex = 0
              } else {
                newIndex = currentIndex+1;
              }
              player.items.weaponIndex = newIndex;
              player.currentWeapon = player.items.weapons[newIndex]

              if (!player.popups.find(x=>x.msg === player.items.weapons[newIndex].type)) {
                player.popups.push(
                  {
                    state: false,
                    count: 0,
                    limit: 30,
                    type: '',
                    position: '',
                    msg: player.items.weapons[newIndex].type,
                    img: '',

                  }
                )
              }

              // console.log(player.items.weapons,player.currentWeapon,newIndex,player.items.weapons[newIndex]);

            }
            if (
              this.keyPressed[player.number-1].cycleWeapon === true &&
              player.items.weapons.length === 1
            ) {

              if (player.currentWeapon.type === 'crossbow' && player.items.ammo === 0) {
                player.currentWeapon = {
                  name: '',
                  type: '',
                  effect: ''
                }
                console.log('only have empty crossbow left, switching to unarmed');
              } else {


              player.currentWeapon = player.items.weapons[0];
              // console.log('nothing to cycle through');
              this.players[player.number-1].statusDisplay = {
                state: true,
                status: 'no weapons to cycle!',
                count: 1,
                limit: this.players[player.number-1].statusDisplay.limit,
              }

              if (!player.popups.find(x=>x.msg === 'stop')) {
                player.popups.push(
                    {
                      state: false,
                      count: 0,
                      limit: 30,
                      type: '',
                      position: '',
                      msg: 'stop',
                      img: '',

                    }
                  )
              }

              }


            }

            player.cycleWeapon = {
              state: false,
              count: 0,
              limit: player.cycleWeapon.limit,
            }

            let myCell = this.gridInfo.find(cell => cell.number.x === player.currentPosition.cell.number.x && cell.number.y === player.currentPosition.cell.number.y)
            if (myCell.item.name !== '') {
              // console.log('found an item. picking it up');
              this.checkDestination(player)
            }
          }

        }
        else if (this.keyPressed[player.number-1].cycleWeapon === true && player.cycleWeapon.state === true) {
          console.log('already cycling weapon');
        }
        if (this.keyPressed[player.number-1].cycleArmor === true && player.cycleArmor.state === false && player.defending.state !== true && this.keyPressed[player.number-1].defend === false) {
          if (player.cycleArmor.count < player.cycleArmor.limit) {
            player.cycleArmor.count++
            // console.log('player.cycleArmor.count',player.cycleArmor.count);
          }
          if (player.cycleArmor.count >= player.cycleArmor.limit) {

            if (
              this.keyPressed[player.number-1].cycleArmor === true &&
              player.items.armor.length > 0
            ) {
              // console.log('cycling armor');

              // let currentIndex = player.items.armor.indexOf(player.currentArmor);
              let currentIndex = player.items.armorIndex;
              let newIndex;
              if (currentIndex + 1 > player.items.armor.length - 1) {
                newIndex = 0
              } else {
                newIndex = currentIndex+1;
              }


              switch(player.currentArmor.effect) {
                case 'hpUp' :
                  if (player.hp > 1) {
                    // console.log('armor cycle debuff hp',player.hp);
                    player.hp = player.hp - 1;
                    // console.log('armor cycle debuff hp',player.hp);
                  }
                break;
                case 'speedUp' :
                  let currentSpd1 = player.speed.range.indexOf(player.speed.move);
                  if (player.speed.move > .05) {
                    // console.log('armor cycle debuff speed',player.speed.move);
                    player.speed.move = player.speed.range[currentSpd1-1];
                    // console.log('armor cycle debuff speed',player.speed.move);
                  }
                break;
              }

              switch(player.items.armor[newIndex].effect) {
                case 'hpUp' :
                  if (player.hp < 3) {
                    // console.log('armor cycle buff hp',player.hp);
                    player.hp = player.hp + 1
                    // console.log('armor cycle buff hp',player.hp);

                    player.statusDisplay = {
                      state: true,
                      status: 'hpUp',
                      count: 1,
                      limit: player.statusDisplay.limit,
                    }
                  }
                break;
                case 'speedUp' :
                  let currentSpd2 = player.speed.range.indexOf(player.speed.move)
                  if (player.speed.move < .2) {

                    // console.log('armor cycle buff speed',player.speed.move);
                    player.speed.move = player.speed.range[currentSpd2+1]
                    // console.log('armor cycle buff speed',player.speed.move);

                    player.statusDisplay = {
                      state: true,
                      status: 'speedUp',
                      count: 1,
                      limit: player.statusDisplay.limit,
                    }
                  }
                break;
              }

              player.items.armorIndex = newIndex;
              player.currentArmor = player.items.armor[newIndex]

              if (player.items.armor[newIndex].type !== '' && !player.popups.find(x=>x.msg === player.items.armor[newIndex].type)) {
                player.popups.push(
                    {
                      state: false,
                      count: 0,
                      limit: 30,
                      type: '',
                      position: '',
                      msg: player.items.armor[newIndex].type,
                      img: '',

                    }
                  )
              }
              if (player.items.armor[newIndex].type === '' && !player.popups.find(x=>x.msg === 'stop')) {
                player.popups.push(
                    {
                      state: false,
                      count: 0,
                      limit: 30,
                      type: '',
                      position: '',
                      msg: 'stop',
                      img: '',

                    }
                  )
              }


            }
            if (
              this.keyPressed[player.number-1].cycleArmor === true &&
              player.items.armor.length === 0
            ) {
              console.log('no armor to cycle through');
              this.players[player.number-1].statusDisplay = {
                state: true,
                status: 'no armor to cycle!',
                count: 1,
                limit: this.players[player.number-1].statusDisplay.limit,
              }

              if (!player.popups.find(x=>x.msg === 'stop')) {
                player.popups.push(
                  {
                    state: false,
                    count: 0,
                    limit: 30,
                    type: '',
                    position: '',
                    msg: 'stop',
                    img: '',

                  }
                )
              }

            }

            player.cycleArmor = {
              state: false,
              count: 0,
              limit: player.cycleArmor.limit,
            }

            let myCell = this.gridInfo.find(cell => cell.number.x === player.currentPosition.cell.number.x && cell.number.y === player.currentPosition.cell.number.y)
            if (myCell.item.name !== '') {
              // console.log('found an item. picking it up');
              this.checkDestination(player)
            }
          }
        }
        else if (this.keyPressed[player.number-1].cycleArmor === true && player.cycleArmor.state === true) {
          console.log('already cycling armor');
        }


        // FLANKING!
        if (player.flanking.state === true) {

          // RESET DODGING
          this.players[player.number-1].dodging = {
            countState: false,
            state: false,
            count: 0,
            limit: player.dodging.limit,
            peak: {
              start: player.dodging.peak.start,
              end: player.dodging.peak.end,
            }
          }

          if (player.elasticCounter.state === true && player.elasticCounter.type === "dodging") {

            player.elasticCounter.state = false;
          }

          if (this.players[player.number-1].popups.find(x=>x.msg === 'dodging')) {
            this.players[player.number-1].popups.splice(this.players[player.number-1].popups.findIndex(x=>x.msg === 'dodging'),1)
          }



          if (player.flanking.step === 2) {
            console.log('flanking step 2 plyr dir: ',player.direction,' pre-flank dir: ',player.flanking.preFlankDirection,' flank dir: ',player.flanking.direction,"current position: ",player.currentPosition.cell.number,' strafing: ',player.strafing.state,' move step: ',player.moving.step);

            player.direction = this.getOppositeDirection(player.flanking.direction);
            player.turning.toDirection = this.getOppositeDirection(player.flanking.direction);

            player.flanking = {
              checking: false,
              direction: '',
              preFlankDirection: '',
              state: false,
              step: 0,
              target1: {x:0 ,y:0},
              target2: {x:0 ,y:0},
            }

            // if (player.popups.find(x=>x.msg === 'flanking2')) {
            //   player.popups.splice(player.popups.findIndex(y=>y.msg === 'flanking2'),1)
            // }

          }
          if (player.flanking.step === 1) {
            console.log('flanking step 1 plyr dir: ',player.direction,' pre-flank dir: ',player.flanking.preFlankDirection,' flank dir: ',player.flanking.direction,"current position: ",player.currentPosition.cell.number,' strafing: ',player.strafing.state,' move step: ',player.moving.step);
            let target = this.getTarget(player);

            let myCell = this.gridInfo.find(elem2 => elem2.number.x === player.currentPosition.cell.number.x && elem2.number.y === player.currentPosition.cell.number.y)
            let myCellBlock = this.checkMyCellBarrier(player.direction,myCell);


            if (target.cell1.free === true && myCellBlock !== true) {
              player.flanking.step = 2;
              player.flanking.target2 = target.cell1.number;
              // player.action = 'moving';
              player.action = 'flanking';
              player.moving = {
                state: true,
                step: 0,
                course: '',
                origin: {
                  number: {
                    x: player.currentPosition.cell.number.x,
                    y: player.currentPosition.cell.number.y
                  },
                  center: {
                    x: player.currentPosition.cell.center.x,
                    y: player.currentPosition.cell.center.y
                  },
                },
                destination: target.cell1.center
              }
              nextPosition = this.lineCrementer(player);
              player.nextPosition = nextPosition;

              if (player.ai.state === true) {
                this.keyPressed[player.number-1].dodge = false
              }

              if (!player.popups.find(x=>x.msg === "flanking2")) {
                player.popups.push(
                  {
                    state: false,
                    count: 0,
                    limit: 20,
                    type: '',
                    position: '',
                    msg: 'flanking2',
                    img: '',
                  }
                )
              }

              if (this.players[player.number-1].popups.find(x=>x.msg === 'dodging')) {
                this.players[player.number-1].popups.splice(this.players[player.number-1].popups.findIndex(x=>x.msg === 'dodging'),1)
              }
            }
            else {
              // console.log('cancel flanking 2');
              this.players[player.number-1].statusDisplay = {
                state: true,
                status: 'flanking cancelled!',
                count: 1,
                limit: this.players[player.number-1].statusDisplay.limit,
              }
              player.flanking = {
                checking: false,
                direction: '',
                state: false,
                step: 0,
                target1: {x:0 ,y:0},
                target2: {x:0 ,y:0},
              }

              if (player.popups.find(x=>x.msg === 'flanking2')) {
                player.popups.splice(player.popups.findIndex(y=>y.msg === 'flanking2'),1)
              }
              if (!player.popups.find(x=>x.msg === "noFlanking")) {
                player.popups.push(
                  {
                    state: false,
                    count: 0,
                    limit: 30,
                    type: '',
                    position: '',
                    msg: 'noFlanking',
                    img: '',
                  }
                )
              }

            }
          }
        }
        // START
        if (this.keyPressed[player.number-1].dodge === true && player.flanking.state !== true) {


          if (
            this.keyPressed[player.number-1].north === true ||
            this.keyPressed[player.number-1].south === true ||
            this.keyPressed[player.number-1].east === true ||
            this.keyPressed[player.number-1].west === true &&
            player.strafing.state !== true &&
            player.flanking.state !== true
          ) {

            // RESET DODGING
            this.players[player.number-1].dodging = {
              countState: false,
              state: false,
              count: 0,
              limit: player.dodging.limit,
              peak: {
                start: player.dodging.peak.start,
                end: player.dodging.peak.end,
              }
            }
            player.action = 'idle';



            if (player.dodging.countState === true || player.dodging.state === true) {

              this.players[player.number-1].stamina.current += this.staminaCostRef.dodge.pre;

            }

            if (keyPressedDirection !== player.direction) {

              let canFlank = false;
              switch(player.direction) {
                case 'north' :
                  if (keyPressedDirection === 'east' || keyPressedDirection === 'west') {
                    canFlank = true;
                  }
                break;
                case 'south' :
                  if (keyPressedDirection === 'east' || keyPressedDirection === 'west') {
                    canFlank = true;
                  }
                break;
                case 'west' :
                  if (keyPressedDirection === 'north' || keyPressedDirection === 'south') {
                    canFlank = true;
                  }
                break;
                case 'east' :
                  if (keyPressedDirection === 'north' || keyPressedDirection === 'south') {
                    canFlank = true;
                  }
                break;
              }

              if (canFlank === true) {

                if (player.stamina.current - this.staminaCostRef.flank >= 0) {

                  // console.log('flanking step',keyPressedDirection,player.direction);
                  this.players[player.number-1].flanking.checking = true;
                  this.players[player.number-1].flanking.direction = keyPressedDirection;
                  this.players[player.number-1].flanking.preFlankDirection = player.direction;

                  let target = this.getTarget(player);

                  let myCell = this.gridInfo.find(elem2 => elem2.number.x === player.currentPosition.cell.number.x && elem2.number.y === player.currentPosition.cell.number.y)
                  let myCellBlock = this.checkMyCellBarrier(keyPressedDirection,myCell);

                  // if (target.cell1.free === true) {
                  if (target.cell1.free === true && myCellBlock !== true) {

                    player.stamina.current = player.stamina.current - this.staminaCostRef.flank;
                    // console.log('flank stam check1. cost',this.staminaCostRef.flank,'stam',player.stamina.current);

                    // console.log('flanking step 0 plyr dir: ',player.direction,' pre-flank dir: ',player.flanking.preFlankDirection,' flank dir: ',player.flanking.direction,"current position: ",player.currentPosition.cell.number,' strafing: ',player.strafing.state,' move step: ',player.moving.step);

                    this.players[player.number-1].flanking.checking = false;
                    this.players[player.number-1].flanking.state = true;
                    this.players[player.number-1].flanking.step =  1;
                    this.players[player.number-1].flanking.target1 = target.cell1.number;
                    // console.log('this.players[player.number-1].flanking.target1',this.players[player.number-1].flanking.target1);
                    // player.action = 'moving';

                    if (!player.popups.find(x=>x.msg === "preAction2") && !player.popups.find(x=>x.msg === "dodgeStart")) {
                      player.popups.push(
                        {
                          state: false,
                          count: 0,
                          limit: 5,
                          type: '',
                          position: '',
                          msg: 'preAction2',
                          img: '',
                        }
                      )
                    }


                    player.action = 'flanking';
                    player.moving = {
                      state: true,
                      step: 0,
                      course: '',
                      origin: {
                        number: {
                          x: player.currentPosition.cell.number.x,
                          y: player.currentPosition.cell.number.y
                        },
                        center: {
                          x: player.currentPosition.cell.center.x,
                          y: player.currentPosition.cell.center.y
                        },
                      },
                      destination: target.cell1.center
                    }
                    nextPosition = this.lineCrementer(player);
                    player.nextPosition = nextPosition;

                    if (
                      this.mouseOverCell.state === true &&
                      this.mouseOverCell.cell.number.x === player.currentPosition.cell.number.x &&
                      this.mouseOverCell.cell.number.y === player.currentPosition.cell.number.y
                    ) {
                      this.clicked.player = undefined;
                    }

                  }
                  else {
                    // console.log('cancel flanking 1',player.flanking.direction,player.flanking.preFlankDirection,player.direction,player.action);
                    player.action = 'idle';
                    player.turning.toDirection = player.direction;


                    this.players[player.number-1].flanking.checking = false;
                    this.players[player.number-1].flanking.state = false;
                    this.players[player.number-1].flanking.direction = "";
                    this.players[player.number-1].flanking.preFlankDirection = "";

                    if (!player.popups.find(x=>x.msg === "noFlanking")) {
                      player.popups.push(
                        {
                          state: false,
                          count: 0,
                          limit: 30,
                          type: '',
                          position: '',
                          msg: 'noFlanking',
                          img: '',
                        }
                      )
                    }

                  }


                }
                else {
                  // console.log('flank stam check. cost',this.staminaCostRef.flank,'stam',player.stamina.current);
                  player.action = 'idle';
                  player.stamina.current = 0;
                  player.statusDisplay = {
                    state: true,
                    status: "Out of Stamina",
                    count: 1,
                    limit: player.statusDisplay.limit,
                  }

                }

              }
              else {
                // console.log('cant flank1');
              }

            }
            if (keyPressedDirection === player.direction) {
              console.log('!! dodge roll key combo!!');
            }
            else {
              // console.log('cant flank2');
            }
          }

        }



        // BREAK FROM PULLED/PUSHED CHECK
        let plyrPullPushed = false;
        let plyrPullPushedPlyr = 0;
        let breakPulledPushed = false;
        for(const plyr of this.players) {
          if (plyr.prePush.state === true) {
            if (plyr.target.cell1.number.x === player.currentPosition.cell.number.x && plyr.target.cell1.number.y === player.currentPosition.cell.number.y) {
              // console.log('player is being pre pushed by plyr',plyr.number);
              plyrPullPushed = true;
              plyrPullPushedPlyr = plyr.number;
            }
          }
          if (plyr.prePull.state === true) {
            if (plyr.target.cell1.number.x === player.currentPosition.cell.number.x && plyr.target.cell1.number.y === player.currentPosition.cell.number.y) {
              // console.log('player is being pre pulled by plyr',plyr.number);
              plyrPullPushed = true;
              plyrPullPushedPlyr = plyr.number;
            }
          }
        }


        // CAN READ MOVE INPUTS!!
        if (
          player.attacking.state === false &&
          player.defending.state === false &&
          player.defending.count < 1 &&
          player.dodging.state === false &&
          player.dodging.countState === false &&
          player.turning.state !== true &&
          player.postPull.state !== true &&
          player.defendDecay.state !== true &&
          player.flanking.state !== true &&
          player.jumping.state !== true &&
          player.turning.state !== true &&
          player.halfPushBack.state !== true &&
          player.elasticCounter.state !== true
        ) {
          // CONFIRM MOVE KEYPRESS!!
          if (
            this.keyPressed[player.number-1].north === true ||
            this.keyPressed[player.number-1].south === true ||
            this.keyPressed[player.number-1].east === true ||
            this.keyPressed[player.number-1].west === true ||
            this.keyPressed[player.number-1].northEast === true ||
            this.keyPressed[player.number-1].northWest === true ||
            this.keyPressed[player.number-1].southEast === true ||
            this.keyPressed[player.number-1].southWest === true
          ) {

            if (plyrPullPushed === true) {
              breakPulledPushed = true;
            }

            if (player.newMoveDelay.state !== true) {

              // MOVE IF DIRECTION ALIGNS & NOT STRAFING!!
              if (keyPressedDirection === player.direction && player.strafing.state === false) {

                let target = this.getTarget(player)

                if (target.cell1.free === true && player.target.cell1.void === false && target.myCellBlock !== true) {

                  if (player.dead.state === true && player.dead.count === 0) {

                    player.nextPosition = {
                      x: -30,
                      y: -30,
                    }

                  }

                  else if (player.turning.delayCount === 0) {

                    if (player.stamina.current - this.staminaCostRef.move >= 0) {

                      player.stamina.current -= this.staminaCostRef.move;

                      player.action = 'moving';
                      player.moving = {
                        state: true,
                        step: 0,
                        course: '',
                        origin: {
                          number: {
                            x: player.currentPosition.cell.number.x,
                            y: player.currentPosition.cell.number.y
                          },
                          center: {
                            x: player.currentPosition.cell.center,
                            y: player.currentPosition.cell.center
                          },
                        },
                        destination: target.cell1.center
                      }
                      nextPosition = this.lineCrementer(player);
                      player.nextPosition = nextPosition;

                      if (
                        this.mouseOverCell.state === true &&
                        this.mouseOverCell.cell.number.x === player.currentPosition.cell.number.x &&
                        this.mouseOverCell.cell.number.y === player.currentPosition.cell.number.y
                      ) {
                        this.clicked.player = undefined;
                      }

                    }
                    else {

                      player.stamina.current = 0;
                      player.statusDisplay = {
                        state: true,
                        status: 'Out of Stamina',
                        count: 0,
                        limit: player.statusDisplay.limit,
                      }

                    }

                  }

                }

                if (target.cell1.free !== true && target.myCellBlock !== true) {

                  if (target.cell1.occupant.type === "obstacle" && player.pushing.state !== true) {
                    this.preObstaclePushCheck(player,target)
                  }
                  if (target.cell1.occupant.type === "player" && player.pushing.state !== true) {
                    this.prePlayerPushCheck(player,target)
                  }
                  if (player.pushing.state === true) {
                    // console.log('You are already pushing something');
                  }
                }

                if (player.target.cell1.void === true && target.myCellBlock !== true) {
                  // console.log('target is VOID!!',target.cell1.center.x,target.cell1.center.y);


                  if (player.stamina.current - this.staminaCostRef.move >= 0) {

                    player.stamina.current -= this.staminaCostRef.move;

                    this.moveSpeed = player.speed.move;

                    player.moving = {
                      state: true,
                      step: 0,
                      course: '',
                      origin: {
                        number: player.currentPosition.cell.number,
                        center: player.currentPosition.cell.center,
                      },
                      destination: target.cell1.center
                    }

                    nextPosition = this.lineCrementer(player);
                    player.nextPosition = nextPosition;

                    if (
                      this.mouseOverCell.state === true &&
                      this.mouseOverCell.cell.number.x === player.currentPosition.cell.number.x &&
                      this.mouseOverCell.cell.number.y === player.currentPosition.cell.number.y
                    ) {
                      this.clicked.player = undefined;
                    }

                  }
                  else {

                    player.stamina.current = 0;
                    player.statusDisplay = {
                      state: true,
                      status: 'Out of Stamina',
                      count: 0,
                      limit: player.statusDisplay.limit,
                    }

                  }


                }

              }

            }

            // CHANGE DIRECTION IF NOT STRAFING!!
            if (keyPressedDirection !== player.direction && player.strafing.state === false && player.turning.state !== true) {

              // console.log('change player direction to',keyPressedDirection);
              // console.log('player',player.number,player.direction,' turn-start',keyPressedDirection);

              if (player.stamina.current - this.staminaCostRef.turn >= 0) {

                player.stamina.current -= this.staminaCostRef.turn;

                // console.log('start turning');
                player.turning.state = true;
                player.turning.toDirection = keyPressedDirection;

              }
              else {

                player.stamina.current = 0;
                player.statusDisplay = {
                  state: true,
                  status: 'Out of Stamina',
                  count: 0,
                  limit: player.statusDisplay.limit,
                }

              }

            }


            if (player.newMoveDelay.state !== true) {

              // MOVE WHILE STRAFING!!
              if (keyPressedDirection !== player.direction && player.strafing.state === true) {

                player.strafing.direction = keyPressedDirection;
                let target = this.getTarget(player);

                if (target.cell1.free === true && target.myCellBlock !== true) {

                  if (player.stamina.current - this.staminaCostRef.strafe >= 0) {

                    player.stamina.current -= this.staminaCostRef.strafe;
                    this.moveSpeed = player.speed.move;

                    // console.log('start strafing');
                    player.action = 'strafe moving';
                    player.moving = {
                      state: true,
                      step: 0,
                      course: '',
                      origin: {
                        number: {
                          x: player.currentPosition.cell.number.x,
                          y: player.currentPosition.cell.number.y
                        },
                        center: {
                          x: player.currentPosition.cell.center.x,
                          y: player.currentPosition.cell.center.y
                        },
                      },
                      destination: target.cell1.center
                    }
                    nextPosition = this.lineCrementer(player);
                    player.nextPosition = nextPosition;

                    if (
                      this.mouseOverCell.state === true &&
                      this.mouseOverCell.cell.number.x === player.currentPosition.cell.number.x &&
                      this.mouseOverCell.cell.number.y === player.currentPosition.cell.number.y
                    ) {
                      this.clicked.player = undefined;
                    }

                  }
                  else {

                    player.stamina.current = 0;
                    player.statusDisplay = {
                      state: true,
                      status: 'Out of Stamina',
                      count: 0,
                      limit: player.statusDisplay.limit,
                    }

                  }

                }

                if (target.cell1.free === false || target.myCellBlock === true) {
                  // console.log('here',player.direction);
                }
              }

              // JUMPING!!
              if (keyPressedDirection === player.direction && player.strafing.state === true && player.jumping.checking !== true && player.jumping.state !== true) {


                let alarmedPopup = false;
                this.players[player.number-1].jumping.checking = true;
                let target = this.getTarget(player);

                let myCell = this.gridInfo.find(elem => elem.number.x === player.currentPosition.cell.number.x && elem.number.y === player.currentPosition.cell.number.y)
                let cell1 = this.gridInfo.find(elem => elem.number.x === target.cell1.number.x && elem.number.y === target.cell1.number.y)
                let cell2 = this.gridInfo.find(elem => elem.number.x === target.cell2.number.x && elem.number.y === target.cell2.number.y)
                // console.log('cell1',cell1);
                // console.log('cell2',cell2);

                let cellsWithinBounds = true;
                if (!cell1 || !cell2) {
                  cellsWithinBounds = false;
                } else {
                  if (cell1.number.x < 0 || cell1.number.x > this.gridWidth) {
                    cellsWithinBounds = false;
                  }
                  if (cell1.number.y < 0 || cell1.number.y > this.gridWidth) {
                    cellsWithinBounds = false;
                  }
                }

                if (cellsWithinBounds === true) {

                  // CAN ONLY JUMP OVER HAZARDS, DEEP OR VOID
                  if (
                    cell1.void.state === true ||
                    cell1.terrain.type === 'deep' ||
                    cell1.terrain.type === 'hazard'
                  ) {
                    // console.log('a');

                    // CHECK ALL 3 JUMPING CELLS FOR BARRIERS BASED ON POSITION
                    let myCellBlocked = false;
                    let cell1BarrierFacing = false;
                    let cell2BarrierFacing = false;
                    if (myCell.barrier.state === true && myCell.barrier.position === player.direction) {
                      myCellBlocked = true;
                    }
                    if (cell1.barrier.state === true) {
                      switch (cell1.barrier.position) {
                        case 'north':
                          if (
                            player.direction === 'south' ||
                            player.direction === 'north'
                          ) {
                            cell1BarrierFacing = true;
                          }
                          break;
                        case 'south':
                          if (
                            player.direction === 'south' ||
                            player.direction === 'north'
                          ) {
                            cell1BarrierFacing = true;
                          }
                          break;
                        case 'east':
                          if (
                            player.direction === 'east' ||
                            player.direction === 'west'
                          ) {
                            cell1BarrierFacing = true;
                          }
                          break;
                        case 'west':
                          if (
                            player.direction === 'east' ||
                            player.direction === 'west'
                          ) {
                            cell1BarrierFacing = true;
                          }
                          break;
                        default:

                      }
                    }
                    if (cell2.barrier.state === true) {
                      switch (cell2.barrier.position) {
                        case 'north':
                          if (player.direction === 'south') {
                            cell2BarrierFacing = true;
                          }
                          break;
                        case 'south':
                          if (player.direction === 'north') {
                            cell2BarrierFacing = true;
                          }
                          break;
                        case 'east':
                          if (player.direction === 'west') {
                            cell2BarrierFacing = true;
                          }
                          break;
                        case 'west':
                          if (player.direction === 'east') {
                            cell2BarrierFacing = true;
                          }
                          break;
                        default:

                      }
                    }

                    if (
                      cell1.obstacle.state !== true &&
                      cell2.obstacle.state !== true &&
                      cell1BarrierFacing !== true &&
                      cell2BarrierFacing !== true &&
                      myCellBlocked !== true
                    ) {
                      // console.log('no obstacles at jump destination');

                      if (
                        cell2.void.state !== true &&
                        cell2.terrain.type !== 'deep'
                      ) {


                        if (player.stamina.current - this.staminaCostRef.jump >= 0) {

                          // console.log('can jump',player.stamina.current);
                          this.players[player.number-1].jumping.checking = false;
                          this.players[player.number-1].jumping.state = true;
                          player.action = 'jumping'
                          player.stamina.current = player.stamina.current - this.staminaCostRef.jump;

                          player.moving = {
                            state: true,
                            step: 0,
                            course: '',
                            origin: {
                              number: player.currentPosition.cell.number,
                              center: player.currentPosition.cell.center,
                            },
                            destination: target.cell2.center
                          }

                          nextPosition = this.lineCrementer(player);
                          // nextPosition = this.jumpCrementer(player);
                          player.nextPosition = nextPosition;

                          // RESET CELL INFO PLAYER
                          if (
                            this.mouseOverCell.state === true &&
                            this.mouseOverCell.cell.number.x === player.currentPosition.cell.number.x &&
                            this.mouseOverCell.cell.number.y === player.currentPosition.cell.number.y
                          ) {
                            this.clicked.player = undefined;
                          }

                        }
                        else {
                          // this.getTarget(player);
                          this.players[player.number-1].jumping.checking = false;
                          player.action = 'idle';
                          player.stamina.current = 0;
                          player.statusDisplay = {
                            state: true,
                            status: 'Out of Stamina',
                            count: 0,
                            limit: player.statusDisplay.limit,
                          }
                        }

                      } else {
                        // console.log('can only jump over voids or deep water cell 2');
                        this.players[player.number-1].jumping.checking = false;
                        alarmedPopup = true;

                      }


                      // JUMPING INTO PLYR OCCUPIED CELL CAUSES OVERLAP PUSHBACK. IF NOT USE THE FOLLOWING
                      // let targetOccupied = false;
                      // for (const plyr of this.players) {
                      //   if (
                      //     plyr.currentPosition.cell.number.x === player.target.cell2.number.x &&
                      //     plyr.currentPosition.cell.number.y === player.target.cell2.number.y
                      //   ) {
                      //     // console.log('c');
                      //     targetOccupied = true
                      //   }
                      //
                      // }
                      //
                      // if (targetOccupied !== true) {
                      //   if (
                      //     cell2.void.state !== true &&
                      //     cell2.terrain.type !== 'deep'
                      //   ) {
                      //     // console.log('can jump');
                      //     this.players[player.number-1].jumping.checking = false;
                      //     this.players[player.number-1].jumping.state = true;
                      //     player.action = 'jumping'
                      //     player.stamina.current = player.stamina.current - this.staminaCostRef.jump;
                      //
                      //     player.moving = {
                      //       state: true,
                      //       step: 0,
                      //       course: '',
                      //       origin: {
                      //         number: player.currentPosition.cell.number,
                      //         center: player.currentPosition.cell.center,
                      //       },
                      //       destination: target.cell2.center
                      //     }
                      //
                      //     nextPosition = this.lineCrementer(player);
                      //     // nextPosition = this.jumpCrementer(player);
                      //     player.nextPosition = nextPosition;
                      //   } else {
                      //     // console.log('can only jump over voids or deep water cell 2');
                      //     this.players[player.number-1].jumping.checking = false;
                      //   }
                      // }
                      // else {
                      //   // console.log('jump destination occupied');
                      //   this.players[player.number-1].jumping.checking = false;
                      // }

                    }
                    else {
                      // console.log('jump obstacle detected');
                      this.players[player.number-1].jumping.checking = false;
                      alarmedPopup = true;

                      if (cell1.obstacle.state === true) {
                        console.log("can't jump! obstacle in cell1");
                      }
                      if (cell2.obstacle.state === true) {
                        console.log("can't jump! obstacle in cell2");
                      }
                      if (myCellBlocked === true) {
                        console.log("can't jump! barrier in player cell blocking");
                      }
                      if (cell1BarrierFacing === true) {
                        console.log("can't jump! barrier cell 1 blocking");
                      }
                      if (cell2BarrierFacing === true) {
                        console.log("can't jump! barrier cell 2 blocking");
                      }

                    }
                  } else {
                    // console.log('can only jump over voids, hazards or deep water cell 2');
                    this.players[player.number-1].jumping.checking = false;
                    alarmedPopup = true;

                  }
                } else {
                  // console.log('cell out of bounds');
                  this.players[player.number-1].jumping.checking = false;
                  alarmedPopup = true;

                }

                if (alarmedPopup === true) {

                  if (!this.players[player.number-1].popups.find(x=>x.msg === 'alarmed')) {
                    this.players[player.number-1].popups.push(
                      {
                        state: false,
                        count: 0,
                        limit: 30,
                        type: '',
                        position: '',
                        msg: 'alarmed',
                        img: '',

                      }
                    )
                  }

                }

              }

            }

          }
        }


        // CAN READ NON-MOVE INPUTS!!
        if (
          player.strafing.state === false &&
          player.turning.state !== true &&
          player.postPull.state !== true &&
          player.halfPushBack.state !== true &&
          player.elasticCounter.state !== true
        ) {


          if (this.keyPressed[player.number-1].attack === true || this.keyPressed[player.number-1].defend === true) {

            // ALREADY ATTACKING/DEFENDING!!
            if (player.attacking.state === true || player.defending.state === true) {

              if (this.keyPressed[player.number-1].attack === true) {
                // console.log('already attacking');
              }
              if (this.keyPressed[player.number-1].defend === true) {
                // console.log('already defending',player.number);
              }

            }


            // START ATTACK/DEFEND!!
            if (player.attacking.state === false && player.defending.state === false && player.defendDecay.state !== true) {

              if (this.keyPressed[player.number-1].attack === true && player.success.deflected.state !== true && this.keyPressed[player.number-1].defend !== true) {

                let atkType = player.currentWeapon.type;
                let blunt = 'normal';
                if (player.bluntAttack === true) {
                  atkType = 'blunt';
                  blunt = 'blunt';
                }
                if (player.currentWeapon.name === "") {
                  atkType = 'unarmed';
                }

                // BLUNT ATTACK!!
                if (this.keyPressed[player.number-1].dodge === true) {
                  // console.log('start blunt attack');
                  if (player.dodging.countState === true || player.dodging.state === true || this.keyPressed[player.number-1].dodge === true) {
                    console.log('was dodging, now blunt attacking. cancel dodge. return dodge stamina');
                    player.stamina.current += this.staminaCostRef.dodge.peak;
                    player.dodging = {
                      countState: false,
                      state: false,
                      count: 0,
                      limit: 20,
                      peak: {
                        start: 5,
                        end: 10,
                      }
                    };
                    if (player.elasticCounter.state === true && player.elasticCounter.type === "dodging") {
                      player.elasticCounter.state = false;
                    }
                  }
                  this.keyPressed[player.number-1].dodge = false;

                  let popup = player.popups.find(x=>x.msg === 'dodging')
                  if (popup) {
                    player.popups.splice(player.popups.findIndex(x=>x.msg === 'dodging'),1)
                  }
                  let popup2 = player.popups.find(x=>x.msg === 'dodgeStart')
                  if (popup2) {
                    player.popups.splice(player.popups.findIndex(x=>x.msg === 'dodgeStart'),1)
                  }

                  player.bluntAttack = true;
                  atkType = 'blunt';
                }

                player.action = 'attacking';
                player.attacking = {
                  state: true,
                  count: 1,
                  limit: player.attacking.limit,
                }
                // console.log('start attack');

                if (plyrPullPushed === true) {
                  breakPulledPushed = true;
                }

              }

              if (this.keyPressed[player.number-1].defend === true && player.defendDecay.state !== true && this.keyPressed[player.number-1].attack !== true) {
                // console.log('start defending',player.number);

                // console.log('start defending');
                if (plyrPullPushed === true) {
                  breakPulledPushed = true;
                }

                if (player.defending.count === 0 && player.defendDecay.state !== true) {
                  player.defending = {
                    state: true,
                    count: 1,
                    limit: player.defending.limit,
                  }

                  if (!player.popups.find(x=>x.msg === 'preAction1')) {
                    player.popups.push(
                      {
                        state: false,
                        count: 0,
                        limit: 5,
                        type: '',
                        position: '',
                        msg: 'preAction1',
                        img: '',

                      }
                    )
                  }

                } else {
                  // console.log('cant start defend. might already be in progress');
                }


              }

            }
          }

          // DODGE START
          else if (this.keyPressed[player.number-1].dodge === true && this.keyPressed[player.number-1].attack !== true && this.keyPressed[player.number-1].defend !== true) {
            if (player.dodging.state !== true && player.dodging.countState !== true) {
              // console.log('start dodge wind up');
              player.dodging.countState = true;

              if (plyrPullPushed === true) {
                breakPulledPushed = true;
              }

            } else {
              // console.log('already dodging');
            }
          }
        }


        // BREAK FROM PULLED, PUSHED COMPLETE
        if (breakPulledPushed === true) {
          console.log('player ',player.number,' was being pre-pulled/pushed by ',plyrPullPushedPlyr,' break pulling/pushing and deflect?');

          let shouldDeflect = this.rnJesus(1,player.crits.guardBreak)
          if (shouldDeflect === 1) {

            this.setDeflection(this.players[plyrPullPushedPlyr-1],'bluntAttacked',false);

          }

          // POPUPS
          if (this.players[plyrPullPushedPlyr-1].prePush.state === true) {
            if (!this.players[plyrPullPushedPlyr-1].popups.find(x=>x.msg === "noPush")) {
              this.players[plyrPullPushedPlyr-1].popups.push(
                {
                  state: false,
                  count: 0,
                  limit: 25,
                  type: '',
                  position: '',
                  msg: 'noPush',
                  img: '',
                }
              )
            }

            if (this.players[plyrPullPushedPlyr-1].popups.find(x=>x.msg === 'prePush')) {
              this.players[plyrPullPushedPlyr-1].popups.splice(this.players[plyrPullPushedPlyr-1].popups.findIndex(x=>x.msg === 'prePush'),1)
            }
            if (this.players[plyrPullPushedPlyr-1].popups.find(x=>x.msg === 'noPush')) {
              this.players[plyrPullPushedPlyr-1].popups.splice(this.players[plyrPullPushedPlyr-1].popups.findIndex(x=>x.msg === 'canPush'),1)
            }


          }
          if (this.players[plyrPullPushedPlyr-1].prePull.state === true) {
            if (!this.players[plyrPullPushedPlyr-1].popups.find(x=>x.msg === "noPull")) {
              this.players[plyrPullPushedPlyr-1].popups.push(
                {
                  state: false,
                  count: 0,
                  limit: 25,
                  type: '',
                  position: '',
                  msg: 'noPull',
                  img: '',
                }
              )
            }

            if (this.players[plyrPullPushedPlyr-1].popups.find(x=>x.msg === 'prePull')) {
              this.players[plyrPullPushedPlyr-1].popups.splice(this.players[plyrPullPushedPlyr-1].popups.findIndex(x=>x.msg === 'prePull'),1)
            }
            if (this.players[plyrPullPushedPlyr-1].popups.find(x=>x.msg === 'canPull')) {
              this.players[plyrPullPushedPlyr-1].popups.splice(this.players[plyrPullPushedPlyr-1].popups.findIndex(x=>x.msg === 'canPull'),1)
            }


          }

          this.players[plyrPullPushedPlyr-1].pushing = {
            state: false,
            targetCell: undefined,
            moveSpeed: 0,
          };
          this.players[plyrPullPushedPlyr-1].pulling = {
            state: false,
            targetCell: undefined,
            moveSpeed: 0,
          };
          this.players[plyrPullPushedPlyr-1].prePush = {
            state: false,
            count: 0,
            limit: this.players[plyrPullPushedPlyr-1].prePush.limit,
            targetCell: undefined,
            direction: "",
            pusher: undefined,
          };
          this.players[plyrPullPushedPlyr-1].prePull = {
            state: false,
            count: 0,
            limit: this.players[plyrPullPushedPlyr-1].prePull.limit,
            targetCell: undefined,
            direction: "",
            puller: undefined,
          };

          if (this.players[plyrPullPushedPlyr-1].newPushPullDelay.state !== true) {
            this.players[plyrPullPushedPlyr-1].newPushPullDelay.state = true
          }



          if (this.players[plyrPullPushedPlyr-1].popups.find(x=>x.msg === 'prePush')) {
            this.players[plyrPullPushedPlyr-1].popups.splice(this.players[plyrPullPushedPlyr-1].popups.findIndex(x=>x.msg === 'prePush'),1)
          }
          if (this.players[plyrPullPushedPlyr-1].popups.find(x=>x.msg === 'prePull')) {
            this.players[plyrPullPushedPlyr-1].popups.splice(this.players[plyrPullPushedPlyr-1].popups.findIndex(x=>x.msg === 'prePull'),1)
          }


        }


      }


      // DISPLAY ATTACK AND DEFENSE SUCCESS!
      if (player.success.attackSuccess.state === true) {
        if (player.success.attackSuccess.count < player.success.attackSuccess.limit) {
          player.success.attackSuccess.count++
        }
        else if (player.success.attackSuccess.count >= player.success.attackSuccess.limit) {
          player.success.attackSuccess = {
            state: false,
            count: 0,
            limit: player.success.attackSuccess.limit
          }
        }
      }
      if (player.success.defendSuccess.state === true) {
        if (player.success.defendSuccess.count < player.success.defendSuccess.limit) {
          player.success.defendSuccess.count++
        }
        else if (player.success.defendSuccess.count >= player.success.defendSuccess.limit) {
          player.success.defendSuccess = {
            state: false,
            count: 0,
            limit: player.success.defendSuccess.limit
          }
        }
      }

    }
    else {
      // console.log('sorry no key presses right now. you are deflected');
    }


    // DEFLECTION ELASTIC COUNTER
    if (player.elasticCounter.state === true && player.elasticCounter.type === "deflected") {
      player.action = player.elasticCounter.type;


      // IF PAUSE IS START, COUNT PAUSE 1ST
      if (player.elasticCounter.pause.preState === true && player.elasticCounter.pause.type === "start") {
        player.elasticCounter.pause.preState = false;
        player.elasticCounter.pause.state = true;
        // console.log('start pause, turn on pause');
      }

      // IF PAUSE IS NOT START, COUNT UP
      if (
        player.elasticCounter.pause.type !== "start" &&
        player.elasticCounter.countUp.state !== true &&
        player.elasticCounter.countDown.state !== true &&
        player.elasticCounter.pause.state !== true
      ) {
        player.elasticCounter.countUp.state = true;
      }


      // COUNT UP
      if (player.elasticCounter.countUp.state === true) {

        if (player.elasticCounter.countUp.count < player.elasticCounter.countUp.limit+1) {

          if (player.elasticCounter.countUp.count === 0) {
            // console.log('elastic count up start');
          }

          player.elasticCounter.countUp.count++;
          // console.log('elastic counting up: ',player.elasticCounter.countUp.count);

        }

        // FINISH COUNT UP
        if (player.elasticCounter.countUp.count >= player.elasticCounter.countUp.limit+1) {

          // RESET COUNT UP
          player.elasticCounter.countUp = {
            state: false,
            count: 0,
            limit: player.elasticCounter.countUp.limit,
          }
          // console.log('finished count up. elastic counter peak');

          // IF PAUSE IS PEAK, COUNT PAUSE AT PEAK
          if (player.elasticCounter.pause.preState === true && player.elasticCounter.pause.type === "peak") {
            player.elasticCounter.pause.preState = false;
            player.elasticCounter.pause.state = true;
            // console.log('peak pause. turn on pause');
          }

          // IF PAUSE IS NOT PEAK, COUNT DOWM
          if (player.elasticCounter.pause.type !== "peak") {
            player.elasticCounter.countDown.state = true;
            // console.log('pause is not peak. count down');
          }

        }

      }

      // COUNT PAUSE
      if (player.elasticCounter.pause.state === true) {
        // console.log('pause count. type: ',player.elasticCounter.pause.type);

        // COUNT PAUSE
        if (player.elasticCounter.pause.count < player.elasticCounter.pause.limit+1) {

          if (player.elasticCounter.pause.count === 0) {
            // console.log('pause count start');
          }

          player.elasticCounter.pause.count++;
          // console.log('pause counting: ',player.elasticCounter.pause.count);
        }

        // FINISH PAUSE
        if (player.elasticCounter.pause.count >= player.elasticCounter.pause.limit+1) {
          // console.log('pause count finished');

          // IF PAUSE IS START, COUNT UP
          if (player.elasticCounter.pause.type === "start") {
            player.elasticCounter.countUp.state = true;
            // console.log('start pause count finished. count up');
          }

          // IF PAUSE IS PEAK, COUNT DOWN
          if (player.elasticCounter.pause.type === "peak") {
            player.elasticCounter.countDown.state = true;
            // console.log('peak pause count finished. count down');
          }

          // IF PAUSE IS END, TURN OFF ELASTIC COUNT
          if (player.elasticCounter.pause.type === "end") {
            player.elasticCounter.state = false;
            // player.action = "idle";
            // console.log('end pause count finished. turn off elastic count');
          }

          // RESET PAUSE COUNT
          player.elasticCounter.pause.state = false;
          player.elasticCounter.pause.count = 0;

        }
      }

      // COUNT DOWN
      if (player.elasticCounter.countDown.state === true) {

        // COUNT DOWN
        if (player.elasticCounter.countDown.count < player.elasticCounter.countDown.limit+1) {

          if (player.elasticCounter.countDown.count === 1) {
            // console.log('elastic count down start');
          }

          player.elasticCounter.countDown.count++;
          // console.log('elastic counting down: ',player.elasticCounter.countDown.count);
        }

        // FINISH COUNT DOWN
        if (player.elasticCounter.countDown.count >= player.elasticCounter.countDown.limit+1) {
          player.elasticCounter.countDown = {
            state: false,
            count: 0,
            limit: player.elasticCounter.countDown.limit,
          }
          // console.log('finished count down. elastic counter end');

          // IF PAUSE IS END, COUNT PAUSE
          if (player.elasticCounter.pause.preState === true && player.elasticCounter.pause.type === "end") {
            player.elasticCounter.pause.preState = false;
            player.elasticCounter.pause.state = true;

            // console.log('end pause. turn on pause');
          }

          // IF PAUSE IS NOT END, TURN OFF ELASTIC COUNTER
          if (player.elasticCounter.pause.type !== "end") {
            player.elasticCounter.state = false;
            player.action = "idle";

            // reset deflected here?
            // console.log('pause is not end. turn off elastic count',player.success.deflected.state,player.success.deflected.count,'/',player.success.deflected.limit);
          }


        }

      }

    }


    // OBSTACLE
    // MOVING & FALLING
    for(const cell of this.gridInfo) {


      if (cell.obstacle.state === true && cell.obstacle.moving.state === true && cell.obstacle.moving.falling.state !== true) {
        // console.log('tracking moving obstacle',cell.obstacle.moving.origin);

        let destCellRef = this.gridInfo.find(x => x.number.x === cell.obstacle.moving.destination.number.x && x.number.y === cell.obstacle.moving.destination.number.y)

        let obstacleCrementObj = undefined;
        if (!destCellRef) {
          obstacleCrementObj = this.obstacleMoveCrementer(cell,{center:cell.obstacle.moving.destination.center});
        }
        else {
          obstacleCrementObj = this.obstacleMoveCrementer(cell,destCellRef);
        }



        cell.obstacle.moving.nextPosition = obstacleCrementObj.pos;
        cell.obstacle.moving.step = obstacleCrementObj.step;
        nextPosition = obstacleCrementObj.pos;

        let atDestRanges = [false,false,false,false];

        let destRngIndx = undefined;
        if (
          nextPosition.x >= cell.obstacle.moving.destination.center.x-1 &&
          nextPosition.x <= cell.obstacle.moving.destination.center.x+1 &&
          nextPosition.y >= cell.obstacle.moving.destination.center.y-1 &&
          nextPosition.y <= cell.obstacle.moving.destination.center.y+1
        ) {
          atDestRanges[0] = true;
          destRngIndx = 0;
        }
        if (
          nextPosition.x === cell.obstacle.moving.destination.center.x-0.25 &&
          nextPosition.y === cell.obstacle.moving.destination.center.y+0.5
        ) {
          atDestRanges[1] = true;
          destRngIndx = 1;
        }
        if (
          nextPosition.x === cell.obstacle.moving.destination.center.x &&
          nextPosition.y === cell.obstacle.moving.destination.center.y
        ) {
          atDestRanges[2] = true;
          destRngIndx = 2;
        }
        if (
          nextPosition.x === cell.obstacle.moving.destination.center.x-5 &&
          nextPosition.y === cell.obstacle.moving.destination.center.y-5
        ) {
          atDestRanges[3] = true;
          destRngIndx = 3;
        }


        for (const el of atDestRanges) {
          if (el === true) {

            let indx = atDestRanges.indexOf(el);
            // console.log('obstacle at destination');

            if (destCellRef) {
              // console.log('obstacle at in bounds destination',cell.obstacle.moving.nextPosition);

              let cell2 = cell;
              let originLevelData = cell2.levelData.split("_");
              originLevelData[1] = "*";

              let originCellRef = this.gridInfo.find(x => x.number.x === cell.obstacle.moving.origin.number.x && x.number.y === cell.obstacle.moving.origin.number.y)
              let destCellRef = this.gridInfo.find(x => x.number.x === cell.obstacle.moving.destination.number.x && x.number.y === cell.obstacle.moving.destination.number.y)


              if (destCellRef.void.state === true || destCellRef.terrain.type === "deep") {

                destCellRef.obstacle = {
                  state: true,
                  name: cell2.obstacle.name,
                  type: cell2.obstacle.type,
                  hp: cell2.obstacle.hp,
                  destructible: cell2.obstacle.destructible,
                  locked: cell2.obstacle.locked,
                  weight: cell2.obstacle.weight,
                  height: cell2.obstacle.height,
                  items: cell2.obstacle.items,
                  effects: cell2.obstacle.effects,
                  moving: {
                    state: false,
                    step: 0,
                    origin: {
                      number: {
                        x: undefined,
                        y: undefined,
                      },
                      center: {
                        x: undefined,
                        y: undefined,
                      },
                    },
                    destination: {
                      number: {
                        x: undefined,
                        y: undefined,
                      },
                      center: {
                        x: undefined,
                        y: undefined,
                      },
                    },
                    currentPosition: {
                      x: undefined,
                      y: undefined,
                    },
                    nextPosition: {
                      x: destCellRef.center.x,
                      y: destCellRef.center.y,
                    },
                    moveSpeed: 0,
                    pushable: true,
                    pushed: false,
                    pusher: undefined,
                    falling: {
                      state: true,
                      count: 0,
                      limit: cell2.obstacle.moving.falling.limit,
                    }
                  }
                };


                destCellRef.obstacle.moving.nextPosition.x -= this.floorImageWidth/2;
                destCellRef.obstacle.moving.nextPosition.y -= this.floorImageHeight/2;

              }
              if (destCellRef.void.state !== true && destCellRef.terrain.type !== "deep") {
                destCellRef.obstacle = {
                  state: true,
                  name: cell2.obstacle.name,
                  type: cell2.obstacle.type,
                  hp: cell2.obstacle.hp,
                  destructible: cell2.obstacle.destructible,
                  locked: cell2.obstacle.locked,
                  weight: cell2.obstacle.weight,
                  height: cell2.obstacle.height,
                  items: cell2.obstacle.items,
                  effects: cell2.obstacle.effects,
                  moving: {
                    state: false,
                    step: 0,
                    origin: {
                      number: {
                        x: undefined,
                        y: undefined,
                      },
                      center: {
                        x: undefined,
                        y: undefined,
                      },
                    },
                    destination: {
                      number: {
                        x: undefined,
                        y: undefined,
                      },
                      center: {
                        x: undefined,
                        y: undefined,
                      },
                    },
                    currentPosition: {
                      x: undefined,
                      y: undefined,
                    },
                    nextPosition: {
                      x: undefined,
                      y: undefined,
                    },
                    moveSpeed: 0,
                    pushable: true,
                    pushed: false,
                    pusher: undefined,
                    falling: cell2.obstacle.moving.falling,
                  }
                };
              }

              destCellRef.levelData = cell2.levelData;

              originCellRef.obstacle = {
                state: false,
                name: '',
                type: '',
                hp: 0,
                destructible: {
                  state: false,
                  weapons: [],
                  leaveRubble: false,
                },
                locked: {
                  state: false,
                  key: '',
                },
                weight: 1,
                height: 0.5,
                items: [],
                effects: [],
                moving: {
                  state: false,
                  step: 0,
                  origin: {
                    number: {
                      x: undefined,
                      y: undefined,
                    },
                    center: {
                      x: undefined,
                      y: undefined,
                    },
                  },
                  destination: {
                    number: {
                      x: undefined,
                      y: undefined,
                    },
                    center: {
                      x: undefined,
                      y: undefined,
                    },
                  },
                  currentPosition: {
                    x: undefined,
                    y: undefined,
                  },
                  nextPosition: {
                    x: undefined,
                    y: undefined,
                  },
                  moveSpeed: 0,
                  pushable: true,
                  pushed: false,
                  pusher: undefined,
                  falling: {
                    state: false,
                    count: 0,
                    limit: 25,
                  },
                }
              };
              originCellRef.levelData = originLevelData.join("_");


              for(const obs of this.obstacleBarrierToDestroy) {
                if (originCellRef.number.x === obs.cell.number.x && originCellRef.number.y === obs.cell.number.y && destCellRef.void.state !== true) {
                  this.obstacleBarrierToDestroy.push({
                    type: 'obstacle',
                    action: 'damage',
                    count: 0,
                    limit: 30,
                    complete: false,
                    cell: destCellRef,
                  })
                }
              };

              this.obstacleCheckDestination(destCellRef,player);


            }
            else {

              // console.log('obstacle at out of bounds destination',cell.obstacle.moving.origin.center,cell.obstacle.moving.nextPosition);
              let cell2 = cell;
              let originLevelData = cell2.levelData.split("_");
              originLevelData[1] = "*";


              cell2.obstacle.moving.falling = {
                state: true,
                count: 0,
                limit: cell2.obstacle.moving.falling.limit,
              };


              cell2.obstacle.moving.nextPosition.x -= this.floorImageWidth/2;
              cell2.obstacle.moving.nextPosition.y -= this.floorImageHeight/2;

              this.obstaclesOutOfBoundsFall.push(cell2.obstacle);

              let originCellRef = this.gridInfo.find(x => x.number.x === cell.obstacle.moving.origin.number.x && x.number.y === cell.obstacle.moving.origin.number.y)


              originCellRef.obstacle = {
                state: false,
                name: '',
                type: '',
                hp: 0,
                destructible: {
                  state: false,
                  weapons: [],
                  leaveRubble: false,
                },
                locked: {
                  state: false,
                  key: '',
                },
                weight: 1,
                height: 0.5,
                items: [],
                effects: [],
                moving: {
                  state: false,
                  step: 0,
                  origin: {
                    number: {
                      x: undefined,
                      y: undefined,
                    },
                    center: {
                      x: undefined,
                      y: undefined,
                    },
                  },
                  destination: {
                    number: {
                      x: undefined,
                      y: undefined,
                    },
                    center: {
                      x: undefined,
                      y: undefined,
                    },
                  },
                  currentPosition: {
                    x: undefined,
                    y: undefined,
                  },
                  nextPosition: {
                    x: undefined,
                    y: undefined,
                  },
                  moveSpeed: 0,
                  pushable: true,
                  pushed: false,
                  pusher: undefined,
                  falling: {
                    state: false,
                    count: 0,
                    limit: 25,
                  },
                }
              };
              originCellRef.levelData = originLevelData.join("_");

            }


            break;
          }
        }

        // if (cell.obstacle.moving.step >= 1) {
        //
        // }

      }

      // step falling.count
      if (cell.obstacle.state === true && cell.obstacle.moving.falling.state === true) {
        // console.log('falling obstacle');
        if (cell.obstacle.moving.falling.count < cell.obstacle.moving.falling.limit) {
          cell.obstacle.moving.falling.count++;
          // console.log('obstacle falling in bounds a count',cell.obstacle.moving.falling.count,'position',cell.obstacle.moving.nextPosition);
        }
        if (cell.obstacle.moving.falling.count >= cell.obstacle.moving.falling.limit) {
          let cell2 = cell;
          let levelData = cell2.levelData.split("_");
          levelData[1] = "*";
          cell.levelData = levelData.join("_");
          cell.obstacle = {
            state: false,
            name: '',
            type: '',
            hp: 0,
            destructible: {
              state: false,
              weapons: [],
              leaveRubble: false,
            },
            locked: {
              state: false,
              key: '',
            },
            weight: 1,
            height: 0.5,
            items: [],
            effects: [],
            moving: {
              state: false,
              step: 0,
              origin: {
                number: {
                  x: undefined,
                  y: undefined,
                },
                center: {
                  x: undefined,
                  y: undefined,
                },
              },
              destination: {
                number: {
                  x: undefined,
                  y: undefined,
                },
                center: {
                  x: undefined,
                  y: undefined,
                },
              },
              currentPosition: {
                x: undefined,
                y: undefined,
              },
              nextPosition: {
                x: undefined,
                y: undefined,
              },
              moveSpeed: 0,
              pushable: true,
              pushed: false,
              pusher: undefined,
              falling: {
                state: false,
                count: 0,
                limit: 10,
              },
            }
          };
          // console.log('obstacle falling in bounds over');
        }
      }
    }
    for(const elem of this.obstaclesOutOfBoundsFall) {
      if (elem.moving.falling.count < elem.moving.falling.limit) {
        elem.moving.falling.count++;
        // obstacle.moving.nextPosition.y += (obstacle.moving.falling.count*5)
        // console.log('obstacle falling out of bounds a count',elem.moving.falling.count,'position',elem.moving.nextPosition);
      }
      if (elem.moving.falling.count >= elem.moving.falling.limit) {
        // console.log('obstacle falling out of bounds over');
        let index = this.obstaclesOutOfBoundsFall.indexOf(elem)
        this.obstaclesOutOfBoundsFall.splice(index,1)
      }
    }
    // OBSTACLE/BARRIER DAMAGE/DESTROY
    for(const cell of this.obstacleBarrierToDestroy) {
      if (cell.limit > 0) {
        if (cell.count < cell.limit) {
          cell.count++
        }
        else if (cell.count >= cell.limit) {
          let index = this.obstacleBarrierToDestroy.indexOf(cell)
          this.obstacleBarrierToDestroy.splice(index,1)
        }
      }
    }
    // HALF PUSHED BACK
    for (const halfPushBackObstacle of this.halfPushBackObstacles) {

      if (halfPushBackObstacle.state === true) {


        if (halfPushBackObstacle.countUp.state === true) {

          if (halfPushBackObstacle.countUp.count < halfPushBackObstacle.countUp.limit) {

            if (halfPushBackObstacle.countUp.count === 1) {
              // console.log('obstacle 1/2 pushback start');
            }

            halfPushBackObstacle.countUp.count++;
            // console.log('obstacle 1/2 pushback count up',halfPushBackObstacle.countUp.count);
          }

          if (halfPushBackObstacle.countUp.count >= halfPushBackObstacle.countUp.limit) {
            halfPushBackObstacle.countUp = {
              state: false,
              count: 0,
              limit: halfPushBackObstacle.countUp.limit,
            }

            // console.log('obstacle 1/2 pushback peak');
            // this.handleHalfPushBackResult('obstacle',halfPushBackObstacle);
            halfPushBackObstacle.countDown.state = true;
          }

        }

        if (halfPushBackObstacle.countDown.state === true) {

          if (halfPushBackObstacle.countDown.count < halfPushBackObstacle.countDown.limit) {
            halfPushBackObstacle.countDown.count++;
            // console.log('obstacle 1/2 pushback count down',halfPushBackObstacle.countDown.count);
          }

          if (halfPushBackObstacle.countDown.count >= halfPushBackObstacle.countDown.limit) {
            halfPushBackObstacle.countDown = {
              state: false,
              count: 0,
              limit: halfPushBackObstacle.countDown.limit,
            }

            // console.log('obstacle 1/2 pushback end');
            this.handleHalfPushBackResult('obstacle',halfPushBackObstacle);
            halfPushBackObstacle.state = false;
          }

        }


      }

      if (halfPushBackObstacle.state !== true) {
        let index = this.halfPushBackObstacles.indexOf(halfPushBackObstacle)
        this.halfPushBackObstacles.splice(index,1)
      }

    }


    // ITEMS TO DROP
    // -call itemdrop crementer and set position like w/ movement
    for(const cell of this.obstacleItemsToDrop) {
      if (cell.limit > 0) {
        if (cell.count < cell.limit) {
          cell.count++
        }
        else if (cell.count >= cell.limit) {
          let index = this.obstacleItemsToDrop.indexOf(cell)
          this.obstacleItemsToDrop.splice(index,1)
        }
      }
    }

    // ITEMS FALLING/SINKING



    // STATUS DISPLAY STEPPER!!
    if (player.statusDisplay.state === true && player.statusDisplay.count < player.statusDisplay.limit) {
      // console.log('stepping status display');
      player.statusDisplay.count++
    }
    else if (player.statusDisplay.state === true && player.statusDisplay.count >= player.statusDisplay.limit) {
      // console.log('hide status display');
      player.statusDisplay = {
        state: false,
        status: '',
        count: 0,
        limit: player.statusDisplay.limit,
      }
    }


    // POPUPS
    // Testing
    if (this.time === 100 || this.time === 300) {


      let newArray = [];
      let x = 0;
      let y = 0;
      for (const [key, value] of Object.entries(this.popupImageRef)) {
        newArray.push(key);
      }
      for (var i = 0; i < 20; i++) {
        // if (
        //   !player.popups.find(x => x.msg === newArray[i]) &&
        //   // player.number === 2 &&
        //   newArray[i] !==  "hpUp" &&
        //   newArray[i] !==  "hpDown"
        // ) {
        //   player.popups.push(
        //     {
        //       state: false,
        //       count: 0,
        //       limit: 30,
        //       type: '',
        //       position: '',
        //       msg: newArray[i],
        //       img: '',
        //       // cell: this.gridInfo.find(x => x.number.x === 4 && x.number.y === 4)
        //     }
        //   )
        // }
        // if (
        //   newArray[i] !==  "hpUp" &&
        //   newArray[i] !==  "hpDown" &&
        //   !this.cellPopups.find(x => x.msg === newArray[i] && x.cell.number.x === 1 && x.cell.number.y === 5)
        // ) {
        //   this.cellPopups.push(
        //     {
        //       state: false,
        //       count: 0,
        //       limit: 35,
        //       type: '',
        //       position: '',
        //       msg: newArray[i],
        //       img: '',
        //       cell: this.gridInfo.find(x => x.number.x === 1 && x.number.y === 5)
        //     }
        //   )
        // }
        // if (!this.cellPopups.find(x => x.msg === newArray[i] && x.cell.number.x === 4 && x.cell.number.y === 3)) {
        //   this.cellPopups.push(
        //     {
        //       state: false,
        //       count: 0,
        //       limit: 35,
        //       type: '',
        //       position: '',
        //       msg: newArray[i],
        //       color: '',
        //       img: '',
        //       cell: this.gridInfo.find(x => x.number.x === 4 && x.number.y === 3)
        //     }
        //   )
        // }
      };
    }
    //PLAYER
    if (player.popups.length > 0) {

      for (const popup of player.popups) {
        let indx = player.popups.findIndex(x=>x===popup);
        if (popup.state === true && popup.position !== "northWest") {
          if (popup.limit > 0) {
            if (popup.state === true && popup.count < popup.limit) {
              popup.count++
            }
            if (popup.count >= popup.limit) {
              player.popups.splice(indx,1)
            }
          }
          if (popup.limit === 0) {
            // check if the player state it relates to is true, if not remove it
          }

        }


      }

      let currentPopupCount = player.popups.filter(x=>x.state === true).length;
      for (const popup2 of player.popups) {
        if (currentPopupCount < 8) {
          let indx = player.popups.findIndex(x=>x===popup2);
          if (popup2.state === false) {
            popup2.state = true;
            currentPopupCount++;
            // console.log('turn on new popup',popup2.msg);
          }
        } else {
          // console.log('currentPopup display full..',popup2.msg);
        }
      }

    }
    // CELL
    if (this.cellPopups.length > 0) {

      for (const popup of this.cellPopups) {
        let indx = this.cellPopups.findIndex(x=>x===popup);
        if (popup.state === true) {
          if (popup.limit > 0) {
            if (popup.state === true && popup.count < popup.limit) {
              popup.count++
            }
            if (popup.count >= popup.limit) {
              this.cellPopups.splice(indx,1)
            }
          }
          if (popup.limit === 0) {
            // check if the player state it relates to is true, if not remove it
          }

        }


      }

      let currentPopupCount = this.cellPopups.filter(x=>x.state === true).length;
      for (const popup2 of this.cellPopups) {
        if (currentPopupCount < 8) {
          let indx = this.cellPopups.findIndex(x=>x===popup2);
          if (popup2.state === false) {
            popup2.state = true;
            currentPopupCount++;
            // console.log('turn on new popup',popup2.msg);
          }
        } else {
          // console.log('currentPopup display full..',popup2.msg);
        }
      }

    }


    // CAMERA
    // SWITCH ON
    if (this.setInitZoom.state === true) {


        if (this.setInitZoom.gridWidth >= 12) {

          if (this.setInitZoom.windowWidth < 1100) {

            if ((this.camera.zoom.x-1) >= -.25) {

              this.camera.zoom.x -= .04 ;
              this.camera.zoom.y -= .04 ;
              this.camera.zoomDirection = 'out';

              let zoom = this.camera.zoom.x;
              let diff = 1 - zoom;

              this.camera.zoomFocusPan.x = (diff*(canvas.width/2));
              this.camera.zoomFocusPan.y = (diff*(canvas.width/2))-(diff*(canvas.width/6));

              // this.setCameraFocus('input',canvas, context, canvas2, context2);
              this.findFocusCell('panToCell',{},canvas,context)
            }

            if ((this.camera.zoom.x-1) < -.25) {
              this.setInitZoom.state = false;
            }

          }
          if (this.setInitZoom.windowWidth > 1100) {

          }
        }

        if (this.setInitZoom.gridWidth < 12) {

          if (this.setInitZoom.windowWidth < 1100) {

            if ((this.camera.zoom.x-1) >= -.05) {

              this.camera.zoom.x -= .04 ;
              this.camera.zoom.y -= .04 ;
              this.camera.zoomDirection = 'in';

              let zoom = this.camera.zoom.x;
              let diff = 1 - zoom;

              this.camera.zoomFocusPan.x = (diff*(canvas.width/2));
              this.camera.zoomFocusPan.y = (diff*(canvas.width/2))-(diff*(canvas.width/6));



              // this.setCameraFocus('input',canvas, context, canvas2, context2);
              this.findFocusCell('panToCell',{},canvas,context)
            }

            if ((this.camera.zoom.x-1) < -.05) {
              this.setInitZoom.state = false;
            }

          }

        }

    }
    //INPUT MODE SWITCH
    if (this.toggleCameraMode === false && this.camera.state === true) {
      this.camera.startCount = 0;
    }
    if (this.camera.state === false && this.toggleCameraMode === false && this.camera.startCount >= this.camera.startLimit  && this.camera.instructionType === 'default') {
      // console.log('welcome to camera mode');
      this.camera.startCount = 0;
      this.camera.state = true;
      this.camera.fixed = true;
    }
    if (this.toggleCameraMode === true) {

      let state = this.toggleCameraMode;
      if (this.camera.state === false && state === true && this.camera.startCount < this.camera.startLimit) {

        this.camera.startCount++;
      }
      if (this.camera.state === true && state === true && this.camera.startCount < this.camera.startLimit) {
        // console.log('leaving camera mode ...');
        this.camera.startCount++;
      }
      if (this.camera.state === true && state === true && this.camera.startCount >= this.camera.startLimit) {
        // console.log('thank you for using the camera');
        this.camera.startCount = 0;
        this.camera.state = false;
        this.camera.fixed = false;
      }


    }
    //INDICATOR COUNTER
    if (this.camera.limits.state.zoom === true || this.camera.limits.state.pan === true) {
      if (this.camera.limits.state.count < this.camera.limits.state.limit) {
        this.camera.limits.state.count++
      }

    };
    if (this.camera.limits.state.zoom === true || this.camera.limits.state.pan === true) {
      if (this.camera.limits.state.count >= this.camera.limits.state.limit) {
        this.camera.limits.state.count = 0;
        this.camera.limits.state.zoom = false;
        this.camera.limits.state.pan = false;
      }

    };
    //INPUT MODE CONTROLS
    if (this.camera.state === true && this.camera.instructionType === 'default') {

      let setFocus = false;
      let setZoomPan = false;
      let findFocusCell = false;


      // IDLE ANIM STEPPER!
      if (player.action === 'idle') {
        // player.idleAnim.state = true
        if (player.idleAnim.count < player.idleAnim.limit) {
          // console.log('player.idleAnim.count',player.idleAnim.count);
          player.idleAnim.count++

        }
        if (player.idleAnim.count >= player.idleAnim.limit) {
          player.idleAnim.count = 0;
          player.idleAnim.state = false;
        }
      }
      else if (player.action !== 'idle') {
        // player.idleAnim.state = false;
        player.idleAnim.count = 0;
      }


      if (this.keyPressed[player.number-1].attack === true) {
        // if mode is pan and x or y are outside threshold +/- 2, log pan value, special value = true
        this.camera.mode = 'zoom';
      }
      if (this.keyPressed[player.number-1].defend === true) {
        this.camera.mode = 'pan';
      }

      if (this.camera.mode === 'zoom') {

        if (
          this.keyPressed[player.number-1].north === true &&
          this.keyPressed[player.number-1].south !== true &&
          this.camera.zoom.x < this.camera.limits.zoom.max
        ) {

          this.camera.zoom.x += .02 ;
          this.camera.zoom.y += .02 ;
          this.camera.zoomDirection = 'in';
          setFocus = true;
          setZoomPan = true;

          // console.log('zooming in');
        }
        if (this.keyPressed[player.number-1].north === true && this.camera.zoom.x >= this.camera.limits.zoom.max) {
          this.camera.limits.state.zoom = true;
          console.log('zoom in limit',this.camera.limits.state.zoom);

        }
        if (
          this.keyPressed[player.number-1].south === true &&
          this.keyPressed[player.number-1].north !== true &&
          this.camera.zoom.x > this.camera.limits.zoom.min
        ) {

          this.camera.zoom.x -= .02 ;
          this.camera.zoom.y -= .02 ;
          this.camera.zoomDirection = 'out';
          setFocus = true;
          setZoomPan = true;

          // console.log('zooming out');
        }
        if (this.keyPressed[player.number-1].south === true && this.camera.zoom.x <= this.camera.limits.zoom.min) {
          console.log('zoom out limit');
          this.camera.limits.state.zoom = true;
        }

      }

      if (this.camera.mode === 'pan') {

        // ONLY PAN IF CANT SEE WHOLE MAP
        let canPan = false;
        if (window.innerWidth < 1100) {
          if (this.gridWidth >= 12) {
            if (this.camera.zoom.x > .7) {
              canPan = true;
            }
          } else {
            if (this.camera.zoom.x > 1) {
              canPan = true;
            }
          }
        } else {
          if (this.camera.zoom.x > 1) {
            canPan = true;
          }
        }

        if (canPan === true) {

          if (
            this.keyPressed[player.number-1].north === true &&
            this.keyPressed[player.number-1].south !== true &&
            this.keyPressed[player.number-1].east !== true &&
            this.keyPressed[player.number-1].west !== true &&
            this.camera.pan.y < this.camera.limits.pan.y.max
          ) {
            this.camera.pan.y += 10;
            this.camera.adjustedPan.y += (10*this.camera.zoom.x);
            this.camera.panDirection = 'north';
            setFocus = true;
            setZoomPan = true;
            findFocusCell = true;

            // console.log('panning north');

          }
          if (this.keyPressed[player.number-1].north === true && this.camera.pan.y >= this.camera.limits.pan.y.max) {
            console.log('pan limit north');
            this.camera.limits.state.pan = true;
          }
          if (
            this.keyPressed[player.number-1].south === true &&
            this.keyPressed[player.number-1].north !== true &&
            this.keyPressed[player.number-1].west !== true &&
            this.keyPressed[player.number-1].east !== true &&
            this.camera.pan.y > this.camera.limits.pan.y.min
          ) {
            this.camera.pan.y -= 10;
            this.camera.adjustedPan.y -= (10*this.camera.zoom.x);
            this.camera.panDirection = 'south';
            setFocus = true;
            setZoomPan = true;
            findFocusCell = true;

            // console.log('panning south');

          }
          if (this.keyPressed[player.number-1].south === true && this.camera.pan.y <= this.camera.limits.pan.y.min) {
            console.log('pan limit south');
            this.camera.limits.state.pan = true;
          }
          if (
            this.keyPressed[player.number-1].east === true &&
            this.keyPressed[player.number-1].west !== true &&
            this.keyPressed[player.number-1].north !== true &&
            this.keyPressed[player.number-1].south !== true &&
            this.camera.pan.x > this.camera.limits.pan.x.min
          ) {
            this.camera.pan.x -= 10;
            this.camera.adjustedPan.x -= (10*this.camera.zoom.x);
            this.camera.panDirection = 'east';
            setFocus = true;
            setZoomPan = true;
            findFocusCell = true;

            // console.log('panning east');
          }
          if (this.keyPressed[player.number-1].east === true && this.camera.pan.x <= this.camera.limits.pan.x.min) {
            console.log('pan limit east');
            this.camera.limits.state.pan = true;
          }
          if (
            this.keyPressed[player.number-1].west === true &&
            this.keyPressed[player.number-1].east !== true &&
            this.keyPressed[player.number-1].north !== true &&
            this.keyPressed[player.number-1].south !== true &&
            this.camera.pan.x < this.camera.limits.pan.x.max
          ) {
            this.camera.pan.x += 10;
            this.camera.adjustedPan.x += (10*this.camera.zoom.x);
            this.camera.panDirection = 'west';
            setFocus = true;
            setZoomPan = true;
            findFocusCell = true;

            // console.log('panning west');
          }
          if (this.keyPressed[player.number-1].west === true && this.camera.pan.x >= this.camera.limits.pan.x.max) {
            console.log('pan limit west');
            this.camera.limits.state.pan = true;
          }

        } else {
          // console.log('cant pan at this zoom');
          // this.camera.limits.state.pan = true;

          if (
            this.keyPressed[player.number-1].north === true ||
            this.keyPressed[player.number-1].south === true ||
            this.keyPressed[player.number-1].east === true ||
            this.keyPressed[player.number-1].west === true
          ) {
            this.camera.limits.state.pan = true;
          }
        }
      }


      // ADJUST PAN WHEN ZOOMING TO KEEP CENTERED
      if (setZoomPan === true) {
        let zoom = this.camera.zoom.x;


        // if mode is zoom


        let diff;
        if (zoom === 1) {

          this.camera.pan.x = -1;
          this.camera.pan.y = -1;
          this.camera.zoomFocusPan.x = -1;
          this.camera.zoomFocusPan.y = -1;
          this.camera.adjustedPan.x = -1;
          this.camera.adjustedPan.y = -1;

          this.camera.focus.x = (canvas.width/2);
          this.camera.focus.y = (canvas.height/2);

        }


        // ZOOMING IN & OUT ABOVE THRESHOLD
        if (zoom < 1) {

          diff = 1 - zoom;

          this.camera.zoomFocusPan.x = (diff*(canvas.width/2));
          this.camera.zoomFocusPan.y = (diff*(canvas.width/2))-(diff*(canvas.width/6));

        }


        // ZOOMING BELOW THRESHOLD
        if (zoom > 1) {

          diff = zoom - 1;
          let diffx;
          let diffy;

          if (this.camera.mode === 'pan') {

            this.camera.zoomFocusPan.x = ((canvas.width/2)*(1-zoom)+1)+(this.camera.pan.x*zoom);
            this.camera.zoomFocusPan.y = ((canvas.height/2)*(1-zoom)+1)+(this.camera.pan.y*zoom);

          }
          if (this.camera.mode === 'zoom') {

            // ZOOM INTO WHAT CAMERA IS CENTERED ON (MAGIC FORMULA!!!)
            if (this.camera.zoomDirection === "in") {

              this.camera.zoomFocusPan.x = ((canvas.width/2)*(1-zoom)+1)+(this.camera.pan.x*zoom);
              this.camera.zoomFocusPan.y = ((canvas.height/2)*(1-zoom)+1)+(this.camera.pan.y*zoom);

            }

            // WHEN ZOOMING OUT INSIDE THRESHOLD, TEND TOWARDS A CENTER ALIGNMENT
            if (this.camera.zoomDirection === "out") {


              // ADJUST PAN INCREMENT FOR ZOOM OUT CENTERING

              if (this.camera.pan.x > -1) {
                this.camera.pan.x -= 6;
                // this.camera.adjustedPan.x -= (this.camera.pan.x*(this.camera.zoom.x-1));
                // this.camera.adjustedPan.x -= (6*(this.camera.zoom.x-1));
                this.camera.adjustedPan.x -= (3*(this.camera.zoom.x-1));
                // this.camera.adjustedPan.x -= (6*this.camera.zoom.x);
                this.camera.panDirection = 'east';
                setFocus = true;
              }
              if (this.camera.pan.x < -1) {
                this.camera.pan.x += 6;
                // this.camera.adjustedPan.x += (this.camera.pan.x*(this.camera.zoom.x-1));
                // this.camera.adjustedPan.x += (6*(this.camera.zoom.x-1));
                this.camera.adjustedPan.x += (3*(this.camera.zoom.x-1));
                // this.camera.adjustedPan.x += (6*this.camera.zoom.x);
                this.camera.panDirection = 'west';
                setFocus = true;
              }
              if (this.camera.pan.y < -1) {
                this.camera.pan.y += 3.5;
                // this.camera.adjustedPan.y += (this.camera.pan.y*(this.camera.zoom.x-1));
                // this.camera.adjustedPan.y += (3.5*(this.camera.zoom.x-1));
                // this.camera.adjustedPan.y += (1.5*this.camera.zoom.x);
                this.camera.adjustedPan.y += (1.5*(this.camera.zoom.x-1));
                // this.camera.adjustedPan.y += (3.5*this.camera.zoom.x);
                this.camera.panDirection = 'north';
                setFocus = true;
              }
              if (this.camera.pan.y > -1) {
                this.camera.pan.y -= 3.5;
                // this.camera.adjustedPan.y -= (this.camera.pan.y*(this.camera.zoom.x-1));
                // this.camera.adjustedPan.y -= (3.5*(this.camera.zoom.x-1));
                // this.camera.adjustedPan.y -= (1.5*this.camera.zoom.x);
                this.camera.adjustedPan.y -= (1.5*(this.camera.zoom.x-1));
                // this.camera.adjustedPan.y -= (3.5*this.camera.zoom.x);
                this.camera.panDirection = 'south';
                setFocus = true;
              }

              // this.camera.zoomFocusPan.x = ((canvas.width/2)*(1-zoom)+1)-((this.camera.adjustedPan.x+this.camera.pan.x)*(1-zoom));
              // this.camera.zoomFocusPan.y = ((canvas.height/2)*(1-zoom)+1)-((this.camera.adjustedPan.y+this.camera.pan.y)*(1-zoom));


              this.camera.zoomFocusPan.x = ((canvas.width/2)*(1-zoom)+1)+(this.camera.pan.x*zoom);
              this.camera.zoomFocusPan.y = ((canvas.height/2)*(1-zoom)+1)+(this.camera.pan.y*zoom);

              findFocusCell = true;

            }

          }




        }

        // console.log('ZFP!',this.camera.zoomFocusPan.x.toFixed(2),',',this.camera.zoomFocusPan.y.toFixed(2));

      }


      //SET CAMERA FOCUS
      if (setFocus === true) {
        // this.setCameraFocus('input',canvas, context, canvas2, context2);
      }

      if (findFocusCell) {
        this.findFocusCell('panToCell',{},canvas,context)
      }


    };
    // RESET
    if (this.resetCameraSwitch === true) {
      // console.log('resetting camera');

      this.resetCameraSwitch = false;
      this.camera = {
        state: true,
        startCount: 0,
        startLimit: 4,
        mode: 'pan',
        fixed: false,
        target: {
          type: 'player',
          plyrNo: 1,
          cell: {
            x: undefined,
            y: undefined,
          }
        },
        focus: {
          x: undefined,
          y: undefined,
        },
        focusCell: {
          x: this.camera.focusCell.x,
          y: this.camera.focusCell.y,
        },
        cellToPanOrigin: {
          x: undefined,
          y: undefined,
        },
        zoom: {
          x: 1,
          y: 1,
        },
        zoomDirection: 'in',
        pan: {
          x: 1,
          y: 1,
        },
        panDirection: 'east',
        zoomFocusPan: {
          x: -1,
          y: -1,
        },
        adjustedPan: {
          x: 1,
          y: 1,
        },
        limits: {
          zoom: {
            min: .5,
            max: 2.5,
          },
          pan: {
            x: {
              min: -700,
              max: 600,
            },
            y: {
              min: -700,
              max: 600,
            }
          },
          state: {
            count: 0,
            limit: 10,
            zoom: false,
            pan: false,
          }
        },
        instructionType: 'default',
        currentPreInstruction: 0,
        preInstructions: [],
        currentInstruction: 0,
        instructions: [],
      };



      // this.setCameraFocus('reset', canvas, context, canvas2, context2);

    };
    // AUTO CAMERA
    if (this.camera.state !== true && this.camera.fixed !== true) {

      if (this.camera.instructionType === 'default') {

        // PRE/RAW INSTRUCTIONS!!
        if (this.camera.preInstructions.length > 0  && this.camera.instructions.length === 0 ) {
          // console.log('step through auto camera pre instructions',this.camera.preInstructions);

          let preInstruction = this.camera.preInstructions[this.camera.currentPreInstruction];
          // let indx = this.camera.preInstructions.indexOf(preInstruction)
          let focusCell = {
            x: undefined,
            y: undefined,
          }
          // console.log('Step through pre instructions...','preInstructions',preInstruction);

          switch (preInstruction.split("_")[0]) {
            case 'moveTo':

            let speed = preInstruction.split("_")[3];
              if (preInstruction.split("_")[0] === "moveTo") {
                focusCell.x = parseInt(preInstruction.split("_")[1])
                focusCell.y = parseInt(preInstruction.split("_")[2])

                this.findFocusCell('cellToPan',focusCell,canvas,context,speed)

              }
            break;
            case 'zoom':
              if (preInstruction.split("_")[1] === 'outToInit') {
                this.camera.instructions.push(
                  {
                    action:'zoom_outToInit',
                    action2:'',
                    count: 0,
                    count2: 0,
                    limit: 1,
                    limit2: 0,
                    speed: "",
                  }
                )
              }
              else {
                this.camera.instructions.push(
                  {
                    action:'zoom_'+preInstruction.split("_")[1],
                    action2:'',
                    count: 0,
                    count2: 0,
                    limit: parseInt(preInstruction.split("_")[2]),
                    limit2: 0,
                    speed: "",
                  }
                )
              }

            break;
            case 'waitFor':

              this.camera.instructions.push(
                {
                  action:'wait',
                  action2:'',
                  count: 0,
                  count2: 0,
                  limit: parseInt(preInstruction.split("_")[1]),
                  limit2: 0,
                  speed: "",
                }
              )

            break;
          }

          if (this.camera.currentPreInstruction ===  this.camera.preInstructions.length-1) {
            // console.log('this is the last preInstruction. Empty array');
            this.camera.preInstructions = [];
            this.camera.currentPreInstruction = 0;
            // console.log('camera instructions',this.camera.instructions);
          } else {
            this.camera.currentPreInstruction++;
          }

        }


        // PARSED INSTRUCTIONS!
        if (this.camera.instructions.length > 0 && this.camera.currentInstruction < this.camera.instructions.length) {
          // console.log('stepping through all instructions... current',this.camera.currentInstruction,this.camera.instructions[this.camera.currentInstruction]);

          if (this.camera.instructions[this.camera.currentInstruction].speed === 'fast') {

            if (this.camera.instructions[this.camera.currentInstruction].count < this.camera.instructions[this.camera.currentInstruction].limit) {

              if (this.camera.instructions[this.camera.currentInstruction].action === 'wait') {

                  // console.log('single instruction: auto camera waiting. count:',this.camera.instructions[this.camera.currentInstruction].count);
                  this.camera.instructions[this.camera.currentInstruction].count++;

              } else {


                for (var i = 0; i < this.camera.instructions[this.camera.currentInstruction].limit; i++) {
                    // console.log('single instruction: auto camera',this.camera.instructions[this.camera.currentInstruction].action,' count:',this.camera.instructions[this.camera.currentInstruction].count);

                    if (this.camera.instructions[this.camera.currentInstruction].action.split("_")[0] === 'pan') {
                      // console.log('auto camera panning/moving',this.camera.instructions[this.camera.currentInstruction].count);

                      if (this.camera.zoom.x <= 1) {


                        // this.camera.instructions[this.camera.currentInstruction]
                        // this.camera.currentInstruction--;

                        // console.log('moving zoom to panable amount');
                        this.camera.zoom.x += .04 ;
                        this.camera.zoom.y += .04 ;
                        this.camera.zoomDirection = 'in';

                        let zoom = this.camera.zoom.x;
                        let diff = 1 - zoom;

                        this.camera.zoomFocusPan.x = (diff*(canvas.width/2));
                        this.camera.zoomFocusPan.y = (diff*(canvas.width/2))-(diff*(canvas.width/6));

                        // this.setCameraFocus('input',canvas, context, canvas2, context2);
                        this.findFocusCell('panToCell',{},canvas,context)

                      }

                      // console.log('single instruction: adjusting pan x/y -/+ based on direction');

                      switch (this.camera.instructions[this.camera.currentInstruction].action.split("_")[1]) {
                        case 'north':
                          this.camera.pan.y += 1;
                          this.camera.adjustedPan.y += (1*this.camera.zoom.x);
                          this.camera.panDirection = 'north';
                        break;
                        case 'south':
                        this.camera.pan.y -= 1;
                        this.camera.adjustedPan.y -= (1*this.camera.zoom.x);
                        this.camera.panDirection = 'south';
                        break;
                        case 'east':
                          this.camera.pan.x -= 1;
                          this.camera.adjustedPan.x -= (1*this.camera.zoom.x);
                          this.camera.panDirection = 'east';
                        break;
                        case 'west':
                          this.camera.pan.x += 1;
                          this.camera.adjustedPan.x += (1*this.camera.zoom.x);
                          this.camera.panDirection = 'west';
                        break;
                      }

                      let zoom = this.camera.zoom.x;
                      this.camera.zoomFocusPan.x = ((canvas.width/2)*(1-zoom)+1)+(this.camera.pan.x*zoom);
                      this.camera.zoomFocusPan.y = ((canvas.height/2)*(1-zoom)+1)+(this.camera.pan.y*zoom);

                      // this.setCameraFocus('input',canvas, context, canvas2, context2);
                      this.findFocusCell('panToCell',{},canvas,context)

                      if (this.camera.instructions[this.camera.currentInstruction].count === this.camera.instructions[this.camera.currentInstruction].limit) {
                        // console.log('last count on pan instruction',this.camera.instructions[this.camera.currentInstruction].dest);
                      }

                    }
                    if (this.camera.instructions[this.camera.currentInstruction].action.split("_")[0] === 'zoom') {
                      // console.log('single instruction: adjusting zoom x -/+ based on direction',this.camera.instructions[this.camera.currentInstruction].count,this.camera.instructions[this.camera.currentInstruction].limit);

                      switch (this.camera.instructions[this.camera.currentInstruction].action.split("_")[1]) {
                        case 'in':
                          this.camera.zoom.x += .02 ;
                          this.camera.zoom.y += .02 ;
                          this.camera.zoomDirection = 'in';
                        break;
                        case 'out':
                          this.camera.zoom.x -= .02 ;
                          this.camera.zoom.y -= .02 ;
                          this.camera.zoomDirection = 'out';
                        break;
                        case 'outToInit':
                          this.setInitZoom.state = true;
                        break;
                      }

                      // ZOOMING IN & OUT ABOVE THRESHOLD
                      let zoom = this.camera.zoom.x;
                      if (zoom < 1) {

                        let diff = 1 - zoom;

                        this.camera.zoomFocusPan.x = (diff*(canvas.width/2));
                        this.camera.zoomFocusPan.y = (diff*(canvas.width/2))-(diff*(canvas.width/6));

                      }


                      // ZOOMING BELOW THRESHOLD
                      if (zoom > 1) {

                        let diff = zoom - 1;
                        let diffx;
                        let diffy;

                        // ZOOM INTO WHAT CAMERA IS CENTERED ON (MAGIC FORMULA!!!)
                        if (this.camera.instructions[this.camera.currentInstruction].action.split("_")[1] === "in") {

                          this.camera.zoomFocusPan.x = ((canvas.width/2)*(1-zoom)+1)+(this.camera.pan.x*zoom);
                          this.camera.zoomFocusPan.y = ((canvas.height/2)*(1-zoom)+1)+(this.camera.pan.y*zoom);

                        }

                        // WHEN ZOOMING OUT INSIDE THRESHOLD, TEND TOWARDS A CENTER ALIGNMENT
                        if (this.camera.instructions[this.camera.currentInstruction].action.split("_")[1] === "out") {


                          // ADJUST PAN INCREMENT FOR ZOOM OUT CENTERING
                          if (this.camera.pan.x > -1) {
                            this.camera.pan.x -= 6;
                            this.camera.adjustedPan.x -= (3*(this.camera.zoom.x-1));
                            this.camera.panDirection = 'east';
                          }
                          if (this.camera.pan.x < -1) {
                            this.camera.pan.x += 6;
                            this.camera.adjustedPan.x += (3*(this.camera.zoom.x-1));
                            this.camera.panDirection = 'west';
                          }
                          if (this.camera.pan.y < -1) {
                            this.camera.pan.y += 3.5;
                            this.camera.adjustedPan.y += (1.5*(this.camera.zoom.x-1));
                            this.camera.panDirection = 'north';
                          }
                          if (this.camera.pan.y > -1) {
                            this.camera.pan.y -= 3.5;
                            this.camera.adjustedPan.y -= (1.5*(this.camera.zoom.x-1));
                            this.camera.panDirection = 'south';
                          }

                          // this.camera.zoomFocusPan.x = ((canvas.width/2)*(1-zoom)+1)-((this.camera.adjustedPan.x+this.camera.pan.x)*(1-zoom));
                          // this.camera.zoomFocusPan.y = ((canvas.height/2)*(1-zoom)+1)-((this.camera.adjustedPan.y+this.camera.pan.y)*(1-zoom));

                          this.camera.zoomFocusPan.x = ((canvas.width/2)*(1-zoom)+1)+(this.camera.pan.x*zoom);
                          this.camera.zoomFocusPan.y = ((canvas.height/2)*(1-zoom)+1)+(this.camera.pan.y*zoom);

                        }

                      }

                      // this.setCameraFocus('input',canvas, context, canvas2, context2);
                      this.findFocusCell('panToCell',{},canvas,context)

                    }
                    this.camera.instructions[this.camera.currentInstruction].count++;

                }
              }

            }
            else if (
              this.camera.instructions[this.camera.currentInstruction].count >= this.camera.instructions[this.camera.currentInstruction].limit
            ) {

              if (this.camera.instructions[this.camera.currentInstruction].action2 === "" && this.camera.currentInstruction < this.camera.instructions.length) {
                // console.log('single instruction finished w/ no secondaries. step to next instruction');
                this.camera.currentInstruction++;
              }

            }

            if (
              this.camera.instructions[this.camera.currentInstruction] &&
              this.camera.instructions[this.camera.currentInstruction].action2 !== "" &&
              this.camera.instructions[this.camera.currentInstruction].count2 < this.camera.instructions[this.camera.currentInstruction].limit2
            ) {

              for (var i = 0; i < this.camera.instructions[this.camera.currentInstruction].limit2; i++) {
                // console.log('single instruction2: auto camera',this.camera.instructions[this.camera.currentInstruction].action2,' count:',this.camera.instructions[this.camera.currentInstruction].count2);

                switch (this.camera.instructions[this.camera.currentInstruction].action2.split("_")[1]) {
                  case 'north':
                    this.camera.pan.y += 1;
                    this.camera.adjustedPan.y += (1*this.camera.zoom.x);
                    this.camera.panDirection = 'north';
                  break;
                  case 'south':
                  this.camera.pan.y -= 1;
                  this.camera.adjustedPan.y -= (1*this.camera.zoom.x);
                  this.camera.panDirection = 'south';
                  break;
                  case 'east':
                    this.camera.pan.x -= 1;
                    this.camera.adjustedPan.x -= (1*this.camera.zoom.x);
                    this.camera.panDirection = 'east';
                  break;
                  case 'west':
                    this.camera.pan.x += 1;
                    this.camera.adjustedPan.x += (1*this.camera.zoom.x);
                    this.camera.panDirection = 'west';
                  break;
                }
                let zoom = this.camera.zoom.x;
                this.camera.zoomFocusPan.x = ((canvas.width/2)*(1-zoom)+1)+(this.camera.pan.x*zoom);
                this.camera.zoomFocusPan.y = ((canvas.height/2)*(1-zoom)+1)+(this.camera.pan.y*zoom);

                // this.setCameraFocus('input',canvas, context, canvas2, context2);
                this.findFocusCell('panToCell',{},canvas,context)
                this.camera.instructions[this.camera.currentInstruction].count2++;

              }

            }
            else if (
              this.camera.instructions[this.camera.currentInstruction] &&
              this.camera.instructions[this.camera.currentInstruction].action2 !== "" &&
              this.camera.instructions[this.camera.currentInstruction].count2 >= this.camera.instructions[this.camera.currentInstruction].limit2
            ) {

              this.camera.currentInstruction++;

            }

          }

          if (this.camera.instructions[this.camera.currentInstruction]) {


          if (
            this.camera.instructions[this.camera.currentInstruction].speed === 'slow' ||
            this.camera.instructions[this.camera.currentInstruction].speed === ''
          ) {

            if (this.camera.instructions[this.camera.currentInstruction].count < this.camera.instructions[this.camera.currentInstruction].limit) {
              // console.log('step through a single instruction',this.camera.instructions[this.camera.currentInstruction],'count',this.camera.instructions[this.camera.currentInstruction].count);

              if (this.camera.instructions[this.camera.currentInstruction].action === 'wait') {
                // console.log('single instruction: auto camera waiting');
              }
              if (this.camera.instructions[this.camera.currentInstruction].action.split("_")[0] === 'pan') {
                // console.log('auto camera panning/moving',this.camera.instructions[this.camera.currentInstruction].count);

                if (this.camera.zoom.x <= 1) {


                  // this.camera.instructions[this.camera.currentInstruction]
                  // this.camera.currentInstruction--;

                  // console.log('moving zoom to panable amount');
                  this.camera.zoom.x += .04 ;
                  this.camera.zoom.y += .04 ;
                  this.camera.zoomDirection = 'in';

                  let zoom = this.camera.zoom.x;
                  let diff = 1 - zoom;

                  this.camera.zoomFocusPan.x = (diff*(canvas.width/2));
                  this.camera.zoomFocusPan.y = (diff*(canvas.width/2))-(diff*(canvas.width/6));

                  // this.setCameraFocus('input',canvas, context, canvas2, context2);
                  this.findFocusCell('panToCell',{},canvas,context)

                }

                // console.log('single instruction: adjusting pan x/y -/+ based on direction');

                switch (this.camera.instructions[this.camera.currentInstruction].action.split("_")[1]) {
                  case 'north':
                    this.camera.pan.y += 1;
                    this.camera.adjustedPan.y += (1*this.camera.zoom.x);
                    this.camera.panDirection = 'north';
                  break;
                  case 'south':
                  this.camera.pan.y -= 1;
                  this.camera.adjustedPan.y -= (1*this.camera.zoom.x);
                  this.camera.panDirection = 'south';
                  break;
                  case 'east':
                    this.camera.pan.x -= 1;
                    this.camera.adjustedPan.x -= (1*this.camera.zoom.x);
                    this.camera.panDirection = 'east';
                  break;
                  case 'west':
                    this.camera.pan.x += 1;
                    this.camera.adjustedPan.x += (1*this.camera.zoom.x);
                    this.camera.panDirection = 'west';
                  break;
                }

                let zoom = this.camera.zoom.x;
                this.camera.zoomFocusPan.x = ((canvas.width/2)*(1-zoom)+1)+(this.camera.pan.x*zoom);
                this.camera.zoomFocusPan.y = ((canvas.height/2)*(1-zoom)+1)+(this.camera.pan.y*zoom);

                // this.setCameraFocus('input',canvas, context, canvas2, context2);
                this.findFocusCell('panToCell',{},canvas,context)

                if (this.camera.instructions[this.camera.currentInstruction].count === this.camera.instructions[this.camera.currentInstruction].limit) {
                  // console.log('last count on pan instruction',this.camera.instructions[this.camera.currentInstruction].dest);
                }

              }
              if (this.camera.instructions[this.camera.currentInstruction].action.split("_")[0] === 'zoom') {
                // console.log('single instruction: adjusting zoom x -/+ based on direction',this.camera.instructions[this.camera.currentInstruction].count,this.camera.instructions[this.camera.currentInstruction].limit);

                switch (this.camera.instructions[this.camera.currentInstruction].action.split("_")[1]) {
                  case 'in':
                    this.camera.zoom.x += .02 ;
                    this.camera.zoom.y += .02 ;
                    this.camera.zoomDirection = 'in';
                  break;
                  case 'out':
                    this.camera.zoom.x -= .02 ;
                    this.camera.zoom.y -= .02 ;
                    this.camera.zoomDirection = 'out';
                  break;
                  case 'outToInit':
                    this.setInitZoom.state = true;
                  break;
                }

                // ZOOMING IN & OUT ABOVE THRESHOLD
                let zoom = this.camera.zoom.x;
                if (zoom < 1) {

                  let diff = 1 - zoom;

                  this.camera.zoomFocusPan.x = (diff*(canvas.width/2));
                  this.camera.zoomFocusPan.y = (diff*(canvas.width/2))-(diff*(canvas.width/6));

                }


                // ZOOMING BELOW THRESHOLD
                if (zoom > 1) {

                  let diff = zoom - 1;
                  let diffx;
                  let diffy;

                  // ZOOM INTO WHAT CAMERA IS CENTERED ON (MAGIC FORMULA!!!)
                  if (this.camera.instructions[this.camera.currentInstruction].action.split("_")[1] === "in") {

                    this.camera.zoomFocusPan.x = ((canvas.width/2)*(1-zoom)+1)+(this.camera.pan.x*zoom);
                    this.camera.zoomFocusPan.y = ((canvas.height/2)*(1-zoom)+1)+(this.camera.pan.y*zoom);

                  }

                  // WHEN ZOOMING OUT INSIDE THRESHOLD, TEND TOWARDS A CENTER ALIGNMENT
                  if (this.camera.instructions[this.camera.currentInstruction].action.split("_")[1] === "out") {


                    // ADJUST PAN INCREMENT FOR ZOOM OUT CENTERING
                    if (this.camera.pan.x > -1) {
                      this.camera.pan.x -= 6;
                      this.camera.adjustedPan.x -= (3*(this.camera.zoom.x-1));
                      this.camera.panDirection = 'east';
                    }
                    if (this.camera.pan.x < -1) {
                      this.camera.pan.x += 6;
                      this.camera.adjustedPan.x += (3*(this.camera.zoom.x-1));
                      this.camera.panDirection = 'west';
                    }
                    if (this.camera.pan.y < -1) {
                      this.camera.pan.y += 3.5;
                      this.camera.adjustedPan.y += (1.5*(this.camera.zoom.x-1));
                      this.camera.panDirection = 'north';
                    }
                    if (this.camera.pan.y > -1) {
                      this.camera.pan.y -= 3.5;
                      this.camera.adjustedPan.y -= (1.5*(this.camera.zoom.x-1));
                      this.camera.panDirection = 'south';
                    }

                    // this.camera.zoomFocusPan.x = ((canvas.width/2)*(1-zoom)+1)-((this.camera.adjustedPan.x+this.camera.pan.x)*(1-zoom));
                    // this.camera.zoomFocusPan.y = ((canvas.height/2)*(1-zoom)+1)-((this.camera.adjustedPan.y+this.camera.pan.y)*(1-zoom));

                    this.camera.zoomFocusPan.x = ((canvas.width/2)*(1-zoom)+1)+(this.camera.pan.x*zoom);
                    this.camera.zoomFocusPan.y = ((canvas.height/2)*(1-zoom)+1)+(this.camera.pan.y*zoom);

                  }

                }

                // this.setCameraFocus('input',canvas, context, canvas2, context2);
                this.findFocusCell('panToCell',{},canvas,context)

              }

              this.camera.instructions[this.camera.currentInstruction].count++;

            }
            else if (
              this.camera.instructions[this.camera.currentInstruction].count >= this.camera.instructions[this.camera.currentInstruction].limit
            ) {

              // if (this.camera.instructions[this.camera.currentInstruction].action2 === "") {
              if (this.camera.instructions[this.camera.currentInstruction].action2 === "" && this.camera.currentInstruction < this.camera.instructions.length) {
                // console.log('single instruction finished w/ no secondaries. step to next instruction');
                this.camera.currentInstruction++;
              }

            }

            // SECONDARY INSTRUCTIONS
            if (
              this.camera.instructions[this.camera.currentInstruction] &&
              this.camera.instructions[this.camera.currentInstruction].action2 !== "" &&
              this.camera.instructions[this.camera.currentInstruction].count2 < this.camera.instructions[this.camera.currentInstruction].limit2
            ) {

              // console.log('step through a single secondary instruction',this.camera.instructions[this.camera.currentInstruction],'count2',this.camera.instructions[this.camera.currentInstruction].count2);

              switch (this.camera.instructions[this.camera.currentInstruction].action2.split("_")[1]) {
                case 'north':
                  this.camera.pan.y += 1;
                  this.camera.adjustedPan.y += (1*this.camera.zoom.x);
                  this.camera.panDirection = 'north';
                break;
                case 'south':
                this.camera.pan.y -= 1;
                this.camera.adjustedPan.y -= (1*this.camera.zoom.x);
                this.camera.panDirection = 'south';
                break;
                case 'east':
                  this.camera.pan.x -= 1;
                  this.camera.adjustedPan.x -= (1*this.camera.zoom.x);
                  this.camera.panDirection = 'east';
                break;
                case 'west':
                  this.camera.pan.x += 1;
                  this.camera.adjustedPan.x += (1*this.camera.zoom.x);
                  this.camera.panDirection = 'west';
                break;
              }

              let zoom = this.camera.zoom.x;
              this.camera.zoomFocusPan.x = ((canvas.width/2)*(1-zoom)+1)+(this.camera.pan.x*zoom);
              this.camera.zoomFocusPan.y = ((canvas.height/2)*(1-zoom)+1)+(this.camera.pan.y*zoom);

              // this.setCameraFocus('input',canvas, context, canvas2, context2);
              this.findFocusCell('panToCell',{},canvas,context)

              this.camera.instructions[this.camera.currentInstruction].count2++;
            }
            else if (
              this.camera.instructions[this.camera.currentInstruction] &&
              this.camera.instructions[this.camera.currentInstruction].action2 !== "" &&
              this.camera.instructions[this.camera.currentInstruction].count2 >= this.camera.instructions[this.camera.currentInstruction].limit2
            ) {

              // if (this.camera.instructions[this.camera.currentInstruction].action2 !== "") {
              // if (this.camera.currentInstruction < this.camera.instructions.length-1) {
                // console.log('single secondary instruction finished. step to next instruction');
                this.camera.currentInstruction++;
              // }

            }

          }
          }


          // }
          if (this.camera.currentInstruction >= this.camera.instructions.length) {
            console.log('finished camera instructions');
            this.camera.instructions = [];
            this.camera.currentInstruction = 0;
            this.settingAutoCamera = false;
          }


        }

      }

      if (this.camera.instructionType === 'story') {

        // if there are nstructions, execute and step instructions.count, remove from array
        //
        // use a cameraInstructionRef to adjust the camera values accordingly, and push to this.camera.instructions
        //
        // if this is the last instruction, set the instructionType back to default

      }

    }


    // MENU

    if (player.ai.state !== true && this.keyPressed[player.number-1].cycleWeapon === true && this.keyPressed[player.number-1].cycleArmor === true) {
      // toggle the menu here
    }


    // // CHECK PROJECTILES!!
    for (const bolt of this.projectiles) {

      if (bolt.kill === true) {
        let index = this.projectiles.findIndex(blt => blt.id === bolt.id);
        this.projectiles.splice(index, 1);
        // console.log('kill bolt',bolt.currentPosition.number, this.players[bolt.owner-1].currentPosition.cell.number,this.projectiles);
      }

      if (bolt.type === 'bolt' && bolt.moving.state === true && bolt.kill !== true) {
        // console.log('traking projectile');

        let index = this.projectiles.findIndex(blt => blt.id === bolt.id);
        bolt.currentPosition.center = bolt.nextPosition;


        let boltNextPosition = this.boltCrementer(bolt);
        bolt.nextPosition = boltNextPosition;
        // console.log('moving bolt nxt pos',bolt.nextPosition);

        // CHECK WHICH CELL BOLT IS AT
        for (const cell of bolt.target.path) {
          let point = [bolt.currentPosition.center.x,bolt.currentPosition.center.y];
          let polygon = [];
          for (const vertex of cell.vertices) {
            let vertexPoint = [vertex.x-10,vertex.y-5];
            // let vertexPoint = [vertex.x,vertex.y];
            polygon.push(vertexPoint)
          }
          let pip = pointInPolygon(point, polygon)
          if (pip === true) {
            // console.log('bolt passing through cell',cell.number);
            bolt.currentPosition.number = cell.number;

            let infoCell = this.gridInfo.find(x => x.number.x === cell.number.x && x.number.y === cell.number.y);

            if (infoCell.elevation.number === bolt.elevation) {


              let fwdBarrier = false;

              if (infoCell.barrier.state === true && infoCell.barrier.height >= 1) {
                // if (infoCell.barrier.position === bolt.direction) {
                //   fwdBarrier = true;
                // }
                fwdBarrier = this.checkForwardBarrier(bolt.direction,infoCell);
              }

              if (bolt.target.path.length === 1) {
                if (infoCell.barrier.state === true && infoCell.barrier.position === bolt.direction) {
                  this.attackCellContents('bolt',this.players[bolt.owner-1],infoCell,undefined,undefined,bolt)
                }
              }

              let dodged = false;

              // CHECK FOR PLAYERS
              if (fwdBarrier !== true) {
                for (const plyr of this.players) {
                  if (
                    plyr.currentPosition.cell.number.x === cell.number.x &&
                    plyr.currentPosition.cell.number.y === cell.number.y &&
                    plyr.number !== bolt.owner
                  ) {

                    this.projectileAttackParse(bolt,plyr);

                  }

                }



                // CHECK FOR OBSTACLE &  REAR BARRIER COLLISION

                if (infoCell.obstacle.state === true && infoCell.obstacle.height >= 1) {

                  this.attackCellContents('bolt',this.players[bolt.owner-1],infoCell,undefined,undefined,bolt)

                }

                else if (infoCell.barrier.state === true && infoCell.barrier.height >= 1) {

                  this.attackCellContents('bolt',this.players[bolt.owner-1],infoCell,undefined,undefined,bolt)

                }

              }

              else {

                // HANDLE FWD BARRIER BOLT COLLISION
                if (infoCell.barrier.state === true && infoCell.barrier.height >= 1) {

                  this.attackCellContents('bolt',this.players[bolt.owner-1],infoCell,undefined,undefined,bolt)

                }

              }

            }


            else {
              if (infoCell.elevation.number < bolt.elevation) {
                console.log('bolt moving over lower cell. ');

                  this.attackCellContents('flyOverBolt',this.players[bolt.owner-1],infoCell,undefined,undefined,bolt)

              }
              if (infoCell.elevation.number > bolt.elevation) {
                console.log('bolt hit cell of higher elevation.');
                bolt.kill = true;
              }
            }


          }
        }

        // BOLT WENT OUT OF CANVAS BOUNDS
        if (
          bolt.currentPosition.center.x < 0 ||
          bolt.currentPosition.center.y < 0 ||
          bolt.currentPosition.center.x > this.canvasWidth ||
          bolt.currentPosition.center.y > this.canvasHeight
        ) {
          console.log('bolt went out of canvas bounds');
          bolt.kill = true;
        }

      }

      if (bolt.type === 'arc' && bolt.moving.state === true && bolt.kill !== true) {

      }
    }


    // ADD COM PLAYER!
    if (this.addAiPlayerKeyPress === true) {
      // this.addAiRandomPlayer('random')
      // this.addAiRandomPlayer('pursue')
      // this.addAiRandomPlayer('patrol')
      // this.addAiRandomPlayer('defend')
      this.addAiPlayer()
    }
    if (this.addAiCount.state === true) {
      if (this.addAiCount.count < this.addAiCount.limit) {
        this.addAiCount.count++
      }
      if (this.addAiCount.count >= this.addAiCount.limit) {
        this.addAiCount = {
          state: false,
          count: 0,
          limit: this.addAiCount.limit,
        }
      }
    }


    // SYNC W/ GLOBAL PLAYER DATA
    this.players[player.number-1] = player;


    // AI EVALUATE
    if (player.ai.state === true ) {
      this.aiEvaluate(player)
    }


    // DRAW EVERYTHING
    this.drawPlayerStep(player.number, canvas, context, canvas2, context2);


  }
  drawPlayerStep = (playerNumber, canvas, context, canvas2, context2) => {
    // console.log('drawing player step',playerNumber);

    let gridInfo = [];
    class Point {
        constructor(x, y) {
            this.x = x;
            this.y = y;
        }
    }
    let wall = this.refs.wall;
    let wall2 = this.refs.wall2;
    let wall3 = this.refs.wall3;

    canvas.width = this.canvasWidth;
    canvas.height = this.canvasHeight;


    let floorImageWidth = this.floorImageWidth;
    let floorImageHeight = this.floorImageHeight;
    let wallImageWidth = this.wallImageWidth;
    let wallImageHeight = this.wallImageHeight;
    let sceneX = (this.canvasWidth/2);
    let sceneY = this.sceneY;
    let tileWidth = this.tileWidth;


    gridInfo = this.gridInfo;

    let player = this.players[playerNumber-1]

    let updatedPlayerImg;
    let newDirection;

    if (player.falling.state === true) {
      // console.log('player',player.number,'falling count',player.falling.count,'position',player.nextPosition);
      if (player.falling.count === player.falling.limit) {
        this.killPlayer(player)
      }
    }

    context.clearRect(0,0,this.canvasWidth,this.canvasHeight);
    context2.clearRect(0,0,this.canvasWidth,this.canvasHeight);

    context.translate(this.camera.zoomFocusPan.x,this.camera.zoomFocusPan.y);
    context2.translate(this.camera.zoomFocusPan.x,this.camera.zoomFocusPan.y);

    context.scale(this.camera.zoom.x,this.camera.zoom.y);
    context2.scale(this.camera.zoom.x,this.camera.zoom.y);


    for (var x = 0; x < this.gridWidth+1; x++) {
      for (var y = 0; y < this.gridWidth+1; y++) {


        let p = new Point();
        p.x = x * tileWidth;
        p.y = y * tileWidth;
        let iso = this.cartesianToIsometric(p);
        let offset = {x: floorImageWidth/2, y: floorImageHeight}
        iso.x += sceneX
        iso.y += sceneY
        let center = {
          x: iso.x - offset.x/2+23,
          y: iso.y - offset.y/2-2,
        }

        let floor;
        let drawFloor = true;
        let gridInfoCell = this.gridInfo.find(elem => elem.number.x === x && elem.number.y === y);
        gridInfoCell.center = center;
        gridInfoCell.drawCenter = center;
        floor = this.floorImgs[gridInfoCell.terrain.name]


        // VOID
        // FLOOR
        if (gridInfoCell.void.state === true) {
          // drawFloor = false;
          floor = this.floorImgs.void3
        }
        //BLINKER!!
        if (
          this.cellToVoid.state === true &&
          this.cellToVoid.x === x &&
          this.cellToVoid.y === y
        ) {
          if (this.cellToVoid.count === 1) {
            if (!this.cellPopups.find(x => x.msg === "cellVoiding" && x.cell.number.x === gridInfoCell.number.x && x.cell.number.y === gridInfoCell.number.y)) {
              this.cellPopups.push(
                {
                  state: false,
                  count: 0,
                  limit: 35,
                  type: '',
                  position: '',
                  msg: 'cellVoiding',
                  color: '',
                  img: '',
                  cell: this.gridInfo.find(x => x.number.x === gridInfoCell.number.x && x.number.y === gridInfoCell.number.y)
                }
              )
            }
          }
          if(this.cellToVoid.count % 5 === 0) {
            floor = this.floorImgs.void3;
            // drawFloor = false;
          } else {
            floor = this.floorImgs.void2;
            // drawFloor = true;
          }
        }

        // DROWNING
        for (const plyrb of this.players) {
          if (plyrb.drowning === true) {
            if (
              plyrb.currentPosition.cell.number.x === x &&
              plyrb.currentPosition.cell.number.y === y
            ) {
              // console.log('player',plyrb.number,'drowning count',plyrb.falling.count,'position',plyrb.nextPosition);
              if(plyrb.falling.count % 2 === 0) {
                // drawFloor = false;
                floor = this.floorImgs.void3;
              } else {
                // floor = floorImgs.stone
                floor = this.floorImgs[gridInfoCell.terrain.name]
              }
            }
          }
        }

        // FALLING OBSTACLE DEEP BLINKER
        if (gridInfoCell.obstacle.state === true && gridInfoCell.obstacle.moving.falling.state === true && gridInfoCell.terrain.type === "deep") {
          if(gridInfoCell.obstacle.moving.falling.count % 3 === 0) {
            floor = this.floorImgs.void3;
          } else {
            floor = this.floorImgs[gridInfoCell.terrain.name]
          }
        }


        // CELLS UNDER ATTACK & PREATTACK!!
        if (this.cellsUnderAttack.length > 0) {
          for (const cll of this.cellsUnderAttack) {
            if (
              cll.number.x === x &&
              cll.number.y === y
            ) {
              floor = this.refs.floorAttack;
            }
          }
        }
        if (this.cellsUnderPreAttack.length > 0) {
          for (const cll2 of this.cellsUnderPreAttack) {
            if (
              cll2.number.x === x &&
              cll2.number.y === y
            ) {
              floor = this.refs.floorAttack2;
            }
          }
        }
        // CELLS TO HIGHLIGHT
        if (this.cellsToHighlight.length > 0) {
          for (const cll2 of this.cellsToHighlight) {
            if (
              cll2.x === x &&
              cll2.y === y
            ) {
              floor = this.refs.floorVoid;
            }
          }
        }
        // CELLS TO HIGHLIGHT V2!!
        if (this.cellsToHighlight2.length > 0) {

          for (const cll3 of this.cellsToHighlight2) {
            if (
              cll3.number.x === x &&
              cll3.number.y === y
            ) {
              floor = this.refs.floorHighlight;
            }
          }
        }


        // FLOOR
        if (drawFloor === true) {
          context.drawImage(floor, iso.x - offset.x, iso.y - offset.y);
        }

        // RUBBLE
        if (gridInfoCell.rubble === true) {
          context.drawImage(this.floorImgs.rubble, iso.x - offset.x, iso.y - offset.y);
        }


        // CELL COORD LABEL
        context.fillStyle = 'black';
        context.fillText(""+x+","+y+"",iso.x - offset.x/2 + 18,iso.y - offset.y/2 + 12)
        context.fillStyle = "black";
        context.fillRect(center.x, center.y,5,5);


        // CELL VERTEX POINTS
        let vertices = [
          {x:center.x, y:center.y+tileWidth/2},
          {x:center.x+tileWidth, y:center.y},
          {x:center.x, y:center.y-tileWidth/2},
          {x:center.x-tileWidth, y:center.y},
        ];
        for (const vertex of vertices) {
          context.fillStyle = "yellow";
          context.fillRect(vertex.x-2.5, vertex.y-2.5,5,5);

        }
        gridInfoCell.vertices = vertices;


        // TARGET HIGHLIGHT!!
        let floorHighlight;
        for (const plyr3 of this.players) {
          if (
            x === plyr3.target.cell1.number.x &&
            y === plyr3.target.cell1.number.y
          ) {
            if (plyr3.ai.state !== true && plyr3.dead.state !== true && plyr3.falling.state !== true && plyr3.drowning !== true) {
              switch(plyr3.number) {
                case 1:
                  floorHighlight = 'purple';
                break;
                case 2:
                  floorHighlight = 'red';
                break;
              }
            }
            if (plyr3.ai.state === true && plyr3.dead.state !== true && plyr3.falling.state !== true && plyr3.drowning !== true) {
              floorHighlight = 'brown';
            }
            if (plyr3.dead.state !== true) {
              context.lineWidth = 5;
              context.beginPath();
              for (const vertex of vertices) {
                context.strokeStyle = floorHighlight;

                context.lineTo(vertex.x, vertex.y);
              }
              context.closePath();
              context.stroke();
            }
          }
        }

        // MOUSED OVER CELL
        if (this.mouseOverCell.state === true && x === this.mouseOverCell.cell.number.x && y === this.mouseOverCell.cell.number.y) {
          context.lineWidth = 5;
          context.beginPath();
          for (const vertex of vertices) {
            context.strokeStyle = 'orange';
            context.lineTo(vertex.x, vertex.y);
          }
          context.closePath();
          context.stroke();
        }


        // IN GAME ITEM PLACEMENT!!
        if (gridInfoCell.item.name !== '' && gridInfoCell.void.state !== true) {

          let hide = false;
          if (this.obstacleItemsToDrop.length > 0) {
            for(const cell of this.obstacleItemsToDrop) {
              if (gridInfoCell.number.x === cell.target.x && gridInfoCell.number.y === cell.target.y && gridInfoCell.item.name === cell.item.name) {
                hide = true;
              }
            }
          }


          if (hide !== true) {

            let itemImg;
            let fillClr;
            if (gridInfoCell.item.type === 'item') {
              switch(gridInfoCell.item.name) {
                case 'moveSpeedUp' :
                  fillClr = "purple";
                  itemImg = this.itemImgs[gridInfoCell.item.name];
                break;
                case 'moveSpeedDown' :
                  fillClr = "blue";
                  itemImg = this.itemImgs[gridInfoCell.item.name];
                break;
                case 'hpUp' :
                  fillClr = "yellow";
                  itemImg = this.itemImgs[gridInfoCell.item.name];
                break;
                case 'hpDown' :
                  fillClr = "brown";
                  itemImg = this.itemImgs[gridInfoCell.item.name];
                break;
                case 'focusUp' :
                  fillClr = "white";
                  itemImg = this.itemImgs[gridInfoCell.item.name];
                break;
                case 'focusDown' :
                  fillClr = "black";
                  itemImg = this.itemImgs[gridInfoCell.item.name];
                break;
                case 'strengthUp' :
                  fillClr = "green";
                  itemImg = this.itemImgs[gridInfoCell.item.name];
                break;
                case 'strengthDown' :
                  fillClr = "red";
                  itemImg = this.itemImgs[gridInfoCell.item.name];
                break;
                case 'ammo5' :
                  fillClr = "#283618";
                  itemImg = this.itemImgs[gridInfoCell.item.name];
                break;
                case 'ammo10' :
                  fillClr = "#283618";
                  itemImg = this.itemImgs[gridInfoCell.item.name];
                break;
              }
            }
            else if (gridInfoCell.item.type === 'weapon') {
              switch(gridInfoCell.item.subType) {
                case 'sword' :
                  fillClr = "orange";
                  itemImg = this.itemImgs[gridInfoCell.item.subType];
                break;
                case 'spear' :
                  fillClr = "maroon";
                  itemImg = this.itemImgs[gridInfoCell.item.subType];
                break;
                case 'crossbow' :
                  fillClr = "navy";
                  itemImg = this.itemImgs[gridInfoCell.item.subType];
                break;
              }
            }
            else if (gridInfoCell.item.type === 'armor') {
              switch(gridInfoCell.item.subType) {
                case 'helmet' :
                  fillClr = "grey";
                  itemImg = this.itemImgs[gridInfoCell.item.subType];
                break;
                case 'mail' :
                  fillClr = "olive";
                  itemImg = this.itemImgs[gridInfoCell.item.subType];
                break;
                case 'greaves' :
                  fillClr = "#b5179e";
                  itemImg = this.itemImgs[gridInfoCell.item.subType];
                break;
              }
            }

            context.drawImage(itemImg, center.x-15, center.y-15);

            // context.fillStyle = fillClr;
            // context.beginPath();
            // context.arc(center.x, center.y, 10, 0, 2 * Math.PI);
            // context.fill();

          }


        }


        //POPUPS
        // CELL HIGHLIGHT
        for(const popup of this.cellPopups) {
          if (popup.state === true && x === popup.cell.number.x && y === popup.cell.number.y) {
            context.lineWidth = 5;
            context.beginPath();
            for (const vertex of vertices) {
              context.strokeStyle = popup.color;
              context.lineTo(vertex.x, vertex.y);
            }
            context.closePath();
            context.stroke();
          }
        }
        // CELL POPUPS
        if (x === this.gridWidth && y === this.gridWidth) {
          // console.log(this.refs.pickupAmmo);


          for (const popup of this.cellPopups) {

            let popupBorderColor = 'black';
            if (popup.state === true) {
              // console.log('drawing a popup');
              let popupDrawCoords;
              if (popup.position === '' || !popup.position) {
                let currentPopups = this.cellPopups.filter(x=>x.state === true);
                let currentPopupsThisCell = this.cellPopups.filter(x=>x.state === true && x.cell.number.x === popup.cell.number.x && x.cell.number.y === popup.cell.number.y);
                let positions = ['north','east','south','west','northEast','northWest','southEast','southWest'];


                if (popup.color === '') {
                    popup.color = this.cellColorRef.find(x => x.x === popup.cell.number.x && x.y === popup.cell.number.y).color;
                }


                // REMOVE POSITIONS OF POPUPS ALREADY DRAWN FOR THIS CELL
                for (const popup2 of currentPopupsThisCell) {
                  if (popup2.position && popup2.position !== '') {

                    let indx = positions.indexOf(popup2.position);
                    positions.splice(indx,1)
                  }

                }

                let dir = undefined;
                let dirs = [];

                for (const plyr2 of this.players) {
                  if (plyr2.ai.state !== true) {
                    let myPos = popup.cell.number;
                    let invalidPos = this.players[plyr2.number-1].currentPosition.cell.number;
                    // let invalidPositions = [invalidPos];

                    // GET DIRECTION OF PLAYER CELL RELATIVE TO ME
                    dir = this.getDirectionFromCells(myPos,invalidPos);

                    if (dir && positions.includes(dir) === true) {
                      positions.splice(positions.indexOf(dir),1);
                      // console.log('dont draw over player @',dir,'choose frome these position',positions);
                    }


                    // GET DIRECTION THAT ALL OTHER PLAYER'S POPUPS OCCUPY, RELATIVE TO ME
                    for(const pop of plyr2.popups) {

                      dir = undefined;

                      if (pop.state === true) {

                        let invalidPos2 = {
                          x: undefined,
                          y: undefined,
                        }

                        invalidPos2 = this.getCellFromDirection(1,invalidPos,pop.position);


                        // let dir = undefined;

                        dir = this.getDirectionFromCells(myPos,invalidPos2);

                        if (dir && positions.includes(dir) === true) {
                          positions.splice(positions.indexOf(dir),1);
                          // console.log('dont draw over player @',dir,'choose frome these position',positions);
                        }

                      }

                    }


                  }
                }

                // GET DIRECTION OF CELLS THAT AREN'T THIS CELL'S POPUPS' POPUPS CELLS RELATIVE TO ME
                for (const popup2 of currentPopups) {

                  dir = undefined;


                  if (
                    popup.cell.number.x !== popup2.cell.number.x &&
                    popup.cell.number.y !== popup2.cell.number.y &&
                    popup2.msg !== popup.msg &&
                    popup2.state === true
                  ) {

                    let myPos = popup.cell.number;
                    let cellPos = popup2.cell.number;
                    let invalidPos2 = {
                      x: undefined,
                      y: undefined,
                    }

                    invalidPos2 = this.getCellFromDirection(1,cellPos,popup2.position);


                    dir = this.getDirectionFromCells(myPos,invalidPos2);


                    if (dir && positions.includes(dir) === true) {
                      positions.splice(positions.indexOf(dir),1);
                      // console.log('dont draw over player @',dir,'choose frome these position',positions);
                    }

                  }

                }

                if (!positions[0]) {
                  // console.log('no open positions for', popup.msg);
                  popup.state = false;
                  popup.count = 0;
                } else {
                  popup.position = positions[0];
                }


                popup.img = this.popupImageRef[popup.msg]

                popupDrawCoords = this.popupDrawCalc(popup.position,{x:popup.cell.center.x-25,y:popup.cell.center.y-15},0);
                this.drawPopupBubble(context,popupDrawCoords.origin.x,popupDrawCoords.origin.y,this.popupSize,this.popupSize,5,popupDrawCoords.anchor.x,popupDrawCoords.anchor.y,popup.color)
                // context.fillStyle = 'black';
                // context.fillText(""+popup.type+"", popupDrawCoords.origin.x+10, popupDrawCoords.origin.y+5);
                // console.log('popup.msg',popup.msg,popup.img);
                let centerPopupOffset = (this.popupSize-this.popupImgSize)/2;
                context.drawImage(popup.img, popupDrawCoords.origin.x+centerPopupOffset,popupDrawCoords.origin.y+centerPopupOffset,this.popupImgSize,this.popupImgSize);



              }
              else {

                let dir = undefined;
                let dirs = [];


                let currentPopupsNotThis = this.cellPopups.filter(x=>x.state === true && x.msg !== popup.msg && x.cell.number.x !== popup.cell.number.x && x.cell.number.y !== popup.cell.number.y);

                for (const plyr2 of this.players) {
                  if (plyr2.ai.state !== true) {
                    let myPos = popup.cell.number;
                    let invalidPos = this.players[plyr2.number-1].currentPosition.cell.number;


                    // invalidpostions2 push plyr2 position
                    // for player popups
                    //   invalid cell = pop.cell.number + popup position mod, invalposits2 push invalidcell
                    //

                    dir = this.getDirectionFromCells(myPos,invalidPos);

                    dirs.push(dir);


                    for(const pop of plyr2.popups) {

                      if (pop.state === true) {

                        let invalidPos2 = {
                          x: undefined,
                          y: undefined,
                        }

                        invalidPos2 = this.getCellFromDirection(1,invalidPos,pop.position);


                        dir = this.getDirectionFromCells(myPos,invalidPos2);

                        // if (dir && positions.includes(dir) === true) {
                        //   positions.splice(positions.indexOf(dir),1);
                        //   // console.log('dont draw over player @',dir,'choose frome these position',positions);
                        // }
                        dirs.push(dir);

                      }

                    }


                  }
                }

                for (const popup2 of currentPopupsNotThis) {

                  dir = undefined;

                  if (popup2.msg !== popup.msg && popup2.state === true) {

                    let myPos = popup.cell.number;

                    let cellPos = popup2.cell.number;
                    let invalidPos2 = {
                      x: undefined,
                      y: undefined,
                    }

                    invalidPos2 = this.getCellFromDirection(1,cellPos,popup2.position);


                    dir = this.getDirectionFromCells(myPos,invalidPos2);

                    dirs.push(dir);

                  }

                }


                // if (popup.position === dir ) {
                if (dirs.find(x => x === popup.position) ) {
                  // for (const pop of this.cellPopups) {
                  //   pop.position = '';
                  //   pop.state = false;
                  // }
                  this.cellPopups.find(x => x.msg === popup.msg && x.cell.number.x === popup.cell.number.x && x.cell.number.x === popup.cell.number.x).state = false;
                  this.cellPopups.find(x => x.msg === popup.msg && x.cell.number.x === popup.cell.number.x && x.cell.number.x === popup.cell.number.x).position = '';
                  // console.log('reconsidering...',popup.msg);
                }
                else {
                  popup.img = this.popupImageRef[popup.msg]
                  popupDrawCoords = this.popupDrawCalc(popup.position,{x:popup.cell.center.x-25,y:popup.cell.center.y-15},0);
                  // this.drawPopupBubble2(context,popupDrawCoords.origin.x,popupDrawCoords.origin.y,this.popupSize,this.popupSize,2)
                  this.drawPopupBubble(context,popupDrawCoords.origin.x,popupDrawCoords.origin.y,this.popupSize,this.popupSize,5,popupDrawCoords.anchor.x,popupDrawCoords.anchor.y,popup.color)
                  // context.fillStyle = 'black';
                  // context.fillText(""+popup.type+"", popupDrawCoords.origin.x+10, popupDrawCoords.origin.y+5);
                  // console.log('popup.msg',popup.msg);
                  let centerPopupOffset = (this.popupSize-this.popupImgSize)/2;
                  context.drawImage(popup.img, popupDrawCoords.origin.x+centerPopupOffset,popupDrawCoords.origin.y+centerPopupOffset,this.popupImgSize,this.popupImgSize);

                }


              }
            }
          }

        }



        // DRAWN PLAYERS!!
        function playerDrawLog (x,y,plyr) {
          console.log('** playerDrawLog **');
          console.log('-- player --',plyr.number);
          console.log('-- strafing --',plyr.strafing.state);
          console.log('-- turning --',plyr.turning.state);
          console.log('-- currently drawing --',x,y);
          console.log('-- current position --',plyr.currentPosition.cell.number.x,plyr.currentPosition.cell.number.y);
          console.log('-- moving state --',plyr.moving.state);
          console.log('-- moving step --',plyr.moving.step);
          console.log('-- target --',plyr.target.cell1.number.x,plyr.target.cell1.number.y);
          console.log('-- direction --',plyr.direction);
          console.log('-- origin --',plyr.moving.origin.number.x,plyr.moving.origin.number.y);
          console.log('-- action --',plyr.action);
        }
        for (const plyr of this.players) {

          let point = {
            x: plyr.nextPosition.x,
            y: plyr.nextPosition.y,
          };

          let weapon = plyr.currentWeapon.type;
          if (plyr.currentWeapon.type === '' || !plyr.currentWeapon.type) {
            weapon = 'unarmed'
          }

          let finalAnimIndex;

          if (plyr.attacking.state === true && plyr.success.deflected.state !== true) {
            plyr.action = 'attacking'
          }


          // FOR TESTING BY CALLING ONLY @ 1 CELL
          // if (
          //   plyr.currentPosition.cell.number.x === x &&
          //   plyr.currentPosition.cell.number.y === y
          // ) {
          //
          //   switch(plyr.action) {
          //     case 'moving':
          //       let moveSpeed = plyr.speed.move;
          //       if (plyr.terrainMoveSpeed.state === true) {
          //         moveSpeed = plyr.terrainMoveSpeed.speed;
          //       }
          //       if (plyr.pushing.state === true) {
          //         moveSpeed = plyr.pushing.moveSpeed;
          //       }
          //       if (plyr.pulling.state === true) {
          //         moveSpeed = plyr.pulling.moveSpeed;
          //       }
          //       if (plyr.pushed.state === true) {
          //         moveSpeed = plyr.pushed.moveSpeed;
          //       }
          //       if (plyr.pulled.state === true) {
          //         moveSpeed = plyr.pulled.moveSpeed;
          //       }
          //       let rangeIndex = plyr.speed.range.indexOf(moveSpeed)
          //       let moveAnimIndex = this.moveStepRef[rangeIndex].indexOf(plyr.moving.step)
          //       finalAnimIndex = moveAnimIndex;
          //       // console.log('anim testing mv spd',plyr.speed.move,'step',plyr.moving.step,'plyr',plyr.number,'index',finalAnimIndex);
          //       if (plyr.target.cell1.void == true) {
          //         // console.log('anim testing mv void spd',plyr.speed.move,'step',plyr.moving.step,'plyr',plyr.number,'index',finalAnimIndex);
          //       }
          //     break;
          //     case 'jumping':
          //       let rangeIndex4 = plyr.speed.range.indexOf(.1)
          //       let moveAnimIndex4 = this.moveStepRef[rangeIndex4].indexOf(plyr.moving.step)
          //       finalAnimIndex = moveAnimIndex4;
          //       // console.log('anim testing mv spd',plyr.speed.move,'step',plyr.moving.step,'plyr',plyr.number,'index',finalAnimIndex);
          //     break;
          //     case 'strafe moving':
          //       if (plyr.pushBack.state === true ) {
          //         let rangeIndex3 = plyr.speed.range.indexOf(plyr.speed.move)
          //         let moveAnimIndex3 = this.moveStepRef[rangeIndex3].indexOf(plyr.moving.step)
          //         finalAnimIndex = moveAnimIndex3;
          //         // console.log('anim testing pushback spd',plyr.speed.move,'step',plyr.moving.step,'plyr',plyr.number);
          //       } else {
          //         let moveSpeed = plyr.speed.move;
          //         // if (plyr.pushing.state === true) {
          //         //   moveSpeed = plyr.pushing.moveSpeed;
          //         // }
          //         if (plyr.pulling.state === true) {
          //           moveSpeed = plyr.pulling.moveSpeed;
          //         }
          //         if (plyr.pushed.state === true) {
          //           moveSpeed = plyr.pushed.moveSpeed;
          //         }
          //         if (plyr.pulled.state === true) {
          //           moveSpeed = plyr.pulled.moveSpeed;
          //         }
          //         let rangeIndex2 = plyr.speed.range.indexOf(moveSpeed)
          //         let moveAnimIndex2 = this.moveStepRef[rangeIndex2].indexOf(plyr.moving.step)
          //         finalAnimIndex = moveAnimIndex2;
          //         // console.log('anim testing strafe mv spd',plyr.speed.move,'step',plyr.moving.step,'plyr',plyr.number);
          //       }
          //     break;
          //     case 'flanking':
          //       let rangeIndex6 = plyr.speed.range.indexOf(.2)
          //       let moveAnimIndex6 = this.moveStepRef[rangeIndex6].indexOf(plyr.moving.step)
          //       finalAnimIndex = moveAnimIndex6;
          //       // console.log('flanking step',plyr.flanking.step,'step',plyr.moving.step);
          //       // console.log('anim testing mv spd',plyr.speed.move,'step',plyr.moving.step,'plyr',plyr.number,'index',finalAnimIndex);
          //     break;
          //     case 'attacking':
          //       let animIndex = plyr.attacking.count -1;
          //       finalAnimIndex = animIndex;
          //       // console.log('anim testing atk',plyr.attacking.count,'plyr',plyr.number);
          //     break;
          //     case 'defending':
          //     let animIndex2 = plyr.defending.count -1;
          //
          //     if (plyr.defendDecay.state !== true) {
          //       if (plyr.defending.count > 0) {
          //
          //         finalAnimIndex = animIndex2;
          //         // console.log('anim testing def wind up',plyr.defending.count,'plyr',plyr.number, animIndex2);
          //       }
          //       if (plyr.defending.count === 0) {
          //         let animIndex2a = 5;
          //         finalAnimIndex = animIndex2a;
          //         // console.log('anim testing def held',plyr.defending.count,'plyr',plyr.number, animIndex2a);
          //       }
          //     }
          //     if (plyr.defendDecay.state === true) {
          //       if (plyr.defendDecay.count < 11) {
          //         animIndex2 = plyr.defendDecay.count-1;
          //       }
          //       else {
          //
          //         if (plyr.defendDecay.count%10 === 0) {
          //           animIndex2 = 9;
          //         }
          //         else {
          //           let mod = (Math.floor(plyr.defendDecay.count/10)*10)
          //           animIndex2 = (plyr.defendDecay.count-mod)-1;
          //         }
          //
          //       }
          //       finalAnimIndex = animIndex2;
          //     }
          //     // console.log('defend anim index',finalAnimIndex);
          //     break;
          //     case 'idle':
          //       if (plyr.number === 1) {
          //         // console.log('anim testing idle',plyr.idleAnim.count,'plyr',plyr.number);
          //       }
          //       if (plyr.number === 2) {
          //         // console.log('anim testing idle',plyr.idleAnim.count,'plyr',plyr.number);
          //       }
          //       let animIndex3 = plyr.idleAnim.count +1;
          //       finalAnimIndex = animIndex3;
          //     break;
          //     case 'falling':
          //       let animIndex4 = plyr.falling.count -1;
          //       finalAnimIndex = animIndex4;
          //       // console.log('anim testing fall',plyr.falling.count,'plyr',plyr.number);
          //     break;
          //     case 'deflected':
          //       let animIndex5 = plyr.success.deflected.count -1;
          //       // let animIndex5;
          //       if (plyr.success.deflected.count > 10 && plyr.success.deflected.count < 21) {
          //         animIndex5 = (plyr.success.deflected.count-10);
          //       }
          //       if (plyr.success.deflected.count > 20 && plyr.success.deflected.count < 31) {
          //         animIndex5 = (plyr.success.deflected.count-20);
          //       }
          //       if (plyr.success.deflected.count > 30 && plyr.success.deflected.count < 41) {
          //         animIndex5 = (plyr.success.deflected.count-30);
          //       }
          //       if (plyr.success.deflected.count > 40 && plyr.success.deflected.count < 51) {
          //         animIndex5 = (plyr.success.deflected.count-40);
          //       }
          //       if (plyr.halfPushBack.state === true) {
          //         if (plyr.halfPushBack.countUp.state === true) {
          //           animIndex5 = plyr.halfPushBack.countUp.count-1;
          //         }
          //         if (plyr.halfPushBack.countDown.state === true) {
          //           animIndex5 = plyr.halfPushBack.countDown.count-1;
          //         }
          //       }
          //       finalAnimIndex = animIndex5;
          //       // console.log('anim testing dflct',plyr.success.deflected.count,'plyr',plyr.number);
          //     break;
          //     case 'dodging':
          //       let animIndex7 = plyr.dodging.count -1;
          //       finalAnimIndex = animIndex7;
          //       // console.log('anim testing dodge',plyr.dodging.count,'plyr',plyr.number);
          //     break;
          //   }
          //
          // }
          // FOR TESTING BY CALLING ONLY @ 1 CELL


          switch(plyr.action) {
            case 'moving':
              let moveSpeed = plyr.speed.move;
              if (plyr.terrainMoveSpeed.state === true) {
                moveSpeed = plyr.terrainMoveSpeed.speed;
              }
              if (plyr.pushing.state === true) {
                moveSpeed = plyr.pushing.moveSpeed;
              }
              if (plyr.pulling.state === true) {
                moveSpeed = plyr.pulling.moveSpeed;
              }
              if (plyr.pushed.state === true) {
                moveSpeed = plyr.pushed.moveSpeed;
              }
              if (plyr.pulled.state === true) {
                moveSpeed = plyr.pulled.moveSpeed;
              }
              let rangeIndex = plyr.speed.range.indexOf(moveSpeed)
              let moveAnimIndex = this.moveStepRef[rangeIndex].indexOf(plyr.moving.step)
              finalAnimIndex = moveAnimIndex;
              // console.log('anim testing mv spd',plyr.speed.move,'step',plyr.moving.step,'plyr',plyr.number,'index',finalAnimIndex);
              if (plyr.target.cell1.void == true) {
                // console.log('anim testing mv void spd',plyr.speed.move,'step',plyr.moving.step,'plyr',plyr.number,'index',finalAnimIndex);
              }
            break;
            case 'jumping':
              let rangeIndex4 = plyr.speed.range.indexOf(.1)
              let moveAnimIndex4 = this.moveStepRef[rangeIndex4].indexOf(plyr.moving.step)
              finalAnimIndex = moveAnimIndex4;
              // console.log('anim testing mv spd',plyr.speed.move,'step',plyr.moving.step,'plyr',plyr.number,'index',finalAnimIndex);
            break;
            case 'strafe moving':
              if (plyr.pushBack.state === true ) {
                let rangeIndex3 = plyr.speed.range.indexOf(plyr.speed.move)
                let moveAnimIndex3 = this.moveStepRef[rangeIndex3].indexOf(plyr.moving.step)
                finalAnimIndex = moveAnimIndex3;
                // console.log('anim testing pushback spd',plyr.speed.move,'step',plyr.moving.step,'plyr',plyr.number);
              } else {
                let moveSpeed = plyr.speed.move;
                // if (plyr.pushing.state === true) {
                //   moveSpeed = plyr.pushing.moveSpeed;
                // }
                if (plyr.pulling.state === true) {
                  moveSpeed = plyr.pulling.moveSpeed;
                }
                if (plyr.pushed.state === true) {
                  moveSpeed = plyr.pushed.moveSpeed;
                }
                if (plyr.pulled.state === true) {
                  moveSpeed = plyr.pulled.moveSpeed;
                }
                let rangeIndex2 = plyr.speed.range.indexOf(moveSpeed)
                let moveAnimIndex2 = this.moveStepRef[rangeIndex2].indexOf(plyr.moving.step)
                finalAnimIndex = moveAnimIndex2;
                // console.log('anim testing strafe mv spd',plyr.speed.move,'step',plyr.moving.step,'plyr',plyr.number);
              }
            break;
            case 'flanking':
              let rangeIndex6 = plyr.speed.range.indexOf(.2)
              let moveAnimIndex6 = this.moveStepRef[rangeIndex6].indexOf(plyr.moving.step)
              finalAnimIndex = moveAnimIndex6;
              // console.log('flanking step',plyr.flanking.step,'step',plyr.moving.step);
              // console.log('anim testing mv spd',plyr.speed.move,'step',plyr.moving.step,'plyr',plyr.number,'index',finalAnimIndex);
            break;
            case 'attacking':
              // let animIndex = plyr.attacking.count -1;
              let animIndex;


              if (plyr.elasticCounter.state === true && plyr.elasticCounter.type === "attacking") {
                if (plyr.elasticCounter.countUp.state === true) {
                  animIndex = plyr.elasticCounter.countUp.count-1;
                }
                if (plyr.elasticCounter.pause.state === true) {

                  if (plyr.elasticCounter.pause.count < 11) {
                    animIndex = plyr.elasticCounter.pause.count-1;
                  }
                  else {

                    if (plyr.elasticCounter.pause.count%10 === 0) {
                      animIndex = 9;
                      // animIndex5 = 10;
                      // animIndex5 = (plyr.elasticCounter.pause.count-mod)
                    }
                    else {
                      let mod = (Math.floor(plyr.elasticCounter.pause.count/10)*10)
                      animIndex = (plyr.elasticCounter.pause.count-mod)-1;
                    }

                  }

                }
                if (plyr.elasticCounter.countDown.state === true) {
                  animIndex = plyr.elasticCounter.countDown.count-1;
                }
              }
              else {
                animIndex = plyr.attacking.count -1;
              }

              finalAnimIndex = animIndex;
              // console.log('anim testing atk',plyr.attacking.count,'plyr',plyr.number);
            break;
            case 'defending':
              let animIndex2 = plyr.defending.count -1;

              if (plyr.defendDecay.state !== true) {
                if (plyr.defending.count > 0) {

                  finalAnimIndex = animIndex2;
                  // console.log('anim testing def wind up',plyr.defending.count,'plyr',plyr.number, animIndex2);
                }
                if (plyr.defending.count === 0) {
                  let animIndex2a = 5;
                  finalAnimIndex = animIndex2a;
                  // console.log('anim testing def held',plyr.defending.count,'plyr',plyr.number, animIndex2a);
                }
              }
              if (plyr.defendDecay.state === true) {
                if (plyr.defendDecay.count < 11) {
                  animIndex2 = plyr.defendDecay.count-1;
                }
                else {

                  if (plyr.defendDecay.count%10 === 0) {
                    animIndex2 = 9;
                  }
                  else {
                    let mod = (Math.floor(plyr.defendDecay.count/10)*10)
                    animIndex2 = (plyr.defendDecay.count-mod)-1;
                  }

                }
                finalAnimIndex = animIndex2;
              }

            break;
            case 'idle':
              if (plyr.number === 1) {
                // console.log('anim testing idle',plyr.idleAnim.count,'plyr',plyr.number);
              }
              if (plyr.number === 2) {
                // console.log('anim testing idle',plyr.idleAnim.count,'plyr',plyr.number);
              }
              let animIndex3 = plyr.idleAnim.count +1;
              finalAnimIndex = animIndex3;
            break;
            case 'falling':
              let animIndex4 = plyr.falling.count -1;
              finalAnimIndex = animIndex4;
              // console.log('anim testing fall',plyr.falling.count,'plyr',plyr.number);
            break;
            case 'deflected':
              let animIndex5 = plyr.success.deflected.count -1;

              if (plyr.elasticCounter.state === true && plyr.elasticCounter.type === "deflected") {
                if (plyr.elasticCounter.countUp.state === true) {
                  animIndex5 = plyr.elasticCounter.countUp.count-1;
                }
                if (plyr.elasticCounter.pause.state === true) {

                  if (plyr.elasticCounter.pause.count < 11) {
                    animIndex5 = plyr.elasticCounter.pause.count-1;
                  }
                  else {

                    if (plyr.elasticCounter.pause.count%10 === 0) {
                      animIndex5 = 9;
                      // animIndex5 = 10;
                      // animIndex5 = (plyr.elasticCounter.pause.count-mod)
                    }
                    else {
                      let mod = (Math.floor(plyr.elasticCounter.pause.count/10)*10)
                      animIndex5 = (plyr.elasticCounter.pause.count-mod)-1;
                    }

                  }

                }
                if (plyr.elasticCounter.countDown.state === true) {
                  animIndex5 = plyr.elasticCounter.countDown.count-1;
                }
              }
              if (plyr.halfPushBack.state === true) {
                if (plyr.halfPushBack.countUp.state === true) {
                  animIndex5 = plyr.halfPushBack.countUp.count-1;
                }
                if (plyr.halfPushBack.countDown.state === true) {
                  animIndex5 = plyr.halfPushBack.countDown.count-1;
                }
              }
              finalAnimIndex = animIndex5;
              // console.log('anim testing dflct',plyr.success.deflected.count,'plyr',plyr.number);
            break;
            case 'dodging':
              let animIndex7 = plyr.dodging.count -1;

              if (plyr.elasticCounter.state === true && plyr.elasticCounter.type === "dodging") {
                if (plyr.elasticCounter.countUp.state === true) {
                  // animIndex7 = plyr.elasticCounter.countUp.count-1;

                  if (plyr.elasticCounter.countUp.count < 11) {
                    animIndex7 = plyr.elasticCounter.countUp.count-1;
                  }
                  else {

                    if (plyr.elasticCounter.countUp.count%10 === 0) {
                      animIndex7 = 9;
                      // animIndex5 = 10;
                      // animIndex5 = (plyr.elasticCounter.pause.count-mod)
                    }
                    else {
                      let mod = (Math.floor(plyr.elasticCounter.countUp.count/10)*10)
                      animIndex7 = (plyr.elasticCounter.countUp.count-mod)-1;
                    }

                  }

                }
                if (plyr.elasticCounter.pause.state === true) {

                  if (plyr.elasticCounter.pause.count < 11) {
                    animIndex7 = plyr.elasticCounter.pause.count-1;
                  }
                  else {

                    if (plyr.elasticCounter.pause.count%10 === 0) {
                      animIndex7 = 9;
                      // animIndex5 = 10;
                      // animIndex5 = (plyr.elasticCounter.pause.count-mod)
                    }
                    else {
                      let mod = (Math.floor(plyr.elasticCounter.pause.count/10)*10)
                      animIndex7 = (plyr.elasticCounter.pause.count-mod)-1;
                    }

                  }

                }
                if (plyr.elasticCounter.countDown.state === true) {
                  // animIndex7 = plyr.elasticCounter.countDown.count-1;

                  if (plyr.elasticCounter.countDown.count < 11) {
                    animIndex7 = plyr.elasticCounter.countDown.count-1;
                  }
                  else {

                    if (plyr.elasticCounter.countDown.count%10 === 0) {
                      animIndex7 = 9;
                      // animIndex5 = 10;
                      // animIndex5 = (plyr.elasticCounter.pause.count-mod)
                    }
                    else {
                      let mod = (Math.floor(plyr.elasticCounter.countDown.count/10)*10)
                      animIndex7 = (plyr.elasticCounter.countDown.count-mod)-1;
                    }

                  }
                }
              }

              finalAnimIndex = animIndex7;
              // console.log('anim testing dodge',plyr.dodging.count,'plyr',plyr.number);
            break;
          }


          // SPRITE SHEET CHAR AVATAR & ACTION SWITCH!
          if (plyr.ai.state === false) {
            switch(plyr.action) {
              case 'idle':
                updatedPlayerImg = this.playerImgs[plyr.number-1].idle[weapon];
              break;
              case 'moving':
              if (plyr.pushing.state === true) {
                updatedPlayerImg = this.playerImgs[plyr.number-1].pushing[weapon];
              }
              if (plyr.pulled.state === true) {
                updatedPlayerImg = this.playerImgs[plyr.number-1].pulled[weapon];
              }
              if (plyr.pushed.state === true) {
                updatedPlayerImg = this.playerImgs[plyr.number-1].pushed[weapon];
              }
              else {
                updatedPlayerImg = this.playerImgs[plyr.number-1].walking[weapon];
              }

              break;
              case 'jumping':
                updatedPlayerImg = this.playerImgs[plyr.number-1].jumping[weapon];
              break;
              case 'flanking':
                updatedPlayerImg = this.playerImgs[plyr.number-1].flanking[weapon];
              break;
              case 'strafe moving':
                if (plyr.pushBack.state === true) {
                  updatedPlayerImg = this.playerImgs[plyr.number-1].pushBack[weapon];
                }
                if (plyr.pulling.state === true) {
                  updatedPlayerImg = this.playerImgs[plyr.number-1].pulling[weapon];
                }
                if (plyr.pulled.state === true) {
                  updatedPlayerImg = this.playerImgs[plyr.number-1].pulled[weapon];
                }
                if (plyr.pushed.state === true) {
                  updatedPlayerImg = this.playerImgs[plyr.number-1].pushed[weapon];
                }
                else {
                   updatedPlayerImg = this.playerImgs[plyr.number-1].strafing[weapon];
                }
              break;
              case 'falling':
                updatedPlayerImg = this.playerImgs[plyr.number-1].falling[weapon];
              break;
              case 'attacking':
                updatedPlayerImg = this.playerImgs[plyr.number-1].attacking[weapon];
              break;
              case 'defending':
                updatedPlayerImg = this.playerImgs[plyr.number-1].defending[weapon];
              break;
              case 'deflected' :
                updatedPlayerImg = this.playerImgs[plyr.number-1].deflected[weapon];
              break;
              case 'dodging' :
                updatedPlayerImg = this.playerImgs[plyr.number-1].dodging[weapon];
              break;
              case 'dead':
                updatedPlayerImg = this.playerImgs[plyr.number-1].idle[weapon];
              break;
            }
          }
          if (plyr.ai.state === true) {
            let plyrImgIndex;
            if (plyr.ai.imgType === "A") {
              plyrImgIndex = 2;
            }
            else if (plyr.ai.imgType === "B") {
              plyrImgIndex = 3;
            }

            switch(plyr.action) {
              case 'idle':
                updatedPlayerImg = this.playerImgs[plyrImgIndex].idle[weapon];
              break;
              case 'moving':
                if (plyr.pushing.state === true) {
                  updatedPlayerImg = this.playerImgs[plyrImgIndex].pushing[weapon];
                }
                if (plyr.pulled.state === true) {
                  updatedPlayerImg = this.playerImgs[plyrImgIndex].pulled[weapon];
                }
                if (plyr.pushed.state === true) {
                  updatedPlayerImg = this.playerImgs[plyrImgIndex].pushed[weapon];
                }
                else {
                  updatedPlayerImg = this.playerImgs[plyrImgIndex].walking[weapon];
                }
              break;
              case 'jumping':
                updatedPlayerImg = this.playerImgs[plyrImgIndex].jumping[weapon];
              break;
              case 'flanking':
                updatedPlayerImg = this.playerImgs[plyrImgIndex].flanking[weapon];
              break;
              case 'strafe moving':
              if (plyr.pushBack.state === true) {
                updatedPlayerImg = this.playerImgs[plyrImgIndex].pushBack[weapon];
              }
              if (plyr.pulling.state === true) {
                updatedPlayerImg = this.playerImgs[plyrImgIndex].pulling[weapon];
              }
              if (plyr.pulled.state === true) {
                updatedPlayerImg = this.playerImgs[plyrImgIndex].pulled[weapon];
              }
              if (plyr.pushed.state === true) {
                updatedPlayerImg = this.playerImgs[plyrImgIndex].pushed[weapon];
              }
              else {
                 updatedPlayerImg = this.playerImgs[plyrImgIndex].strafing[weapon];
              }
              break;
              case 'falling':
                updatedPlayerImg = this.playerImgs[plyrImgIndex].falling[weapon];
              break;
              case 'attacking':
                updatedPlayerImg = this.playerImgs[plyrImgIndex].attacking[weapon];
              break;
              case 'defending':
                updatedPlayerImg = this.playerImgs[plyrImgIndex].defending[weapon];
              break;
              case 'deflected' :
                updatedPlayerImg = this.playerImgs[plyrImgIndex].deflected[weapon];
              break;
              case 'dodging' :
                updatedPlayerImg = this.playerImgs[plyrImgIndex].dodging[weapon];
              break;
              case 'dead':
                updatedPlayerImg = this.playerImgs[plyrImgIndex].idle[weapon];
              break;
            }
          }


          // SET SPRITE SHEET CLIP LOCATION!
          let dirs = ['north','south','east','west']
          let dirIndex = dirs.indexOf(plyr.direction);
          let sHeight = this.charSpriteHeight;
          let sWidth = this.charSpriteWidth;
          let sy = dirIndex * sHeight;
          let sx = (finalAnimIndex - 1)* sWidth;



          // PLAYER OUTLINES
          if (this.showPlayerOutlines === true) {

            // PLAYER OUTLINES
            let popupCoordObject = {
              north: this.popupDrawCalc("north",{x:plyr.nextPosition.x-25,y:plyr.nextPosition.y-25},plyr.number),
              west: this.popupDrawCalc("west",{x:plyr.nextPosition.x-25,y:plyr.nextPosition.y-25},plyr.number),
              south: this.popupDrawCalc("south",{x:plyr.nextPosition.x-25,y:plyr.nextPosition.y-25},plyr.number),
            };
            let origin = popupCoordObject.west;
            let width = popupCoordObject.north.pt4.x - origin.pt3.x;
            let height = popupCoordObject.south.pt2.y - origin.pt3.y;
            context.strokeStyle = 'white';
            context.lineWidth = 2;
            context.beginPath();
            context.roundRect(origin.pt3.x,origin.pt3.y, width, height, 2);
            context.stroke();

            let origin2 = {x:plyr.nextPosition.x-(this.floorImageHeight/2),y:plyr.nextPosition.y-(this.floorImageHeight)};
            let height2 = (plyr.nextPosition.y+(this.floorImageHeight/2))+2-(plyr.nextPosition.y-(this.floorImageHeight));
            let width2 = this.playerDrawWidth+2;
            context.strokeStyle = 'white';
            context.lineWidth = 2;
            context.beginPath();
            context.roundRect(origin2.x,origin2.y, width2+2, this.playerDrawHeight*1.5, 2);
            // context.roundRect(origin2.x,origin2.y, width2, height2, 2);
            // context.roundRect(origin2.x,origin2.y, this.playerDrawWidth, this.playerDrawHeight*1.5, 2);
            // context.roundRect(origin2.x,origin2.y, this.playerDrawWidth+2, this.floorImageHeight*1.5, 2);
            context.stroke();

          }



          //PLAYER DEPTH SORTING!!

          // MOVING & MID STRAFE KEY RELEASE
          if (plyr.target.cell1.void === false && plyr.moving.state === true && plyr.falling.state !== true && plyr.jumping.state !== true) {
            let jumpYCalc = 10 - this.moveStepRef[1].indexOf(plyr.moving.step);
            // console.log('move',finalAnimIndex);
            // if (plyr.direction === 'north' || plyr.direction === 'northWest' || plyr.direction === 'west') {
            //   if (x === plyr.moving.origin.number.x && y === plyr.moving.origin.number.y) {
            //     // console.log('ff',plyr.action ,finalAnimIndex,'plyr #', player.number);
            //
            //     if (plyr.jumping.state === true) {
            //       context.drawImage(updatedPlayerImg, sx, sy, sWidth, sHeight, point.x-25, point.y-25-(jumpYCalc*3), this.playerDrawWidth, this.playerDrawHeight);
            //     } else {
            //       context.drawImage(updatedPlayerImg, sx, sy, sWidth, sHeight, point.x-25, point.y-25, this.playerDrawWidth, this.playerDrawHeight);
            //     }
            //
            //     // console.log('moving @ drawstep ...finalAnimIndex',finalAnimIndex,plyr.action,'terrainMoveSpeed state',plyr.terrainMoveSpeed.state,'animation mv spd terrain',plyr.terrainMoveSpeed.speed,'animation mv spd',plyr.speed.move,'step',plyr.moving.step);
            //
            //   }

            let direction = plyr.direction;
            if (plyr.strafing.direction !== "") {
              direction = plyr.strafing.direction;
            }
            if (direction === 'north') {

              if (x === plyr.moving.origin.number.x && y === plyr.moving.origin.number.y) {
                // console.log('ff',plyr.action ,finalAnimIndex,'plyr #', player.number);

                if (plyr.jumping.state === true) {
                  context.drawImage(updatedPlayerImg, sx, sy, sWidth, sHeight, point.x-(this.playerDrawWidth/2), point.y-(this.playerDrawHeight/2)-(jumpYCalc*3), this.playerDrawWidth, this.playerDrawHeight);
                } else {
                  context.drawImage(updatedPlayerImg, sx, sy, sWidth, sHeight, point.x-(this.playerDrawWidth/2), point.y-(this.playerDrawHeight/2), this.playerDrawWidth, this.playerDrawHeight);
                }

                // console.log('moving @ drawstep ...finalAnimIndex',finalAnimIndex,plyr.action,'terrainMoveSpeed state',plyr.terrainMoveSpeed.state,'animation mv spd terrain',plyr.terrainMoveSpeed.speed,'animation mv spd',plyr.speed.move,'step',plyr.moving.step);

              }
            }
            if (direction === 'west') {
              if (x === plyr.moving.origin.number.x && y === plyr.moving.origin.number.y) {
                // console.log('ff',plyr.action ,finalAnimIndex,'plyr #', player.number);

                if (plyr.jumping.state === true) {
                  context.drawImage(updatedPlayerImg, sx, sy, sWidth, sHeight, point.x-(this.playerDrawWidth/2), point.y-(this.playerDrawHeight/2)-(jumpYCalc*3), this.playerDrawWidth, this.playerDrawHeight);
                } else {
                  context.drawImage(updatedPlayerImg, sx, sy, sWidth, sHeight, point.x-(this.playerDrawWidth/2), point.y-(this.playerDrawHeight/2), this.playerDrawWidth, this.playerDrawHeight);
                }

                // console.log('moving @ drawstep ...finalAnimIndex',finalAnimIndex,plyr.action,'terrainMoveSpeed state',plyr.terrainMoveSpeed.state,'animation mv spd terrain',plyr.terrainMoveSpeed.speed,'animation mv spd',plyr.speed.move,'step',plyr.moving.step);

              }
            }
            // if (plyr.direction === 'east' || plyr.direction === 'south' || plyr.direction === 'southEast') {
            //   if (x === plyr.moving.origin.number.x && y === plyr.moving.origin.number.y) {
            //     // console.log('ff',plyr.action ,finalAnimIndex,'plyr #', player.number);
            //     console.log('here',x,y);
            //     if (plyr.jumping.state === true) {
            //       context2.translate(this.camera.pan.x,this.camera.pan.y);
            //       context2.scale(this.camera.zoom.x,this.camera.zoom.y);
            //       context2.drawImage(updatedPlayerImg, sx, sy, sWidth, sHeight, point.x-25, point.y-25-(jumpYCalc*3), this.playerDrawWidth, this.playerDrawHeight);
            //
            //     } else {
            //       context2.translate(this.camera.pan.x,this.camera.pan.y);
            //       context2.scale(this.camera.zoom.x,this.camera.zoom.y);
            //       context2.drawImage(updatedPlayerImg, sx, sy, sWidth, sHeight, point.x-25, point.y-25, this.playerDrawWidth, this.playerDrawHeight);
            //
            //     }
            //     // console.log('moving @ drawstep ...finalAnimIndex',finalAnimIndex,plyr.action,'terrainMoveSpeed state',plyr.terrainMoveSpeed.state,'animation mv spd terrain',plyr.terrainMoveSpeed.speed,'animation mv spd',plyr.speed.move,'step',plyr.moving.step);
            //     // playerDrawLog(x,y,plyr)
            //   }
            // }
            if (direction === 'east') {
              if (x === plyr.moving.origin.number.x+1 && y === plyr.moving.origin.number.y) {
                // console.log('ff',plyr.action ,finalAnimIndex,'plyr #', player.number);
                // console.log('here',x,y);
                if (plyr.jumping.state === true) {
                  context.drawImage(updatedPlayerImg, sx, sy, sWidth, sHeight, point.x-(this.playerDrawWidth/2), point.y-(this.playerDrawHeight/2)-(jumpYCalc*3), this.playerDrawWidth, this.playerDrawHeight);

                } else {
                  context.drawImage(updatedPlayerImg, sx, sy, sWidth, sHeight, point.x-(this.playerDrawWidth/2), point.y-(this.playerDrawHeight/2), this.playerDrawWidth, this.playerDrawHeight);

                }
                // console.log('moving @ drawstep ...finalAnimIndex',finalAnimIndex,plyr.action,'terrainMoveSpeed state',plyr.terrainMoveSpeed.state,'animation mv spd terrain',plyr.terrainMoveSpeed.speed,'animation mv spd',plyr.speed.move,'step',plyr.moving.step);
                // playerDrawLog(x,y,plyr)
              }
            }
            if (direction === 'south') {
              if (x === plyr.moving.origin.number.x && y === plyr.moving.origin.number.y+1) {
                // console.log('ff',plyr.action ,finalAnimIndex,'plyr #', player.number);
                if (plyr.jumping.state === true) {
                  context.drawImage(updatedPlayerImg, sx, sy, sWidth, sHeight, point.x-(this.playerDrawWidth/2), point.y-(this.playerDrawHeight/2)-(jumpYCalc*3), this.playerDrawWidth, this.playerDrawHeight);
                } else {
                  context.drawImage(updatedPlayerImg, sx, sy, sWidth, sHeight, point.x-(this.playerDrawWidth/2), point.y-(this.playerDrawHeight/2), this.playerDrawWidth, this.playerDrawHeight);
                }
                // console.log('moving @ drawstep ...finalAnimIndex',finalAnimIndex,plyr.action,'terrainMoveSpeed state',plyr.terrainMoveSpeed.state,'animation mv spd terrain',plyr.terrainMoveSpeed.speed,'animation mv spd',plyr.speed.move,'step',plyr.moving.step);
                // playerDrawLog(x,y,plyr)
              }
            }

            if (plyr.pushBack.state === true) {

              // context.drawImage(indicatorImgs.pushback, point.x-20, point.y-20, 35,35);
            }

          }
          // STATIONARY & HALFPUSH BACK
          else if (plyr.moving.state === false && plyr.ghost.state !== true && plyr.dodging.state !== true && plyr.elasticCounter.state !== true && plyr.action !== 'attacking') {

            if (plyr.halfPushBack.state === true && plyr.success.deflected.state !== true) {


              let finalCoords = this.calcElasticCountCoords('halfPushBack','player',plyr).coords;
              let drawCell = this.calcElasticCountCoords('halfPushBack','player',plyr).drawCell;

              // if (x === drawCell.x && y === drawCell.y) {
              //
              //   context.drawImage(updatedPlayerImg, sx, sy, sWidth, sHeight, finalCoords.x, finalCoords.y, this.playerDrawWidth, this.playerDrawHeight)
              //
              // }

              if (
                !this.gridInfo.find(x => x.number.x === this.getCellFromDirection(1,plyr.currentPosition.cell.number,plyr.elasticCounter.direction).x && x.number.y === this.getCellFromDirection(1,plyr.currentPosition.cell.number,plyr.elasticCounter.direction).y )
              ) {
                if (
                  x === plyr.currentPosition.cell.number.x &&
                  y === plyr.currentPosition.cell.number.y
                ) {
                  context.drawImage(updatedPlayerImg, sx, sy, sWidth, sHeight, finalCoords.x, finalCoords.y, this.playerDrawWidth, this.playerDrawHeight)
                }
              }
              else {

                if (plyr.direction === 'north') {
                  if (
                    x === plyr.currentPosition.cell.number.x &&
                    y === plyr.currentPosition.cell.number.y+1
                  ) {
                    context.drawImage(updatedPlayerImg, sx, sy, sWidth, sHeight, finalCoords.x, finalCoords.y, this.playerDrawWidth, this.playerDrawHeight)
                  }
                }
                if (plyr.direction === 'east') {
                  if (
                    x === plyr.currentPosition.cell.number.x &&
                    y === plyr.currentPosition.cell.number.y
                  ) {
                    context.drawImage(updatedPlayerImg, sx, sy, sWidth, sHeight, finalCoords.x, finalCoords.y, this.playerDrawWidth, this.playerDrawHeight)
                  }
                }
                if (plyr.direction === 'west') {
                  if (
                    x === plyr.currentPosition.cell.number.x+1 &&
                    y === plyr.currentPosition.cell.number.y
                  ) {
                    context.drawImage(updatedPlayerImg, sx, sy, sWidth, sHeight, finalCoords.x, finalCoords.y, this.playerDrawWidth, this.playerDrawHeight)
                  }
                }
                if (plyr.direction === 'south') {
                  if (
                    x === plyr.currentPosition.cell.number.x+1 &&
                    y === plyr.currentPosition.cell.number.y
                  ) {
                    context.drawImage(updatedPlayerImg, sx, sy, sWidth, sHeight, finalCoords.x, finalCoords.y, this.playerDrawWidth, this.playerDrawHeight)
                  }
                }

              }



            }
            else {

              if (x === plyr.moving.origin.number.x && y === plyr.moving.origin.number.y && plyr.success.deflected.state === false) {

                context.drawImage(updatedPlayerImg, sx, sy, sWidth, sHeight, point.x-(this.playerDrawWidth/2), point.y-(this.playerDrawHeight/2), this.playerDrawWidth, this.playerDrawHeight);

              }

            }


          }
          // VOID MOVE
          else if (plyr.target.cell1.void === true && plyr.moving.state === true && plyr.falling.state !== true && plyr.jumping.state !== true) {

            // console.log('heading for thevoid @ draw step');
            // if (
            //   x === plyr.currentPosition.cell.number.x &&
            //   y === plyr.currentPosition.cell.number.y
            // ) {
            //   console.log('heading for thevoid @ draw step',plyr.target.cell1.number);
            // }


            if (plyr.moving.origin.number.x === this.gridWidth && plyr.moving.origin.number.y !== 0 && plyr.moving.origin.number.y !== this.gridWidth) {
              if (x === plyr.moving.origin.number.x && y === plyr.moving.origin.number.y + 1) {

                context.drawImage(updatedPlayerImg, sx, sy, sWidth, sHeight, point.x-(this.playerDrawWidth/2), point.y-(this.playerDrawHeight/2), this.playerDrawWidth, this.playerDrawHeight)
                // context.fillStyle = "black";
                // context.fillRect(point.x, point.y,5,5);
              }
            }
            if (plyr.moving.origin.number.x === this.gridWidth && plyr.moving.origin.number.y === 0) {
              if (x === plyr.moving.origin.number.x && y === plyr.moving.origin.number.y) {

                context.drawImage(updatedPlayerImg, sx, sy, sWidth, sHeight, point.x-(this.playerDrawWidth/2), point.y-(this.playerDrawHeight/2), this.playerDrawWidth, this.playerDrawHeight);
                // context.fillStyle = "black";
                // context.fillRect(point.x, point.y,5,5);
              }
            }
            if (plyr.moving.origin.number.x === this.gridWidth && plyr.moving.origin.number.y === this.gridWidthd) {
              if (x === plyr.moving.origin.number.x && y === plyr.moving.origin.number.y) {

                context.drawImage(updatedPlayerImg, sx, sy, sWidth, sHeight, point.x-(this.playerDrawWidth/2), point.y-(this.playerDrawHeight/2), this.playerDrawWidth, this.playerDrawHeight)
                // context.fillStyle = "black";
                // context.fillRect(point.x, point.y,5,5);
              }
            }
            if (plyr.moving.origin.number.x === 0 && plyr.moving.origin.number.y === this.gridWidthd) {
              if (x === plyr.moving.origin.number.x && y === plyr.moving.origin.number.y) {

                context.drawImage(updatedPlayerImg, sx, sy, sWidth, sHeight, point.x-(this.playerDrawWidth/2), point.y-(this.playerDrawHeight/2), this.playerDrawWidth, this.playerDrawHeight)
                // context.fillStyle = "black";
                // context.fillRect(point.x, point.y,5,5);
              }
            }
            if (plyr.moving.origin.number.x === 0 && plyr.moving.origin.number.y === 0) {
              if (x === plyr.moving.origin.number.x && y === plyr.moving.origin.number.y) {

                context.drawImage(updatedPlayerImg, sx, sy, sWidth, sHeight, point.x-(this.playerDrawWidth/2), point.y-(this.playerDrawHeight/2), this.playerDrawWidth, this.playerDrawHeight)
                // context.fillStyle = "black";
                // context.fillRect(point.x, point.y,5,5);
              }
            }
            else {
              if (x === plyr.moving.origin.number.x + 1 && y === plyr.moving.origin.number.y) {

                context.drawImage(updatedPlayerImg, sx, sy, sWidth, sHeight, point.x-(this.playerDrawWidth/2), point.y-(this.playerDrawHeight/2), this.playerDrawWidth, this.playerDrawHeight)
                // context.fillStyle = "black";
                // context.fillRect(point.x, point.y,5,5);
              }
            }
          }

          // if (plyr.attacking.state === true) {
          if ((plyr.attacking.state === true || plyr.action === 'attacking') && plyr.moving.state === false && plyr.ghost.state !== true && plyr.dodging.state !== true) {

            if (plyr.elasticCounter.state === true && plyr.elasticCounter.type === "attacking") {

              let finalCoords = this.calcElasticCountCoords('attacking','player',plyr).coords;
              let drawCell = this.calcElasticCountCoords('attacking','player',plyr).drawCell;


              // test logging
              if (x ===this.gridWidth && y === this.gridWidth) {

                if (plyr.elasticCounter.countUp.state === true) {
                  // this.testDraw.push({color: 'red',x:finalCoords.x,y:finalCoords.y })
                  // console.log('dodging elastic count coords: countUp: ',plyr.elasticCounter.countUp.count,finalCoords,plyr.elasticCounter.direction);
                }
                if (plyr.elasticCounter.countDown.state === true) {
                  // this.testDraw.push({color: 'blue',x:finalCoords.x,y:finalCoords.y })
                  // console.log('dodging elastic count coords: countDown: ',plyr.elasticCounter.countDown.count,finalCoords,plyr.elasticCounter.direction);
                }
                if (plyr.elasticCounter.pause.state === true) {
                  // this.testDraw.push({color: 'blue',x:finalCoords.x,y:finalCoords.y })
                  // console.log('dodging elastic count coords: pause: ',plyr.elasticCounter.pause.count,finalCoords,plyr.elasticCounter.direction);
                }

              }



              if (!this.gridInfo.find(x => x.number.x === this.getCellFromDirection(1,plyr.currentPosition.cell.number,plyr.elasticCounter.direction).x && x.number.y === this.getCellFromDirection(1,plyr.currentPosition.cell.number,plyr.elasticCounter.direction).y )) {

                if (
                  x === plyr.currentPosition.cell.number.x &&
                  y === plyr.currentPosition.cell.number.y
                ) {
                  context.drawImage(updatedPlayerImg, sx, sy, sWidth, sHeight, finalCoords.x, finalCoords.y, this.playerDrawWidth, this.playerDrawHeight)
                }

              }
              else {

                if (plyr.elasticCounter.direction === 'north') {
                  if (
                    x === plyr.currentPosition.cell.number.x &&
                    y === plyr.currentPosition.cell.number.y
                  ) {
                    context.drawImage(updatedPlayerImg, sx, sy, sWidth, sHeight, finalCoords.x, finalCoords.y, this.playerDrawWidth, this.playerDrawHeight)
                  }
                }
                if (plyr.elasticCounter.direction === 'east') {
                  if (
                    x === plyr.currentPosition.cell.number.x+1 &&
                    y === plyr.currentPosition.cell.number.y
                  ) {
                    context.drawImage(updatedPlayerImg, sx, sy, sWidth, sHeight, finalCoords.x, finalCoords.y, this.playerDrawWidth, this.playerDrawHeight)
                  }
                }
                if (plyr.elasticCounter.direction === 'west') {
                  if (
                    x === plyr.currentPosition.cell.number.x &&
                    y === plyr.currentPosition.cell.number.y
                  ) {
                    context.drawImage(updatedPlayerImg, sx, sy, sWidth, sHeight, finalCoords.x, finalCoords.y, this.playerDrawWidth, this.playerDrawHeight)
                  }
                }
                if (plyr.elasticCounter.direction === 'south') {
                  if (
                    x === plyr.currentPosition.cell.number.x &&
                    y === plyr.currentPosition.cell.number.y+1
                  ) {
                    context.drawImage(updatedPlayerImg, sx, sy, sWidth, sHeight, finalCoords.x, finalCoords.y, this.playerDrawWidth, this.playerDrawHeight)
                  }
                }

              }

            }

            else {

              if (x === plyr.moving.origin.number.x && y === plyr.moving.origin.number.y && plyr.success.deflected.state === false) {

                context.drawImage(updatedPlayerImg, sx, sy, sWidth, sHeight, point.x-(this.playerDrawWidth/2), point.y-(this.playerDrawHeight/2), this.playerDrawWidth, this.playerDrawHeight);

              }

            }

            // if (x === plyr.moving.origin.number.x && y === plyr.moving.origin.number.y && plyr.success.deflected.state === false) {
            //
            //   context.drawImage(updatedPlayerImg, sx, sy, sWidth, sHeight, point.x-(this.playerDrawWidth/2), point.y-(this.playerDrawHeight/2), this.playerDrawWidth, this.playerDrawHeight);
            //
            // }

          }



          if (plyr.jumping.state === true ) {
            let jumpYCalc = 10 - this.moveStepRef[1].indexOf(plyr.moving.step);

            if (plyr.direction === 'north') {
              if (x === plyr.moving.origin.number.x && y === plyr.moving.origin.number.y) {
                context.drawImage(updatedPlayerImg, sx, sy, sWidth, sHeight, point.x-(this.playerDrawWidth/2), point.y-(this.playerDrawHeight/2)-(jumpYCalc*3), this.playerDrawWidth, this.playerDrawHeight);
              }
            }
            if (plyr.direction === 'west') {
              if (x === plyr.moving.origin.number.x && y === plyr.moving.origin.number.y) {
                context.drawImage(updatedPlayerImg, sx, sy, sWidth, sHeight, point.x-(this.playerDrawWidth/2), point.y-(this.playerDrawHeight/2)-(jumpYCalc*3), this.playerDrawWidth, this.playerDrawHeight);
              }
            }
            if (plyr.direction === 'east') {
              if (x === plyr.target.cell2.number.x && y === plyr.target.cell2.number.y) {
                context.drawImage(updatedPlayerImg, sx, sy, sWidth, sHeight, point.x-(this.playerDrawWidth/2), point.y-(this.playerDrawHeight/2)-(jumpYCalc*3), this.playerDrawWidth, this.playerDrawHeight);
              }
            }
            if (plyr.direction === 'south') {
              if (x === plyr.target.cell2.number.x && y === plyr.target.cell2.number.y) {
                context.drawImage(updatedPlayerImg, sx, sy, sWidth, sHeight, point.x-(this.playerDrawWidth/2), point.y-(this.playerDrawHeight/2)-(jumpYCalc*3), this.playerDrawWidth, this.playerDrawHeight);
              }
            }
          }
          if (plyr.strafing.state === true && plyr.falling.state !== true && plyr.jumping.state !== true) {
            if (plyr.strafing.direction === 'north' || plyr.strafing.direction === 'northWest' || plyr.strafing.direction === 'west') {
              if (x === plyr.moving.origin.number.x && y === plyr.moving.origin.number.y) {
                // context.drawImage(updatedPlayerImg, point.x-25, point.y-25, 55,55);
                context.drawImage(updatedPlayerImg, sx, sy, sWidth, sHeight, point.x-(this.playerDrawWidth/2), point.y-(this.playerDrawHeight/2), this.playerDrawWidth, this.playerDrawHeight);
                // playerDrawLog(x,y,plyr)
              }

            }
            if (plyr.strafing.direction === 'east' || plyr.direction === 'east') {
              if (x === plyr.moving.origin.number.x+1 && y === plyr.moving.origin.number.y) {
              // if (x === plyr.target.cell1.number.x && y === plyr.target.cell1.number.y) {
                // context.drawImage(updatedPlayerImg, point.x-25, point.y-25, 55,55);
                context.drawImage(updatedPlayerImg, sx, sy, sWidth, sHeight, point.x-(this.playerDrawWidth/2), point.y-(this.playerDrawHeight/2), this.playerDrawWidth, this.playerDrawHeight);
                // playerDrawLog(x,y)
              }

            }
            if (plyr.strafing.direction === 'south' || plyr.direction === 'south') {
              if (x === plyr.moving.origin.number.x && y === plyr.moving.origin.number.y+1) {
              // if (x === plyr.moving.destination.number.x && y === plyr.moving.destination.number.y) {
              // if (x === plyr.target.cell1.number.x && y === plyr.target.cell1.number.y) {
                // context.drawImage(updatedPlayerImg, point.x-25, point.y-25, 55,55);
                context.drawImage(updatedPlayerImg, sx, sy, sWidth, sHeight, point.x-(this.playerDrawWidth/2), point.y-(this.playerDrawHeight/2), this.playerDrawWidth, this.playerDrawHeight);
                // playerDrawLog(x,y)
              }

            }
            if (plyr.strafing.direction === 'northEast') {
              if (x === plyr.moving.origin.number.x+1 && y === plyr.moving.origin.number.y) {
                // context.drawImage(updatedPlayerImg, point.x-25, point.y-25, 55,55);
                context.drawImage(updatedPlayerImg, sx, sy, sWidth, sHeight, point.x-(this.playerDrawWidth/2), point.y-(this.playerDrawHeight/2), this.playerDrawWidth, this.playerDrawHeight);
                // playerDrawLog(x,y)
              }
            }
            if (plyr.strafing.direction === 'southWest') {
              if (x === plyr.moving.origin.number.x && y === plyr.moving.origin.number.y+1) {
                // context.drawImage(updatedPlayerImg, point.x-25, point.y-25, 55,55);
                context.drawImage(updatedPlayerImg, sx, sy, sWidth, sHeight, point.x-(this.playerDrawWidth/2), point.y-(this.playerDrawHeight/2), this.playerDrawWidth, this.playerDrawHeight);
                // playerDrawLog(x,y)
              }
            }
          }
          if (plyr.flanking.state === true && plyr.falling.state !== true) {


            if (plyr.flanking.step === 1) {


              if (plyr.flanking.direction === 'north') {
                if (x === plyr.moving.origin.number.x && y === plyr.moving.origin.number.y) {
                  // console.log('draw flank north',);
                  context.drawImage(updatedPlayerImg, sx, sy, sWidth, sHeight, point.x-(this.playerDrawWidth/2), point.y-(this.playerDrawHeight/2), this.playerDrawWidth, this.playerDrawHeight);
                }
              }

              if (plyr.flanking.direction === 'west') {
                if (x === plyr.moving.origin.number.x && y === plyr.moving.origin.number.y) {
                  // console.log('draw flank west',);
                  context.drawImage(updatedPlayerImg, sx, sy, sWidth, sHeight, point.x-(this.playerDrawWidth/2), point.y-(this.playerDrawHeight/2), this.playerDrawWidth, this.playerDrawHeight);
                }
              }

              if (plyr.flanking.direction === 'east') {
                if (x === plyr.moving.origin.number.x+1 && y === plyr.moving.origin.number.y) {
                  // console.log('draw flank east',);
                  context.drawImage(updatedPlayerImg, sx, sy, sWidth, sHeight, point.x-(this.playerDrawWidth/2), point.y-(this.playerDrawHeight/2), this.playerDrawWidth, this.playerDrawHeight);
                }
              }

              if (plyr.flanking.direction === 'south') {
                if (x === plyr.moving.origin.number.x && y === plyr.moving.origin.number.y+1) {
                  // console.log('draw flank south',);
                  context.drawImage(updatedPlayerImg, sx, sy, sWidth, sHeight, point.x-(this.playerDrawWidth/2), point.y-(this.playerDrawHeight/2), this.playerDrawWidth, this.playerDrawHeight);
                }
              }

            }

            if (plyr.flanking.step === 2) {


              if (plyr.direction === 'north') {
                if (x === plyr.moving.origin.number.x && y === plyr.moving.origin.number.y) {
                  context.drawImage(updatedPlayerImg, sx, sy, sWidth, sHeight, point.x-(this.playerDrawWidth/2), point.y-(this.playerDrawHeight/2), this.playerDrawWidth, this.playerDrawHeight)
                }
              }

              if (plyr.direction === 'west') {
                if (x === plyr.moving.origin.number.x && y === plyr.moving.origin.number.y) {
                  context.drawImage(updatedPlayerImg, sx, sy, sWidth, sHeight, point.x-(this.playerDrawWidth/2), point.y-(this.playerDrawHeight/2), this.playerDrawWidth, this.playerDrawHeight)
                }
              }

              if (plyr.direction === 'east') {
                if (x === plyr.moving.origin.number.x+1 && y === plyr.moving.origin.number.y) {
                  context.drawImage(updatedPlayerImg, sx, sy, sWidth, sHeight, point.x-(this.playerDrawWidth/2), point.y-(this.playerDrawHeight/2), this.playerDrawWidth, this.playerDrawHeight)
                }
              }

              if (plyr.direction === 'south') {
                if (x === plyr.moving.origin.number.x && y === plyr.moving.origin.number.y+1) {
                  context.drawImage(updatedPlayerImg, sx, sy, sWidth, sHeight, point.x-(this.playerDrawWidth/2), point.y-(this.playerDrawHeight/2), this.playerDrawWidth, this.playerDrawHeight)
                }
              }

            }

          }
          if (plyr.falling.state === true) {

            if (
              x === plyr.target.cell1.number.x &&
              y === plyr.target.cell1.number.y
            ) {
              context.drawImage(updatedPlayerImg, sx, sy, sWidth, sHeight, point.x-(this.playerDrawWidth/2), point.y-(this.playerDrawHeight/2), this.playerDrawWidth, this.playerDrawHeight);
              // playerDrawLog(x,y,plyr)
            }

            if (
              plyr.target.cell1.number.x < 0 ||
              plyr.target.cell1.number.y < 0 ||
              plyr.target.cell1.number.x > this.gridWidth ||
              plyr.target.cell1.number.y > this.gridWidth
            ) {
              if (
                x === plyr.moving.origin.number.x &&
                y === plyr.moving.origin.number.y
              ) {
                context.drawImage(updatedPlayerImg, sx, sy, sWidth, sHeight, point.x-(this.playerDrawWidth/2), point.y-(this.playerDrawHeight/2), this.playerDrawWidth, this.playerDrawHeight);
                // playerDrawLog(x,y,plyr)
              }
            }

          }
          if (plyr.success.deflected.state === true) {


            if (plyr.elasticCounter.state === true && plyr.elasticCounter.type === 'deflected') {

              let finalCoords = this.calcElasticCountCoords('deflected','player',plyr).coords;
              let drawCell = this.calcElasticCountCoords('deflected','player',plyr).drawCell;

              if (
                !this.gridInfo.find(x => x.number.x === this.getCellFromDirection(1,plyr.currentPosition.cell.number,plyr.elasticCounter.direction).x && x.number.y === this.getCellFromDirection(1,plyr.currentPosition.cell.number,plyr.elasticCounter.direction).y )
              ) {
                if (
                  x === plyr.currentPosition.cell.number.x &&
                  y === plyr.currentPosition.cell.number.y
                ) {
                  context.drawImage(updatedPlayerImg, sx, sy, sWidth, sHeight, finalCoords.x, finalCoords.y, this.playerDrawWidth, this.playerDrawHeight)
                }
              }
              else {

                if (plyr.elasticCounter.direction === 'south') {
                  if (
                    x === plyr.currentPosition.cell.number.x &&
                    y === plyr.currentPosition.cell.number.y+1
                  ) {
                    context.drawImage(updatedPlayerImg, sx, sy, sWidth, sHeight, finalCoords.x, finalCoords.y, this.playerDrawWidth, this.playerDrawHeight)
                  }
                }
                if (plyr.elasticCounter.direction === 'west') {
                  if (
                    x === plyr.currentPosition.cell.number.x &&
                    y === plyr.currentPosition.cell.number.y
                  ) {
                    context.drawImage(updatedPlayerImg, sx, sy, sWidth, sHeight, finalCoords.x, finalCoords.y, this.playerDrawWidth, this.playerDrawHeight)
                  }
                }
                if (plyr.elasticCounter.direction === 'east') {
                  if (
                    x === plyr.currentPosition.cell.number.x+1 &&
                    y === plyr.currentPosition.cell.number.y
                  ) {

                    context.drawImage(updatedPlayerImg, sx, sy, sWidth, sHeight, finalCoords.x, finalCoords.y, this.playerDrawWidth, this.playerDrawHeight)
                  }
                }
                if (plyr.elasticCounter.direction === 'north') {
                  if (
                    x === plyr.currentPosition.cell.number.x+1 &&
                    y === plyr.currentPosition.cell.number.y
                  ) {
                    context.drawImage(updatedPlayerImg, sx, sy, sWidth, sHeight, finalCoords.x, finalCoords.y, this.playerDrawWidth, this.playerDrawHeight)
                  }
                }

              }




            }
            if (plyr.elasticCounter.state !== true && plyr.elasticCounter.type === 'deflected' && x === this.gridWidth && y === this.gridWidth) {
              // console.log('deflected elastic counter overflow?',plyr.success.deflected.count);
            }

          }
          if (plyr.action === "dodging" && plyr.success.deflected.state !== true) {


            if (plyr.elasticCounter.state === true && plyr.elasticCounter.type === 'dodging') {

              let finalCoords = this.calcElasticCountCoords('dodging','player',plyr).coords;
              let drawCell = this.calcElasticCountCoords('dodging','player',plyr).drawCell;


              // test logging
              if (x ===this.gridWidth && y === this.gridWidth) {

                if (plyr.elasticCounter.countUp.state === true) {
                  // this.testDraw.push({color: 'red',x:finalCoords.x,y:finalCoords.y })
                  // console.log('dodging elastic coount coords: countUp: ',plyr.elasticCounter.countUp.count,finalCoords,plyr.elasticCounter.direction);
                }
                if (plyr.elasticCounter.countDown.state === true) {
                  // this.testDraw.push({color: 'blue',x:finalCoords.x,y:finalCoords.y })
                  // console.log('dodging elastic coount coords: countDown: ',plyr.elasticCounter.countDown.count,finalCoords,plyr.elasticCounter.direction);
                }
                if (plyr.elasticCounter.pause.state === true) {
                  // this.testDraw.push({color: 'blue',x:finalCoords.x,y:finalCoords.y })
                  // console.log('dodging elastic coount coords: pause: ',plyr.elasticCounter.pause.count,finalCoords,plyr.elasticCounter.direction);
                }

              }



              if (!this.gridInfo.find(x => x.number.x === this.getCellFromDirection(1,plyr.currentPosition.cell.number,plyr.elasticCounter.direction).x && x.number.y === this.getCellFromDirection(1,plyr.currentPosition.cell.number,plyr.elasticCounter.direction).y )) {

                if (
                  x === plyr.currentPosition.cell.number.x &&
                  y === plyr.currentPosition.cell.number.y
                ) {
                  context.drawImage(updatedPlayerImg, sx, sy, sWidth, sHeight, finalCoords.x, finalCoords.y, this.playerDrawWidth, this.playerDrawHeight)
                }

              }
              else {

                if (plyr.elasticCounter.direction === 'north') {
                  if (
                    x === plyr.currentPosition.cell.number.x &&
                    y === plyr.currentPosition.cell.number.y
                  ) {
                    context.drawImage(updatedPlayerImg, sx, sy, sWidth, sHeight, finalCoords.x, finalCoords.y, this.playerDrawWidth, this.playerDrawHeight)
                  }
                }
                if (plyr.elasticCounter.direction === 'east') {
                  if (
                    x === plyr.currentPosition.cell.number.x+1 &&
                    y === plyr.currentPosition.cell.number.y
                  ) {
                    context.drawImage(updatedPlayerImg, sx, sy, sWidth, sHeight, finalCoords.x, finalCoords.y, this.playerDrawWidth, this.playerDrawHeight)
                  }
                }
                if (plyr.elasticCounter.direction === 'west') {
                  if (
                    x === plyr.currentPosition.cell.number.x &&
                    y === plyr.currentPosition.cell.number.y
                  ) {
                    context.drawImage(updatedPlayerImg, sx, sy, sWidth, sHeight, finalCoords.x, finalCoords.y, this.playerDrawWidth, this.playerDrawHeight)
                  }
                }
                if (plyr.elasticCounter.direction === 'south') {
                  if (
                    x === plyr.currentPosition.cell.number.x &&
                    y === plyr.currentPosition.cell.number.y+1
                  ) {
                    context.drawImage(updatedPlayerImg, sx, sy, sWidth, sHeight, finalCoords.x, finalCoords.y, this.playerDrawWidth, this.playerDrawHeight)
                  }
                }

              }




            }

          }

          // DEPTH SORTING!!


          if (plyr.respawn === true) {

            if (
              x === plyr.startPosition.cell.number.x &&
              y === plyr.startPosition.cell.number.y
            ) {
              // console.log('respawning... confirm dead player',plyr.dead.state,x,y);

              let canRespawn = false;
              let positionOccupied = false;
              let respawnPosCellRef = this.gridInfo.find(x => x.number.x === plyr.startPosition.cell.number.x && x.number.y === plyr.startPosition.cell.number.y)
              let respawnCellNo;
              let respawnCellCenter;

              for (const plyrx of this.players) {
                if (
                  plyrx.currentPosition.cell.number.x === plyr.startPosition.cell.number.x &&
                  plyrx.currentPosition.cell.number.y === plyr.startPosition.cell.number.y
                 ) {
                   positionOccupied = true;

                }
              }
              if (respawnPosCellRef.obstacle.state === true || respawnPosCellRef.terrain.type === "deep" || respawnPosCellRef.void === true) {
                positionOccupied = true;

              }


              if (positionOccupied === true) {


                respawnCellNo = this.getRandomFreeCell();
                respawnPosCellRef = this.gridInfo.find(x => x.number.x === respawnCellNo.number.x && x.number.y === respawnCellNo.number.y)


                if (respawnCellNo) {
                  canRespawn = true;
                }
                else {
                  console.log('no cells for respawn. Unlikely but true. Reassign obstacle cell');
                  if (this.gridInfo.filter(x => x.obstacle.state === true)[0]) {

                    this.gridInfo.filter(x => x.obstacle.state === true)[0].obstacle.state = false;
                    respawnPosCellRef = this.gridInfo.find(x => x.number.x === respawnCellNo.number.x && x.number.y === respawnCellNo.number.y)
                    let oldLvlData = this.gridInfo.filter(x => x.obstacle.state === true)[0].levelData.split("_");
                    oldLvlData[1] = "*";
                    this.gridInfo.filter(x => x.obstacle.state === true)[0].levelData = oldLvlData.join("_");
                    canRespawn = true;
                  }
                  else {
                    console.log('no free cells for respawn and no obstacle cell to comandeer. Highly unlikley');

                    if (this.gridInfo.filter(x => x.void.state === true)[0]) {

                      this.gridInfo.filter(x => x.void.state === true)[0].void.state = false;
                      respawnPosCellRef = this.gridInfo.find(x => x.number.x === respawnCellNo.number.x && x.number.y === respawnCellNo.number.y)
                      let oldLvlData = this.gridInfo.filter(x => x.void.state === true)[0].levelData.split("_");
                      oldLvlData[3] = "a";
                      this.gridInfo.filter(x => x.void.state === true)[0].levelData = oldLvlData.join("_");
                      canRespawn = true;
                    }
                  }


                }
              }

              else if (canRespawn = true && respawnPosCellRef) {
                canRespawn = true;
              }

              if (canRespawn === true) {
                // console.log('can respawn');
                let respawnPoint = respawnPosCellRef;
                plyr.dead.state = false;
                plyr.currentPosition.cell.number = respawnPoint.number;
                plyr.currentPosition.cell.center = respawnPoint.center;
                plyr.nextPosition = respawnPoint.center;
                this.getTarget(plyr)
                plyr.moving = {
                  state: false,
                  step: 0,
                  course: '',
                  origin: {
                    number: {
                      x: respawnPoint.number.x,
                      y: respawnPoint.number.y
                    },
                    center: {
                      x: respawnPoint.center.x,
                      y: respawnPoint.center.y
                    },
                  },
                  destination: {
                    x: this.players[plyr.number-1].target.cell1.center.x,
                    y: this.players[plyr.number-1].target.cell1.center.y
                  }
                }

                plyr.direction = 'north';
                plyr.respawn = false;
                this.players[plyr.number-1] = plyr;


                context.drawImage(updatedPlayerImg, sx, sy, sWidth, sHeight,  respawnPoint.center.x-25, respawnPoint.center.y-50,this.playerDrawWidth, this.playerDrawHeight)

                if (
                    this.settingAutoCamera === false &&
                    player.ai.state !== true &&
                    this.camera.preInstructions.length === 0 &&
                    this.camera.instructions.length === 0
                  ) {

                  this.setAutoCamera('playerSpawnFocus',plyr)
                }
                else {
                  console.log('no setting auto cam: playerSpawnFocus');
                }


              }



                // let respawnPoint = {
                //   number: {
                //     x: 0,
                //     y: 0,
                //   },
                //   center: {
                //     x: 0,
                //     y: 0,
                //   }
                // }
                // let altRespawnPoint = {
                //   number: {
                //     x: 0,
                //     y: 0,
                //   },
                //   center: {
                //     x: 0,
                //     y: 0,
                //   }
                // }
                // let altRespawnPoint2 = {
                //   number: {
                //     x: 0,
                //     y: 0,
                //   },
                //   center: {
                //     x: 0,
                //     y: 0,
                //   }
                // }
                // let respawnCellOccupied = false;
                //
                // // console.log('matching grid info with start position');
                // let elem1 = this.gridInfo.find(gridCell => gridCell.number.x === this.gridWidth && gridCell.number.y === this.gridWidth);
                // altRespawnPoint.number.x = elem1.number.x;
                // altRespawnPoint.number.y = elem1.number.y;
                // altRespawnPoint.center.x = elem1.center.x;
                // altRespawnPoint.center.y = elem1.center.y;
                //
                // let elem2 = this.gridInfo.find(gridCell => gridCell.number.x === this.gridWidth && gridCell.number.y === 0);
                // altRespawnPoint2.number.x = elem2.number.x;
                // altRespawnPoint2.number.y = elem2.number.y;
                // altRespawnPoint2.center.x = elem2.center.x;
                // altRespawnPoint2.center.y = elem2.center.y;
                //
                //
                // // '**_*_0.0_a_0**'
                // // barrierbarrierPosition_obstacle_x.y_terrain_elevationNumberelevationTypeelevationPosition
                //
                //
                // let elem3 = this.gridInfo.find(gridCell => gridCell.number.x === plyr.startPosition.cell.number.x && gridCell.number.y === plyr.startPosition.cell.number.y);
                // for (const [key, row] of Object.entries(this.['levelData'+this.gridWidth])) {
                //   for (const cell of row) {
                //     if (
                //       cell.split('_')[0] !== "**" ||
                //       cell.split('_')[1] !== "*"
                //       // cell.charAt(0) === 'y' ||
                //       // cell.charAt(0) ===  'z'
                //     ) {
                //       let obstaclePosition = {
                //         // x: Number(cell.charAt(1)),
                //         x: Number(cell.split("_")[2].charAt(0)),
                //         y: row.indexOf(cell),
                //       }
                //       // console.log('found obstacle during map scan @',obstaclePosition.x,obstaclePosition.y,'targetNumber',targetCellNumber.x,targetCellNumber.y);
                //       if (
                //         elem3.number.x === obstaclePosition.x &&
                //         elem3.number.y === obstaclePosition.y
                //       ) {
                //         // console.log('an obstacle is in your way');
                //         respawnCellOccupied = true;
                //       }
                //     }
                //   }
                // }
                // if (elem3.void.state === true ) {
                //   respawnCellOccupied = true;
                // }
                // for (const plyr2 of this.players) {
                //   if (plyr2.number !== plyr.number) {
                //     if (
                //       elem3.number.x === plyr2.currentPosition.cell.number.x &&
                //       elem3.number.y === plyr2.currentPosition.cell.number.y
                //     ) {
                //       respawnCellOccupied = true;
                //     }
                //   }
                // }
                //
                // if (
                //   respawnCellOccupied === false
                // ) {
                //
                //   respawnPoint.number.x = elem3.number.x;
                //   respawnPoint.number.y = elem3.number.y;
                //   respawnPoint.center.x = elem3.center.x;
                //   respawnPoint.center.y = elem3.center.y;
                //
                //
                //
                //   plyr.dead.state = false;
                //   plyr.currentPosition.cell = respawnPoint;
                //   plyr.nextPosition = respawnPoint.center;
                //   this.getTarget(plyr)
                //   plyr.moving = {
                //     state: false,
                //     step: 0,
                //     course: '',
                //     origin: {
                //       number: {
                //         x: respawnPoint.number.x,
                //         y: respawnPoint.number.y
                //       },
                //       center: {
                //         x: respawnPoint.center.x,
                //         y: respawnPoint.center.y
                //       },
                //     },
                //     destination: {
                //       x: this.players[plyr.number-1].target.cell1.center.x,
                //       y: this.players[plyr.number-1].target.cell1.center.y
                //     }
                //   }
                //
                //   plyr.direction = 'north';
                //   plyr.respawn = false;
                //   this.players[plyr.number-1] = plyr;
                //
                //   // context.drawImage(updatedPlayerImg, respawnPoint.center.x-25, respawnPoint.center.y-50, 55,55);
                //
                //   context.drawImage(updatedPlayerImg, sx, sy, sWidth, sHeight,  respawnPoint.center.x-25, respawnPoint.center.y-50,this.playerDrawWidth, this.playerDrawHeight)
                //
                //   if (
                //       this.settingAutoCamera === false &&
                //       player.ai.state !== true &&
                //       this.camera.preInstructions.length === 0 &&
                //       this.camera.instructions.length === 0
                //     ) {
                //     this.setAutoCamera('playerSpawnFocus',plyr)
                //   }
                //   else {
                //     console.log('no setting auto cam: playerSpawnFocus');
                //   }
                //
                //
                // }
                // else if (respawnCellOccupied === true) {
                //
                //   console.log("no free cells for respawn");
                //   alert("no free cells for respawn");
                //
                //   // if (plyr.number === 1) {
                //   //   respawnPoint = altRespawnPoint;
                //   // }
                //   // if (plyr.number === 2) {
                //   //   respawnPoint = altRespawnPoint2;
                //   // }
                //
                // }

              }

            }
          if (plyr.dead.state === true && player.dead.count > 0 && plyr.dead.count < plyr.dead.limit) {

            if (
              x === plyr.ghost.position.cell.number.x &&
              y === plyr.ghost.position.cell.number.y
            ) {
              // console.log('player',plyr.number,'dying',player.dead.count);
              context.drawImage(this.indicatorImgs.death, plyr.ghost.position.cell.center.x-15, plyr.ghost.position.cell.center.y-15, 25,25);
            }
          }
          if (plyr.ghost.state === true && player.dead.count === 0) {
            if (x === plyr.ghost.position.cell.number.x && y === plyr.ghost.position.cell.number.y) {
              // console.log('player ',plyr.number,'ghost @',plyr.ghost.position.cell.number,plyr.ghost.position.cell.center);
              context.drawImage(this.indicatorImgs.ghost, plyr.ghost.position.cell.center.x-20, plyr.ghost.position.cell.center.y-20, 25,25);
            }
          }


          // PLAYER POPUPS
          if (x === this.gridWidth && y === this.gridWidth ) {

            let popupBorderColor = this.playerColourRef['player'+plyr.number+''];


            if (plyr.dead.state !== true && plyr.popups.length > 0) {


              for (const popup of plyr.popups) {
                if (popup.state === true) {
                  // console.log('drawing a popup');
                  let popupDrawCoords;
                  if (popup.position === '' || !popup.position) {
                    let currentPopups = plyr.popups.filter(x=>x.state === true);
                    // let positions = ['north','east','south','west','northEast','southEast','southWest']
                    let positions = ['north','east','south','west','northEast','northWest','southEast','southWest']


                    if (plyr.strafing.state === true) {
                      if (positions[0] === plyr.strafing.direction) {
                        const first = positions.shift();
                        positions.push(first);
                      }
                    }
                    else {
                      if (positions[0] === plyr.direction) {
                        const first = positions.shift();
                        positions.push(first);
                      }
                    }


                    // REMOVE POSITIONS ALREADY TAKEN BY PLAYERS' OTHER POPUPS
                    for (const popup2 of currentPopups) {
                      if (popup2.position && popup2.position !== '') {

                        let indx = positions.indexOf(popup2.position);
                        positions.splice(indx,1)
                      }

                    }

                    let dir = undefined;

                    // CHECK OTHER PLAYER'S POSITION AND THE POPUPS POSITION
                    for (const plyr2 of this.players) {
                      if (plyr2.ai.state !== true && plyr2.number !== plyr.number) {
                        let myPos = plyr.currentPosition.cell.number;
                        let invalidPos = this.players[plyr2.number-1].currentPosition.cell.number;

                        dir = undefined;
                        // let invalidPositions = [invalidPos];

                        // GET DIRECTION OF OTHER PLAYER CELL RELATIVE TO ME
                        dir = this.getDirectionFromCells(myPos,invalidPos);

                        if (dir && positions.includes(dir) === true) {
                          positions.splice(positions.indexOf(dir),1);
                          // console.log('player popups (unset): human player position is close to player',plyr.number,' @ ',invalidPos,'dir',dir);
                          // console.log('dont draw over player @',dir,'choose frome these position',positions);
                        }


                        // GET DIRECTION OF ALL OTHER PLAYERS' POPUPS OCCUPY, RELATIVE TO ME
                        for(const pop of plyr2.popups) {

                          dir = undefined;

                          if (pop.state === true) {

                            let invalidPos2 = {
                              x: undefined,
                              y: undefined,
                            }

                            invalidPos2 = this.getCellFromDirection(1,invalidPos,pop.position);


                            dir = this.getDirectionFromCells(myPos,invalidPos2);

                            if (dir && positions.includes(dir) === true) {
                              positions.splice(positions.indexOf(dir),1);
                              // console.log('player popups (unset): human player popup position is close to player',plyr.number,' @ ',invalidPos2,'dir',dir);
                              // console.log('dont draw over player @',dir,'choose frome these position',positions);
                            }

                          }

                        }


                      }
                    }


                    // GET DIRECTION OF CELL POPUPS' POPUPS  CELLS RELATIVE TO ME
                    for (const popup2 of this.cellPopups) {

                      dir = undefined;

                      if (popup2.state === true) {

                        let myPos = plyr.currentPosition.cell.number;
                        let cellPos = popup2.cell.number;
                        let invalidPos2 = {
                          x: undefined,
                          y: undefined,
                        }


                        invalidPos2 = this.getCellFromDirection(1,cellPos,popup2.position);


                        dir = this.getDirectionFromCells(myPos,invalidPos2);

                        if (dir && positions.includes(dir) === true) {
                          positions.splice(positions.indexOf(dir),1);
                          // console.log('player popups (unset): cell popup position is close to player',plyr.number,' @ ',invalidPos2,'dir',dir);
                          // console.log('dont draw over player @',dir,'choose frome these position',positions);
                        }


                        // let indx = positions.indexOf(popup2.position);
                        // positions.splice(indx,1)
                      }

                    }


                    // console.log('new or postponed popup ',popup.msg,'position',positions[0]);

                    if (!positions[0]) {
                      // console.log('no open positions for new or postponed popup', popup.msg);
                      popup.state = false;
                      popup.count = 0;
                    } else {
                      popup.position = positions[0];
                    }


                    let popupProgress = false;
                    let showProgress = false;
                    let writeValue = false;
                    if (
                      plyr.prePush.state === true ||
                      plyr.prePull.state === true ||
                      plyr.dodging.state === true ||
                      plyr.action === 'dodging' ||
                      plyr.action === 'defending' ||
                      plyr.action === 'attacking' ||
                      plyr.attacking.state === true
                    ) {
                      showProgress = true;
                    }
                    if (
                      popup.msg === "attacking1" ||
                      popup.msg === "attacking2" ||
                      popup.msg === "defending" ||
                      popup.msg === "prePush" ||
                      popup.msg === "prePull" ||
                      popup.msg === "dodging"
                    ) {
                      popupProgress = true;
                    }

                    if (popup.img === "") {
                      popup.img = this.popupImageRef[popup.msg];
                    }

                    if (popup.msg.split("_")) {
                      if (popup.msg.split("_")[0] === "hpUp" || popup.msg.split("_")[0] === "hpDown") {
                        writeValue = true;
                        popup.img = this.popupImageRef[popup.msg.split("_")[0]]
                      }
                    }


                    popupDrawCoords = this.popupDrawCalc(popup.position,{x:point.x-25,y:point.y-25},plyr.number);

                    this.drawPopupBubble(context,popupDrawCoords.origin.x,popupDrawCoords.origin.y,this.popupSize,this.popupSize,5,popupDrawCoords.anchor.x,popupDrawCoords.anchor.y,popupBorderColor);
                    let centerPopupOffset = (this.popupSize-this.popupImgSize)/2;

                    if (showProgress === true  && popupProgress === true) {
                      let perc = this.playerPopupProgressCalc(plyr,popup)
                      context.fillStyle = this.popupProgressImgGradColor2;
                      context.beginPath();
                      // context.roundRect(popupDrawCoords.origin.x,(popupDrawCoords.origin.y)+this.popupSize, this.popupSize, this.popupSize*perc, 5);
                      // context.stroke();
                      context.fillStyle = this.popupProgressImgGradColor1;
                      context.roundRect(popupDrawCoords.origin.x,(popupDrawCoords.origin.y)+this.popupSize, 10, this.popupSize*perc, 5);
                      context.fill();
                    }


                    if (writeValue === true) {
                      context.font = "15px Arial";
                      context.fillStyle = 'black';
                      context.fillText(popup.msg.split("_")[1],popupDrawCoords.origin.x+((this.popupSize-(popup.msg.split("_")[1].length*7))/2),popupDrawCoords.origin.y+15);

                      centerPopupOffset = (this.popupSize-this.popupImgSize*.75)/2;
                      context.drawImage(popup.img, popupDrawCoords.origin.x+centerPopupOffset,popupDrawCoords.origin.y+(centerPopupOffset+5),this.popupImgSize*.75,this.popupImgSize*.75);
                    }
                    else {
                      context.drawImage(popup.img, popupDrawCoords.origin.x+centerPopupOffset,popupDrawCoords.origin.y+centerPopupOffset,this.popupImgSize,this.popupImgSize);
                    }



                  }
                  else if (popup.position !== 'northWest') {


                    let dir = undefined;
                    let dirs = [];

                    let currentPopups = this.cellPopups.filter(x=>x.state === true);

                    // HAVE ANY OTHER PLAYERS OR OTHER PLAYERS' POPUPS MOVED TO INVALID POSITIONS SINCE POPUP'S 1ST DRAW
                    for (const plyr2 of this.players) {
                      if (plyr2.ai.state !== true && plyr2.number !== plyr.number) {
                        let myPos = plyr.currentPosition.cell.number;
                        let invalidPos = this.players[plyr2.number-1].currentPosition.cell.number;


                        dir = this.getDirectionFromCells(myPos,invalidPos);

                        if (dir) {
                          // console.log('player popups (set): human player position is close to player',plyr.number,' @ ',invalidPos,' dir ',dir);
                          dirs.push(dir);
                        }


                        for(const pop of plyr2.popups) {


                          dir = undefined;
                          let invalidPos2 = {
                            x: undefined,
                            y: undefined,
                          }

                          invalidPos2 = this.getCellFromDirection(1,invalidPos,pop.position);



                          dir = this.getDirectionFromCells(myPos,invalidPos2);

                          // if (dir && positions.includes(dir) === true) {
                          //   positions.splice(positions.indexOf(dir),1);
                          //   // console.log('dont draw over player @',dir,'choose frome these position',positions);
                          // }
                          if (dir) {
                            // console.log('player popups (set): human player popup position is close to player',plyr.number,' @ ',invalidPos2,' dir ',dir);
                            dirs.push(dir);
                          }

                        }

                      }
                    }

                    // HAVE ANY CELL POPUPS MOVED TO A NEARBY CELL TO ME
                    for (const popup2 of currentPopups) {

                      dir = undefined;

                      let myPos = plyr.currentPosition.cell.number;

                      let cellPos = popup2.cell.number;
                      let invalidPos2 = {
                        x: undefined,
                        y: undefined,
                      }


                      invalidPos2 = this.getCellFromDirection(1,cellPos,popup2.position);


                      dir = this.getDirectionFromCells(myPos,invalidPos2);

                      if (dir) {
                        // console.log('player popups (set): cell popup position is close to player',plyr.number,' @ ',invalidPos2,' dir ',dir);
                        dirs.push(dir);
                      }


                    }

                    // console.log('dirs',dirs,'popup.position',popup.position);
                    // if (popup.position === dir ) {
                    if (dirs.find(x => x === popup.position) ) {

                      plyr.popups.find(x => x.msg === popup.msg).position = '';
                      plyr.popups.find(x => x.msg === popup.msg).state = false;
                      // console.log("A new invalid direction === popup's position. reconsidering...",popup.msg);
                    }
                    else {


                      let popupProgress = false;
                      let showProgress = false;
                      let writeValue = false;
                      if (
                        plyr.prePush.state === true ||
                        plyr.prePull.state === true ||
                        plyr.dodging.state === true ||
                        plyr.action === 'dodging' ||
                        plyr.action === 'defending' ||
                        plyr.action === 'attacking' ||
                        plyr.attacking.state === true
                      ) {
                        showProgress = true;
                      }
                      if (
                        popup.msg === "attacking" ||
                        popup.msg === "attacking1" ||
                        popup.msg === "attacking2" ||
                        popup.msg === "defending" ||
                        popup.msg === "prePush" ||
                        popup.msg === "prePull" ||
                        popup.msg === "dodging"
                      ) {
                        popupProgress = true;
                      }

                      if (popup.img === "") {
                        popup.img = this.popupImageRef[popup.msg];
                      }

                      if (popup.msg.split("_")) {
                        if (popup.msg.split("_")[0] === "hpUp" || popup.msg.split("_")[0] === "hpDown") {
                          writeValue = true;
                          popup.img = this.popupImageRef[popup.msg.split("_")[0]]
                        }
                      }


                      popupDrawCoords = this.popupDrawCalc(popup.position,{x:point.x-25,y:point.y-25},plyr.number);
                      this.drawPopupBubble(context,popupDrawCoords.origin.x,popupDrawCoords.origin.y,this.popupSize,this.popupSize,5,popupDrawCoords.anchor.x,popupDrawCoords.anchor.y,popupBorderColor);
                      let centerPopupOffset = (this.popupSize-this.popupImgSize)/2;

                      if (showProgress === true && popupProgress === true) {
                        let perc = this.playerPopupProgressCalc(plyr,popup)
                        context.fillStyle = this.popupProgressImgGradColor2;
                        context.beginPath();
                        // context.roundRect(popupDrawCoords.origin.x,(popupDrawCoords.origin.y)+this.popupSize, this.popupSize, this.popupSize*perc, 5);
                        // context.stroke();
                        context.fillStyle = this.popupProgressImgGradColor1;
                        context.roundRect(popupDrawCoords.origin.x,(popupDrawCoords.origin.y)+this.popupSize, 10, this.popupSize*perc, 5);
                        context.fill();
                      }


                      if (writeValue === true) {
                        context.font = "15px Arial";
                        context.fillStyle = 'black';
                        context.fillText(popup.msg.split("_")[1],popupDrawCoords.origin.x+((this.popupSize-(popup.msg.split("_")[1].length*7))/2),popupDrawCoords.origin.y+15)

                        centerPopupOffset = (this.popupSize-this.popupImgSize*.75)/2
                        context.drawImage(popup.img, popupDrawCoords.origin.x+centerPopupOffset,popupDrawCoords.origin.y+(centerPopupOffset+5),this.popupImgSize*.75,this.popupImgSize*.75);
                      }
                      else {
                        context.drawImage(popup.img, popupDrawCoords.origin.x+centerPopupOffset,popupDrawCoords.origin.y+centerPopupOffset,this.popupImgSize,this.popupImgSize);
                      }


                    }


                  }
                }
              }

            }

          }

          this.players[plyr.number-1] = plyr;


        }


        // OBSTACLES & BARRIERS
        // FALLING
        // IN BOUNDS
        if (gridInfoCell.obstacle.state === true && gridInfoCell.obstacle.moving.falling.state === true) {

          let obstacleImg = this.obstacleImgs[gridInfoCell.obstacle.type]

          context.drawImage(obstacleImg, gridInfoCell.obstacle.moving.nextPosition.x, gridInfoCell.obstacle.moving.nextPosition.y);
          gridInfoCell.obstacle.moving.nextPosition.y += 2

          // console.log('falling obstacle',gridInfoCell.obstacle.moving.nextPosition,'x/y',x,y);
        }
        // OUT OF BOUNDS
        for(const obstacle of this.obstaclesOutOfBoundsFall) {
          // here!! draw at origin cell x/y
          // if (x === 0 && y === 0) {
          if (x === obstacle.moving.origin.number.x && y === obstacle.moving.origin.number.y) {
            // console.log('obstacle falling out of bounds b count',obstacle.moving.origin.center,'position',obstacle.moving.nextPosition);
            let obstacleImg = this.obstacleImgs[obstacle.type]
            context.drawImage(obstacleImg, obstacle.moving.nextPosition.x, obstacle.moving.nextPosition.y);
            obstacle.moving.nextPosition = {
              x: obstacle.moving.nextPosition.x,
              y: obstacle.moving.nextPosition.y + 2
              // y: obstacle.moving.nextPosition.y+obstacle.moving.falling.count*5
            }

          }
        }

        // STATIONARY
        if (gridInfoCell.obstacle.state === true && gridInfoCell.void.state !== true && gridInfoCell.terrain.type !== "deep" && gridInfoCell.obstacle.moving.falling.state !== true) {

          let hide = false;

          if (this.obstacleBarrierToDestroy.length > 0) {
            for(const cell of this.obstacleBarrierToDestroy) {
              if (cell.type === 'obstacle' && gridInfoCell.number.x === cell.cell.number.x && gridInfoCell.number.y === cell.cell.number.y && gridInfoCell.obstacle.name === cell.cell.obstacle.name) {
                hide = true;
              }
            }
          }

          if (this.halfPushBackObstacles.length > 0) {
            let obstacleImg = this.obstacleImgs[gridInfoCell.obstacle.type]

            for (const obs of this.halfPushBackObstacles) {
              if (obs.myCellNo.x === gridInfoCell.number.x && obs.myCellNo.y === gridInfoCell.number.y) {
                if (obs.state === true) {
                  if (obs.countUp.state === true) {
                    hide = true;
                  }
                }
              }
            }
          }

          if (hide !== true) {
            let obstacleImg = this.obstacleImgs[gridInfoCell.obstacle.type]

            if (gridInfoCell.obstacle.moving.state !== true) {
              context.drawImage(obstacleImg, iso.x - offset.x, iso.y - (obstacleImg.height));
            }
            else {
              // console.log('x/y',x,y);
              // context.drawImage(obstacleImg, gridInfoCell.obstacle.moving.nextPosition.x-offset.x, gridInfoCell.obstacle.moving.nextPosition.y- Math.ceil(obstacleImg.height/2));
            }

          }

        }

        // MOVING
        for(const cell of this.gridInfo) {

          if (cell.obstacle.state === true && cell.obstacle.moving.state === true) {

            let drawHere = {
              x: cell.obstacle.moving.origin.number.x,
              y: cell.obstacle.moving.origin.number.y
            }
            let direction = undefined;
            if (cell.obstacle.moving.destination.number.y === cell.obstacle.moving.origin.number.y+1) {
              direction = 'south';
            }
            if (cell.obstacle.moving.destination.number.y === cell.obstacle.moving.origin.number.y-1) {
              direction = 'north';
            }
            if (cell.obstacle.moving.destination.number.x === cell.obstacle.moving.origin.number.x-1) {
              direction = 'west';
            }
            if (cell.obstacle.moving.destination.number.x === cell.obstacle.moving.origin.number.x+1) {
              direction = 'east';
            }

            if (
              cell.obstacle.moving.destination.number.x !== null &&
              cell.obstacle.moving.destination.number.x > -1 &&
              cell.obstacle.moving.destination.number.x < this.gridWidth+1
            ) {
              if(direction === 'south' || direction === 'east') {

                drawHere = cell.obstacle.moving.destination.number;
              }
            }


            if (x === drawHere.x && y === drawHere.y ) {
              // console.log('x/y',x,y,direction,cell.obstacle.moving.step);

              let obstacleImg = this.obstacleImgs[cell.obstacle.type];
              context.drawImage(obstacleImg, cell.obstacle.moving.nextPosition.x-offset.x, cell.obstacle.moving.nextPosition.y- Math.ceil(obstacleImg.height/2, 30, 30));

            }

            // console.log('falling obstacle',gridInfoCell.obstacle.moving.nextPosition,'x/y',x,y);
          }
        }
        // HALFPUSHBACK
        if (this.halfPushBackObstacles.length > 0) {

          let drawCell;
          for (const obs of this.halfPushBackObstacles) {
            // if (obs.state === true) {
            //   if (obs.countUp.state === true) {
            //     if (obs.countUp.count === 1 && !obs.coords.x && !obs.coords.y) {
            //       obs.coords = {
            //         x: (iso.x - offset.x),
            //         y: (iso.y - (obstacleImg.height)),
            //       }
            //       drawCell = this.calcElasticCountCoords('halfPushBack','obstacle',obs).drawCell;
            //       console.log('drawCell1',drawCell);
            //       if (x === drawCell.x && y === drawCell.y) {
            //           context.drawImage(obstacleImg, obs.coords.x, obs.coords.y);
            //       }
            //
            //     }
            //     else {
            //
            //       obs.coords = this.calcElasticCountCoords('halfPushBack','obstacle',obs).coords;
            //       drawCell = this.calcElasticCountCoords('halfPushBack','obstacle',obs).drawCell;
            //       console.log('drawCell2',drawCell);
            //       if (x === drawCell.x && y === drawCell.y) {
            //           context.drawImage(obstacleImg, obs.coords.x, obs.coords.y);
            //       }
            //     }
            //   }
            // }
            if (obs.myCellNo.x === gridInfoCell.number.x && obs.myCellNo.y === gridInfoCell.number.y && gridInfoCell.obstacle.type) {
              if (obs.state === true) {
                if (obs.countUp.state === true) {
                  let obstacleImg = this.obstacleImgs[gridInfoCell.obstacle.type]
                  if (obs.countUp.count === 1 && !obs.coords.x && !obs.coords.y) {

                    obs.coords = {
                      x: (iso.x - offset.x),
                      y: (iso.y - (obstacleImg.height)),
                    }
                    context.drawImage(obstacleImg, obs.coords.x, obs.coords.y);

                  }
                  else {

                    obs.coords = this.calcElasticCountCoords('halfPushBack','obstacle',obs).coords;
                    context.drawImage(obstacleImg, obs.coords.x, obs.coords.y);

                  }
                }
              }
            }
          }
        }

        // DROP ITEMS & DAMAGE/DESTROY OBSTACLES & BARRIERS
        for(const cell of this.obstacleBarrierToDestroy) {
          if (gridInfoCell.number.x === cell.cell.number.x && gridInfoCell.number.y === cell.cell.number.y ) {
          // if (gridInfoCell.number.x === cell.cell.number.x && gridInfoCell.number.y === cell.cell.number.y && (cell.cell.obstacle.type || cell.cell.barrier.type)) {
            if(cell.count % 3 === 0) {
              if (cell.type === "obstacle" && cell.cell.obstacle.type) {

                let obstacleImg = this.obstacleImgs[cell.cell.obstacle.type];
                context.drawImage(obstacleImg, iso.x - offset.x, iso.y - (obstacleImg.height));

              }
              if (cell.type === "barrier" && cell.cell.barrier.type) {

                let barrierImg = this.barrierImgs[cell.cell.barrier.type][cell.cell.barrier.position];
                context.drawImage(barrierImg, iso.x - offset.x, iso.y - barrierImg.height, barrierImg.width, barrierImg.height);

              }

            }
          }
        }
        for(const cell of this.obstacleItemsToDrop) {
          // console.log('obstacleItemsToDrop',cell);
          if (gridInfoCell.number.x === cell.target.x && gridInfoCell.number.y === cell.target.y) {
            if(cell.count % 3 === 0) {
              let itemImg;
              if (cell.item.type === "item") {
                itemImg = this.itemImgs[cell.item.name];
              }
              if (cell.item.type === "weapon" || cell.item.type === "armor") {
                itemImg = this.itemImgs[cell.item.subType];
              }
              context.drawImage(itemImg, center.x-15, center.y-15);
            }
          }
        }

        // STATIONARY BARRIERS
        if (gridInfoCell.barrier.state === true && gridInfoCell.void.state !== true) {


          let hide = false;

          if (this.obstacleBarrierToDestroy.length > 0) {
            for(const cell of this.obstacleBarrierToDestroy) {
              if (cell.type === 'barrier' && gridInfoCell.number.x === cell.cell.number.x && gridInfoCell.number.y === cell.cell.number.y && gridInfoCell.barrier.name === cell.cell.barrier.name) {
                hide = true;
              }
            }
          }

          if (hide !== true) {

            let barrierImg = this.barrierImgs[gridInfoCell.barrier.type][gridInfoCell.barrier.position];
            context.drawImage(barrierImg, iso.x - offset.x, iso.y - barrierImg.height, barrierImg.width, barrierImg.height);

          }



        }


        // PROJECTILES
        for (const bolt of this.projectiles) {

          if (
            bolt.currentPosition.number.x === x &&
            bolt.currentPosition.number.y === y
          ) {
            let boltImg;
            switch(bolt.direction) {
              case 'north':
                boltImg = this.boltImgs[bolt.direction]
              break;
              case 'south':
                boltImg = this.boltImgs[bolt.direction]
              break;
              case 'east':
                boltImg = this.boltImgs[bolt.direction]
              break;
              case 'west':
                boltImg = this.boltImgs[bolt.direction]
              break;
            }
            // console.log('dd',boltImg,bolt.direction);

             // context2.fillStyle = "black";
             // context2.fillRect(bolt.currentPosition.center.x, bolt.currentPosition.center.y,10,5);
             // this.testDraw.push({color:'green',x:bolt.currentPosition.center.x,y:bolt.currentPosition.center.y})
             context.drawImage(boltImg, bolt.currentPosition.center.x-15, bolt.currentPosition.center.y-15, 35,35);
          }
        }


        // CAMERA FOCUS POINT
        if (x === this.gridWidth && y === this.gridWidth ) {
          // console.log('Camera centered');
          // context.fillStyle = 'yellow';
          // context.beginPath();
          // context.arc(this.camera.focus.x, this.camera.focus.y, 10, 0, 2 * Math.PI);
          // context.arc(this.camera.zoomFocusPan.x, this.camera.zoomFocusPan.y, 10, 0, 2 * Math.PI);
          // context.fill();

        }


        // TEST DRAW
        for (const point of this.testDraw ) {
          context.fillStyle = point.color;
          context.beginPath();
          context.arc(point.x, point.y, 5, 0, 2 * Math.PI);
          context.fill();
        }


      }
    }


    this.players[player.number-1] = player;


    // if (player.ai.state === true ) {
    //   this.aiEvaluate(player)
    // }

  }


  startProcessLevelData = (canvas) => {
    // console.log('startProcessLevelData',this.gridWidth);

    let gridInfo = [];
    let settingsGridInfo = [];

    canvas.width = this.canvasWidth;
    canvas.height = this.canvasHeight;

    let floorImageWidth = this.floorImageWidth;
    let floorImageHeight = this.floorImageHeight;
    let wallImageWidth = this.wallImageWidth;
    let wallImageHeight = this.wallImageHeight;
    let sceneX = this.canvasWidth/2;
    let sceneY = this.sceneY;
    let tileWidth = this.tileWidth;

    class Point {
        constructor(x, y) {
            this.x = x;
            this.y = y;
        }
    }


    for (var x = 0; x < this.gridWidth+1; x++) {
      for (var y = 0; y < this.gridWidth+1; y++) {

        let p = new Point();
        p.x = x * tileWidth;
        p.y = y * tileWidth;


        let iso = this.cartesianToIsometric(p);
        let offset = {x: floorImageWidth/2, y: floorImageHeight}

        // apply offset to center scene for a better view
        iso.x += sceneX
        iso.y += sceneY

        let center = {
          x: Math.round(iso.x - offset.x/2+this.cellCenterOffsetX),
          y: Math.round(iso.y - offset.y/2-this.cellCenterOffsetY),
        }

        gridInfo.push({
          number:{x:x,y:y},
          center:{x:center.x,y:center.y},
          drawCenter:{x:center.x,y:center.y},
          vertices: [
            {x:center.x, y:center.y+this.tileWidth/2},
            {x:center.x+this.tileWidth, y:center.y},
            {x:center.x, y:center.y-this.tileWidth/2},
            {x:center.x-this.tileWidth, y:center.y},
          ],
          side: Math.sqrt((this.tileWidth/2)^2+(this.tileWidth)^2),
          levelData: '',
          edge: {
            state: false,
            side: ''
          },
          terrain: {
            name: '',
            type: '',
            effect: ''
          },
          item: {
            name: '',
            type: '',
            subType: '',
            effect: '',
            initDrawn: false
          },
          void: {
            state: false
          },
          obstacle: {
            state: false,
            name: '',
            type: '',
            hp: 2,
            destructible: {
              state: false,
              weapons: [],
              leaveRubble: false,
            },
            locked: {
              state: false,
              key: '',
            },
            weight: 1,
            height: 0.5,
            items: [],
            effects: [],
            moving: {
              state: false,
              step: 0,
              origin: {
                number: {
                  x: undefined,
                  y: undefined,
                },
                center: {
                  x: undefined,
                  y: undefined,
                },
              },
              destination: {
                number: {
                  x: undefined,
                  y: undefined,
                },
                center: {
                  x: undefined,
                  y: undefined,
                },
              },
              currentPosition: {
                x: undefined,
                y: undefined,
              },
              nextPosition: {
                x: undefined,
                y: undefined,
              },
              moveSpeed: 0,
              pushable: true,
              pushed: false,
              pusher: undefined,
              falling: {
                state: false,
                count: 0,
                limit: 10,
              },
            }
          },
          barrier: {
            state: false,
            name: '',
            type: '',
            hp: 2,
            destructible: {
              state: false,
              weapons: [],
              leaveRubble: false,
            },
            locked: {
              state: false,
              key: '',
            },
            position: '',
            height: 1,
          },
          elevation: {
            number: 0,
            type: '',
            position: '',
          },
          rubble: false,
        })

      }
    }

    for (var x = 0; x < this.settingsGridWidth+1; x++) {
      for (var y = 0; y < this.settingsGridWidth+1; y++) {

        let p2 = new Point();
        p2.x = x * tileWidth/2;
        p2.y = y * tileWidth/2;

        let iso2 = this.cartesianToIsometric(p2);
        let offset2 = {x: (floorImageWidth/2)/2, y: (floorImageHeight/2)}

        // apply offset to center scene for a better view

        iso2.x += this.settingsSceneX;
        iso2.y += this.settingsSceneY;

        let center2 = {
          x: Math.round(iso2.x - offset2.x/2+(this.cellCenterOffsetX/2)),
          y: Math.round(iso2.y - offset2.y/2-(this.cellCenterOffsetY/2)),
        }


        settingsGridInfo.push({
          number:{x:x,y:y},
          center:{x:center2.x,y:center2.y},
          drawCenter:{x:center2.x,y:center2.y},
          vertices: [
            {x:center2.x, y:center2.y+this.tileWidth/4},
            {x:center2.x+this.tileWidth/2, y:center2.y},
            {x:center2.x, y:center2.y-this.tileWidth/4},
            {x:center2.x-this.tileWidth/2, y:center2.y},
          ],
          side: Math.sqrt(((this.tileWidth/2)/2)^2+((this.tileWidth/2))^2),
          levelData: '',
          edge: {
            state: false,
            side: ''
          },
          terrain: {
            name: '',
            type: '',
            effect: ''
          },
          item: {
            name: '',
            type: '',
            subType: '',
            effect: '',
            initDrawn: false
          },
          void: {
            state: false
          },
          obstacle: {
            state: false,
            name: '',
            type: '',
            hp: 2,
            destructible: {
              state: false,
              weapons: [],
              leaveRubble: false,
            },
            locked: {
              state: false,
              key: '',
            },
            weight: 1,
            height: 0.5,
            items: [],
            effects: [],
            moving: {
              state: false,
              step: 0,
              origin: {
                number: {
                  x: undefined,
                  y: undefined,
                },
                center: {
                  x: undefined,
                  y: undefined,
                },
              },
              destination: {
                number: {
                  x: undefined,
                  y: undefined,
                },
                center: {
                  x: undefined,
                  y: undefined,
                },
              },
              currentPosition: {
                x: undefined,
                y: undefined,
              },
              nextPosition: {
                x: undefined,
                y: undefined,
              },
              moveSpeed: 0,
              pushable: true,
              pushed: false,
              pusher: undefined,
              falling: {
                state: false,
                count: 0,
                limit: 10,
              },
            }
          },
          barrier: {
            state: false,
            name: '',
            type: '',
            hp: 2,
            destructible: {
              state: false,
              weapons: [],
              leaveRubble: false,
            },
            locked: {
              state: false,
              key: '',
            },
            position: '',
            height: 1,
          },
          elevation: {
            number: 0,
            type: '',
            position: '',
          },
          rubble: false,
        })

      }
    }

    this.settingsGridInfo = settingsGridInfo;
    this.gridInfo = gridInfo;

  }
  processLevelData = (allCells) => {
    // console.log('processing level data','grid width',this.gridWidth);

    for(const elem of allCells) {

      // APPLY LEVEL DATA TO GRID INFO CELLS!
      let levelData2Row = 'row'+elem.number.x;
      let elemLevelData = this['levelData'+this.gridWidth][levelData2Row][elem.number.y];

      if (
        (elemLevelData.split('_')[1] !== "*" &&
        this.terrainLevelDataRef[elemLevelData.split('_')[3]].type === 'deep') ||
        (elemLevelData.split('_')[1] !== "*" && this.terrainLevelDataRef[elemLevelData.split('_')[3]].type === 'void')
      ) {
        elemLevelData = elemLevelData.replaceAt(3, '*');
      }
      elem.levelData = elemLevelData;
      // console.log('level data processing',elem.levelData);


      // '**_*_0.0_a_0**'
      // barrierType(a,b,c)BarrierPosition(n,s,e,w)_obstacle_x.y_terrain_elevationNumber(0,1,2)ElevationType(a,b,c)ElevationPosition(n,s,e,w)


      elem.terrain = this.terrainLevelDataRef[elem.levelData.split('_')[3]]
      if (elem.terrain.name === 'void') {
        elem.void.state = true
      }

      elem.elevation.number = parseInt(elem.levelData.split('_')[4].charAt(0));
      if (elem.levelData.split('_')[4].charAt(1) !== '*') {
        elem.elevation.type = this.elevationTypeLevelDataRef[elem.levelData.split('_')[4].charAt(1)]
      }


      if (elem.levelData.split('_')[4].charAt(1) !== '*') {
        switch (elem.levelData.split('_')[4].charAt(2)) {
          case 'n':
            elem.elevation = {
              number: elem.elevation.number,
              type: elem.elevation.type,
              position: 'north',
            }
          break;
          case 's':
            elem.elevation = {
              number: elem.elevation.number,
              type: elem.elevation.type,
              position: 'south',
            }
          break;
          case 'e':
            elem.elevation = {
              number: elem.elevation.number,
              type: elem.elevation.type,
              position: 'east',
            }
          break;
          case 'w':
            elem.elevation = {
              number: elem.elevation.number,
              type: elem.elevation.type,
              position: 'west',
            }
          break;
          default:

          break
        }
      }


      // OBSTACLE
      if (elem.levelData.split('_')[1] !== '*') {
        elem.obstacle = this.obstacleLevelDataRef[elem.levelData.split('_')[1]];
      }

      // BARRIER
      if (elem.levelData.split('_')[0] !== '**') {
        elem.barrier = this.barrierLevelDataRef[elem.levelData.split('_')[0].charAt(0)];

        switch (elem.levelData.split('_')[0].charAt(1)) {
          case 'n':
            elem.barrier = {
              state: elem.barrier.state,
              name: elem.barrier.name,
              type: elem.barrier.type,
              hp: elem.barrier.hp,
              destructible: elem.barrier.destructible,
              locked: elem.barrier.locked,
              position: 'north',
              height: elem.barrier.height,
            }
          break;
          case 's':
            elem.barrier = {
              state: elem.barrier.state,
              name: elem.barrier.name,
              type: elem.barrier.type,
              hp: elem.barrier.hp,
              destructible: elem.barrier.destructible,
              locked: elem.barrier.locked,
              position: 'south',
              height: elem.barrier.height,
            }
          break;
          case 'e':
            elem.barrier = {
              state: elem.barrier.state,
              name: elem.barrier.name,
              type: elem.barrier.type,
              hp: elem.barrier.hp,
              destructible: elem.barrier.destructible,
              locked: elem.barrier.locked,
              position: 'east',
              height: elem.barrier.height,
            }
          break;
          case 'w':
            elem.barrier = {
              state: elem.barrier.state,
              name: elem.barrier.name,
              type: elem.barrier.type,
              hp: elem.barrier.hp,
              destructible: elem.barrier.destructible,
              locked: elem.barrier.locked,
              position: 'west',
              height: elem.barrier.height,
            }
          break;
          default:
          break;
        }
      }

      // console.log('oo2',elem.levelData,elem.number,elem.terrain);

      // SET EDGES!
      if (elem.number.x === 0) {
        elem.edge = {
          state: true,
          side: 'west'
        }
      }
      if (elem.number.x === this.gridWidth) {
        elem.edge = {
          state: true,
          side: 'east'
        }
      }
      if (elem.number.y === this.gridWidth) {
        elem.edge = {
          state: true,
          side: 'south'
        }
      }
      if (elem.number.y === 0) {
        elem.edge = {
          state: true,
          side: 'north'
        }
      }

    }


    for(const elem2 of this.settingsGridInfo) {

      // SET LEVEL DATA!
      let levelData2Row = 'row'+elem2.number.x;
      let elemLevelData = this['levelData'+this.settingsGridWidth][levelData2Row][elem2.number.y];
      if (
        (elemLevelData.split('_')[1] !== "*" &&
        this.terrainLevelDataRef[elemLevelData.split('_')[3]].type === 'deep') ||
        (elemLevelData.split('_')[1] !== "*" && this.terrainLevelDataRef[elemLevelData.split('_')[3]].type === 'void')
      ) {
        elemLevelData = elemLevelData.replaceAt(3, '*');
      }
      elem2.levelData = elemLevelData;

      // TERRAIN
      elem2.terrain = this.terrainLevelDataRef[elem2.levelData.split('_')[3]]
      if (elem2.terrain.name === 'void') {
        elem2.void.state = true
      }

      // ELEVATION NUMBER
      elem2.elevation.number = parseInt(elem2.levelData.split('_')[4].charAt(0));
      if (elem2.levelData.split('_')[4].charAt(1) !== '*') {
        elem2.elevation.type = this.elevationTypeLevelDataRef[elem2.levelData.split('_')[4].charAt(1)]
      }

      // ELEVATION POSITION
      if (elem2.levelData.split('_')[4].charAt(1) !== '*') {
        switch (elem2.levelData.split('_')[4].charAt(2)) {
          case 'n':
            elem2.elevation = {
              number: elem2.elevation.number,
              type: elem2.elevation.type,
              position: 'north',
            }
          break;
          case 's':
            elem2.elevation = {
              number: elem2.elevation.number,
              type: elem2.elevation.type,
              position: 'south',
            }
          break;
          case 'e':
            elem2.elevation = {
              number: elem2.elevation.number,
              type: elem2.elevation.type,
              position: 'east',
            }
          break;
          case 'w':
            elem2.elevation = {
              number: elem2.elevation.number,
              type: elem2.elevation.type,
              position: 'west',
            }
          break;
          default:
        }
      }

      // OBSTACLE
      if (elem2.levelData.split('_')[1] !== '*') {
        elem2.obstacle = this.obstacleLevelDataRef[elem2.levelData.split('_')[1]];
      }

      // BARRIER
      if (elem2.levelData.split('_')[0] !== '**') {
        elem2.barrier = this.barrierLevelDataRef[elem2.levelData.split('_')[0].charAt(0)];

        switch (elem2.levelData.split('_')[0].charAt(1)) {
          case 'n':
            elem2.barrier = {
              state: elem2.barrier.state,
              name: elem2.barrier.name,
              type: elem2.barrier.type,
              hp: elem2.barrier.hp,
              destructible: elem2.barrier.destructible,
              locked: elem2.barrier.locked,
              position: 'north',
              height: elem2.barrier.height,
            }
          break;
          case 's':
            elem2.barrier = {
              state: elem2.barrier.state,
              name: elem2.barrier.name,
              type: elem2.barrier.type,
              hp: elem2.barrier.hp,
              destructible: elem2.barrier.destructible,
              locked: elem2.barrier.locked,
              position: 'south',
              height: elem2.barrier.height,
            }
          break;
          case 'e':
            elem2.barrier = {
              state: elem2.barrier.state,
              name: elem2.barrier.name,
              type: elem2.barrier.type,
              hp: elem2.barrier.hp,
              destructible: elem2.barrier.destructible,
              locked: elem2.barrier.locked,
              position: 'east',
              height: elem2.barrier.height,
            }
          break;
          case 'w':
            elem2.barrier = {
              state: elem2.barrier.state,
              name: elem2.barrier.name,
              type: elem2.barrier.type,
              hp: elem2.barrier.hp,
              destructible: elem2.barrier.destructible,
              locked: elem2.barrier.locked,
              position: 'west',
              height: elem2.barrier.height,
            }
          break;
          default:
        }

      }

      // console.log('oo2',elem.levelData,elem.number,elem.terrain);

      // SET EDGES!
      if (elem2.number.x === 0) {
        elem2.edge = {
          state: true,
          side: 'west'
        }
      }
      if (elem2.number.x === this.settingsGridWidth) {
        elem2.edge = {
          state: true,
          side: 'east'
        }
      }
      if (elem2.number.y === this.settingsGridWidth) {
        elem2.edge = {
          state: true,
          side: 'south'
        }
      }
      if (elem2.number.y === 0) {
        elem2.edge = {
          state: true,
          side: 'north'
        }
      }

    }

    // gridInfo to 2D array
    let gridInfo2d = [];
    for (let i = 0; i <= this.gridWidth; i++) {
    // for (let i = 9; i >= 0; i--) {
      let newArray = [];
      for (var j = 0; j < allCells.length; j++) {
        if (allCells[j]['number'].x === i) {
          newArray.push(allCells[j])
        }
      }
      gridInfo2d.push(newArray)
    }


    this.gridInfo2D = gridInfo2d;
    // console.log('gridInfo2d',this.gridInfo2D);
    this.gridInfo = allCells;

    // this.settingsFormAiGridInfo = this.gridInfo;
    // console.log('post parse gridInfo',this.gridInfo);

    // console.log('yyy',allCells.filter(x => x.barrier.state === true).map(y => y = y.barrier.position));
    // console.log('yyy2',this.settingsGridInfo.filter(x => x.barrier.state === true).map(y => y = y.barrier.position));

    this.updatePathArray()


  }
  drawGridInit = (canvas, context, canvas2, context2) => {
    // console.log('drawing initial');


    context.clearRect(0,0,this.canvasWidth,this.canvasHeight)
    context2.clearRect(0,0,this.canvasWidth,this.canvasHeight)

    let gridInfo = [];
    class Point {
        constructor(x, y) {
            this.x = x;
            this.y = y;
        }
    }

    this.popupImageRef = {
      attackStart: this.refs.preAttackIndicate,
      preAction1: this.refs.preAction1Indicate,
      preAction2: this.refs.preAction2Indicate,
      attacking: this.refs.attack3Indicate,
      attacking1: this.refs.attack1Indicate,
      attacking2: this.refs.attack2Indicate,
      missedAttack: this.refs.missedIndicate,
      attackingBlunt: this.refs.attackBluntIndicate2,
      attackingUnarmed: this.refs.attackUnarmedIndicate,
      attacked1: this.refs.attack1Indicate,
      attacked2: this.refs.attack2Indicate,
      attackDefended: this.refs.attackBreakIndicate,
      attackParried: this.refs.attackParriedIndicate,
      boltKilled: this.refs.boltKilledIndicate,
      attackCancelled: this.refs.attackBreakIndicate,
      injured: this.refs.deflectInjuredIndicate,
      hpDown: this.refs.deflectInjuredIndicate2,
      hpUp: this.refs.healIndicate,
      defending: this.refs.defendIndicate,
      defending_1: this.refs.defendIndicate1,
      defending_2: this.refs.defendIndicate2,
      defending_3: this.refs.defendIndicate3,
      defending_4: this.refs.defendIndicate4,
      defendSuccess: this.refs.defendSuccessIndicate,
      guardBroken: this.refs.defendBreakIndicate,
      deflected: this.refs.deflectBluntIndicate,
      dodgeStart: this.refs.preAction2Indicate,
      dodgeSuccess: this.refs.dodgeIndicate,
      dodging: this.refs.dodgeIndicate,
      flanking: this.refs.flankIndicate,
      pushedBack: this.refs.pushbackIndicate,
      falling: this.refs.fallingIndicate,
      outOfStamina: this.refs.outOfStaminaIndicate,
      outOfAmmo: this.refs.outOfAmmoIndicate,
      missionEngage: this.refs.deflectIndicate2,
      missionPursue: this.refs.pursueMissionIndicate2,
      missionRetrieve: this.refs.retrieveMissionIndicate,
      missionDefend: this.refs.defendMissionIndicate,
      missionPatrol: this.refs.patrolMissionIndicate,
      missionRetreat: this.refs.retreatIndicate,
      missionEnroute: this.refs.enrouteIndicate,
      missionComplete: this.refs.completeMissionIndicate,
      thinking: this.refs.thinkingIndicate,
      alarmed: this.refs.preAttack2Indicate,
      pathSwitch: this.refs.pathSwitchIndicate,
      targetSwitch: this.refs.targetSwitchIndicate,
      aggressiveMode: this.refs.aggressiveModeIndicate,
      passiveMode: this.refs.passiveModeIndicate,
      pickupWeapon: this.refs.pickupWeaponIndicate,
      pickupArmor: this.refs.pickupArmorIndicate,
      dropWeapon: this.refs.dropWeaponIndicate,
      dropArmor: this.refs.dropArmorIndicate,
      pickupBuff: this.refs.pickupBuffIndicate,
      pickupDebuff: this.refs.pickupDebuffIndicate,
      pickupAmmo: this.refs.pickupAmmoIndicate,
      inventoryFull: this.refs.inventoryFullIndicate,
      stop: this.refs.boltDefendIndicate,
      dropWeapon: this.refs.dropWeaponIndicate,
      dropArmor: this.refs.dropArmorIndicate,
      drowning: this.refs.drowningIndicate,
      terrainSlowdown: this.refs.terrainSlowdownIndicate,
      terrainSpeedup: this.refs.terrainSpeedupIndicate,
      terrainInjured: this.refs.terrainInjuredIndicate,
      destroyedItem: this.refs.destroyedItemIndicate,
      sword: this.refs.itemSword,
      spear: this.refs.itemSpear,
      crossbow: this.refs.itemCrossbow,
      longbow: this.refs.itemBow,
      helmet: this.refs.itemHelmet1,
      mail: this.refs.itemMail1,
      greaves: this.refs.itemGreaves1,

      missedAttack2: this.refs.missedIndicate2,
      prePush: this.refs.prePushIndicate,
      canPush: this.refs.canPushIndicate,
      noPush: this.refs.noPushingIndicate,
      pushing: this.refs.pushingIndicate,
      prePull: this.refs.prePullIndicate,
      canPull: this.refs.canPullIndicate,
      noPull: this.refs.noPullingIndicate,
      pulling: this.refs.pullingIndicate,
      pushedPulled: this.refs.pushedPulledIndicate,
      unbreakable: this.refs.unbreakableIndicate,
      dodging2: this.refs.dodgeIndicate2,
      attackFeint: this.refs.attackFeintIndicate,
      attackFeint2: this.refs.attackFeintIndicate2,
      attackFeint3: this.refs.attackFeintIndicate3,
      defendFeint: this.refs.defendFeintIndicate,
      defendFeint2: this.refs.defendFeintIndicate2,
      defendFeint3: this.refs.defendFeintIndicate3,
      dodgeFeint: this.refs.dodgeFeintIndicate,
      dodgeFeint2: this.refs.dodgeFeintIndicate2,
      boltDefend2: this.refs.boltDefendIndicate2,
      flanking2: this.refs.flankIndicate2,
      noFlanking: this.refs.noFlankIndicate,
      cellVoiding: this.refs.cellVoidingIndicate,
      cellVoiding2: this.refs.cellVoidingIndicate2,
    };
    this.indicatorImgs = {
      preAttack: this.refs.preAttackIndicate,
      preAttack2: this.refs.preAttack2Indicate,
      attack1: this.refs.attack1Indicate,
      attack2: this.refs.attack2Indicate,
      attack3: this.refs.attack3Indicate,
      attackUnarmed: this.refs.attackUnarmedIndicate,
      attackBlunt: this.refs.attackBluntIndicate,
      attackSuccess: this.refs.attackSuccessIndicate,
      defend: this.refs.defendIndicate,
      deflect: this.refs.deflectIndicate,
      deflectInjured: this.refs.deflectInjuredIndicate,
      deflectBlunt: this.refs.deflectBluntIndicate,
      pushback: this.refs.pushbackIndicate,
      ghost: this.refs.ghostIndicate,
      death: this.refs.deathIndicate,
      attackBreak: this.refs.attackBreakIndicate,
      defendBreak: this.refs.defendBreakIndicate,
      dodge: this.refs.dodgeIndicate,
    }
    this.playerImgs = [
      {
        idle: {
          unarmed: this.refs.playerImgIdleSheet,
          sword: this.refs.playerImgIdleSheet,
          spear: this.refs.playerImgIdleSheet,
          crossbow: this.refs.playerImgIdleSheet,
        },
        walking: {
          unarmed: this.refs.playerImgMoveSheet,
          sword: this.refs.playerImgMoveSheet,
          spear: this.refs.playerImgMoveSheet,
          crossbow: this.refs.playerImgMoveSheet,
        },
        jumping: {
          unarmed: this.refs.playerImgMoveSheet,
          sword: this.refs.playerImgMoveSheet,
          spear: this.refs.playerImgMoveSheet,
          crossbow: this.refs.playerImgMoveSheet,
        },
        dodging: {
          unarmed: this.refs.playerImgMoveSheet,
          sword: this.refs.playerImgMoveSheet,
          spear: this.refs.playerImgMoveSheet,
          crossbow: this.refs.playerImgMoveSheet,
        },
        flanking: {
          unarmed: this.refs.playerImgMoveSheet,
          sword: this.refs.playerImgMoveSheet,
          spear: this.refs.playerImgMoveSheet,
          crossbow: this.refs.playerImgMoveSheet,
        },
        strafing: {
          unarmed: this.refs.playerImgMoveSheet,
          sword: this.refs.playerImgMoveSheet,
          spear: this.refs.playerImgMoveSheet,
          crossbow: this.refs.playerImgMoveSheet,
        },
        attacking: {
          unarmed: this.refs.player1ImgAttackSheet,
          sword: this.refs.player1ImgAttackSheet,
          spear: this.refs.player1ImgAttackSheet,
          crossbow: this.refs.player1ImgAttackSheet,
        },
        defending: {
          unarmed: this.refs.playerImgMoveSheet,
          sword: this.refs.playerImgMoveSheet,
          spear: this.refs.playerImgMoveSheet,
          crossbow: this.refs.playerImgMoveSheet,
        },
        deflected: {
          unarmed: this.refs.playerImgMoveSheet,
          sword: this.refs.playerImgMoveSheet,
          spear: this.refs.playerImgMoveSheet,
          crossbow: this.refs.playerImgMoveSheet,
        },
        pushBack: {
          unarmed: this.refs.playerImgMoveSheet,
          sword: this.refs.playerImgMoveSheet,
          spear: this.refs.playerImgMoveSheet,
          crossbow: this.refs.playerImgMoveSheet,
        },
        falling: {
          unarmed: this.refs.playerImgMoveSheet,
          sword: this.refs.playerImgMoveSheet,
          spear: this.refs.playerImgMoveSheet,
          crossbow: this.refs.playerImgMoveSheet,
        },
        pushing: {
          unarmed: this.refs.playerImgMoveSheet,
          sword: this.refs.playerImgMoveSheet,
          spear: this.refs.playerImgMoveSheet,
          crossbow: this.refs.playerImgMoveSheet,
        },
        pulling: {
          unarmed: this.refs.playerImgMoveSheet,
          sword: this.refs.playerImgMoveSheet,
          spear: this.refs.playerImgMoveSheet,
          crossbow: this.refs.playerImgMoveSheet,
        },
        pushed: {
          unarmed: this.refs.playerImgMoveSheet,
          sword: this.refs.playerImgMoveSheet,
          spear: this.refs.playerImgMoveSheet,
          crossbow: this.refs.playerImgMoveSheet,
        },
        pulled: {
          unarmed: this.refs.playerImgMoveSheet,
          sword: this.refs.playerImgMoveSheet,
          spear: this.refs.playerImgMoveSheet,
          crossbow: this.refs.playerImgMoveSheet,
        },
      },
      {
        idle: {
          unarmed: this.refs.player2ImgIdleSheet,
          sword: this.refs.player2ImgIdleSheet,
          spear: this.refs.player2ImgIdleSheet,
          crossbow: this.refs.player2ImgIdleSheet,
        },
        walking: {
          unarmed: this.refs.player2ImgMoveSheet,
          sword: this.refs.player2ImgMoveSheet,
          spear: this.refs.player2ImgMoveSheet,
          crossbow: this.refs.player2ImgMoveSheet,
        },
        jumping: {
          unarmed: this.refs.player2ImgMoveSheet,
          sword: this.refs.player2ImgMoveSheet,
          spear: this.refs.player2ImgMoveSheet,
          crossbow: this.refs.player2ImgMoveSheet,
        },
        dodging: {
          unarmed: this.refs.player2ImgMoveSheet,
          sword: this.refs.player2ImgMoveSheet,
          spear: this.refs.player2ImgMoveSheet,
          crossbow: this.refs.player2ImgMoveSheet,
        },
        flanking: {
          unarmed: this.refs.player2ImgMoveSheet,
          sword: this.refs.player2ImgMoveSheet,
          spear: this.refs.player2ImgMoveSheet,
          crossbow: this.refs.player2ImgMoveSheet,
        },
        strafing: {
          unarmed: this.refs.player2ImgMoveSheet,
          sword: this.refs.player2ImgMoveSheet,
          spear: this.refs.player2ImgMoveSheet,
          crossbow: this.refs.player2ImgMoveSheet,
        },
        attacking: {
          unarmed: this.refs.player2ImgAttackSheet,
          sword: this.refs.player2ImgAttackSheet,
          spear: this.refs.player2ImgAttackSheet,
          crossbow: this.refs.player2ImgAttackSheet,
        },
        defending: {
          unarmed: this.refs.player2ImgDefendSheet,
          sword: this.refs.player2ImgDefendSheet,
          spear: this.refs.player2ImgDefendSheet,
          crossbow: this.refs.player2ImgDefendSheet,
        },
        deflected: {
          unarmed: this.refs.player2ImgMoveSheet,
          sword: this.refs.player2ImgMoveSheet,
          spear: this.refs.player2ImgMoveSheet,
          crossbow: this.refs.player2ImgMoveSheet,
        },
        pushBack: {
          unarmed: this.refs.player2ImgMoveSheet,
          sword: this.refs.player2ImgMoveSheet,
          spear: this.refs.player2ImgMoveSheet,
          crossbow: this.refs.player2ImgMoveSheet,
        },
        falling: {
          unarmed: this.refs.player2ImgMoveSheet,
          sword: this.refs.player2ImgMoveSheet,
          spear: this.refs.player2ImgMoveSheet,
          crossbow: this.refs.player2ImgMoveSheet,
        },
        pushing: {
          unarmed: this.refs.player2ImgMoveSheet,
          sword: this.refs.player2ImgMoveSheet,
          spear: this.refs.player2ImgMoveSheet,
          crossbow: this.refs.player2ImgMoveSheet,
        },
        pulling: {
          unarmed: this.refs.player2ImgMoveSheet,
          sword: this.refs.player2ImgMoveSheet,
          spear: this.refs.player2ImgMoveSheet,
          crossbow: this.refs.player2ImgMoveSheet,
        },
        pushed: {
          unarmed: this.refs.player2ImgMoveSheet,
          sword: this.refs.player2ImgMoveSheet,
          spear: this.refs.player2ImgMoveSheet,
          crossbow: this.refs.player2ImgMoveSheet,
        },
        pulled: {
          unarmed: this.refs.player2ImgMoveSheet,
          sword: this.refs.player2ImgMoveSheet,
          spear: this.refs.player2ImgMoveSheet,
          crossbow: this.refs.player2ImgMoveSheet,
        },
      },
      {
        idle: {
          unarmed: this.refs.playerComAImgIdleSheet,
          sword: this.refs.playerComAImgIdleSheet,
          spear: this.refs.playerComAImgIdleSheet,
          crossbow: this.refs.playerComAImgIdleSheet,
        },
        walking: {
          unarmed: this.refs.comAImgMoveSheet,
          sword: this.refs.comAImgMoveSheet,
          spear: this.refs.comAImgMoveSheet,
          crossbow: this.refs.comAImgMoveSheet,
        },
        jumping: {
          unarmed: this.refs.comAImgMoveSheet,
          sword: this.refs.comAImgMoveSheet,
          spear: this.refs.comAImgMoveSheet,
          crossbow: this.refs.comAImgMoveSheet,
        },
        dodging: {
          unarmed: this.refs.comAImgMoveSheet,
          sword: this.refs.comAImgMoveSheet,
          spear: this.refs.comAImgMoveSheet,
          crossbow: this.refs.comAImgMoveSheet,
        },
        flanking: {
          unarmed: this.refs.comAImgMoveSheet,
          sword: this.refs.comAImgMoveSheet,
          spear: this.refs.comAImgMoveSheet,
          crossbow: this.refs.comAImgMoveSheet,
        },
        strafing: {
          unarmed: this.refs.comAImgMoveSheet,
          sword: this.refs.comAImgMoveSheet,
          spear: this.refs.comAImgMoveSheet,
          crossbow: this.refs.comAImgMoveSheet,
        },
        attacking: {
          unarmed: this.refs.comAImgAttackSheet,
          sword: this.refs.comAImgAttackSheet,
          spear: this.refs.comAImgAttackSheet,
          crossbow: this.refs.comAImgAttackSheet,
        },
        defending: {
          unarmed: this.refs.comAImgDefendSheet,
          sword: this.refs.comAImgDefendSheet,
          spear: this.refs.comAImgDefendSheet,
          crossbow: this.refs.comAImgDefendSheet,
        },
        deflected: {
          unarmed: this.refs.comAImgMoveSheet,
          sword: this.refs.comAImgMoveSheet,
          spear: this.refs.comAImgMoveSheet,
          crossbow: this.refs.comAImgMoveSheet,
        },
        pushBack: {
          unarmed: this.refs.comAImgMoveSheet,
          sword: this.refs.comAImgMoveSheet,
          spear: this.refs.comAImgMoveSheet,
          crossbow: this.refs.comAImgMoveSheet,
        },
        falling: {
          unarmed: this.refs.comAImgMoveSheet,
          sword: this.refs.comAImgMoveSheet,
          spear: this.refs.comAImgMoveSheet,
          crossbow: this.refs.comAImgMoveSheet,
        },
        pushing: {
          unarmed: this.refs.comAImgMoveSheet,
          sword: this.refs.comAImgMoveSheet,
          spear: this.refs.comAImgMoveSheet,
          crossbow: this.refs.comAImgMoveSheet,
        },
        pulling: {
          unarmed: this.refs.comAImgMoveSheet,
          sword: this.refs.comAImgMoveSheet,
          spear: this.refs.comAImgMoveSheet,
          crossbow: this.refs.comAImgMoveSheet,
        },
        pushed: {
          unarmed: this.refs.comAImgMoveSheet,
          sword: this.refs.comAImgMoveSheet,
          spear: this.refs.comAImgMoveSheet,
          crossbow: this.refs.comAImgMoveSheet,
        },
        pulled: {
          unarmed: this.refs.comAImgMoveSheet,
          sword: this.refs.comAImgMoveSheet,
          spear: this.refs.comAImgMoveSheet,
          crossbow: this.refs.comAImgMoveSheet,
        },
      },
      {
        idle: {
          unarmed: this.refs.playerComBImgIdleSheet,
          sword: this.refs.playerComBImgIdleSheet,
          spear: this.refs.playerComBImgIdleSheet,
          crossbow: this.refs.playerComBImgIdleSheet,
        },
        walking: {
          unarmed: this.refs.comBImgMoveSheet,
          sword: this.refs.comBImgMoveSheet,
          spear: this.refs.comBImgMoveSheet,
          crossbow: this.refs.comBImgMoveSheet,
        },
        jumping: {
          unarmed: this.refs.comBImgMoveSheet,
          sword: this.refs.comBImgMoveSheet,
          spear: this.refs.comBImgMoveSheet,
          crossbow: this.refs.comBImgMoveSheet,
        },
        dodging: {
          unarmed: this.refs.comBImgMoveSheet,
          sword: this.refs.comBImgMoveSheet,
          spear: this.refs.comBImgMoveSheet,
          crossbow: this.refs.comBImgMoveSheet,
        },
        flanking: {
          unarmed: this.refs.comBImgMoveSheet,
          sword: this.refs.comBImgMoveSheet,
          spear: this.refs.comBImgMoveSheet,
          crossbow: this.refs.comBImgMoveSheet,
        },
        strafing: {
          unarmed: this.refs.comBImgMoveSheet,
          sword: this.refs.comBImgMoveSheet,
          spear: this.refs.comBImgMoveSheet,
          crossbow: this.refs.comBImgMoveSheet,
        },
        attacking: {
          unarmed: this.refs.comBImgAttackSheet,
          sword: this.refs.comBImgAttackSheet,
          spear: this.refs.comBImgAttackSheet,
          crossbow: this.refs.comBImgAttackSheet,
        },
        defending: {
          unarmed: this.refs.comBImgDefendSheet,
          sword: this.refs.comBImgDefendSheet,
          spear: this.refs.comBImgDefendSheet,
          crossbow: this.refs.comBImgDefendSheet,
        },
        deflected: {
          unarmed: this.refs.comBImgMoveSheet,
          sword: this.refs.comBImgMoveSheet,
          spear: this.refs.comBImgMoveSheet,
          crossbow: this.refs.comBImgMoveSheet,
        },
        pushBack: {
          unarmed: this.refs.comBImgMoveSheet,
          sword: this.refs.comBImgMoveSheet,
          spear: this.refs.comBImgMoveSheet,
          crossbow: this.refs.comBImgMoveSheet,
        },
        falling: {
          unarmed: this.refs.comBImgMoveSheet,
          sword: this.refs.comBImgMoveSheet,
          spear: this.refs.comBImgMoveSheet,
          crossbow: this.refs.comBImgMoveSheet,
        },
        pushing: {
          unarmed: this.refs.comBImgMoveSheet,
          sword: this.refs.comBImgMoveSheet,
          spear: this.refs.comBImgMoveSheet,
          crossbow: this.refs.comBImgMoveSheet,
        },
        pulling: {
          unarmed: this.refs.comBImgMoveSheet,
          sword: this.refs.comBImgMoveSheet,
          spear: this.refs.comBImgMoveSheet,
          crossbow: this.refs.comBImgMoveSheet,
        },
        pushed: {
          unarmed: this.refs.comBImgMoveSheet,
          sword: this.refs.comBImgMoveSheet,
          spear: this.refs.comBImgMoveSheet,
          crossbow: this.refs.comBImgMoveSheet,
        },
        pulled: {
          unarmed: this.refs.comBImgMoveSheet,
          sword: this.refs.comBImgMoveSheet,
          spear: this.refs.comBImgMoveSheet,
          crossbow: this.refs.comBImgMoveSheet,
        },
      },
    ]
    this.itemImgs = {
      moveSpeedUp: this.refs.itemSpdUp,
      moveSpeedDown: this.refs.itemSpdDown,
      hpUp: this.refs.itemHpUp,
      hpDown: this.refs.itemHpDown,
      focusUp: this.refs.itemFocusUp,
      focusDown: this.refs.itemFocusDown,
      strengthUp: this.refs.itemStrUp,
      strengthDown: this.refs.itemStrDown,
      sword: this.refs.itemSword,
      spear: this.refs.itemSpear,
      crossbow: this.refs.itemBow,
      helmet: this.refs.itemHelmet1,
      ammo5: this.refs.itemAmmo,
      ammo10: this.refs.itemAmmo,
      mail: this.refs.itemMail1,
      greaves: this.refs.itemGreaves1,
    };
    this.boltImgs = {
      north: this.refs.itemBoltNorth,
      south: this.refs.itemBoltSouth,
      east: this.refs.itemBoltEast,
      west: this.refs.itemBoltWest,
    }
    this.floorImgs = {
      grass: this.refs.floorGrass,
      stone: this.refs.floorStone,
      dirt: this.refs.floorDirt,
      pond: this.refs.floorPond,
      mud: this.refs.floorMud,
      sand: this.refs.floorSand,
      ice: this.refs.floorIce,
      lava: this.refs.floorLava,
      bramble: this.refs.floorBramble,
      river: this.refs.floorRiver,
      void: this.refs.floorVoid,
      void2: this.refs.floorVoid2,
      void3: this.refs.floorVoid3,
      rubble: this.refs.floorRubble,
    }
    this.obstacleImgs = {
      table: this.refs.obstacleAHalf,
      closet: this.refs.obstacleAFull,
      chair: this.refs.obstacleBHalf,
      shelf: this.refs.obstacleBFull,
      smallBox: this.refs.obstacleCHalf,
      largeBox: this.refs.obstacleCFull,
      counter: this.refs.obstacleDHalf,
      chest: this.refs.obstacleEHalf,
      crate: this.refs.obstacleCrate,
      barrel: this.refs.obstacleBarrel,
      chest: this.refs.obstacleCrate,
      table: this.refs.obstacleCrate,
      chair: this.refs.obstacleCrate,
      shelf: this.refs.obstacleCrate,
      counter: this.refs.obstacleCrate,
      smallBox: this.refs.obstacleCrate,
      largeBox: this.refs.obstacleBarrel,
    }
    this.barrierImgs = {
      wall: {
        north: this.refs.barrierANorth,
        south: this.refs.barrierASouth,
        east: this.refs.barrierAEast,
        west: this.refs.barrierAWest,
      },
      door: {
        north: this.refs.barrierANorth,
        south: this.refs.barrierASouth,
        east: this.refs.barrierAEast,
        west: this.refs.barrierAWest,
      },
      balcony: {
        north: this.refs.barrierANorth,
        south: this.refs.barrierASouth,
        east: this.refs.barrierAEast,
        west: this.refs.barrierAWest,
      },
    }

    // LOAD CROSSBOW AMMO
    for (const plyr of this.players) {
      if (plyr.currentWeapon.type === 'crossbow') {
        let ammo = parseInt(plyr.currentWeapon.effect.split('+')[1])
        plyr.items.ammo = plyr.items.ammo + ammo;
      }
    }

    let floor;
    let wall = this.refs.wall;
    let wall2 = this.refs.wall2;
    let wall3 = this.refs.wall3;

    canvas.width = this.canvasWidth;
    canvas.height = this.canvasHeight;

    let floorImageWidth = this.floorImageWidth;
    let floorImageHeight = this.floorImageHeight;
    let wallImageWidth = this.wallImageWidth;
    let wallImageHeight = this.wallImageHeight;
    let sceneX = this.canvasWidth/2;
    let sceneY = this.sceneY;
    let tileWidth = this.tileWidth;



    this.startProcessLevelData(canvas);
    // gridInfo = this.gridInfo;

    this.processLevelData(this.gridInfo);


    // RESET START POSITION IF DOESN'T EXIST IN CURRENT GRID OR CONFLICTING W/ THIS MAP
    for (const plyr of this.players) {

      // if (!this.gridInfo.find(x => x.number.x === plyr.startPosition.cell.number.x && x.number.y === plyr.startPosition.cell.number.y)) {
      if (!this.gridInfo.find(x => x.number.x === plyr.startPosition.cell.number.x && x.number.y === plyr.startPosition.cell.number.y)) {

        let cll = {x: undefined, y: undefined};
        let randomFreeCellChosen = false;

        while (randomFreeCellChosen !== true) {
          cll.x = this.rnJesus(0,this.gridWidth)
            cll.y = this.rnJesus(0,this.gridWidth)
            randomFreeCellChosen = this.checkCell(cll);
        }

        if (randomFreeCellChosen === true) {
          plyr.startPosition.cell.number = cll;
        }

      }

      // RECONSIDER/RANDOM CHOOSE START POSTION IF CONFLICTING W/ THIS MAP
      if (
        this.gridInfo.find(x => x.number.x === plyr.startPosition.cell.number.x && x.number.y === plyr.startPosition.cell.number.y).terrain.type === "deep" ||
        this.gridInfo.find(x => x.number.x === plyr.startPosition.cell.number.x && x.number.y === plyr.startPosition.cell.number.y).terrain.type === "void" ||
        this.gridInfo.find(x => x.number.x === plyr.startPosition.cell.number.x && x.number.y === plyr.startPosition.cell.number.y).void.state === true ||
        this.gridInfo.find(x => x.number.x === plyr.startPosition.cell.number.x && x.number.y === plyr.startPosition.cell.number.y).obstacle.state === true
      ) {

        let cll = {x: undefined, y: undefined};
        let randomFreeCellChosen = false;

        while (randomFreeCellChosen !== true) {
          cll.x = this.rnJesus(0,this.gridWidth)
            cll.y = this.rnJesus(0,this.gridWidth)
            randomFreeCellChosen = this.checkCell(cll);
        }

        if (randomFreeCellChosen === true) {
          plyr.startPosition.cell.number = cll;
        }

      }

    }
    // console.log('post process barrier check init',this.gridInfo.filter(x => x.barrier.state === true).map(y => y = y.barrier.position));


    if (this.camera.fixed !== true) {
      // this.setCameraFocus('init', canvas, context, canvas2, context2);
    }
    // this.findFocusCell('panToCell',{},canvas,context)


    // CENTER LARGER GRIDS
    if (window.innerWidth < 1100 && this.gridWidth >= 12) {
      // this.camera.zoom.x = 0.7;
      // this.camera.zoom.y = 0.7;

      this.setInitZoom = {
        state: true,
        windowWidth: window.innerWidth,
        gridWidth: this.gridWidth,
      }
    }
    if (window.innerWidth > 1100 && this.gridWidth >= 12) {
      // this.camera.zoom.x = 1;
      // this.camera.zoom.y = 1;

      this.setInitZoom = {
        state: true,
        windowWidth: window.innerWidth,
        gridWidth: this.gridWidth,
      }
    }
    if (window.innerWidth < 1100 && this.gridWidth < 12) {
      // this.camera.zoom.x = 1;
      // this.camera.zoom.y = 1;

      this.setInitZoom = {
        state: true,
        windowWidth: window.innerWidth,
        gridWidth: this.gridWidth,
      }
    }

    let diff = 1 - this.camera.zoom.x;

    // FOCUSED ZOOMING INIT SET
    this.camera.pan.x = (diff*this.canvasWidth/2);
    this.camera.pan.y = (diff*this.canvasWidth/2)-(diff*350);
    if (this.camera.pan.x === 0) {
      this.camera.pan.x = -1
      this.camera.pan.y = -1
    }


    if (this.showSettingsCanvasData.state === true) {
      this.settingsFormGridWidthUpdate(this.settingsGridWidth)
    }


    this.placeItems({init: true, items: ''});


    // CELL COLOR REF
    let preCellColorRef = this.gridInfo.map(x => x = {x:x.number.x,y:x.number.y,color:''});
    for(const cell of preCellColorRef) {
      let colorCheckPass = false;
      while (colorCheckPass === false) {
        let randomColor = `rgb(${this.rnJesus(0,255)},${this.rnJesus(0,255)},${this.rnJesus(0,255)})`;
        let colorsInUse = preCellColorRef.filter(x => x.color !== '').map(y => y === y.color);
        if (colorsInUse.find(x => x === randomColor)) {
          colorCheckPass = false;
        }
        else {
          cell.color = randomColor;
          colorCheckPass = true;
        }
      }
    };
    this.cellColorRef = preCellColorRef;


    for (var x = 0; x < this.gridWidth+1; x++) {
      for (var y = 0; y < this.gridWidth+1; y++) {
        let p = new Point();
        p.x = x * tileWidth;
        p.y = y * tileWidth;

        let iso = this.cartesianToIsometric(p);
        let offset = {x: floorImageWidth/2, y: floorImageHeight}

        // apply offset to center scene for a better view
        iso.x += sceneX
        iso.y += sceneY


        let center = {
          x: iso.x - offset.x/2+this.cellCenterOffsetX,
          y: iso.y - offset.y/2-this.cellCenterOffsetY,
        }


        let cell = this.gridInfo.find(elem => elem.number.x === x && elem.number.y === y);
        let cellLevelData = this.gridInfo.find(elem => elem.number.x === x && elem.number.y === y).levelData;


        floor = this.floorImgs[cell.terrain.name]

        if (cell.void.state === true) {
          // drawFloor = false;
          floor = this.floorImgs.void3
        }


        // context.drawImage(floor, iso.x - offset.x, iso.y - offset.y, 100, 100);
        context.drawImage(floor, iso.x - offset.x, iso.y - offset.y);

        context.fillStyle = 'black';
        context.fillText(""+x+","+y+"",iso.x - offset.x/2 + 18,iso.y - offset.y/2 + 12);

        context.fillStyle = "black";
        context.fillRect(center.x, center.y,5,5);


        // INITIAL ITEM DISTRIBUTION!!
        let cell2 = this.gridInfo.find(elem => elem.number.x === x && elem.number.y === y);
        if (cell2.item.name !== '') {
          // console.log('found cell with item');
          if (cell2.item.initDrawn === false) {
            // console.log('found cell with item undrawn');
            let itemImg;
            let fillClr;
            if (cell2.item.type === 'item') {
              switch(cell2.item.name) {
                case 'moveSpeedUp' :
                  fillClr = "purple";
                  itemImg = this.itemImgs[cell2.item.name];
                break;
                case 'moveSpeedDown' :
                  fillClr = "blue";
                  itemImg = this.itemImgs[cell2.item.name];
                break;
                case 'hpUp' :
                  fillClr = "yellow";
                  itemImg = this.itemImgs[cell2.item.name];
                break;
                case 'hpDown' :
                  fillClr = "brown";
                  itemImg = this.itemImgs[cell2.item.name];
                break;
                case 'focusUp' :
                  fillClr = "white";
                  itemImg = this.itemImgs[cell2.item.name];
                break;
                case 'focusDown' :
                  fillClr = "black";
                  itemImg = this.itemImgs[cell2.item.name];
                break;
                case 'strengthUp' :
                  fillClr = "green";
                  itemImg = this.itemImgs[cell2.item.name];
                break;
                case 'strengthDown' :
                  fillClr = "red";
                  itemImg = this.itemImgs[cell2.item.name];
                break;
                case 'ammo5' :
                  fillClr = '#283618';
                  itemImg = this.itemImgs[cell2.item.name];
                break;
                case 'ammo10' :
                  fillClr = '#283618';
                  itemImg = this.itemImgs[cell2.item.name];
                break;
              }
            }
            else if (cell2.item.type === 'weapon') {
              switch(cell2.item.subType) {
                case 'sword' :
                  fillClr = "orange";
                  itemImg = this.itemImgs[cell2.item.subType];
                break;
                case 'spear' :
                  fillClr = "maroon";
                  itemImg = this.itemImgs[cell2.item.subType];
                break;
                case 'crossbow' :
                  fillClr = "navy";
                  itemImg = this.itemImgs[cell2.item.subType];
                break;
              }
            }
            else if (cell2.item.type === 'armor') {
              switch(cell2.item.subType) {
                case 'helmet' :
                  fillClr = "grey";
                  itemImg = this.itemImgs[cell2.item.subType];
                break;
                case 'mail' :
                  fillClr = "olive";
                  itemImg = this.itemImgs[cell2.item.subType];
                break;
                case 'greaves' :
                  fillClr = "#b5179e";
                  itemImg = this.itemImgs[cell2.item.subType];
                break;
              }
            }


            // context.fillStyle = fillClr;
            // context.beginPath();
            // context.arc(center.x, center.y, 15, 0, 2 * Math.PI);
            // context.fill();

            context.drawImage(itemImg ,center.x-15, center.y-15, 30,30);
          }
        }


        let vertices = [
          {x:center.x, y:center.y+tileWidth/2},
          {x:center.x+tileWidth, y:center.y},
          {x:center.x, y:center.y-tileWidth/2},
          {x:center.x-tileWidth, y:center.y},
        ];
        for (const vertex of vertices) {
          context.fillStyle = "yellow";
          context.fillRect(vertex.x-2.5, vertex.y-2.5,5,5);
        }


        for (const player of this.players) {

          if (
            x === player.startPosition.cell.number.x &&
            y === player.startPosition.cell.number.y
          ) {

            let playerImg;
            let playerImgIndex;
            let atkType = player.currentWeapon.type;
            if (player.currentWeapon.name === "") {
              atkType = "unarmed";
            }

            if (player.ai.state === true) {

              if (player.ai.imgType === "A") {
                playerImgIndex = 2;
              }
              else if (player.ai.imgType === "B") {
                playerImgIndex = 3;
              }

              playerImg = this.playerImgs[playerImgIndex].idle[atkType];
            } else {
              playerImg = this.playerImgs[player.number-1].idle[atkType];
            }


            let dirs = ['north','south','east','west']
            let dirIndex = dirs.indexOf(player.direction);
            let sHeight = this.charSpriteHeight;
            let sWidth = this.charSpriteWidth;
            let sy = dirIndex * sHeight;
            let sx = 0 * sWidth;


            // player.speed.move = .1;
            player.dead.state = false;
            player.dead.count = 0;

            let point = {
              x: 0,
              y: 0,
            };

            let cell = this.gridInfo.find(elem => elem.number.x === player.startPosition.cell.number.x && elem.number.y === player.startPosition.cell.number.y)
            point.x = cell.center.x;
            point.y = cell.center.y;

            player.currentPosition.cell = {
              number: {
                x: player.startPosition.cell.number.x,
                y: player.startPosition.cell.number.y
              },
              center : {
                x: point.x,
                y: point.y
              }
            }
            player.moving = {
              state: false,
              step: 0,
              course: '',
              origin: {
                number: {
                  x: player.startPosition.cell.number.x,
                  y: player.startPosition.cell.number.y,
                },
                center: {
                  x: point.x,
                  y: point.y,
                },
              },
              destination: {
                x: 0,
                y: 0,
              }
            }
            player.nextPosition = {
              x: point.x,
              y: point.y
            }

            this.players[player.number-1] = player;

            this.getTarget(player);

            context.drawImage(playerImg, sx, sy, sWidth, sHeight, point.x-30, point.y-30, this.playerDrawWidth, this.playerDrawHeight);

          }

        }

        // OBSTACLES & BARRIERS
        if (cell.barrier.state === true && cell.void.state !== true) {
          let barrierImg = this.barrierImgs[cell.barrier.type][cell.barrier.position];
          context.drawImage(barrierImg, iso.x - offset.x, iso.y - barrierImg.height, barrierImg.width, barrierImg.height);
        }

        if (cell.obstacle.state === true && cell.void.state !== true) {
          let obstacleImg = this.obstacleImgs[cell.obstacle.type]
          context.drawImage(obstacleImg, iso.x - offset.x, iso.y - (obstacleImg.height));
        }


        this.init = false;
        this.setState({
          loading: false,
        })

      }
    }


  }



  render() {
    return (
      <React.Fragment>

        {this.state.loading === true && (
          <Loading />
        )}

        <div className="containerTop">


          <div className="timer">
            <p className="timerText">
            {this.time}
            </p>
          </div>

          <div className={this.state.containerInnerClass}>

            <canvas
              width={this.canvasWidth}
              height={this.canvasHeight}
              ref={this.canvasRef}
              className="canvas"
            />
            <canvas
              width={this.canvasWidth}
              height={this.canvasHeight}
              ref={this.canvasRef2}
              className="canvas2"
            />

            // DEBUB BOX
            <div className={this.debugBoxStyle}>
              <DebugBox
                player={this.players[0]}
                expand={this.expandDebugBox}
                minimize={this.minimizeDebugBox}
              />
            </div>
            {this.players.length > 1 &&(
              <div className={this.debugBoxStyle2}>
                <DebugBox
                  player={this.players[1]}
                  expand={this.expandDebugBox}
                  minimize={this.minimizeDebugBox}
                />
              </div>
            )}

            // SETTINGS BOX
            <div className="settingsSwitch">
              <a href="javascript:" className="setSwitchLink" onClick={this.openSettings}>
                <OverlayTrigger
                  placement={'top'}
                  overlay={
                    <Popover id={`popover-positioned-${'top'}`}>
                      <Popover.Content>
                        <strong>Show Settings</strong>
                      </Popover.Content>
                    </Popover>
                  }
                >
                  <FontAwesomeIcon icon={faCogs} size="sm" className="setSwitchIcon"/>
                </OverlayTrigger>

              </a>
              {this.aiPlayers[0] &&(
              // {this.updateSettingsFormAiDataData.random &&(
                <a href="javascript:" className="setSwitchLink cameraModeHighlighted" onClick={this.toggleAiDisplay}>
                  <OverlayTrigger
                    placement={'top'}
                    overlay={
                      <Popover id={`popover-positioned-${'top'}`}>
                        <Popover.Content>
                          <strong>Toggle Ai Sub-menu</strong>
                        </Popover.Content>
                      </Popover>
                    }
                  >
                    <FontAwesomeIcon icon={faRobot} size="sm" className="setSwitchIcon"/>
                  </OverlayTrigger>

                </a>
              )}
              {!this.aiPlayers[0] &&(
              // {!this.updateSettingsFormAiDataData.random &&(
                <a href="javascript:" className="setSwitchLink" onClick={this.toggleAiDisplay}>
                  <OverlayTrigger
                    placement={'top'}
                    overlay={
                      <Popover id={`popover-positioned-${'top'}`}>
                        <Popover.Content>
                          <strong>Toggle Ai Sub-menu</strong>
                        </Popover.Content>
                      </Popover>
                    }
                  >
                    <FontAwesomeIcon icon={faRobot} size="sm" className="setSwitchIcon"/>
                  </OverlayTrigger>

                </a>
              )}
              {this.camera.state === false && (
                <a href="javascript:" className="setSwitchLink" onClick={this.menuToggleCamera}>
                  <OverlayTrigger
                    placement={'top'}
                    overlay={
                      <Popover id={`popover-positioned-${'top'}`}>
                        <Popover.Content>
                          <strong>Toggle Camera Sub-menu</strong>
                        </Popover.Content>
                      </Popover>
                    }
                  >
                    <FontAwesomeIcon icon={faVideo} size="sm" className="setSwitchIcon"/>
                  </OverlayTrigger>

                </a>
              )}
              <a href="javascript:" className="setSwitchLink" onClick={this.gameReset.bind(this,'soft')}>
                <OverlayTrigger
                  placement={'top'}
                  overlay={
                    <Popover id={`popover-positioned-${'top'}`}>
                      <Popover.Content>
                        <strong>Reset Game (w/ last settings)</strong>
                      </Popover.Content>
                    </Popover>
                  }
                >
                  <FontAwesomeIcon icon={faUndo} size="sm" className="setSwitchIcon"/>
                </OverlayTrigger>

              </a>
              )}

            </div>


            // CAMERA BOX
            {this.camera.state === true && (
              <div className="cameraBox">
                <CameraControl
                  camera={this.camera}
                  close={this.closeCamera}
                  toggleMode={this.toggleCameraModeUI}
                  preReset={this.preResetCamera}
                />
              </div>
            )}


            // CELL INFO
            {this.showCellInfoBox !== true && (
              <div className="cellInfoSwitch">
                <OverlayTrigger
                  placement={'top'}
                  overlay={
                    <Popover id={`popover-positioned-${'top'}`}>
                      <Popover.Content>
                        <strong>Click or mouse over a cell to get more info</strong>
                      </Popover.Content>
                    </Popover>
                  }
                >
                  <FontAwesomeIcon icon={faChessBoard} size="sm" className="setSwitchIcon"/>
                </OverlayTrigger>

              </div>
            )}
            {this.showCellInfoBox === true && (
              <CellInfo
                ref={this.cellInfoBoxRef}
                clicked={this.clicked}
                close={this.closeCellInfoBox}
                setCellInfoMouseOver={this.setCellInfoMouseOver}
              />
            )}


            // AI STATUS BOX
            {this.state.showAiStatus === true && (
              <AiStatus
                players={this.players}
                aiPlayers={this.aiPlayers}
                onAiAdd={this.addAiRandomPlayer}
              />
            )}


          </div>





          {this.state.showSettings === true && (
            <Settings
              gridWidth={this.gridWidth}
              onConfirm={this.loadSettings}
              onCancel={this.cancelSettings}
              getCustomAiStartPosList={this.getCustomAiStartPosList}
              aiStartPosList={this.settingsFormAiStartPosList}
              aiSettingsFormHandler={this.aiSettingsFormHandler}
              updateSettingsFormAiDataData={this.updateSettingsFormAiDataData}
              updateSettingsFormAiData={this.updateSettingsFormAiData}
              rnJesus={this.rnJesus}
              settingsFormGridWidthUpdate={this.settingsFormGridWidthUpdate}
              plyrStartPosList={this.settingsFormPlyrStartPosList}
              getCustomPlyrStartPosList={this.getCustomPlyrStartPosList}
              gamepad={this.gamepad}
              canvasRef={this.canvasRef3}
              canvasRef2={this.canvasRef4}
              canvasHeight={this.settingsCanvasHeight}
              canvasWidth={this.settingsCanvasWidth}
              gridInfo={this.settingsGridInfo}
              clickedCell={this.settingsClicked}
              showCanvasData={this.showSettingsCanvasData}
              updateSettingsCanvasData={this.updateSettingsCanvasData}
              disableInitItems={this.disableInitItems}
              settingsFormPlayerData={this.settingsFormPlayerData}
              updateSettingsFormPlayerData={this.updateSettingsFormPlayerData}
            />
          )}


          <svg className="popupProgressSvg hidden" ref="popupProgressSvg"  xmlns="http://www.w3.org/2000/svg" viewBox="0 -0.5 30 30" shape-rendering="crispEdges">
            <metadata>Made with Pixels to Svg https://codepen.io/shshaw/pen/XbxvNj</metadata>
            <path id="border" stroke="yellow" stroke-width="5px" d="M4 0h21M2 1h26M1 2h2M27 2h2M1 3h1M28 3h1M1 4h1M28 4h2M0 5h2M28 5h2M0 6h2M28 6h2M0 7h2M28 7h2M0 8h2M28 8h2M0 9h2M28 9h2M0 10h2M28 10h2M0 11h2M28 11h2M0 12h2M28 12h2M0 13h2M28 13h2M0 14h2M28 14h2M0 15h2M28 15h2M0 16h2M28 16h2M0 17h2M28 17h2M0 18h2M28 18h2M0 19h2M28 19h2M0 20h2M28 20h2M0 21h2M28 21h2M0 22h2M28 22h2M0 23h2M28 23h2M0 24h2M28 24h2M0 25h2M28 25h1M1 26h1M28 26h1M1 27h2M27 27h2M2 28h26M5 29h21" />
            <rect id="rect" x="1" y="1" rx="5" ry="5" width="95%" height="0%" fill="url(#grad)"/>
            <defs>
              <linearGradient id="grad" x1="0%" y1="0%" x2="0%" y2="100%">
                <stop offset="0%" stopColor={this.popupProgressSvgGradColor1} stopOpacity="100%" />
                <stop offset="100%"  stopColor={this.popupProgressSvgGradColor2} stopOpacity="100%"/>
              </linearGradient>
            </defs>
          </svg>


          <img src="" className="hidden" height={this.popupImgSize} width={this.popupImgSize} ref="popupProgressImg" alt="logo"/>

          <img src={floorGrass} className='hidden' ref="floorGrass" alt="logo" id="floor1"/>
          <img src={floorDirt} className='hidden' ref="floorDirt" alt="logo" id="floor2"/>
          <img src={floorIce} className='hidden' ref="floorIce" alt="logo" id="floor2"/>
          <img src={floorStone} className='hidden' ref="floorStone" alt="logo" id="floor2"/>
          <img src={floorSand} className='hidden' ref="floorSand" alt="logo" id="floor2"/>
          <img src={floorMud} className='hidden' ref="floorMud" alt="logo" id="floor2"/>
          <img src={floorPond} className='hidden' ref="floorPond" alt="logo" id="floor2"/>
          <img src={floorRiver} className='hidden' ref="floorRiver" alt="logo" id="floor2"/>
          <img src={floorBramble} className='hidden' ref="floorBramble" alt="logo" id="floor2"/>
          <img src={floorLava} className='hidden' ref="floorLava" alt="logo" id="floor2"/>
          <img src={floorAttack} className='hidden' ref="floorAttack" alt="logo" id="floor3"/>
          <img src={floorAttack2} className='hidden' ref="floorAttack2" alt="logo" id="floor3"/>
          <img src={floorVoid} className='hidden' ref="floorVoid" alt="logo" id="floor4"/>
          <img src={floorVoid2} className='hidden' ref="floorVoid2" alt="logo" id="floor4"/>
          <img src={floorVoid3} className='hidden' ref="floorVoid3" alt="logo" id="floor4"/>
          <img src={floorHighlight} className='hidden' ref="floorHighlight" alt="logo" id="floor4"/>
          <img src={floorRubble} className='hidden' ref="floorRubble" alt="logo" id="floor4"/>
          <img src={wall} className='hidden' ref="wall" id="wall" alt="logo" />
          <img src={wall2} className='hidden' ref="wall2" id="wall2" alt="logo" />
          <img src={wall3} className='hidden' ref="wall3" id="wall3" alt="logo" />


          <img src={obstacleAHalf} className='hidden' ref="obstacleAHalf" id="wall3" alt="logo" />
          <img src={obstacleAFull} className='hidden' ref="obstacleAFull" id="wall3" alt="logo" />
          <img src={obstacleBHalf} className='hidden' ref="obstacleBHalf" id="wall3" alt="logo" />
          <img src={obstacleBFull} className='hidden' ref="obstacleBFull" id="wall3" alt="logo" />
          <img src={obstacleCHalf} className='hidden' ref="obstacleCHalf" id="wall3" alt="logo" />
          <img src={obstacleCFull} className='hidden' ref="obstacleCFull" id="wall3" alt="logo" />
          <img src={obstacleDHalf} className='hidden' ref="obstacleDHalf" id="wall3" alt="logo" />
          <img src={obstacleDFull} className='hidden' ref="obstacleDFull" id="wall3" alt="logo" />
          <img src={obstacleEHalf} className='hidden' ref="obstacleEHalf" id="wall3" alt="logo" />
          <img src={obstacleEFull} className='hidden' ref="obstacleEFull" id="wall3" alt="logo" />
          <img src={obstacleCrate} className='hidden' ref="obstacleCrate" id="wall3" alt="logo" />
          <img src={obstacleBarrel} className='hidden' ref="obstacleBarrel" id="wall3" alt="logo" />
          <img src={barrierANorth} className='hidden' ref="barrierANorth" id="wall3" alt="logo" />
          <img src={barrierASouth} className='hidden' ref="barrierASouth" id="wall3" alt="logo" />
          <img src={barrierAEast} className='hidden' ref="barrierAEast" id="wall3" alt="logo" />
          <img src={barrierAWest} className='hidden' ref="barrierAWest" id="wall3" alt="logo" />


          <img src={attack1Indicate} className='hidden playerImgs' ref="attack1Indicate" id="attack1Indicate" alt="logo" />
          <img src={attack2Indicate} className='hidden playerImgs' ref="attack2Indicate" id="attack2Indicate" alt="logo" />
          <img src={attack3Indicate} className='hidden playerImgs' ref="attack3Indicate" id="attack3Indicate" alt="logo" />
          <img src={attackUnarmedIndicate} className='hidden playerImgs' ref="attackUnarmedIndicate" id="attackUnarmedIndicate" alt="logo" />
          <img src={attackBluntIndicate} className='hidden playerImgs' ref="attackBluntIndicate" id="attackBluntIndicate" alt="logo" />
          <img src={attackSuccessIndicate} className='hidden playerImgs' ref="attackSuccessIndicate" id="attackSuccessIndicate" alt="logo" />
          <img src={defendIndicate} className='hidden playerImgs' ref="defendIndicate" id="defendIndicate" alt="logo" />
          <img src={defendIndicate1} className='hidden playerImgs' ref="defendIndicate1" id="defendIndicate1" alt="logo" />
          <img src={defendIndicate2} className='hidden playerImgs' ref="defendIndicate2" id="defendIndicate2" alt="logo" />
          <img src={defendIndicate3} className='hidden playerImgs' ref="defendIndicate3" id="defendIndicate3" alt="logo" />
          <img src={defendIndicate4} className='hidden playerImgs' ref="defendIndicate4" id="defendIndicate4" alt="logo" />
          <img src={deflectIndicate} className='hidden playerImgs' ref="deflectIndicate" id="deflectIndicate" alt="logo" />
          <img src={deflectIndicate2} className='hidden playerImgs' ref="deflectIndicate2" id="deflectIndicate2" alt="logo" />
          <img src={deflectInjuredIndicate} className='hidden playerImgs' ref="deflectInjuredIndicate" id="deflectInjuredIndicate" alt="logo" />
          <img src={deflectInjuredIndicate2} className='hidden playerImgs' ref="deflectInjuredIndicate2" id="deflectInjuredIndicate" alt="logo" />
          <img src={deflectBluntIndicate} className='hidden playerImgs' ref="deflectBluntIndicate" id="deflectBluntIndicate" alt="logo" />
          <img src={pushbackIndicate} className='hidden playerImgs' ref="pushbackIndicate" id="pushbackIndicate" alt="logo" />
          <img src={ghostIndicate} className='hidden playerImgs' ref="ghostIndicate" id="ghostIndicate" alt="logo" />
          <img src={deathIndicate} className='hidden playerImgs' ref="deathIndicate" id="deathIndicate" alt="logo" />
          <img src={preAttackIndicate} className='hidden playerImgs' ref="preAttackIndicate" id="preAttackIndicate" alt="logo" />
          <img src={preAttack2Indicate} className='hidden playerImgs' ref="preAttack2Indicate" id="preAttack2Indicate" alt="logo" />
          <img src={attackBreakIndicate} className='hidden playerImgs' ref="attackBreakIndicate" id="attackBreakIndicate" alt="logo" />
          <img src={defendBreakIndicate} className='hidden playerImgs' ref="defendBreakIndicate" id="defendBreakIndicate" alt="logo" />
          <img src={defendSuccessIndicate} className='hidden playerImgs' ref="defendSuccessIndicate" id="defendBreakIndicate" alt="logo" />
          <img src={boltDefendIndicate} className='hidden playerImgs' ref="boltDefendIndicate" id="boltDefendIndicate" alt="logo" />
          <img src={dodgeIndicate} className='hidden playerImgs' ref="dodgeIndicate" id="dodgeIndicate" alt="logo" />
          <img src={preAction1Indicate} className="hidden playerImgs" ref="preAction1Indicate" id="preAction1Indicate" alt="logo"/>
          <img src={preAction2Indicate} className="hidden playerImgs" ref="preAction2Indicate" id="preAction2Indicate" alt="logo"/>
          <img src={fallingIndicate} className="hidden playerImgs" ref="fallingIndicate" id="fallingIndicate" alt="logo"/>
          <img src={completeMissionIndicate} className="hidden playerImgs" ref="completeMissionIndicate" id="completeMissionIndicate" alt="logo"/>
          <img src={flankIndicate} className="hidden playerImgs" ref="flankIndicate" id="flankIndicate" alt="logo"/>
          <img src={attackBluntIndicate2} className="hidden playerImgs" ref="attackBluntIndicate2" id="attackBluntIndicate2" alt="logo"/>
          <img src={enrouteIndicate} className="hidden playerImgs" ref="enrouteIndicate" id="enrouteIndicate" alt="logo"/>
          <img src={targetSwitchIndicate} className="hidden playerImgs" ref="targetSwitchIndicate" id="targetSwitchIndicate" alt="logo"/>
          <img src={pathSwitchIndicate} className="hidden playerImgs" ref="pathSwitchIndicate" id="pathSwitchIndicate" alt="logo"/>
          <img src={retreatIndicate} className="hidden playerImgs" ref="retreatIndicate" id="retreatIndicate" alt="logo"/>
          <img src={defendSuccessIndicate} className="hidden playerImgs" ref="defendSuccessIndicate" id="defendSuccessIndicate" alt="logo"/>
          <img src={healIndicate} className="hidden playerImgs" ref="healIndicate" id="defendSuccessIndicate" alt="logo"/>


          <img src={preAttack2Indicate} className="hidden playerImgs" ref="preAttack2Indicate" id="preAttack2Indicate" alt="..." />
          <img src={preAction1Indicate} className="hidden playerImgs" ref="preAction1Indicate" id="preAction1Indicate" alt="..." />
          <img src={preAction2Indicate} className="hidden playerImgs" ref="preAction2Indicate" id="preAction2Indicate" alt="..." />
          <img src={attackBreakIndicate} className="hidden playerImgs" ref="attackBreakIndicate" id="attackBreakIndicate" alt="..." />
          <img src={missedIndicate} className="hidden playerImgs" ref="missedIndicate" id="missedIndicate" alt="..." />
          <img src={defendBreakIndicate} className="hidden playerImgs" ref="defendBreakIndicate" id="defendBreakIndicate" alt="..." />
          <img src={boltDefendIndicate} className="hidden playerImgs" ref="boltDefendIndicate" id="boltDefendIndicate" alt="..." />
          <img src={dodgeIndicate} className="hidden playerImgs" ref="dodgeIndicate" id="dodgeIndicate" alt="..." />
          <img src={fallingIndicate} className="hidden playerImgs" ref="fallingIndicate" id="fallingIndicate" alt="..." />
          <img src={completeMissionIndicate} className="hidden playerImgs" ref="completeMissionIndicate" id="completeMissionIndicate" alt="..." />
          <img src={flankIndicate} className="hidden playerImgs" ref="flankIndicate" id="flankIndicate" alt="..." />
          <img src={attackBluntIndicate2} className="hidden playerImgs" ref="attackBluntIndicate2" id="attackBluntIndicate2" alt="..." />
          <img src={enrouteIndicate} className="hidden playerImgs" ref="enrouteIndicate" id="enrouteIndicate" alt="..." />
          <img src={targetSwitchIndicate} className="hidden playerImgs" ref="targetSwitchIndicate" id="targetSwitchIndicate" alt="..." />
          <img src={pathSwitchIndicate} className="hidden playerImgs" ref="pathSwitchIndicate" id="pathSwitchIndicate" alt="..." />
          <img src={retreatIndicate} className="hidden playerImgs" ref="retreatIndicate" id="retreatIndicate" alt="..." />
          <img src={defendSuccessIndicate} className="hidden playerImgs" ref="defendSuccessIndicate" id="defendSuccessIndicate" alt="..." />
          <img src={aggressiveModeIndicate} className="hidden playerImgs" ref="aggressiveModeIndicate" id="aggressiveModeIndicate" alt="..." />
          <img src={passiveModeIndicate} className="hidden playerImgs" ref="passiveModeIndicate" id="passiveModeIndicate" alt="..." />
          <img src={thinkingIndicate} className="hidden playerImgs" ref="thinkingIndicate" id="thinkingIndicate" alt="..." />
          <img src={defendMissionIndicate} className="hidden playerImgs" ref="defendMissionIndicate" id="defendMissionIndicate" alt="..." />
          <img src={patrolMissionIndicate} className="hidden playerImgs" ref="patrolMissionIndicate" id="patrolMissionIndicate" alt="..." />
          <img src={pursueMissionIndicate} className="hidden playerImgs" ref="pursueMissionIndicate" id="pursueMissionIndicate" alt="..." />
          <img src={pursueMissionIndicate2} className="hidden playerImgs" ref="pursueMissionIndicate2" id="pursueMissionIndicate2" alt="..." />
          <img src={retrieveMissionIndicate} className="hidden playerImgs" ref="retrieveMissionIndicate" id="retrieveMissionIndicate" alt="..." />
          <img src={drowningIndicate} className="hidden playerImgs" ref="drowningIndicate" id="drowningIndicate" alt="..." />
          <img src={destroyedItemIndicate} className="hidden playerImgs" ref="destroyedItemIndicate" id="destroyedItemIndicate" alt="..." />
          <img src={pickupBuffIndicate} className="hidden playerImgs" ref="pickupBuffIndicate" id="pickupBuffIndicate" alt="..." />
          <img src={pickupDebuffIndicate} className="hidden playerImgs" ref="pickupDebuffIndicate" id="pickupDebuffIndicate" alt="..." />
          <img src={pickupWeaponIndicate} className="hidden playerImgs" ref="pickupWeaponIndicate" id="pickupWeaponIndicate" alt="..." />
          <img src={dropWeaponIndicate} className="hidden playerImgs" ref="dropWeaponIndicate" id="dropWeaponIndicate" alt="..." />
          <img src={dropArmorIndicate} className="hidden playerImgs" ref="dropArmorIndicate" id="dropArmorIndicate" alt="..." />
          <img src={pickupArmorIndicate} className="hidden playerImgs" ref="pickupArmorIndicate" id="pickupArmorIndicate" alt="..." />
          <img src={pickupAmmoIndicate} className="hidden playerImgs" ref="pickupAmmoIndicate" id="pickupAmmoIndicate" alt="..." />
          <img src={terrainSpeedupIndicate} className="hidden playerImgs" ref="terrainSpeedupIndicate" id="terrainSpeedupIndicate" alt="..." />
          <img src={terrainSlowdownIndicate} className="hidden playerImgs" ref="terrainSlowdownIndicate" id="terrainSlowdownIndicate" alt="..." />
          <img src={terrainInjuredIndicate} className="hidden playerImgs" ref="terrainInjuredIndicate" id="terrainInjuredIndicate" alt="..." />
          <img src={outOfStaminaIndicate} className="hidden playerImgs" ref="outOfStaminaIndicate" id="outOfStaminaIndicate" alt="..." />
          <img src={boltKilledIndicate} className="hidden playerImgs" ref="boltKilledIndicate" id="boltKilledIndicate" alt="..." />
          <img src={attackParriedIndicate} className="hidden playerImgs" ref="attackParriedIndicate" id="attackParriedIndicate" alt="..." />
          <img src={inventoryFullIndicate} className="hidden playerImgs" ref="inventoryFullIndicate" id="inventoryFullIndicate" alt="..." />
          <img src={outOfAmmoIndicate} className="hidden playerImgs" ref="outOfAmmoIndicate" id="outOfAmmoIndicate" alt="..." />


          <img src={missedIndicate2} className="hidden playerImgs" ref="missedIndicate2" id="missedIndicate2" alt="..." />
          <img src={prePushIndicate} className="hidden playerImgs" ref="prePushIndicate" id="prePushIndicate" alt="..." />
          <img src={canPushIndicate} className="hidden playerImgs" ref="canPushIndicate" id="canPushIndicate" alt="..." />
          <img src={noPushingIndicate} className="hidden playerImgs" ref="noPushingIndicate" id="noPushingIndicate" alt="..." />
          <img src={pushingIndicate} className="hidden playerImgs" ref="pushingIndicate" id="pushingIndicate" alt="..." />
          <img src={prePullIndicate} className="hidden playerImgs" ref="prePullIndicate" id="prePullIndicate" alt="..." />
          <img src={canPullIndicate} className="hidden playerImgs" ref="canPullIndicate" id="canPullIndicate" alt="..." />
          <img src={noPullingIndicate} className="hidden playerImgs" ref="noPullingIndicate" id="noPullingIndicate" alt="..." />
          <img src={pullingIndicate} className="hidden playerImgs" ref="pullingIndicate" id="pullingIndicate" alt="..." />
          <img src={pushedPulledIndicate} className="hidden playerImgs" ref="pushedPulledIndicate" id="pushedPulledIndicate" alt="..." />
          <img src={unbreakableIndicate} className="hidden playerImgs" ref="unbreakableIndicate" id="unbreakableIndicate" alt="..." />
          <img src={dodgeIndicate2} className="hidden playerImgs" ref="dodgeIndicate2" id="dodgeIndicate2" alt="..." />
          <img src={attackFeintIndicate} className="hidden playerImgs" ref="attackFeintIndicate" id="attackFeintIndicate" alt="..." />
          <img src={attackFeintIndicate2} className="hidden playerImgs" ref="attackFeintIndicate2" id="attackFeintIndicate2" alt="..." />
          <img src={attackFeintIndicate3} className="hidden playerImgs" ref="attackFeintIndicate3" id="attackFeintIndicate3" alt="..." />
          <img src={defendFeintIndicate} className="hidden playerImgs" ref="defendFeintIndicate" id="defendFeintIndicate" alt="..." />
          <img src={defendFeintIndicate2} className="hidden playerImgs" ref="defendFeintIndicate2" id="defendFeintIndicate2" alt="..." />

          <img src={defendFeintIndicate3} className="hidden playerImgs" ref="defendFeintIndicate3" id="defendFeintIndicate3" alt="..." />
          <img src={dodgeFeintIndicate} className="hidden playerImgs" ref="dodgeFeintIndicate" id="dodgeFeintIndicate" alt="..." />
          <img src={dodgeFeintIndicate2} className="hidden playerImgs" ref="dodgeFeintIndicate2" id="dodgeFeintIndicate2" alt="..." />
          <img src={boltDefendIndicate2} className="hidden playerImgs" ref="boltDefendIndicate2" id="boltDefendIndicate" alt="..." />
          <img src={flankIndicate2} className="hidden playerImgs" ref="flankIndicate2" id="flankIndicate2" alt="..." />
          <img src={noFlankIndicate} className="hidden playerImgs" ref="noFlankIndicate" id="noFlankIndicate" alt="..." />
          <img src={cellVoidingIndicate} className="hidden playerImgs" ref="cellVoidingIndicate" id="cellVoidingIndicate" alt="..." />
          <img src={cellVoidingIndicate2} className="hidden playerImgs" ref="cellVoidingIndicate2" id="cellVoidingIndicate2" alt="..." />


          <img src={sword} className='hidden playerImgs' ref="itemSword" id="itemSword" alt="logo" />
          <img src={spear} className='hidden playerImgs' ref="itemSpear" id="itemSpear" alt="logo" />
          <img src={bow} className='hidden playerImgs' ref="itemBow" id="itemBow" alt="logo" />
          <img src={crossbow} className='hidden playerImgs' ref="itemCrossbow" id="itemCrossbow" alt="logo" />
          <img src={boltNorth} className='hidden playerImgs' ref="itemBoltNorth" id="itemBoltNorth" alt="logo" />
          <img src={boltSouth} className='hidden playerImgs' ref="itemBoltSouth" id="itemBoltSouth" alt="logo" />
          <img src={boltEast} className='hidden playerImgs' ref="itemBoltEast" id="itemBoltEast" alt="logo" />
          <img src={boltWest} className='hidden playerImgs' ref="itemBoltWest" id="itemBoltWest" alt="logo" />
          <img src={ammo} className='hidden playerImgs' ref="itemAmmo" id="itemAmmo" alt="logo" />
          <img src={mail1} className='hidden playerImgs' ref="itemMail1" id="itemMail1" alt="logo" />
          <img src={mail2} className='hidden playerImgs' ref="itemMail2" id="itemMail2" alt="logo" />
          <img src={mail3} className='hidden playerImgs' ref="itemMail3" id="itemMail3" alt="logo" />
          <img src={greaves1} className='hidden playerImgs' ref="itemGreaves1" id="itemGreaves1" alt="logo" />
          <img src={greaves2} className='hidden playerImgs' ref="itemGreaves2" id="itemGreaves2" alt="logo" />
          <img src={greaves3} className='hidden playerImgs' ref="itemGreaves3" id="itemGreaves3" alt="logo" />
          <img src={helmet1} className='hidden playerImgs' ref="itemHelmet1" id="itemHelmet1" alt="logo" />
          <img src={hpUp} className='hidden playerImgs' ref="itemHpUp" id="itemHpUp" alt="logo" />
          <img src={hpDown} className='hidden playerImgs' ref="itemHpDown" id="itemHpDown" alt="logo" />
          <img src={spdUp} className='hidden playerImgs' ref="itemSpdUp" id="itemSpdUp" alt="logo" />
          <img src={spdDown} className='hidden playerImgs' ref="itemSpdDown" id="itemSpdDown" alt="logo" />
          <img src={strUp} className='hidden playerImgs' ref="itemStrUp" id="itemStrUp" alt="logo" />
          <img src={strDown} className='hidden playerImgs' ref="itemStrDown" id="itemStrDown" alt="logo" />
          <img src={focusUp} className='hidden playerImgs' ref="itemFocusUp" id="itemFocusUp" alt="logo" />
          <img src={focusDown} className='hidden playerImgs' ref="itemFocusDown" id="itemFocusDown" alt="logo" />


          <img src={playerImgIdleSheet} className='hidden playerImgs' ref="playerImgIdleSheet" id="playerImgIdleSheet" alt="logo" />
          <img src={player2ImgIdleSheet} className='hidden playerImgs' ref="player2ImgIdleSheet" id="player2ImgIdleSheet" alt="logo" />
          <img src={playerComAImgIdleSheet} className='hidden playerImgs' ref="playerComAImgIdleSheet" id="playerComAImgIdleSheet" alt="logo" />
          <img src={playerComBImgIdleSheet} className='hidden playerImgs' ref="playerComBImgIdleSheet" id="playerComBImgIdleSheet" alt="logo" />


          <img src={playerImgMoveSheet} className='hidden playerImgs' ref="playerImgMoveSheet" id="playerImgMoveSheet" alt="logo" />
          <img src={player2ImgMoveSheet} className='hidden playerImgs' ref="player2ImgMoveSheet" id="player2ImgMoveSheet" alt="logo" />
          <img src={comAImgMoveSheet} className='hidden playerImgs' ref="comAImgMoveSheet" id="comAImgMoveSheet" alt="logo" />
          <img src={comBImgMoveSheet} className='hidden playerImgs' ref="comBImgMoveSheet" id="comBImgMoveSheet" alt="logo" />


          <img src={player1DefendSheet} className='hidden playerImgs' ref="player1ImgDefendSheet" id="player1ImgDefendSheet" alt="logo" />
          <img src={player2DefendSheet} className='hidden playerImgs' ref="player2ImgDefendSheet" id="player2ImgDefendSheet" alt="logo" />
          <img src={comADefendSheet} className='hidden playerImgs' ref="comAImgDefendSheet" id="comAImgDefendSheet" alt="logo" />
          <img src={comBDefendSheet} className='hidden playerImgs' ref="comBImgDefendSheet" id="comBImgDefendSheet" alt="logo" />

          <img src={player1AttackSheet} className='hidden playerImgs' ref="player1ImgAttackSheet" id="player1ImgAttackSheet" alt="logo" />
          <img src={player2AttackSheet} className='hidden playerImgs' ref="player2ImgAttackSheet" id="player2ImgAttackSheet" alt="logo" />
          <img src={comAAttackSheet} className='hidden playerImgs' ref="comAImgAttackSheet" id="comAImgAttackSheet" alt="logo" />
          <img src={comBAttackSheet} className='hidden playerImgs' ref="comBImgAttackSheet" id="comBImgAttackSheet" alt="logo" />


        </div>
      </React.Fragment>
    )
  }
}

export default App;

import React, { Component, createRef } from "react";
import Easystar from "easystarjs";
import Pathfinding from "pathfinding";
// import { AStarFinder } from "astar-typescript";
import OverlayTrigger from "react-bootstrap/OverlayTrigger";
import Popover from "react-bootstrap/Popover";
import { FontAwesomeIcon } from "@fortawesome/react-fontawesome";
import {
  faCogs,
  faRobot,
  faVideo,
  faSearchPlus,
  faExpandAlt,
  faUndo,
  faQuestionCircle,
  faBorderAll,
  faChessBoard,
  faExclamationTriangle,
  faCheckSquare,
} from "@fortawesome/free-solid-svg-icons";

import logo from "./logo.svg";
import bgCompass from "./assets/bgCompass.png";

import floorDirt from "./assets/terrain/floorDirt.png";
import floorGrass from "./assets/terrain/floorGrass.png";
import floorIce from "./assets/terrain/floorIce.png";
import floorMud from "./assets/terrain/floorMud.png";
import floorPond from "./assets/terrain/floorPond.png";
import floorRiver from "./assets/terrain/floorRiver.png";
import floorSand from "./assets/terrain/floorSand.png";
import floorStone from "./assets/terrain/floorStone.png";
import floorBramble from "./assets/terrain/floorBramble.png";
import floorLava from "./assets/terrain/floorLava.png";
import floorAttack from "./assets/terrain/floorAttacked.png";
import floorAttack2 from "./assets/terrain/floorAttacked2.png";
import floorVoid from "./assets/terrain/floorVoid.png";
import floorVoid2 from "./assets/terrain/floorVoid2.png";
import floorVoid3 from "./assets/terrain/floorVoid3.png";
import floorHighlight from "./assets/terrain/floorHighlight.png";

import floorRubble from "./assets/obstacles/floorRubble.png";

import wall from "./assets/obstacles/wall.png";
import wall2 from "./assets/obstacles/wall2.png";
import wall3 from "./assets/obstacles/wall3.png";
import obstacleAHalf from "./assets/obstacles/obstacleA_half.png";
import obstacleAFull from "./assets/obstacles/obstacleA_full.png";
import obstacleBHalf from "./assets/obstacles/obstacleB_half.png";
import obstacleBFull from "./assets/obstacles/obstacleB_full.png";
import obstacleCHalf from "./assets/obstacles/obstacleC_half.png";
import obstacleCFull from "./assets/obstacles/obstacleC_full.png";
import obstacleDHalf from "./assets/obstacles/obstacleD_half.png";
import obstacleDFull from "./assets/obstacles/obstacleD_full.png";
import obstacleEHalf from "./assets/obstacles/obstacleE_half.png";
import obstacleEFull from "./assets/obstacles/obstacleE_full.png";
import obstacleCrate from "./assets/obstacles/obstacle_crate.png";
import obstacleBarrel from "./assets/obstacles/obstacle_barrel.png";
import barrierANorth from "./assets/obstacles/barrierA_north.png";
import barrierASouth from "./assets/obstacles/barrierA_south.png";
import barrierAEast from "./assets/obstacles/barrierA_east.png";
import barrierAWest from "./assets/obstacles/barrierA_west.png";

import attack1Indicate from "./assets/indicators/attack1.png";
import attack2Indicate from "./assets/indicators/attack2.png";
import attack3Indicate from "./assets/indicators/attacky.png";
import attackUnarmedIndicate from "./assets/items/unarmed.png";
import attackBluntIndicate from "./assets/indicators/blunt.png";
import attackSuccessIndicate from "./assets/indicators/attackSuccess.png";
import missedIndicate from "./assets/indicators/miss.png";
import missedIndicate2 from "./assets/indicators/miss2.png";
import defendIndicate from "./assets/indicators/defend.png";
import defendIndicate1 from "./assets/indicators/defend3.png";
import defendIndicate2 from "./assets/indicators/defend4.png";
import defendIndicate3 from "./assets/indicators/defend5.png";
import defendIndicate4 from "./assets/indicators/defend6.png";
import deflectIndicate from "./assets/indicators/deflect.png";
import deflectIndicate2 from "./assets/indicators/deflect2.png";
import deflectInjuredIndicate from "./assets/indicators/deflectInjured2.png";
import deflectInjuredIndicate2 from "./assets/indicators/deflectInjured.png";
import deflectBluntIndicate from "./assets/indicators/death2.png";
import pushbackIndicate from "./assets/indicators/pushback.png";
import ghostIndicate from "./assets/indicators/ghost.png";
import deathIndicate from "./assets/indicators/death.png";
import preAttackIndicate from "./assets/indicators/preAttack.png";
import healIndicate from "./assets/indicators/healIndicate.png";

import prePushIndicate from "./assets/indicators/prePush.png";
import canPushIndicate from "./assets/indicators/canPush.png";
import noPushingIndicate from "./assets/indicators/noPushing.png";
import pushingIndicate from "./assets/indicators/pushing.png";
import prePullIndicate from "./assets/indicators/prePull.png";
import canPullIndicate from "./assets/indicators/canPull.png";
import noPullingIndicate from "./assets/indicators/noPulling.png";
import pullingIndicate from "./assets/indicators/pulling.png";
import pushedPulledIndicate from "./assets/indicators/pushedPulled.png";
import unbreakableIndicate from "./assets/indicators/unbreakable.png";
import attackFeintIndicate from "./assets/indicators/attackFeint.png";
import attackFeintIndicate2 from "./assets/indicators/attackFeint2.png";
import defendFeintIndicate from "./assets/indicators/defendFeint.png";
import defendFeintIndicate2 from "./assets/indicators/defendFeint2.png";

import defendFeintIndicate3 from "./assets/indicators/defendFeint3.png";
import attackFeintIndicate3 from "./assets/indicators/attackFeint3.png";
import dodgeFeintIndicate from "./assets/indicators/dodgeFeint.png";
import dodgeFeintIndicate2 from "./assets/indicators/dodgeFeint2.png";

import cellVoidingIndicate from "./assets/indicators/cellVoiding.png";
import cellVoidingIndicate2 from "./assets/indicators/cellVoiding2.png";
import boltDefendIndicate2 from "./assets/indicators/boltDefend2.png";
import flankIndicate2 from "./assets/indicators/flanking2.png";
import noFlankIndicate from "./assets/indicators/noFlanking.png";

import preAttack2Indicate from "./assets/indicators/preAttack2.png";
import preAction1Indicate from "./assets/indicators/preAction1.png";
import preAction2Indicate from "./assets/indicators/preAction2.png";
import attackBreakIndicate from "./assets/indicators/attackBreak.png";
import defendBreakIndicate from "./assets/indicators/defendBreak.png";
import boltDefendIndicate from "./assets/indicators/boltDefend.png";
import dodgeIndicate from "./assets/indicators/dodge.png";
import dodgeIndicate2 from "./assets/indicators/dodge2.png";
import fallingIndicate from "./assets/indicators/falling.png";
import completeMissionIndicate from "./assets/indicators/complete.png";
import flankIndicate from "./assets/indicators/flank.png";
import attackBluntIndicate2 from "./assets/indicators/blunt2.png";
import enrouteIndicate from "./assets/indicators/enroute.png";
import targetSwitchIndicate from "./assets/indicators/targetSwitch.png";
import pathSwitchIndicate from "./assets/indicators/pathSwitch.svg";
import retreatIndicate from "./assets/indicators/retreat.png";
import defendSuccessIndicate from "./assets/indicators/defendSuccess.png";
import aggressiveModeIndicate from "./assets/indicators/angry.png";
import passiveModeIndicate from "./assets/indicators/meditation.png";
import thinkingIndicate from "./assets/indicators/mind.png";
import defendMissionIndicate from "./assets/indicators/police.png";
import patrolMissionIndicate from "./assets/indicators/location.png";
import pursueMissionIndicate from "./assets/indicators/treasure-map.png";
import pursueMissionIndicate2 from "./assets/indicators/missionPursue.png";
import retrieveMissionIndicate from "./assets/indicators/treasure.png";
import drowningIndicate from "./assets/indicators/drown.png";
import destroyedItemIndicate from "./assets/indicators/destroyedItem.png";
import pickupBuffIndicate from "./assets/indicators/pickupBuff.png";
import pickupDebuffIndicate from "./assets/indicators/pickupDebuff.png";
import pickupWeaponIndicate from "./assets/indicators/pickupWeapon.png";
import dropWeaponIndicate from "./assets/indicators/dropWeapon.png";
import dropArmorIndicate from "./assets/indicators/dropArmor.png";
import pickupArmorIndicate from "./assets/indicators/pickupArmor.png";
import pickupAmmoIndicate from "./assets/indicators/pickupAmmo.png";
import terrainSpeedupIndicate from "./assets/indicators/terrainSpeedup.png";
import terrainSlowdownIndicate from "./assets/indicators/terrainSlowdown.png";
import terrainInjuredIndicate from "./assets/indicators/terrainInjured.png";
import outOfStaminaIndicate from "./assets/indicators/outOfStamina.png";
import boltKilledIndicate from "./assets/indicators/boltKilled.png";
import attackParriedIndicate from "./assets/indicators/attackParried.png";
import inventoryFullIndicate from "./assets/indicators/inventoryFull.png";
import outOfAmmoIndicate from "./assets/indicators/outOfAmmo.png";
import timerIndicate from "./assets/indicators/timer.png";
import chargeIndicate from "./assets/indicators/charge.png";

import mail1 from "./assets/items/mail1.png";
import mail2 from "./assets/items/mail2.png";
import mail3 from "./assets/items/mail3.png";
import greaves1 from "./assets/items/greaves1.png";
import greaves2 from "./assets/items/greaves2.png";
import greaves3 from "./assets/items/greaves3.png";
import helmet1 from "./assets/items/helmet1.png";
import hpUp from "./assets/items/hpUp.png";
import hpDown from "./assets/items/hpDown.png";
import spdUp from "./assets/items/spdUp.png";
import spdDown from "./assets/items/spdDown.png";
import strUp from "./assets/items/strUp.png";
import strDown from "./assets/items/strDown.png";
import focusUp from "./assets/items/focusUp.png";
import focusDown from "./assets/items/focusDown.png";
import ammo from "./assets/items/ammo.png";
import bow from "./assets/items/bow.png";
import boltNorth from "./assets/items/boltNorth.png";
import boltSouth from "./assets/items/boltSouth.png";
import boltEast from "./assets/items/boltEast.png";
import boltWest from "./assets/items/boltWest.png";
import spear from "./assets/items/spear.png";
import sword from "./assets/items/sword.png";
import crossbow from "./assets/items/crossbow.png";

import playerImgIdleSheet from "./assets/player/sheet1.png";
import player2ImgIdleSheet from "./assets/player/sheet2.png";
import playerComAImgIdleSheet from "./assets/player/sheetComA.png";
import playerComBImgIdleSheet from "./assets/player/sheetComB.png";
import playerImgMoveSheet from "./assets/player/sheetMoving1.png";
import player2ImgMoveSheet from "./assets/player/sheetMoving2.png";
import comAImgMoveSheet from "./assets/player/sheetMovingComA.png";
import comBImgMoveSheet from "./assets/player/sheetMovingComB.png";
import player1DefendSheet from "./assets/player/sheetDefend1.png";
import player2DefendSheet from "./assets/player/sheetDefend2.png";
import comADefendSheet from "./assets/player/sheetDefendComA.png";
import comBDefendSheet from "./assets/player/sheetDefendComB.png";
import player1AttackSheet from "./assets/player/sheetAttack1.png";
import player2AttackSheet from "./assets/player/sheetAttack2.png";
import comAAttackSheet from "./assets/player/sheetAttackComA.png";
import comBAttackSheet from "./assets/player/sheetAttackComB.png";

import testSpriteNorth from "./assets/player/testSpriteNorth.png";
import testSpriteSouth from "./assets/player/testSpriteSouth.png";
import testSpriteEast from "./assets/player/testSpriteEast.png";
import testSpriteWest from "./assets/player/testSpriteWest.png";

import moveSheetNew from "./assets/player/movingSheetNew.png";
import idleSheetNew from "./assets/player/idleSheetNew.png";
import idleSheetNew2 from "./assets/player/idleSheetNew2.png";
import attackSheetNew from "./assets/player/attackSheetNew.png";
import defendSheetNew from "./assets/player/defendSheetNew.png";
import dodgeSheetNew from "./assets/player/dodgingSheetNew.png";
import deflectedFallingSheetNew from "./assets/player/deflectedFallingSheetNew.png";

import "./App.css";

import DebugBox from "./debugBox";
import Settings from "./settings";
import CellInfo from "./cellInfo";
import Loading from "./loading";
import AiStatus from "./aiStatus";
import CameraControl from "./cameraControl";
import Helper from "./helper";

import pointInPolygon from "point-in-polygon";

class App extends Component {
  state = {
    showSettings: true,
    showAiStatus: false,
    canvas: undefined,
    context: undefined,
    canvas2: undefined,
    context2: undefined,
    canvas3: undefined,
    context3: undefined,
    canvas4: undefined,
    context4: undefined,
    containerInnerClass: "containerInner",
    sceneY: {
      three: 400,
      six: 300,
      nine: 220,
      twelve: 150,
    },
    loading: true,
    stateUpdater: "",
    settingAiPlayers: 0,
  };

  constructor(props) {
    super(props);
    this.time = 0;

    this.canvasRef = React.createRef();
    this.canvasRef2 = React.createRef();

    // SETTINGS CANVASES
    this.canvasRef3 = React.createRef();
    this.canvasRef4 = React.createRef();

    this.cellInfoBoxRef = React.createRef();

    this.debugBoxStyle = "debugDisplay closedDebug";
    this.debugBoxStyle2 = "debugDisplay2 closedDebug";

    // LEVEL DRAW SETUP
    this.tileColumnOffset = 100; // pixels
    this.tileRowOffset = 50; // pixels
    this.originX = 0; // offset from left
    this.originY = 0; // offset from top
    this.Xtiles = 10;
    this.Ytiles = 10;
    this.showCoordinates = true;
    this.selectedTileX = -1;
    this.selectedTileY = -1;

    this.canvasWidth = 1300;
    this.canvasHeight = 790;

    // this.canvasWidth = 1000;
    // this.canvasHeight = 600;

    this.floorImageWidth = 103;
    this.floorImageHeight = 53;

    this.wallImageWidth = 103;
    this.wallImageHeight = 98;
    this.sceneY = 220;
    this.tileWidth = 50;
    this.gridWidth = 9;

    this.cellCenterOffsetX = 23;
    this.cellCenterOffsetY = 2;

    // '**_*_0.0_a_0**'
    // barrierType(a,b,c)BarrierPosition(n,s,e,w)_obstacle_x.y_terrain_elevationNumber(0,1,2)ElevationType(a,b,c)ElevationPosition(n,s,e,w)

    // GRIND INFO, LEVEL DATA & MAPPING
    this.init = false;
    // this.openVoid = true;
    this.openVoid = false;
    this.cellToVoid = {
      state: false,
      x: 0,
      y: 0,
      count: 0,
      limit: 35,
    };
    this.voidTimer = {
      count: 0,
      limit: 10000,
    };
    this.voidCustomCell = false;
    this.gridInfo = [];
    this.settingsGridInfo = [];
    this.gridInfo2D = [];
    this.gridInfo2 = [];
    this.gridInfo2D2 = [];
    this.levelData = [
      [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
      [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
      [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
      [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
      [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
      [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
      [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
      [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
      [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
      [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
      [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
    ];
    this.levelData12 = {
      row0: [
        "**_*_0.0_a_0a*",
        "**_*_0.1_a_0a*",
        "**_*_0.2_a_0a*",
        "**_*_0.3_a_0a*",
        "**_*_0.4_a_0a*",
        "**_*_0.5_a_0a*",
        "**_*_0.6_a_0a*",
        "**_*_0.7_a_0a*",
        "**_*_0.8_a_0a*",
        "**_*_0.9_a_0a*",
        "**_*_0.10_a_0a*",
        "**_*_0.11_a_0a*",
        "**_*_0.12_a_0a*",
      ],
      row1: [
        "**_*_1.0_a_0a*",
        "**_*_1.1_a_0a*",
        "**_*_1.2_a_0a*",
        "**_*_1.3_a_0a*",
        "**_*_1.4_a_0a*",
        "**_*_1.5_a_0a*",
        "**_*_1.6_a_0a*",
        "**_*_1.7_a_0a*",
        "**_*_1.8_a_0a*",
        "**_*_1.9_a_0a*",
        "**_*_1.10_a_0a*",
        "**_*_1.11_a_0a*",
        "**_*_1.12_a_0a*",
      ],
      row2: [
        "**_*_2.0_a_0a*",
        "**_*_2.1_a_0a*",
        "**_b_2.2_a_0a*",
        "**_*_2.3_a_0a*",
        "**_*_2.4_a_0a*",
        "**_*_2.5_a_0a*",
        "**_*_2.6_a_0a*",
        "**_*_2.7_a_0a*",
        "**_*_2.8_a_0a*",
        "**_*_2.9_a_0a*",
        "**_*_2.10_a_0a*",
        "**_*_2.11_a_0a*",
        "**_*_2.12_a_0a*",
      ],
      row3: [
        "**_c_3.0_a_0a*",
        "**_*_3.1_a_0a*",
        "**_c_3.2_a_0a*",
        "**_*_3.3_a_0a*",
        "**_*_3.4_a_0a*",
        "**_*_3.5_a_0a*",
        "**_h_3.6_a_0a*",
        "**_*_3.7_a_0a*",
        "**_*_3.8_a_0a*",
        "**_*_3.9_a_0a*",
        "**_*_3.10_a_0a*",
        "**_*_3.11_a_0a*",
        "**_*_3.12_a_0a*",
      ],
      row4: [
        "**_*_4.0_a_0a*",
        "**_*_4.1_a_0a*",
        "**_*_4.2_a_0a*",
        "**_*_4.3_a_0a*",
        "**_*_4.4_a_0a*",
        "**_*_4.5_a_0a*",
        "**_h_4.6_a_0a*",
        "**_*_4.7_a_0a*",
        "**_*_4.8_a_0a*",
        "**_*_4.9_a_0a*",
        "**_*_4.10_a_0a*",
        "**_*_4.11_a_0a*",
        "**_*_4.12_a_0a*",
      ],
      row5: [
        "**_*_5.0_a_0a*",
        "**_*_5.1_a_0a*",
        "**_*_5.2_a_0a*",
        "**_*_5.3_a_0a*",
        "**_*_5.4_a_0a*",
        "**_*_5.5_a_0a*",
        "**_*_5.6_a_0a*",
        "**_*_5.7_a_0a*",
        "**_*_5.8_a_0a*",
        "**_*_5.9_a_0a*",
        "**_*_5.10_a_0a*",
        "**_*_5.11_a_0a*",
        "**_*_5.12_a_0a*",
      ],
      row6: [
        "**_*_6.0_a_0a*",
        "**_*_6.1_a_0a*",
        "**_*_6.2_a_0a*",
        "**_*_6.3_a_0a*",
        "**_*_6.4_a_0a*",
        "**_*_6.5_a_0a*",
        "**_*_6.6_a_0a*",
        "**_*_6.7_a_0a*",
        "**_*_6.8_a_0a*",
        "**_*_6.9_a_0a*",
        "**_*_6.10_a_0a*",
        "**_*_6.11_a_0a*",
        "**_*_6.12_a_0a*",
      ],
      row7: [
        "**_*_7.0_a_0a*",
        "**_*_7.1_a_0a*",
        "**_*_7.2_a_0a*",
        "**_*_7.3_a_0a*",
        "**_*_7.4_a_0a*",
        "**_*_7.5_a_0a*",
        "**_*_7.6_a_0a*",
        "**_*_7.7_a_0a*",
        "**_*_7.8_a_0a*",
        "**_*_7.9_a_0a*",
        "**_*_7.10_a_0a*",
        "**_*_7.11_a_0a*",
        "**_*_7.12_a_0a*",
      ],
      row8: [
        "**_*_8.0_a_0a*",
        "**_*_8.1_a_0a*",
        "**_*_8.2_a_0a*",
        "**_*_8.3_a_0a*",
        "**_*_8.4_a_0a*",
        "**_*_8.5_a_0a*",
        "**_*_8.6_a_0a*",
        "**_*_8.7_a_0a*",
        "**_*_8.8_a_0a*",
        "**_*_8.9_a_0a*",
        "**_*_8.10_a_0a*",
        "**_*_8.11_a_0a*",
        "**_*_8.12_a_0a*",
      ],
      row9: [
        "**_*_9.0_a_0a*",
        "**_*_9.1_a_0a*",
        "**_*_9.2_a_0a*",
        "**_*_9.3_a_0a*",
        "**_*_9.4_a_0a*",
        "**_*_9.5_a_0a*",
        "**_*_9.6_a_0a*",
        "**_*_9.7_a_0a*",
        "**_*_9.8_a_0a*",
        "**_*_9.9_a_0a*",
        "**_*_9.10_a_0a*",
        "**_*_9.11_a_0a*",
        "**_*_9.12_a_0a*",
      ],
      row10: [
        "**_*_10.0_a_0a*",
        "**_*_10.1_a_0a*",
        "**_*_10.2_a_0a*",
        "**_*_10.3_a_0a*",
        "**_*_10.4_a_0a*",
        "**_*_10.5_a_0a*",
        "**_*_10.6_a_0a*",
        "**_*_10.7_a_0a*",
        "**_*_10.8_a_0a*",
        "**_*_10.9_a_0a*",
        "**_*_10.10_a_0a*",
        "**_*_10.11_a_0a*",
        "**_*_10.12_a_0a*",
      ],
      row11: [
        "**_*_11.0_a_0a*",
        "**_*_11.1_a_0a*",
        "**_*_11.2_a_0a*",
        "**_*_11.3_a_0a*",
        "**_*_11.4_a_0a*",
        "**_*_11.5_a_0a*",
        "**_*_11.6_a_0a*",
        "**_*_11.7_a_0a*",
        "**_*_11.8_a_0a*",
        "**_*_11.9_a_0a*",
        "**_*_11.10_a_0a*",
        "**_*_11.11_a_0a*",
        "**_*_11.12_a_0a*",
      ],
      row12: [
        "**_*_12.0_a_0a*",
        "**_*_12.1_a_0a*",
        "**_*_12.2_a_0a*",
        "**_*_12.3_a_0a*",
        "**_*_12.4_a_0a*",
        "**_*_12.5_a_0a*",
        "**_*_12.6_a_0a*",
        "**_*_12.7_a_0a*",
        "**_*_12.8_a_0a*",
        "**_*_12.9_a_0a*",
        "**_*_12.10_a_0a*",
        "**_*_12.11_a_0a*",
        "**_*_12.12_a_0a*",
      ],
    };
    this.levelData9 = {
      row0: [
        "**_*_0.0_a_0a*",
        "**_*_0.1_a_0a*",
        "**_*_0.2_a_0a*",
        "cw_*_0.3_a_0a*",
        "**_*_0.4_a_0a*",
        "**_*_0.5_a_0a*",
        "**_*_0.6_a_0a*",
        "**_*_0.7_a_0a*",
        "**_*_0.8_h_0a*",
        "**_*_0.9_h_0a*",
      ],
      row1: [
        "**_*_1.0_a_0a*",
        "cn_*_1.1_a_0a*",
        "**_c_1.2_a_0a*",
        "**_*_1.3_a_0a*",
        "**_*_1.4_a_0a*",
        "**_*_1.5_a_0a*",
        "**_*_1.6_a_0a*",
        "**_*_1.7_a_0a*",
        "**_h_1.8_a_0a*",
        "**_*_1.9_a_0a*",
      ],
      row2: [
        "**_*_2.0_a_0a*",
        "**_*_2.1_a_0a*",
        "**_*_2.2_a_0a*",
        "**_*_2.3_a_0a*",
        "**_*_2.4_a_0a*",
        "**_*_2.5_a_0a*",
        "**_*_2.6_a_0a*",
        "**_*_2.7_a_0a*",
        "**_*_2.8_a_0a*",
        "**_*_2.9_a_0a*",
      ],
      row3: [
        "**_*_3.0_a_0a*",
        "**_*_3.1_a_0a*",
        "**_h_3.2_a_0a*",
        "**_*_3.3_a_0a*",
        "**_*_3.4_a_0a*",
        "**_*_3.5_a_0a*",
        "**_c_3.6_a_0a*",
        "**_*_3.7_a_0a*",
        "**_*_3.8_a_0a*",
        "**_c_3.9_a_0a*",
      ],
      row4: [
        "**_*_4.0_a_0a*",
        "dn_*_4.1_a_0a*",
        "**_*_4.2_f_0a*",
        "**_*_4.3_f_0a*",
        "**_*_4.4_a_0a*",
        "**_*_4.5_a_0a*",
        "**_*_4.6_j_0a*",
        "**_*_4.7_a_0a*",
        "**_*_4.8_a_0a*",
        "**_*_4.9_a_0a*",
      ],
      row5: [
        "**_*_5.0_a_0a*",
        "**_*_5.1_a_0a*",
        "de_*_5.2_a_0a*",
        "**_*_5.3_a_0a*",
        "**_*_5.4_a_0a*",
        "**_h_5.5_a_0a*",
        "**_*_5.6_a_0a*",
        "**_*_5.7_a_0a*",
        "**_*_5.8_a_0a*",
        "**_*_5.9_a_0a*",
      ],
      row6: [
        "**_*_6.0_b_0a*",
        "**_*_6.1_j_0a*",
        "**_*_6.2_j_0a*",
        "**_*_6.3_j_0a*",
        "**_*_6.4_j_0a*",
        "**_*_6.5_j_0a*",
        "**_*_6.6_j_0a*",
        "**_*_6.7_j_0a*",
        "de_*_6.8_j_0a*",
        "**_*_6.9_j_0a*",
      ],
      row7: [
        "**_*_7.0_j_0a*",
        "**_*_7.1_j_0a*",
        "**_*_7.2_a_0a*",
        "cw_*_7.3_a_0a*",
        "**_*_7.4_a_0a*",
        "**_*_7.5_a_0a*",
        "**_*_7.6_a_0a*",
        "cw*_*_7.7_a_0a*",
        "**_*_7.8_a_0a*",
        "dw_*_7.9_d_0a*",
      ],
      row8: [
        "**_*_8.0_a_0a*",
        "**_*_8.1_a_0a*",
        "**_*_8.2_a_0a*",
        "**_*_8.3_a_0a*",
        "**_*_8.4_a_0a*",
        "**_*_8.5_a_0a*",
        "**_*_8.6_a_0a*",
        "**_*_8.7_a_0a*",
        "**_*_8.8_a_0a*",
        "**_*_8.9_d_0a*",
      ],
      row9: [
        "**_*_9.0_a_0a*",
        "**_*_9.1_a_0a*",
        "**_*_9.2_a_0a*",
        "**_*_9.3_a_0a*",
        "**_*_9.4_a_0a*",
        "**_*_9.5_a_0a*",
        "**_*_9.6_a_0a*",
        "**_*_9.7_a_0a*",
        "**_*_9.8_a_0a*",
        "**_*_9.9_a_0a*",
      ],
    };
    this.levelData6 = {
      row0: [
        "**_a_0.0_a_0a*",
        "**_*_0.1_a_0a*",
        "**_*_0.2_a_0a*",
        "**_*_0.3_a_0a*",
        "**_*_0.4_a_0a*",
        "**_*_0.5_a_0a*",
        "**_*_0.6_a_0a*",
      ],
      row1: [
        "**_*_1.0_a_0a*",
        "**_*_1.1_a_0a*",
        "**_*_1.2_a_0a*",
        "**_*_1.3_a_0a*",
        "**_*_1.4_a_0a*",
        "**_*_1.5_a_0a*",
        "**_*_1.6_a_0a*",
      ],
      row2: [
        "**_h_2.0_a_0a*",
        "**_*_2.1_j_0a*",
        "**_*_2.2_j_0a*",
        "**_*_2.3_j_0a*",
        "**_*_2.4_j_0a*",
        "**_*_2.5_j_0a*",
        "**_*_2.6_a_0a*",
      ],
      row3: [
        "**_h_3.0_a_0a*",
        "**_*_3.1_j_0a*",
        "**_*_3.2_b_0a*",
        "**_*_3.3_j_0a*",
        "**_*_3.4_b_0a*",
        "**_*_3.5_j_0a*",
        "**_*_3.6_a_0a*",
      ],
      row4: [
        "**_*_4.0_a_0a*",
        "**_*_4.1_j_0a*",
        "**_*_4.2_j_0a*",
        "**_*_4.3_j_0a*",
        "**_*_4.4_j_0a*",
        "**_*_4.5_j_0a*",
        "**_*_4.6_a_0a*",
      ],
      row5: [
        "**_*_5.0_a_0a*",
        "**_*_5.1_a_0a*",
        "**_*_5.2_a_0a*",
        "**_*_5.3_a_0a*",
        "**_*_5.4_a_0a*",
        "**_*_5.5_a_0a*",
        "**_*_5.6_a_0a*",
      ],
      row6: [
        "**_*_6.0_a_0a*",
        "**_*_6.1_a_0a*",
        "**_*_6.2_a_0a*",
        "**_*_6.3_a_0a*",
        "**_*_6.4_a_0a*",
        "**_*_6.5_a_0a*",
        "**_*_6.6_a_0a*",
      ],
    };
    this.levelData3 = {
      row0: ["**_a_0.0_a_0a*", "**_*_0.1_a_0a*", "**_*_0.2_a_0a*", "**_*_0.3_a_0a*"],
      row1: ["**_*_1.0_a_0a*", "**_*_1.1_a_0a*", "**_*_1.2_a_0a*", "**_*_1.3_a_0a*"],
      row2: ["**_*_2.0_a_0a*", "**_*_2.1_a_0a*", "**_b_2.2_a_0a*", "**_*_2.3_a_0a*"],
      row3: ["**_h_3.0_a_0a*", "**_*_3.1_a_0a*", "**_h_3.2_a_0a*", "**_*_3.3_a_0a*"],
    };
    this.terrainLevelDataRef = {
      a: {
        name: "grass",
        type: "grass",
        effect: "",
      },
      b: {
        name: "stone",
        type: "road",
        effect: "",
      },
      c: {
        name: "dirt",
        type: "road",
        effect: "",
      },
      d: {
        name: "pond",
        type: "shallow",
        effect: "",
      },
      e: {
        name: "mud",
        type: "sticky",
        effect: "",
      },
      f: {
        name: "sand",
        type: "sticky",
        effect: "",
      },
      g: {
        name: "ice",
        type: "slippery",
        effect: "",
      },
      h: {
        name: "lava",
        type: "hazard",
        effect: "",
      },
      i: {
        name: "bramble",
        type: "hazard",
        effect: "",
      },
      j: {
        name: "river",
        type: "deep",
        effect: "",
      },
      k: {
        name: "void",
        type: "void",
        effect: "void",
      },
    };
    this.terrainMoveSpeedRef = {
      shallow: 0.1,
      sticky: 0.05,
      slippery: 0.2,
    };

    // OBSTACLES HAVE MAX 5 ITEMS
    this.obstacleLevelDataRef = {
      a: {
        id: 0,
        trap: {
          state: false,
          persistent: false,
          remaining: 5,
          direction: "",
          target: {},
          timer: {
            enabled: false,
            state: false,
            count: 0,
            limit: 5,
          },
          trigger: {
            type: "player",
          },
          action: "attack",
          acting: {
            state: false,
            count: 0,
            peak: 0,
            limit: 0,
            direction: "",
            directionType: "",
          },
          itemNameRef: "crossbow1",
          item: {},
          ammo: 0,
        },
        state: true,
        name: "chest1",
        type: "chest",
        hp: 5,
        destructible: {
          state: true,
          weapons: ["sword1", "spear1"],
          leaveRubble: false,
        },
        locked: {
          state: false,
          key: "",
        },
        weight: 1,
        height: 0.5,
        items: [],
        effects: [],
        moving: {
          state: false,
          step: 0,
          origin: {
            number: {
              x: undefined,
              y: undefined,
            },
            center: {
              x: undefined,
              y: undefined,
            },
          },
          destination: {
            number: {
              x: undefined,
              y: undefined,
            },
            center: {
              x: undefined,
              y: undefined,
            },
          },
          currentPosition: {
            x: undefined,
            y: undefined,
          },
          nextPosition: {
            x: undefined,
            y: undefined,
          },
          moveSpeed: 0,
          pushable: true,
          pushed: false,
          pusher: undefined,
          falling: {
            state: false,
            count: 0,
            limit: 25,
          },
        },
      },
      b: {
        id: 0,
        trap: {
          state: false,
          persistent: false,
          remaining: 5,
          direction: "",
          target: {},
          timer: {
            enabled: false,
            state: false,
            count: 0,
            limit: 5,
          },
          trigger: {
            type: "player",
          },
          action: "attack",
          acting: {
            state: false,
            count: 0,
            peak: 0,
            limit: 0,
            direction: "",
            directionType: "",
          },
          itemNameRef: "sword1",
          item: {},
          ammo: 0,
        },
        state: true,
        name: "table1",
        type: "table",
        hp: 1,
        destructible: {
          state: true,
          weapons: ["sword1", "bolt", "spear1"],
          leaveRubble: false,
        },
        locked: {
          state: false,
          key: "",
        },
        weight: 1,
        height: 0.5,
        items: [
          {
            name: "sword1",
            type: "weapon",
            subType: "sword",
            effect: "",
          },
        ],
        effects: [],
        moving: {
          state: false,
          step: 0,
          origin: {
            number: {
              x: undefined,
              y: undefined,
            },
            center: {
              x: undefined,
              y: undefined,
            },
          },
          destination: {
            number: {
              x: undefined,
              y: undefined,
            },
            center: {
              x: undefined,
              y: undefined,
            },
          },
          currentPosition: {
            x: undefined,
            y: undefined,
          },
          nextPosition: {
            x: undefined,
            y: undefined,
          },
          moveSpeed: 0,
          pushable: true,
          pushed: false,
          pusher: undefined,
          falling: {
            state: false,
            count: 0,
            limit: 25,
          },
        },
      },
      c: {
        id: 0,
        trap: {
          state: false,
          persistent: false,
          remaining: 5,
          direction: "",
          target: {},
          timer: {
            enabled: false,
            state: false,
            count: 0,
            limit: 5,
          },
          trigger: {
            type: "player",
          },
          action: "attack",
          acting: {
            state: false,
            count: 0,
            peak: 0,
            limit: 0,
            direction: "",
            directionType: "",
          },
          itemNameRef: "crossbow1",
          item: {},
          ammo: 0,
        },
        state: true,
        name: "closet1",
        type: "barrel",
        hp: 2,
        destructible: {
          state: false,
          weapons: ["sword1", "bolt", "spear1"],
          leaveRubble: true,
        },
        locked: {
          state: false,
          key: "",
        },
        weight: 0.5,
        height: 1,
        items: [
          {
            name: "hpUp",
            type: "item",
            subType: "",
            effect: "hpUp",
          },
          {
            name: "sword1",
            type: "weapon",
            subType: "sword",
            effect: "",
          },
        ],
        effects: [],
        moving: {
          state: false,
          step: 0,
          origin: {
            number: {
              x: undefined,
              y: undefined,
            },
            center: {
              x: undefined,
              y: undefined,
            },
          },
          destination: {
            number: {
              x: undefined,
              y: undefined,
            },
            center: {
              x: undefined,
              y: undefined,
            },
          },
          currentPosition: {
            x: undefined,
            y: undefined,
          },
          nextPosition: {
            x: undefined,
            y: undefined,
          },
          moveSpeed: 0,
          pushable: true,
          pushed: false,
          pusher: undefined,
          falling: {
            state: false,
            count: 0,
            limit: 25,
          },
        },
      },
      d: {
        id: 0,
        trap: {
          state: false,
          persistent: false,
          remaining: 0,
          direction: "",
          target: {},
          timer: {
            enabled: false,
            state: false,
            count: 0,
            limit: 5,
          },
          trigger: {
            type: "player",
          },
          action: "attack",
          acting: {
            state: false,
            count: 0,
            peak: 0,
            limit: 0,
            direction: "",
            directionType: "",
          },
          itemNameRef: "crossbow1",
          item: {},
          ammo: 0,
        },
        state: true,
        name: "chair1",
        type: "chair",
        hp: 2,
        destructible: {
          state: true,
          weapons: ["sword1"],
          leaveRubble: false,
        },
        locked: {
          state: false,
          key: "",
        },
        weight: 1,
        height: 0.5,
        items: [],
        effects: [],
        moving: {
          state: false,
          step: 0,
          origin: {
            number: {
              x: undefined,
              y: undefined,
            },
            center: {
              x: undefined,
              y: undefined,
            },
          },
          destination: {
            number: {
              x: undefined,
              y: undefined,
            },
            center: {
              x: undefined,
              y: undefined,
            },
          },
          currentPosition: {
            x: undefined,
            y: undefined,
          },
          nextPosition: {
            x: undefined,
            y: undefined,
          },
          moveSpeed: 0,
          pushable: true,
          pushed: false,
          pusher: undefined,
          falling: {
            state: false,
            count: 0,
            limit: 25,
          },
        },
      },
      e: {
        id: 0,
        trap: {
          state: false,
          persistent: false,
          remaining: 0,
          direction: "",
          target: {},
          timer: {
            enabled: false,
            state: false,
            count: 0,
            limit: 5,
          },
          trigger: {
            type: "player",
          },
          action: "attack",
          acting: {
            state: false,
            count: 0,
            peak: 0,
            limit: 0,
            direction: "",
            directionType: "",
          },
          itemNameRef: "crossbow1",
          item: {},
          ammo: 0,
        },
        state: true,
        name: "shelf1",
        type: "shelf",
        hp: 2,
        destructible: {
          state: true,
          weapons: ["sword1"],
          leaveRubble: false,
        },
        locked: {
          state: false,
          key: "",
        },
        weight: 1,
        height: 1,
        items: [],
        effects: [],
        moving: {
          state: false,
          step: 0,
          origin: {
            number: {
              x: undefined,
              y: undefined,
            },
            center: {
              x: undefined,
              y: undefined,
            },
          },
          destination: {
            number: {
              x: undefined,
              y: undefined,
            },
            center: {
              x: undefined,
              y: undefined,
            },
          },
          currentPosition: {
            x: undefined,
            y: undefined,
          },
          nextPosition: {
            x: undefined,
            y: undefined,
          },
          moveSpeed: 0,
          pushable: true,
          pushed: false,
          pusher: undefined,
          falling: {
            state: false,
            count: 0,
            limit: 25,
          },
        },
      },
      f: {
        id: 0,
        trap: {
          state: false,
          persistent: false,
          remaining: 0,
          direction: "",
          target: {},
          timer: {
            enabled: false,
            state: false,
            count: 0,
            limit: 5,
          },
          trigger: {
            type: "player",
          },
          action: "attack",
          acting: {
            state: false,
            count: 0,
            peak: 0,
            limit: 0,
            direction: "",
            directionType: "",
          },
          itemNameRef: "crossbow1",
          item: {},
          ammo: 0,
        },
        state: true,
        name: "counter1",
        type: "counter",
        hp: 2,
        destructible: {
          state: true,
          weapons: ["sword1"],
          leaveRubble: false,
        },
        locked: {
          state: false,
          key: "",
        },
        weight: 1,
        height: 0.5,
        items: [],
        effects: [],
        moving: {
          state: false,
          step: 0,
          origin: {
            number: {
              x: undefined,
              y: undefined,
            },
            center: {
              x: undefined,
              y: undefined,
            },
          },
          destination: {
            number: {
              x: undefined,
              y: undefined,
            },
            center: {
              x: undefined,
              y: undefined,
            },
          },
          currentPosition: {
            x: undefined,
            y: undefined,
          },
          nextPosition: {
            x: undefined,
            y: undefined,
          },
          moveSpeed: 0,
          pushable: true,
          pushed: false,
          pusher: undefined,
          falling: {
            state: false,
            count: 0,
            limit: 25,
          },
        },
      },
      g: {
        id: 0,
        trap: {
          state: false,
          persistent: false,
          remaining: 0,
          direction: "",
          target: {},
          timer: {
            enabled: false,
            state: false,
            count: 0,
            limit: 5,
          },
          trigger: {
            type: "player",
          },
          action: "attack",
          acting: {
            state: false,
            count: 0,
            peak: 0,
            limit: 0,
            direction: "",
            directionType: "",
          },
          itemNameRef: "crossbow1",
          item: {},
          ammo: 0,
        },
        state: true,
        name: "smallBox1",
        type: "smallBox",
        hp: 2,
        destructible: {
          state: true,
          weapons: ["sword1"],
          leaveRubble: false,
        },
        locked: {
          state: false,
          key: "",
        },
        weight: 1,
        height: 0.5,
        items: [],
        effects: [],
        moving: {
          state: false,
          step: 0,
          origin: {
            number: {
              x: undefined,
              y: undefined,
            },
            center: {
              x: undefined,
              y: undefined,
            },
          },
          destination: {
            number: {
              x: undefined,
              y: undefined,
            },
            center: {
              x: undefined,
              y: undefined,
            },
          },
          currentPosition: {
            x: undefined,
            y: undefined,
          },
          nextPosition: {
            x: undefined,
            y: undefined,
          },
          moveSpeed: 0,
          pushable: true,
          pushed: false,
          pusher: undefined,
          falling: {
            state: false,
            count: 0,
            limit: 25,
          },
        },
      },
      h: {
        id: 0,
        trap: {
          state: false,
          persistent: false,
          remaining: 5,
          direction: "",
          target: {},
          timer: {
            enabled: false,
            state: false,
            count: 0,
            limit: 65,
          },
          trigger: {
            type: "any",
          },
          action: "attack",
          acting: {
            state: false,
            count: 0,
            peak: 0,
            limit: 0,
            direction: "",
            directionType: "",
          },
          itemNameRef: "sword1",
          item: {},
          ammo: 0,
        },
        state: true,
        name: "largeBox1",
        type: "largeBox",
        hp: 2,
        destructible: {
          state: false,
          weapons: ["sword1"],
          leaveRubble: false,
        },
        locked: {
          state: false,
          key: "",
        },
        weight: 1,
        height: 1,
        items: [],
        effects: [],
        moving: {
          state: false,
          step: 0,
          origin: {
            number: {
              x: undefined,
              y: undefined,
            },
            center: {
              x: undefined,
              y: undefined,
            },
          },
          destination: {
            number: {
              x: undefined,
              y: undefined,
            },
            center: {
              x: undefined,
              y: undefined,
            },
          },
          currentPosition: {
            x: undefined,
            y: undefined,
          },
          nextPosition: {
            x: undefined,
            y: undefined,
          },
          moveSpeed: 0,
          pushable: true,
          pushed: false,
          pusher: undefined,
          falling: {
            state: false,
            count: 0,
            limit: 25,
          },
        },
      },
      i: {
        id: 0,
        trap: {
          state: false,
          persistent: false,
          remaining: 0,
          direction: "",
          target: {},
          timer: {
            enabled: false,
            state: false,
            count: 0,
            limit: 5,
          },
          trigger: {
            type: "player",
          },
          action: "attack",
          acting: {
            state: false,
            count: 0,
            peak: 0,
            limit: 0,
            direction: "",
            directionType: "",
          },
          itemNameRef: "crossbow1",
          item: {},
          ammo: 0,
        },
        state: true,
        name: "closet2",
        type: "barrel",
        hp: 2,
        destructible: {
          state: true,
          weapons: ["sword1", "bolt", "spear1"],
          leaveRubble: true,
        },
        locked: {
          state: false,
          key: "",
        },
        weight: 1,
        height: 1,
        items: [
          {
            name: "hpUp",
            type: "item",
            subType: "",
            effect: "hpUp",
          },
          {
            name: "sword1",
            type: "weapon",
            subType: "sword",
            effect: "",
          },
          {
            name: "spear1",
            type: "weapon",
            subType: "spear",
            effect: "",
          },
          {
            name: "crossbow1",
            type: "weapon",
            subType: "crossbow",
            effect: "ammo+5",
          },
          {
            name: "ironPlate",
            type: "armor",
            subType: "mail",
            effect: "hpUp",
          },
          {
            name: "ammo10",
            type: "item",
            subType: "",
            effect: "",
          },
        ],
        effects: [],
        moving: {
          state: false,
          step: 0,
          origin: {
            number: {
              x: undefined,
              y: undefined,
            },
            center: {
              x: undefined,
              y: undefined,
            },
          },
          destination: {
            number: {
              x: undefined,
              y: undefined,
            },
            center: {
              x: undefined,
              y: undefined,
            },
          },
          currentPosition: {
            x: undefined,
            y: undefined,
          },
          nextPosition: {
            x: undefined,
            y: undefined,
          },
          moveSpeed: 0,
          pushable: true,
          pushed: false,
          pusher: undefined,
          falling: {
            state: false,
            count: 0,
            limit: 25,
          },
        },
      },
    };
    this.barrierLevelDataRef = {
      a: {
        id: 0,
        trap: {
          state: false,
          persistent: false,
          remaining: 0,
          direction: "",
          target: {},
          timer: {
            enabled: false,
            state: false,
            count: 0,
            limit: 5,
          },
          trigger: {
            type: "player",
          },
          action: "attack",
          acting: {
            state: false,
            count: 0,
            peak: 0,
            limit: 0,
            direction: "",
            directionType: "",
          },
          itemNameRef: "crossbow1",
          item: {},
          ammo: 0,
        },
        state: true,
        name: "wall1",
        type: "wall",
        hp: 2,
        destructible: {
          state: false,
          weapons: [],
          leaveRubble: false,
        },
        locked: {
          state: false,
          key: "",
        },
        position: "",
        height: 1,
      },
      b: {
        id: 0,
        trap: {
          state: false,
          persistent: false,
          remaining: 0,
          direction: "",
          target: {},
          timer: {
            enabled: false,
            state: false,
            count: 0,
            limit: 5,
          },
          trigger: {
            type: "player",
          },
          action: "attack",
          acting: {
            state: false,
            count: 0,
            peak: 0,
            limit: 0,
            direction: "",
            directionType: "",
          },
          itemNameRef: "crossbow1",
          item: {},
          ammo: 0,
        },
        state: true,
        name: "door1",
        type: "door",
        hp: 3,
        destructible: {
          state: true,
          weapons: ["sword1"],
          leaveRubble: false,
        },
        locked: {
          state: false,
          key: "",
        },
        position: "",
        height: 1,
      },
      c: {
        id: 0,
        trap: {
          state: false,
          persistent: true,
          remaining: 5,
          direction: "",
          target: {},
          timer: {
            enabled: true,
            state: false,
            count: 0,
            limit: 65,
          },
          trigger: {
            type: "any",
          },
          action: "attack",
          acting: {
            state: false,
            count: 0,
            peak: 0,
            limit: 0,
            direction: "",
            directionType: "",
          },
          itemNameRef: "sword1",
          item: {},
          ammo: 0,
        },
        state: true,
        name: "balcony1",
        type: "balcony",
        hp: 2,
        destructible: {
          state: true,
          weapons: ["sword1", "spear1", "bolt"],
          leaveRubble: true,
        },
        locked: {
          state: false,
          key: "",
        },
        position: "",
        height: 1,
      },
      d: {
        id: 0,
        trap: {
          state: false,
          persistent: true,
          remaining: 5,
          direction: "",
          target: {},
          timer: {
            enabled: true,
            state: false,
            count: 0,
            limit: 65,
          },
          trigger: {
            type: "any",
          },
          action: "attack",
          acting: {
            state: false,
            count: 0,
            peak: 0,
            limit: 0,
            direction: "",
            directionType: "",
          },
          itemNameRef: "sword1",
          item: {},
          ammo: 0,
        },
        state: true,
        name: "balconyX",
        type: "balcony",
        hp: 2,
        destructible: {
          state: true,
          weapons: ["sword1", "spear1", "bolt"],
          leaveRubble: true,
        },
        locked: {
          state: false,
          key: "",
        },
        position: "",
        height: 1,
      },
    };
    this.customTrapSetNewCustomTestData = [
      {
        persistent: false,
        remaining: 5,
        timerEnabled: true,
        timerLimit: 70,
        triggerType: "any",
        itemNameRef: "spear2",
        type: "obstacle",
        location: {
          x: 2,
          y: 3,
        },
      },
      {
        persistent: false,
        remaining: 15,
        timerEnabled: false,
        timerLimit: 0,
        triggerType: "any",
        itemNameRef: "crossbow1",
        type: "obstacle",
        location: {
          x: 3,
          y: 6,
        },
      },
    ];
    this.elevationTypeLevelDataRef = {
      a: "floor",
      b: "step",
      c: "ramp",
    };
    this.pathArray = [];

    // ITEMS
    this.itemList = [
      {
        name: "moveSpeedUp",
        amount: 5,
        total: 5,
        type: "item",
        effect: "speedUp",
      },
      {
        name: "moveSpeedDown",
        amount: 5,
        total: 5,
        type: "item",
        effect: "speedDown",
      },
      {
        name: "hpUp",
        amount: 4,
        total: 4,
        type: "item",
        effect: "hpUp",
      },
      {
        name: "hpDown",
        amount: 4,
        total: 4,
        type: "item",
        effect: "hpDown",
      },
      {
        name: "focusUp",
        amount: 4,
        total: 4,
        type: "item",
        effect: "focusUp",
      },
      {
        name: "focusDown",
        amount: 4,
        total: 4,
        type: "item",
        effect: "focusDown",
      },
      {
        name: "strengthUp",
        amount: 4,
        total: 4,
        type: "item",
        effect: "strengthUp",
      },
      {
        name: "strengthDown",
        amount: 4,
        total: 4,
        type: "item",
        effect: "strengthDown",
      },
      {
        name: "spear1",
        amount: 3,
        total: 3,
        type: "weapon",
        subType: "spear",
        effect: "",
      },
      {
        name: "spear2",
        amount: 3,
        total: 3,
        type: "weapon",
        subType: "spear",
        effect: "",
      },
      {
        name: "sword1",
        amount: 2,
        total: 2,
        type: "weapon",
        subType: "sword",
        effect: "",
      },
      {
        name: "sword2",
        amount: 2,
        total: 2,
        type: "weapon",
        subType: "sword",
        effect: "",
      },
      {
        name: "crossbow1",
        amount: 2,
        total: 2,
        type: "weapon",
        subType: "crossbow",
        effect: "ammo+5",
      },
      {
        name: "crossbow2",
        amount: 2,
        total: 2,
        type: "weapon",
        subType: "crossbow",
        effect: "ammo+7",
      },
      {
        name: "helmet1",
        amount: 3,
        total: 3,
        type: "armor",
        subType: "helmet",
        effect: "+10",
      },
      {
        name: "ironPlate",
        amount: 2,
        total: 2,
        type: "armor",
        subType: "mail",
        effect: "hpUp",
      },
      {
        name: "ninjaGi",
        amount: 2,
        total: 2,
        type: "armor",
        subType: "mail",
        effect: "snghit-5",
      },
      {
        name: "ghostMail",
        amount: 1,
        total: 1,
        type: "armor",
        subType: "mail",
        effect: "snghit-10",
      },
      {
        name: "speedGreaves",
        amount: 2,
        total: 2,
        type: "armor",
        subType: "greaves",
        effect: "speedUp",
      },
      {
        name: "ammo5",
        amount: 4,
        total: 4,
        type: "item",
        effect: "",
      },
      {
        name: "ammo10",
        amount: 2,
        total: 2,
        type: "item",
        effect: "",
      },
    ];
    this.disableInitItems = true;
    this.initItemList = [
      // {
      //   name: 'moveSpeedUp',
      //   type: 'item',
      //   effect: 'speedUp',
      // },
      // {
      //   name: 'moveSpeedDown',
      //   type: 'item',
      //   effect: 'speedDown',
      // },

      {
        name: "ammo5",
        type: "item",
        effect: "",
      },
      // {
      //   name: 'ammo10',
      //   type: 'item',
      //   effect: '',
      // },
      {
        name: "hpUp",
        type: "item",
        effect: "hpUp",
      },
      // {
      //   name: 'hpDown',
      //   type: 'item',
      //   effect: 'hpDown',
      // },
      {
        name: "spear1",
        type: "weapon",
        subType: "spear",
        effect: "",
      },
      // {
      //   name: 'sword2',
      //   type: 'weapon',
      //   subType: 'sword',
      //   effect: '',
      // },
      {
        name: "crossbow1",
        type: "weapon",
        subType: "crossbow",
        effect: "ammo+10",
      },
      // {
      //   name: 'ghostMail',
      //   type: 'armor',
      //   subType: 'mail',
      //   effect: 'snghit-5',
      // },
      {
        name: "speedGreaves",
        type: "armor",
        subType: "greaves",
        effect: "speedUp",
      },
      {
        name: "ironPlate",
        type: "armor",
        subType: "mail",
        effect: "hpUp",
      },
      // {
      //   name: 'helmet1',
      //   type: 'armor',
      //   subType: 'helmet',
      //   effect: '+10',
      // },
      // {
      //   name: 'helmet2',
      //   type: 'armor',
      //   subType: 'helmet',
      //   effect: '',
      // },
      {
        name: "strengthUp",
        type: "item",
        effect: "strengthUp",
      },
      {
        name: "strengthUp",
        type: "item",
        effect: "strengthUp",
      },
      // {
      //   name: 'hpUp',
      //   type: 'item',
      //   effect: 'hpUp',
      // },
      {
        name: "strengthUp",
        type: "item",
        effect: "strengthUp",
      },
      {
        name: "strengthUp",
        type: "item",
        effect: "strengthUp",
      },
    ];
    this.customItemPlacement = {
      state: true,
      cells: [
        { x: 0, y: 9 },
        { x: 0, y: 8 },
        { x: 0, y: 7 },
        { x: 0, y: 6 },
        { x: 1, y: 9 },
        { x: 1, y: 8 },
        { x: 1, y: 7 },
        { x: 1, y: 6 },
        { x: 2, y: 9 },
        { x: 2, y: 8 },
        { x: 2, y: 7 },
        { x: 2, y: 6 },
        { x: 5, y: 6 },
        { x: 6, y: 6 },
        { x: 6, y: 6 },
      ],
    };

    // PLAYER
    this.playerNumber = 2;
    this.currentPlayer = 1;
    this.players = [
      {
        number: 1,
        startPosition: {
          cell: {
            number: {
              x: 0,
              y: 6,
            },
            center: {
              x: 0,
              y: 0,
            },
          },
        },
        currentPosition: {
          cell: {
            number: {
              x: 0,
              y: 0,
            },
            center: {
              x: 0,
              y: 0,
            },
          },
        },
        nextPosition: {
          x: 0,
          y: 0,
        },
        target: {
          cell1: {
            number: {
              x: 0,
              y: 0,
            },
            center: {
              x: 0,
              y: 0,
            },
            free: true,
            occupant: {
              type: "",
              player: "",
            },
            void: false,
          },
          cell2: {
            number: {
              x: 0,
              y: 0,
            },
            center: {
              x: 0,
              y: 0,
            },
            free: true,
            occupant: {
              type: "",
              player: "",
            },
            void: false,
          },
          myCellBlock: false,
        },
        direction: "east",
        turning: {
          state: false,
          toDirection: "",
          delayCount: 0,
          limit: 5.1,
        },
        turnCheckerDirection: "",
        action: "idle",
        moving: {
          state: false,
          step: 0,
          course: "",
          origin: {
            number: {
              x: 0,
              y: 0,
            },
            center: {
              x: 0,
              y: 0,
            },
          },
          destination: {
            x: 0,
            y: 0,
          },
        },
        newMoveDelay: {
          state: false,
          count: 0,
          limit: 15,
        },
        strafing: {
          state: false,
          direction: "",
        },
        strafeReleaseHook: false,
        moveCancel: {
          state: false,
          oldDirection: "",
          newDirection: "",
          returningTo: {},
          returningFrom: {},
        },
        flanking: {
          checking: false,
          preFlankDirection: "",
          direction: "",
          state: false,
          step: 0,
          target1: { x: 0, y: 0 },
          target2: { x: 0, y: 0 },
        },
        drowning: false,
        attacking: {
          state: false,
          count: 0,
          limit: 20,
          strength: 0,
          direction: "",
          directionType: "", //thrust or slash
          animRef: {},
          peak: false,
          charge: 0,
          chargePeak: false,
          peakCount: 0,
          blunt: false,
          clashing: {
            state: false,
            count: 0,
            limit: 10,
          },
        },
        defending: {
          state: false,
          count: 0,
          limit: 4,
          animRef: {},
          peak: false,
          peakCount: 0,
          decay: {
            state: false,
            count: 0,
            limit: 25,
          },
          direction: "",
          directionType: "", //thrust or slash
        },
        dodging: {
          countState: false,
          state: false,
          count: 0,
          limit: 20,
          peak: {
            start: 8,
            end: 12,
          },
          direction: "",
        },
        jumping: {
          checking: false,
          state: false,
        },
        success: {
          attackSuccess: {
            state: false,
            count: 0,
            limit: 10,
          },
          defendSuccess: {
            state: false,
            count: 0,
            limit: 10,
          },
          deflected: {
            state: false,
            count: 0,
            limit: 20,
            predeflect: false,
            type: "",
          },
        },
        pushBack: {
          state: false,
          prePushBackMoveSpeed: 0,
        },
        halfPushBack: {
          state: false,
          direction: "",
          type: "",
          countUp: {
            state: true,
            count: 0,
            limit: 0,
          },
          countDown: {
            state: false,
            count: 0,
            limit: 0,
          },
          coords: {
            x: undefined,
            y: undefined,
          },
        },
        falling: {
          state: false,
          count: 0,
          limit: 10,
        },
        dead: {
          state: false,
          count: 0,
          limit: 10,
        },
        ghost: {
          state: false,
          position: {
            cell: {
              number: {
                x: 0,
                y: 0,
              },
              center: {
                x: 0,
                y: 0,
              },
            },
          },
        },
        respawn: false,
        points: 0,
        speed: {
          move: 0.1,
          range: [0.05, 0.1, 0.125, 0.2],
        },
        terrainMoveSpeed: {
          state: false,
          speed: 0,
        },
        hp: 2,
        currentWeapon: {
          name: "sword1",
          type: "sword",
          effect: "",
        },
        currentArmor: {
          name: "",
          type: "",
          effect: "",
        },
        items: {
          weaponIndex: 0,
          armorIndex: 0,
          weapons: [
            {
              name: "sword1",
              type: "sword",
              effect: "",
            },
          ],
          armor: [],
          ammo: 20,
        },
        inventorySize: 4,
        cycleWeapon: {
          state: false,
          count: 0,
          limit: 3,
        },
        cycleArmor: {
          state: false,
          count: 0,
          limit: 3,
        },
        crits: {
          singleHit: 1,
          doubleHit: 6,
          pushBack: 4,
          guardBreak: 3,
          dodge: 0,
        },
        statusDisplay: {
          state: false,
          status: "",
          count: 0,
          limit: 15,
        },
        popups: [
          {
            state: true,
            count: 0,
            limit: 0,
            type: "",
            position: "northWest",
            msg: "",
            img: "",
          },
        ],
        itemDrop: {
          state: false,
          count: 0,
          limit: 10,
          item: {
            name: "",
          },
          gear: {
            type: "",
          },
        },
        itemPickup: {
          state: false,
          count: 0,
          limit: 10,
          item: {
            name: "",
          },
          gear: {
            type: "",
          },
        },
        discardGear: {
          state: false,
          count: 0,
          limit: 8,
        },
        idleAnim: {
          state: false,
          count: 0,
          limit: 6,
        },
        ai: {
          state: false,
          imgType: "",
          primaryMission: "",
          mission: "",
          prevMission: "",
          currentObjective: "",
          targetSet: false,
          targetAcquired: false,
          safeRange: true,
          pathArray: [],
          targetPlayer: {
            number: 1,
            currentPosition: {
              x: undefined,
              y: undefined,
            },
            target: {
              number1: {
                x: undefined,
                y: undefined,
              },
              number2: {
                x: undefined,
                y: undefined,
              },
            },
            action: "",
          },
          instructions: [],
          currentInstruction: 0,
          resetInstructions: false,
          patrolling: {
            checkin: undefined,
            state: false,
            area: [],
            loopControl: false,
          },
          defending: {
            checkin: undefined,
            state: false,
            area: [],
          },
          persuing: {
            state: false,
          },
          engaging: {
            state: true,
            targetAction: "",
          },
          retrieving: {
            checkin: undefined,
            state: false,
            point: { x: undefined, y: undefined },
            targetItem: {
              name: "",
              type: "",
              subType: "",
              effect: "",
            },
            safe: true,
          },
          retreating: {
            checkin: undefined,
            state: false,
            point: { x: undefined, y: undefined },
            level: 0,
            safe: true,
          },
          organizing: {
            weaponPriorityIndex: 0,
            armorPriorityIndex: 0,
            dropped: {
              state: false,
              gear: {
                name: "",
                type: "",
                subType: "",
                effect: "",
              },
            },
          },
          mode: "",
          upgradeWeapon: false,
          upgradeArmor: false,
          pathfindingRanges: {
            spear: 3,
            crossbow: 5,
          },
        },
        stamina: {
          current: 20,
          max: 20,
        },
        newPushPullDelay: {
          state: false,
          count: 0,
          limit: 10,
        },
        prePush: {
          state: false,
          count: 0,
          limit: 15,
          targetCell: undefined,
          direction: "",
          pusher: undefined,
        },
        pushing: {
          state: false,
          targetCell: undefined,
          moveSpeed: 0,
        },
        prePull: {
          state: false,
          count: 0,
          limit: 15,
          targetCell: undefined,
          direction: "",
          puller: undefined,
        },
        pulling: {
          state: false,
          targetCell: undefined,
          moveSpeed: 0,
        },
        postPull: {
          state: false,
          count: 0,
          limit: 10,
        },
        pushed: {
          state: false,
          pusher: 0,
          moveSpeed: 0,
        },
        pulled: {
          state: false,
          puller: 0,
          moveSpeed: 0,
        },
        elasticCounter: {
          preState: false,
          state: false,
          direction: "",
          type: "",
          subType: "",
          countUp: {
            state: false,
            count: 0,
            limit: 6,
          },
          countDown: {
            state: false,
            count: 0,
            limit: 6,
          },
          coords: {
            x: undefined,
            y: undefined,
          },
          pause: {
            preState: false,
            state: false,
            type: "",
            count: 0,
            limit: 6,
          },
        },
        team: "Red",
        input: "Keyboard",
      },
      {
        number: 2,
        startPosition: {
          cell: {
            number: {
              x: 2,
              y: 6,
            },
            center: {
              x: 0,
              y: 0,
            },
          },
        },
        currentPosition: {
          cell: {
            number: {
              x: 0,
              y: 0,
            },
            center: {
              x: 0,
              y: 0,
            },
          },
        },
        nextPosition: {
          x: 0,
          y: 0,
        },
        target: {
          cell1: {
            number: {
              x: 0,
              y: 0,
            },
            center: {
              x: 0,
              y: 0,
            },
            free: true,
            occupant: {
              type: "",
              player: "",
            },
            void: false,
          },
          cell2: {
            number: {
              x: 0,
              y: 0,
            },
            center: {
              x: 0,
              y: 0,
            },
            free: true,
            occupant: {
              type: "",
              player: "",
            },
            void: false,
          },
          myCellBlock: false,
        },
        direction: "west",
        turning: {
          state: false,
          toDirection: "",
          delayCount: 0,
          limit: 5.1,
        },
        turnCheckerDirection: "",
        action: "idle",
        moving: {
          state: false,
          step: 0,
          course: "",
          origin: {
            number: {
              x: 0,
              y: 0,
            },
            center: {
              x: 0,
              y: 0,
            },
          },
          destination: {
            x: 0,
            y: 0,
          },
        },
        newMoveDelay: {
          state: false,
          count: 0,
          limit: 15,
        },
        strafing: {
          state: false,
          direction: "",
        },
        strafeReleaseHook: false,
        moveCancel: {
          state: false,
          oldDirection: "",
          newDirection: "",
          returningTo: {},
          returningFrom: {},
        },
        flanking: {
          checking: false,
          preFlankDirection: "",
          direction: "",
          state: false,
          step: 0,
          target1: { x: 0, y: 0 },
          target2: { x: 0, y: 0 },
        },
        attacking: {
          state: false,
          count: 0,
          limit: 20,
          strength: 0,
          direction: "",
          directionType: "", //thrust or slash
          animRef: {},
          peak: false,
          peakCount: 0,
          charge: 0,
          chargePeak: false,
          blunt: false,
          clashing: {
            state: false,
            count: 0,
            limit: 10,
          },
        },
        defending: {
          state: false,
          count: 0,
          limit: 4,
          animRef: {},
          peak: false,
          peakCount: 0,
          decay: {
            state: false,
            count: 0,
            limit: 25,
          },
          direction: "",
          directionType: "", //thrust or slash
        },
        drowning: false,
        dodging: {
          countState: false,
          state: false,
          count: 0,
          limit: 20,
          peak: {
            start: 8,
            end: 12,
          },
          direction: "",
        },
        jumping: {
          checking: false,
          state: false,
        },
        success: {
          attackSuccess: {
            state: false,
            count: 0,
            limit: 10,
          },
          defendSuccess: {
            state: false,
            count: 0,
            limit: 10,
          },
          deflected: {
            state: false,
            count: 0,
            limit: 20,
            predeflect: false,
            type: "",
          },
        },
        pushBack: {
          state: false,
          prePushBackMoveSpeed: 0,
        },
        halfPushBack: {
          state: false,
          direction: "",
          type: "",
          countUp: {
            state: true,
            count: 0,
            limit: 0,
          },
          countDown: {
            state: false,
            count: 0,
            limit: 0,
          },
          coords: {
            x: undefined,
            y: undefined,
          },
        },
        falling: {
          state: false,
          count: 0,
          limit: 10,
        },
        dead: {
          state: false,
          count: 0,
          limit: 10,
        },
        ghost: {
          state: false,
          position: {
            cell: {
              number: {
                x: 0,
                y: 0,
              },
              center: {
                x: 0,
                y: 0,
              },
            },
          },
        },
        respawn: false,
        points: 0,
        speed: {
          move: 0.1,
          range: [0.05, 0.1, 0.125, 0.2],
        },
        terrainMoveSpeed: {
          state: false,
          speed: 0,
        },
        hp: 2,
        currentWeapon: {
          name: "sword1",
          type: "sword",
          effect: "",
        },
        currentArmor: {
          name: "",
          type: "",
          effect: "",
        },
        items: {
          weaponIndex: 0,
          armorIndex: 0,
          weapons: [
            {
              name: "sword1",
              type: "sword",
              effect: "",
            },
          ],
          armor: [],
          ammo: 0,
        },
        inventorySize: 4,
        cycleWeapon: {
          state: false,
          count: 0,
          limit: 3,
        },
        cycleArmor: {
          state: false,
          count: 0,
          limit: 3,
        },
        crits: {
          singleHit: 1,
          doubleHit: 6,
          pushBack: 4,
          guardBreak: 3,
          dodge: 0,
        },
        statusDisplay: {
          state: false,
          status: "",
          count: 0,
          limit: 15,
        },
        popups: [
          {
            state: true,
            count: 0,
            limit: 0,
            type: "",
            position: "northWest",
            msg: "",
            img: "",
          },
        ],
        itemDrop: {
          state: false,
          count: 0,
          limit: 10,
          item: {
            name: "",
          },
          gear: {
            type: "",
          },
        },
        itemPickup: {
          state: false,
          count: 0,
          limit: 10,
          item: {
            name: "",
          },
          gear: {
            type: "",
          },
        },
        discardGear: {
          state: false,
          count: 0,
          limit: 8,
        },
        idleAnim: {
          state: false,
          count: 0,
          limit: 6,
        },
        ai: {
          state: false,
          imgType: "",
          primaryMission: "",
          mission: "",
          prevMission: "",
          currentObjective: "",
          targetSet: false,
          targetAcquired: false,
          safeRange: true,
          pathArray: [],
          targetPlayer: {
            number: 1,
            currentPosition: {
              x: undefined,
              y: undefined,
            },
            target: {
              number1: {
                x: undefined,
                y: undefined,
              },
              number2: {
                x: undefined,
                y: undefined,
              },
            },
            action: "",
          },
          instructions: [],
          currentInstruction: 0,
          resetInstructions: false,
          patrolling: {
            checkin: undefined,
            state: false,
            area: [],
            loopControl: false,
          },
          defending: {
            checkin: undefined,
            state: false,
            area: [],
          },
          persuing: {
            state: false,
          },
          engaging: {
            state: true,
            targetAction: "",
          },
          retrieving: {
            checkin: undefined,
            state: false,
            point: { x: undefined, y: undefined },
            targetItem: {
              name: "",
              type: "",
              subType: "",
              effect: "",
            },
            safe: true,
          },
          retreating: {
            checkin: undefined,
            state: false,
            point: { x: undefined, y: undefined },
            level: 0,
            safe: true,
          },
          organizing: {
            weaponPriorityIndex: 0,
            armorPriorityIndex: 0,
            dropped: {
              state: false,
              gear: {
                name: "",
                type: "",
                subType: "",
                effect: "",
              },
            },
          },
          mode: "",
          upgradeWeapon: false,
          upgradeArmor: false,
          pathfindingRanges: {
            spear: 3,
            crossbow: 5,
          },
        },
        stamina: {
          current: 20,
          max: 20,
        },
        newPushPullDelay: {
          state: false,
          count: 0,
          limit: 10,
        },
        prePush: {
          state: false,
          count: 0,
          limit: 15,
          targetCell: undefined,
          direction: "",
          pusher: undefined,
        },
        pushing: {
          state: false,
          targetCell: undefined,
          moveSpeed: 0,
        },
        prePull: {
          state: false,
          count: 0,
          limit: 15,
          targetCell: undefined,
          direction: "",
          puller: undefined,
        },
        pulling: {
          state: false,
          targetCell: undefined,
          moveSpeed: 0,
        },
        postPull: {
          state: false,
          count: 0,
          limit: 10,
        },
        pushed: {
          state: false,
          pusher: 0,
          moveSpeed: 0,
        },
        pulled: {
          state: false,
          puller: 0,
          moveSpeed: 0,
        },
        elasticCounter: {
          preState: false,
          state: false,
          direction: "",
          type: "",
          subType: "",
          countUp: {
            state: false,
            count: 0,
            limit: 6,
          },
          countDown: {
            state: false,
            count: 0,
            limit: 6,
          },
          coords: {
            x: undefined,
            y: undefined,
          },
          pause: {
            preState: false,
            state: false,
            type: "",
            count: 0,
            limit: 6,
          },
        },
        team: "Blue",
        input: "Keyboard",
      },
    ];

    // INPUT
    this.gamepad = false;
    this.keyPressed = [
      {
        north: false,
        south: false,
        east: false,
        west: false,
        attack: false,
        defend: false,
        strafe: false,
        dodge: false,
        pull: false,
        kick: false,
        cycleWeapon: false,
        cycleArmor: false,
        discardWeapon: false,
        discardArmor: false,
        uiMenu: false,
        playerMenu: false,
        rotateRight: false,
        rotateLeft: false,
      },
      {
        north: false,
        south: false,
        east: false,
        west: false,
        attack: false,
        defend: false,
        strafe: false,
        dodge: false,
        pull: false,
        kick: false,
        cycleWeapon: false,
        cycleArmor: false,
        discardWeapon: false,
        discardArmor: false,
        uiMenu: false,
        playerMenu: false,
        rotateRight: false,
        rotateLeft: false,
      },
    ];
    this.clicked = {
      cell: {
        number: {
          x: 0,
          y: 0,
        },
        center: {
          x: 0,
          y: 0,
        },
        drawCenter: {
          x: 0,
          y: 0,
        },
        vertices: [
          {
            x: 0,
            y: 0,
          },
          {
            x: 0,
            y: 0,
          },
          {
            x: 0,
            y: 0,
          },
          {
            x: 0,
            y: 0,
          },
        ],
        side: 0,
        levelData: "",
        edge: {
          state: false,
          side: "",
        },
        terrain: {
          name: "",
          type: "",
          effect: "",
        },
        item: {
          name: "",
          type: "",
          subType: "",
          effect: "",
          initDrawn: false,
        },
        void: {
          state: false,
        },
        obstacle: {
          id: 0,
          trap: {},
          state: false,
          name: "",
          type: "",
          hp: 2,
          destructible: {
            state: false,
            weapons: [],
            leaveRubble: false,
          },
          locked: {
            state: false,
            key: "",
          },
          weight: 1,
          height: 0.5,
          items: [],
          effects: [],
          moving: {
            state: false,
            step: 0,
            origin: {
              number: {
                x: undefined,
                y: undefined,
              },
              center: {
                x: undefined,
                y: undefined,
              },
            },
            destination: {
              number: {
                x: undefined,
                y: undefined,
              },
              center: {
                x: undefined,
                y: undefined,
              },
            },
            currentPosition: {
              x: undefined,
              y: undefined,
            },
            nextPosition: {
              x: undefined,
              y: undefined,
            },
            moveSpeed: 0,
            pushable: true,
            pushed: false,
            pusher: undefined,
            falling: {
              state: false,
              count: 0,
              limit: 10,
            },
          },
        },
        barrier: {
          id: 0,
          trap: {},
          state: false,
          name: "",
          type: "",
          hp: 2,
          destructible: {
            state: false,
            weapons: [],
            leaveRubble: false,
          },
          locked: {
            state: false,
            key: "",
          },
          position: "",
          height: 1,
        },
        elevation: {
          number: 0,
          type: "",
          position: "",
        },
        rubble: false,
      },
      player: undefined,
    };
    this.turnCheckerDirection = "";

    // SETTINGS
    this.settingsGridWidth = 9;
    this.settingsCanvasHeight = 500;
    this.settingsCanvasWidth = 700;
    this.settingsSceneX = 250;
    this.settingsSceneY = 40;
    this.settingsClicked = {
      number: {
        x: 0,
        y: 0,
      },
      center: {
        x: 0,
        y: 0,
      },
      drawCenter: {
        x: 0,
        y: 0,
      },
      vertices: [
        {
          x: 0,
          y: 0,
        },
        {
          x: 0,
          y: 0,
        },
        {
          x: 0,
          y: 0,
        },
        {
          x: 0,
          y: 0,
        },
      ],
      side: 0,
      levelData: "",
      edge: {
        state: false,
        side: "",
      },
      terrain: {
        name: "",
        type: "",
        effect: "",
      },
      item: {
        name: "",
        type: "",
        subType: "",
        effect: "",
        initDrawn: false,
      },
      void: {
        state: false,
      },
      obstacle: {
        id: 0,
        trap: {},
        state: false,
        name: "",
        type: "",
        hp: 2,
        destructible: {
          state: false,
          weapons: [],
          leaveRubble: false,
        },
        locked: {
          state: false,
          key: "",
        },
        weight: 1,
        height: 0.5,
        items: [],
        effects: [],
        moving: {
          state: false,
          step: 0,
          origin: {
            number: {
              x: undefined,
              y: undefined,
            },
            center: {
              x: undefined,
              y: undefined,
            },
          },
          destination: {
            number: {
              x: undefined,
              y: undefined,
            },
            center: {
              x: undefined,
              y: undefined,
            },
          },
          currentPosition: {
            x: undefined,
            y: undefined,
          },
          nextPosition: {
            x: undefined,
            y: undefined,
          },
          moveSpeed: 0,
          pushable: true,
          pushed: false,
          pusher: undefined,
          falling: {
            state: false,
            count: 0,
            limit: 10,
          },
        },
      },
      barrier: {
        id: 0,
        trap: {},
        state: false,
        name: "",
        type: "",
        hp: 2,
        destructible: {
          state: false,
          weapons: [],
          leaveRubble: false,
        },
        locked: {
          state: false,
          key: "",
        },
        position: "",
        height: 1,
      },
      elevation: {
        number: 0,
        type: "",
        position: "",
      },
      rubble: false,
    };
    this.settingsFormAiGridInfo = [];
    this.settingsFormAiStartPosList = [];
    this.updateSettingsFormAiDataData = {};
    this.settingsFormPlyrGridInfo = [];
    this.settingsFormPlyrStartPosList = [];
    this.settingsFormPlayerData = {};
    this.showSettingsKeyPress = {
      state: false,
      count: 0,
      limit: 4,
    };
    this.showSettingsCanvasData = {
      state: true,
      field: "human_start",
      plyrNo: 1,
      type: "start",
    };
    this.gamepadConfig = [];
    this.connectedGamepadsInit = false;

    // CELL INFO
    this.showCellInfoBox = false;
    this.mouseOverCell = {
      state: false,
      cell: undefined,
      count: 0,
      threshold: 40,
    };
    this.mousedOverCellCoords = {
      x: undefined,
      y: undefined,
    };
    this.mouseMoving = false;
    this.mouseOverCellSwitchOff = {
      state: false,
      count: 0,
      limit: 100,
    };
    this.cellInfoMouseOver = false;

    //LOOP & ANIMATION
    this.stepper = {
      now: 0,
      dt: 0,
      last: 0,
      step: 1 / 60,
      fps: 0,

      secondsPassed: 0,
      oldTimeStamp: 0,
      movingSpeed: 30,
      frameCount: 0,

      fps2: 30,
      interval: 1000 / 30,
      lastTime: 0,
      currentTime: new Date().getTime(),
      deltaTime: 0,
    };
    this.moveStepRef = [
      [
        0.05, 0.1, 0.15, 0.2, 0.25, 0.3, 0.35, 0.4, 0.45, 0.5, 0.55, 0.6, 0.65, 0.7, 0.75,
        0.8, 0.85, 0.9, 0.95, 1,
      ],
      [0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1],
      [0.125, 0.25, 0.375, 0.5, 0.625, 0.75, 0.875, 1],
      [0.2, 0.4, 0.6, 0.8, 1],
    ];
    this.actionAnimFrameTypeCountRef = {
      attacking: {
        typeCount: 7,
        sheetLength: 70,
      },
      defending: {
        typeCount: 5,
        sheetLength: 50,
      },
    };
    this.attackAnimRef = {
      limit: {
        unarmed: {
          thrust: {
            normal: 30,
            charged: 40,
          },
          slash: {
            normal: 35,
            charged: 45,
          },
        },
        sword: {
          thrust: {
            normal: 40,
            charged: 50,
          },
          slash: {
            normal: 45,
            charged: 55,
          },
        },
        spear: {
          thrust: {
            normal: 50,
            charged: 60,
          },
          slash: {
            normal: 55,
            charged: 65,
          },
        },
        crossbow: {
          thrust: {
            normal: 40,
            charged: 50,
          },
          slash: {
            normal: 50,
            charged: 60,
          },
        },
      },
      peak: {
        unarmed: {
          thrust: {
            normal: 15,
            charged: 25,
          },
          slash: {
            normal: 20,
            charged: 30,
          },
        },
        sword: {
          thrust: {
            normal: 25,
            charged: 35,
          },
          slash: {
            normal: 30,
            charged: 40,
          },
        },
        spear: {
          thrust: {
            normal: 35,
            charged: 45,
          },
          slash: {
            normal: 40,
            charged: 50,
          },
        },
        crossbow: {
          thrust: {
            normal: 35,
            charged: 45,
          },
          slash: {
            normal: 35,
            charged: 45,
          },
        },
      },
    };
    this.obstacleBarrierTrapAttackAnimRef = {
      limit: {
        sword: 25,
        spear: 30,
        crossbow: 30,
      },
      peak: {
        sword: 15,
        spear: 20,
        crossbow: 20,
      },
    };
    this.defendAnimRef = {
      limit: {
        unarmed: {
          thrust: 20,
          slash: 20,
        },
        sword: {
          thrust: 30,
          slash: 30,
        },
        spear: {
          thrust: 40,
          slash: 40,
        },
        crossbow: {
          thrust: 30,
          slash: 30,
        },
      },
      peak: {
        unarmed: {
          thrust: 11,
          slash: 11,
          // 7
        },
        sword: {
          thrust: 15,
          slash: 15,
          // 12
        },
        spear: {
          thrust: 20,
          slash: 20,
          // 17
        },
        crossbow: {
          thrust: 17,
          slash: 17,
        },
      },
    };
    this.staminaCostRef = {
      attack: {
        unarmed: {
          blunt: {
            pre: 1,
            peak: 2,
          },
          normal: {
            pre: 1,
            peak: 2,
          },
        },
        sword: {
          blunt: {
            pre: 2,
            peak: 3,
          },
          normal: {
            pre: 2,
            peak: 3,
          },
        },
        spear: {
          blunt: {
            pre: 2,
            peak: 4,
          },
          normal: {
            pre: 2,
            peak: 4,
          },
        },
        crossbow: {
          blunt: {
            pre: 1,
            peak: 3,
          },
          normal: {
            pre: 1,
            peak: 3,
          },
        },
      },
      deflected: {
        outOfStamina: 0,
        attacked: 3,
        bluntAttacked: 2,
        defended: 3,
        parried: 5,
        knockedOut: 0,
      },
      defend: {
        pre: 1.5,
        peak: 2,
      },
      dodge: {
        pre: 2,
        peak: 4,
      },
      flank: 5,
      jump: 6,
      pushBack: 7,
      push: 3,
      pull: 4,
      move: 0.1,
      strafe: 0.5,
      turn: 0.5,
    };
    this.deflectedLengthRef = {
      outOfStamina: 50,
      attacked: 18,
      bluntAttacked: 23,
      defended: 10,
      parried: 25,
      knockedOut: 65,
    };
    this.baseDodgeCountRef = {
      limit: 20,
      peak: {
        start: 8,
        end: 12,
      },
    };
    this.simultaneousAttackAllowance = 2;
    this.defendPeakAllowance = 2;
    this.projectiles = [];
    this.projectileSpeed = 0.1;
    this.cellsUnderAttack = [];
    this.cellsUnderPreAttack = [];
    this.cellsToHighlight = [];
    this.cellsToHighlight2 = [];
    this.gamepadPollCounter = {
      count1: 0,
      count2: 0,
      store1: [],
      store2: [],
    };
    this.charSpriteHeight = 100;
    this.charSpriteWidth = 60;
    this.playerColourRef = {
      player1: "red",
      player2: "blue",
      player3: "green",
      player4: "purple",
      player5: "orange",
      player6: "brown",
      player7: "",
      player8: "",
    };
    this.playerDrawWidth = 45;
    this.playerDrawHeight = 45;
    this.playerDrawWidth2 = 55;
    this.playerDrawHeight2 = 85;
    this.popupSize = 45;
    this.popupImgSize = 25;
    this.movingObstacles = [];
    this.halfPushBackObstacles = [];

    this.obstacleBarrierToDestroy = [];
    this.obstacleItemsToDrop = [];
    this.obstaclesOutOfBoundsFall = [];
    this.cellPopups = [];
    this.popupImageRef = {};
    this.indicatorImgs = {};
    this.playerImgs = [];
    this.itemImgs = {};
    this.boltImgs = {};
    this.floorImgs = {};
    this.obstacleImgs = {};
    this.barrierImgs = {};
    this.cellColorRef = [];
    this.popupProgressBorderSvgPath = "";
    this.popupProgressImgGradColor1 = "rgb(255,0,0)";
    this.popupProgressImgGradColor2 = "rgb(255,255,0)";

    this.halfPushBackChaining = true;
    this.halfPushBackChainingMoveAll = true;

    this.showPlayerOutlines = false;

    // CAMERA
    this.toggleCameraMode = false;
    this.camera = {
      state: false,
      startCount: 0,
      startLimit: 4,
      mode: "pan",
      fixed: false,
      target: {
        type: "player",
        plyrNo: 1,
        cell: {
          x: undefined,
          y: undefined,
        },
      },
      focus: {
        x: undefined,
        y: undefined,
      },
      focusCell: {
        x: 4,
        y: 4,
      },
      cellToPanOrigin: {
        x: 4,
        y: 4,
      },
      zoom: {
        x: 1,
        y: 1,
      },
      zoomDirection: "in",
      pan: {
        x: 1,
        y: 1,
      },
      panDirection: "east",
      adjustedPan: {
        x: -1,
        y: -1,
      },
      zoomFocusPan: {
        x: -1,
        y: -1,
      },
      limits: {
        zoom: {
          min: 0.5,
          max: 2.5,
        },
        pan: {
          x: {
            min: -400,
            max: 400,
          },
          y: {
            min: -200,
            max: 200,
          },
        },
        state: {
          count: 0,
          limit: 10,
          zoom: false,
          pan: false,
        },
      },
      instructionType: "default",
      currentPreInstruction: 0,
      preInstructions: [],
      currentInstruction: 0,
      instructions: [],
      customView: {
        state: false,
        zoom: 0,
        pan: {
          x: 0,
          y: 0,
        },
        keyPressCount: {
          start: 0,
          limit: 4,
        },
      },
    };
    this.cameraInstructionRef = {
      default: {},
      story: {},
      // FollowPlayer2, centerOnCell21 etc
    };
    this.resetCameraSwitch = false;
    this.setInitZoom = {
      state: false,
      windowWidth: 0,
      gridWidth: 0,
      count: 0,
      limit: 0,
    };
    this.engagedZoomThreshold = {
      melee: 0.5,
      ranged: 0.1,
    };
    this.settingAutoCamera = false;
    this.settingAutoCameraFollowBolt = false;
    this.highlightZoomPanFocusCell = true;
    this.zoomThresh = -0.05;
    this.autoCamPanWaitingForPath = false;

    // AI
    this.aiInitSettings = {
      randomStart: false,
      startPosition: {
        number: { x: 1, y: 7 },
      },
      primaryMission: "defend",
      mission: undefined,
      mode: "careful",
      partolArea: [
        { x: 8, y: 6 },
        // {x: 7, y: 4}
      ],
      weapons: [],
      armor: [],
      team: "",
    };
    this.addAiPlayerKeyPress = false;
    this.addAiCount = {
      state: false,
      count: 0,
      limit: 10,
    };
    this.aiPlayers = [];
    this.aiTarget = 1;
    this.resetAiTarget = {
      state: false,
      state2: false,
      player: 1,
      count: 0,
      limit: 25,
    };
    this.allPlayersDead = false;
    this.removeAi = undefined;
    this.easyStar = undefined;
    this.getPath = false;
    this.aiDeflectCheck = false;
    this.aiDeflectedCheck = [];

    this.bloodSacrificeEvent = {
      state: false,
      count: 0,
      limit: 100,
      restore: false,
    };
    this.bloodSacrificeVoidedCells = [];

    this.testDraw = [];
    this.testData = "";

    // ASSETS
    this.testRefNorth = React.createRef();
    this.testRefSouth = React.createRef();
    this.testRefEast = React.createRef();
    this.testRefWest = React.createRef();

    this.bgCompassRef = React.createRef();

    this.popupProgressImgRef = React.createRef();
    this.popupProgressSvgRef = React.createRef();
    this.floorGrassRef = React.createRef();
    this.floorDirtRef = React.createRef();
    this.floorIceRef = React.createRef();
    this.floorStoneRef = React.createRef();
    this.floorSandRef = React.createRef();
    this.floorMudRef = React.createRef();
    this.floorPondRef = React.createRef();
    this.floorRiverRef = React.createRef();
    this.floorBrambleRef = React.createRef();
    this.floorLavaRef = React.createRef();
    this.floorAttackRef = React.createRef();
    this.floorAttack2Ref = React.createRef();
    this.floorVoidRef = React.createRef();
    this.floorVoid2Ref = React.createRef();
    this.floorVoid3Ref = React.createRef();
    this.floorHighlightRef = React.createRef();
    this.floorRubbleRef = React.createRef();

    this.cellVoidingIndicateRef = React.createRef();
    this.cellVoidingIndicate2Ref = React.createRef();

    this.wallRef = React.createRef();
    this.wall2Ref = React.createRef();
    this.wall3Ref = React.createRef();

    this.obstacleAHalfRef = React.createRef();
    this.obstacleAFullRef = React.createRef();
    this.obstacleBHalfRef = React.createRef();
    this.obstacleBFullRef = React.createRef();
    this.obstacleCHalfRef = React.createRef();
    this.obstacleCFullRef = React.createRef();
    this.obstacleDHalfRef = React.createRef();
    this.obstacleDFullRef = React.createRef();
    this.obstacleEHalfRef = React.createRef();
    this.obstacleEFullRef = React.createRef();
    this.obstacleCrateRef = React.createRef();
    this.obstacleBarrelRef = React.createRef();
    this.barrierANorthRef = React.createRef();
    this.barrierASouthRef = React.createRef();
    this.barrierAEastRef = React.createRef();
    this.barrierAWestRef = React.createRef();

    this.unbreakableIndicateRef = React.createRef();

    this.timerIndicateRef = React.createRef();

    this.preAction1IndicateRef = React.createRef();
    this.preAction2IndicateRef = React.createRef();
    this.preAction1IndicateRef = React.createRef();
    this.preAction2IndicateRef = React.createRef();

    this.preAttackIndicateRef = React.createRef();
    this.preAttack2IndicateRef = React.createRef();

    this.attack1IndicateRef = React.createRef();
    this.attack2IndicateRef = React.createRef();
    this.attack3IndicateRef = React.createRef();

    this.attackUnarmedIndicateRef = React.createRef();
    this.attackBluntIndicateRef = React.createRef();
    this.attackBluntIndicate2Ref = React.createRef();

    this.attackSuccessIndicateRef = React.createRef();

    this.attackBreakIndicateRef = React.createRef();

    this.attackFeintIndicateRef = React.createRef();
    this.attackFeintIndicate2Ref = React.createRef();
    this.attackFeintIndicate3Ref = React.createRef();

    this.attackParriedIndicateRef = React.createRef();
    this.chargeIndicateRef = React.createRef();

    this.missedIndicateRef = React.createRef();
    this.missedIndicate2Ref = React.createRef();

    this.defendIndicateRef = React.createRef();
    this.defendIndicate1Ref = React.createRef();
    this.defendIndicate2Ref = React.createRef();
    this.defendIndicate3Ref = React.createRef();
    this.defendIndicate4Ref = React.createRef();

    this.defendBreakIndicateRef = React.createRef();
    this.defendSuccessIndicateRef = React.createRef();
    this.defendBreakIndicateRef = React.createRef();

    this.defendFeintIndicateRef = React.createRef();
    this.defendFeintIndicate2Ref = React.createRef();
    this.defendFeintIndicate3Ref = React.createRef();

    this.boltDefendIndicateRef = React.createRef();
    this.boltDefendIndicate2Ref = React.createRef();
    this.boltKilledIndicateRef = React.createRef();

    this.deflectIndicateRef = React.createRef();
    this.deflectIndicate2Ref = React.createRef();
    this.deflectInjuredIndicateRef = React.createRef();
    this.deflectInjuredIndicate2Ref = React.createRef();
    this.deflectBluntIndicateRef = React.createRef();

    this.pushbackIndicateRef = React.createRef();

    this.dodgeIndicateRef = React.createRef();
    this.dodgeIndicateRef = React.createRef();
    this.dodgeFeintIndicateRef = React.createRef();
    this.dodgeFeintIndicate2Ref = React.createRef();
    this.dodgeIndicate2Ref = React.createRef();

    this.flankIndicateRef = React.createRef();
    this.flankIndicate2Ref = React.createRef();
    this.noFlankIndicateRef = React.createRef();

    this.fallingIndicateRef = React.createRef();
    this.drowningIndicateRef = React.createRef();

    this.ghostIndicateRef = React.createRef();
    this.deathIndicateRef = React.createRef();

    this.healIndicateRef = React.createRef();

    this.outOfStaminaIndicateRef = React.createRef();
    this.inventoryFullIndicateRef = React.createRef();
    this.outOfAmmoIndicateRef = React.createRef();

    this.destroyedItemIndicateRef = React.createRef();
    this.pickupBuffIndicateRef = React.createRef();
    this.pickupDebuffIndicateRef = React.createRef();
    this.pickupWeaponIndicateRef = React.createRef();
    this.dropWeaponIndicateRef = React.createRef();
    this.dropArmorIndicateRef = React.createRef();
    this.pickupArmorIndicateRef = React.createRef();
    this.pickupAmmoIndicateRef = React.createRef();

    this.prePushIndicateRef = React.createRef();
    this.canPushIndicateRef = React.createRef();
    this.noPushingIndicateRef = React.createRef();
    this.pushingIndicateRef = React.createRef();
    this.prePullIndicateRef = React.createRef();
    this.canPullIndicateRef = React.createRef();
    this.noPullingIndicateRef = React.createRef();
    this.pullingIndicateRef = React.createRef();
    this.pushedPulledIndicateRef = React.createRef();

    this.terrainSpeedupIndicateRef = React.createRef();
    this.terrainSlowdownIndicateRef = React.createRef();
    this.terrainInjuredIndicateRef = React.createRef();

    // ITEMS
    this.itemSpdUpRef = React.createRef();
    this.itemSpdDownRef = React.createRef();
    this.itemHpUpRef = React.createRef();
    this.itemHpDownRef = React.createRef();
    this.itemFocusUpRef = React.createRef();
    this.itemFocusDownRef = React.createRef();
    this.itemStrUpRef = React.createRef();
    this.itemStrDownRef = React.createRef();
    this.itemHelmet1Ref = React.createRef();
    this.itemAmmoRef = React.createRef();
    this.itemAmmoRef = React.createRef();
    this.itemMail1Ref = React.createRef();
    this.itemGreaves1Ref = React.createRef();
    this.itemBoltNorthRef = React.createRef();
    this.itemBoltSouthRef = React.createRef();
    this.itemBoltEastRef = React.createRef();
    this.itemBoltWestRef = React.createRef();
    this.itemSwordRef = React.createRef();
    this.itemSpearRef = React.createRef();
    this.itemBowRef = React.createRef();
    this.itemCrossbowRef = React.createRef();
    this.boltNorthRef = React.createRef();
    this.boltSouthRef = React.createRef();
    this.boltEastRef = React.createRef();
    this.boltWestRef = React.createRef();
    this.ammoRef = React.createRef();
    this.mail1Ref = React.createRef();
    this.mail2Ref = React.createRef();
    this.mail3Ref = React.createRef();
    this.greaves1Ref = React.createRef();
    this.greaves2Ref = React.createRef();
    this.greaves3Ref = React.createRef();
    this.helmet1Ref = React.createRef();
    this.hpUpRef = React.createRef();
    this.hpDownRef = React.createRef();
    this.spdUpRef = React.createRef();
    this.spdDownRef = React.createRef();
    this.strUpRef = React.createRef();
    this.strDownRef = React.createRef();
    this.focusUpRef = React.createRef();
    this.focusDownRef = React.createRef();

    this.playerImgIdleSheetRef = React.createRef();
    this.player2ImgIdleSheetRef = React.createRef();
    this.playerComAImgIdleSheetRef = React.createRef();
    this.playerComBImgIdleSheetRef = React.createRef();
    this.playerImgMoveSheetRef = React.createRef();
    this.player2ImgMoveSheetRef = React.createRef();
    this.comAImgMoveSheetRef = React.createRef();
    this.comBImgMoveSheetRef = React.createRef();
    this.player1ImgDefendSheetRef = React.createRef();
    this.player2ImgDefendSheetRef = React.createRef();
    this.comAImgDefendSheetRef = React.createRef();
    this.comBImgDefendSheetRef = React.createRef();
    this.player1ImgAttackSheetRef = React.createRef();
    this.player2ImgAttackSheetRef = React.createRef();
    this.comAImgAttackSheetRef = React.createRef();
    this.comBImgAttackSheetRef = React.createRef();

    // AI
    this.completeMissionIndicateRef = React.createRef();
    this.enrouteIndicateRef = React.createRef();
    this.targetSwitchIndicateRef = React.createRef();
    this.pathSwitchIndicateRef = React.createRef();
    this.retreatIndicateRef = React.createRef();

    this.completeMissionIndicateRef = React.createRef();
    this.enrouteIndicateRef = React.createRef();
    this.targetSwitchIndicateRef = React.createRef();
    this.pathSwitchIndicateRef = React.createRef();
    this.retreatIndicateRef = React.createRef();
    this.aggressiveModeIndicateRef = React.createRef();
    this.passiveModeIndicateRef = React.createRef();
    this.thinkingIndicateRef = React.createRef();
    this.defendMissionIndicateRef = React.createRef();
    this.patrolMissionIndicateRef = React.createRef();
    this.pursueMissionIndicateRef = React.createRef();
    this.pursueMissionIndicate2Ref = React.createRef();
    this.retrieveMissionIndicateRef = React.createRef();

    this.moveSheetNewRef = React.createRef();
    this.idleSheetNewRef = React.createRef();
    this.idleSheetNew2Ref = React.createRef();
    this.attackSheetNewRef = React.createRef();
    this.defendSheetNewRef = React.createRef();
    this.dodgeSheetNewRef = React.createRef();
    this.deflectedFallingSheetNewRef = React.createRef();
  }

  componentDidMount() {
    // Helper.init()

    this.easyStar = new Easystar.js();

    if (window.innerWidth < 1100) {
      this.setState({
        containerInnerClass: "containerInnerSmall",
        sceneY: {
          three: 300,
          six: 200,
          nine: 120,
          twelve: 50,
        },
      });

      switch (this.gridWidth) {
        case 3:
          this.sceneY = 300;
          break;
        case 6:
          this.sceneY = 200;
          break;
        case 9:
          this.sceneY = 120;
          break;
        case 12:
          this.sceneY = 50;
          break;
      }

      this.canvasWidth = 1000;
      this.canvasHeight = 600;
    }

    let canvas = this.canvasRef.current;
    let context = canvas.getContext("2d");

    let canvas2 = this.canvasRef2.current;
    let context2 = canvas2.getContext("2d");

    this.setState({
      canvas: canvas,
      context: context,
      canvas2: canvas2,
      context2: context2,
    });

    this.deflectedFallingSheetNewRef.current.onload = () => {
      this.addListeners(canvas, canvas2);

      this.updateSettingsFormPlayerData({
        input: [
          { plyrNo: 1, input: "keyboard" },
          { plyrNo: 2, input: "keyboard" },
        ],
        weapon: [
          { plyrNo: 1, weapons: ["sword", "spear", "crossbow"] },
          { plyrNo: 2, weapons: ["sword", "spear", "crossbow"] },
        ],
        armor: [
          { plyrNo: 1, armor: [] },
          { plyrNo: 2, armor: [] },
        ],
        team: [
          { plyrNo: 1, team: "Red" },
          { plyrNo: 2, team: "Blue" },
        ],
      });
      this.drawGridInit(
        this.state.canvas,
        this.state.context,
        this.state.canvas2,
        this.state.context2
      );
      this.getCustomPlyrStartPosList([
        {
          plyrNo: 1,
          selected: undefined,
          posArray: [],
        },
        {
          plyrNo: 2,
          selected: undefined,
          posArray: [],
        },
      ]);

      window.requestAnimationFrame(this.gameLoop);
    };
  }
  componentWillUnmount() {
    window.cancelAnimationFrame(this.stepper.currentTime);
  }

  pollGamepads = () => {
    const gamepads = navigator.getGamepads ? navigator.getGamepads() : [];
    // console.log('gamepads',gamepads,navigator.getGamepads ? navigator.getGamepads() : []);

    let connectedGamepadsCount = gamepads.filter((x) => x !== null).length;
    let connectedGamepads = gamepads.filter((x) => x !== null);
    for (const pad of connectedGamepads) {
      if (
        pad.id.substr(0, 11) === "Joy-Con (R)" ||
        pad.id.substr(0, 11) === "Joy-Con (L)"
      ) {
        connectedGamepads.splice(
          connectedGamepads.indexOf((x) => x.index === pad.index),
          1
        );
      }
    }

    // console.log('connectedGamepads',connectedGamepads);

    let currentGamepadPlayer;
    let settingsGamepadPlayerCount = this.gamepadConfig.filter(
      (x) => x.input === "Gamepad"
    ).length;

    if (this.gamepadPollCounter.count1 === 0) {
      this.gamepadPollCounter.count1 = 1;
    } else {
      this.gamepadPollCounter.count1 = 0;
    }
    if (this.gamepadPollCounter.count2 === 0) {
      this.gamepadPollCounter.count2 = 1;
    } else {
      this.gamepadPollCounter.count2 = 0;
    }

    let keyPressed = [];
    let connectedGamepadIndexB = 0;
    console.log("xxx", this.gamepadConfig);
    for (const elem of this.gamepadConfig) {
      let indx = this.gamepadConfig.indexOf((x) => x.plyrNo === elem.plyrNo);

      if (elem.input === "Gamepad") {
        keyPressed.push({
          state: true,
          plyrNo: elem.plyrNo,
          keyPressed: {
            north: false,
            south: false,
            east: false,
            west: false,
            attack: false,
            defend: false,
            strafe: false,
            dodge: false,
            pull: false,
            kick: false,
            cycleArmor: false,
            discardWeapon: false,
            discardArmor: false,
            uiMenu: false,
            playerMenu: false,
            rotateRight: false,
            rotateLeft: false,
          },
        });

        this.players[elem.plyrNo - 1].strafing.state = false;

        if (this.connectedGamepadsInit !== true && connectedGamepads[0]) {
          if (connectedGamepads[connectedGamepadIndexB]) {
            elem.type = connectedGamepads[connectedGamepadIndexB].id.substr(0, 11);
            elem.id =
              connectedGamepads[connectedGamepadIndexB].id.substr(0, 11) +
              "_" +
              connectedGamepads[connectedGamepadIndexB].index;
            elem.mapping = connectedGamepads[connectedGamepadIndexB].mapping;
            elem.gamepadIndex = connectedGamepads[connectedGamepadIndexB].index;

            connectedGamepadIndexB++;
          }

          // console.log('this.gamepadConfig + connected gamepads',this.gamepadConfig,connectedGamepads,settingsGamepadPlayerCount);

          if (
            this.gamepadConfig.filter((x) => x.id !== "").length ===
            settingsGamepadPlayerCount
          ) {
            this.connectedGamepadsInit = true;
          }
        }
      } else {
        // dummy object for setting global keypressed by index
        keyPressed.push({
          state: false,
          plyrNo: elem.plyrNo,
          keyPressed: {
            north: false,
            south: false,
            east: false,
            west: false,
            attack: false,
            defend: false,
            strafe: false,
            dodge: false,
            pull: false,
            kick: false,
            cycleArmor: false,
            discardWeapon: false,
            discardArmor: false,
            uiMenu: false,
            playerMenu: false,
            rotateRight: false,
            rotateLeft: false,
          },
        });
      }
    }
    connectedGamepadIndexB = 0;

    let showSettingsKeyPressState = false;

    let gamepadEngaged = false;
    // for(let g = 0; g < gamepads.length; g++) {
    for (let g = 0; g < connectedGamepads.length; g++) {
      const gp = connectedGamepads[g];

      if (gp) {
        // console.log('gp',gp);
        let gamepadConfigRef = this.gamepadConfig.find(
          (x) => x.gamepadIndex === gp.index
        );

        if (gamepadConfigRef) {
          currentGamepadPlayer = gamepadConfigRef.plyrNo;
          const keyPressedIndex = currentGamepadPlayer - 1;

          if (
            gp.id.substr(0, 11) !== "Joy-Con (R)" &&
            gp.id.substr(0, 11) !== "Joy-Con (L)"
          ) {
            // CHECK BUTTONS!!
            for (const btn of gp.buttons) {
              if (btn.pressed === true) {
                // DEBUGGING
                if (
                  // b btn
                  gp.buttons.indexOf(btn) === 0 ||
                  // a btn
                  gp.buttons.indexOf(btn) === 1 ||
                  // y btn
                  gp.buttons.indexOf(btn) === 2 ||
                  // x btn
                  gp.buttons.indexOf(btn) === 3 ||
                  // l btn
                  gp.buttons.indexOf(btn) === 4 ||
                  // r btn
                  gp.buttons.indexOf(btn) === 5 ||
                  // l trigger
                  gp.buttons.indexOf(btn) === 6 ||
                  // r trigger
                  gp.buttons.indexOf(btn) === 7 ||
                  // - btn
                  gp.buttons.indexOf(btn) === 8 ||
                  // + btn
                  gp.buttons.indexOf(btn) === 9 ||
                  // l stick press
                  gp.buttons.indexOf(btn) === 10 ||
                  // r stick press
                  gp.buttons.indexOf(btn) === 11 ||
                  // dpad up
                  gp.buttons.indexOf(btn) === 12 ||
                  // dpad down
                  gp.buttons.indexOf(btn) === 13 ||
                  // dpad left
                  gp.buttons.indexOf(btn) === 14 ||
                  // dpad right
                  gp.buttons.indexOf(btn) === 15
                ) {
                  // console.log('player '+currentGamepadPlayer+' btn ',gp.buttons.indexOf(btn),' pressed');
                  // console.log('gp',gp);
                  gamepadEngaged = true;
                }

                switch (gp.buttons.indexOf(btn)) {
                  case 0:
                    // b btn
                    // console.log('player '+currentGamepadPlayer+' defend btn pressed');
                    keyPressed[keyPressedIndex].keyPressed.defend = true;
                    break;
                  case 1:
                    // a btn
                    // console.log('player '+currentGamepadPlayer+' attack btn pressed');
                    keyPressed[keyPressedIndex].keyPressed.attack = true;
                    break;
                  case 2:
                    // y btn
                    // console.log('player '+currentGamepadPlayer+' strafe btn pressed');
                    keyPressed[keyPressedIndex].keyPressed.strafe = true;
                    break;
                  case 3:
                    // x btn
                    // console.log('player '+currentGamepadPlayer+' dodge btn pressed');
                    keyPressed[keyPressedIndex].keyPressed.dodge = true;
                    break;
                  case 4:
                    // l btn
                    // console.log('player '+currentGamepadPlayer+' discard weapon btn pressed');
                    keyPressed[keyPressedIndex].keyPressed.discardWeapon = true;
                    break;
                  case 5:
                    // r btn
                    if (this.players[currentGamepadPlayer - 1].dead.state === true) {
                      this.respawn(this.playerscurrentGamepadPlayer - 1);
                      // console.log('player '+currentGamepadPlayer+' cycle weapon btn pressed: RESPAWN');
                    } else {
                      // console.log('player '+currentGamepadPlayer+' cycle weapon btn pressed');
                      keyPressed[keyPressedIndex].keyPressed.cycleWeapon = true;
                    }
                    break;
                  case 6:
                    // l trigger
                    // console.log('player '+currentGamepadPlayer+' discard armor btn pressed');
                    keyPressed[keyPressedIndex].keyPressed.discardArmor = true;
                    break;
                  case 7:
                    // r trigger
                    // console.log('player '+currentGamepadPlayer+' cycle armor btn pressed');
                    keyPressed[keyPressedIndex].keyPressed.cycleArmor = true;
                    break;
                  case 8:
                    // - btn
                    showSettingsKeyPressState = true;
                    break;
                  case 9:
                    // + btn
                    this.gameReset("soft");
                    break;
                  case 10:
                    // l stick press
                    break;
                  case 11:
                    // r stick press
                    break;
                  case 12:
                    // dpad up
                    // console.log('player '+currentGamepadPlayer+' kick btn pressed');
                    keyPressed[keyPressedIndex].keyPressed.kick = true;
                    break;
                  case 13:
                    // dpad down
                    // console.log('player '+currentGamepadPlayer+' pull btn pressed');
                    keyPressed[keyPressedIndex].keyPressed.pull = true;
                    break;
                  case 14:
                    // dpad left
                    // console.log('player '+currentGamepadPlayer+' ui menu toggle btn pressed');
                    keyPressed[keyPressedIndex].keyPressed.uiMenu = true;
                    break;
                  case 15:
                    // dpad right
                    // console.log('player '+currentGamepadPlayer+' player menu toggle btn pressed');
                    keyPressed[keyPressedIndex].keyPressed.playerMenu = true;
                    break;
                  default:
                }
              }
            }

            // CHECK AXES!!
            // DEBUGGING
            // axes 0(x),1(y) == left stick, 2(x),3(y) == right stick
            for (const axis of gp.axes) {
              if (axis !== 0) {
                if (gp.axes.indexOf(axis) === 0) {
                  // console.log('player '+currentGamepadPlayer+' left stick x axis value',axis.toFixed(2));
                }
                if (gp.axes.indexOf(axis) === 1) {
                  // console.log('player '+currentGamepadPlayer+' left stick y axis value',axis.toFixed(2));
                }
                if (gp.axes.indexOf(axis) === 2) {
                  // console.log('player '+currentGamepadPlayer+' right stick x axis value',axis.toFixed(2));
                }
                if (gp.axes.indexOf(axis) === 3) {
                  // console.log('player '+currentGamepadPlayer+' right stick y axis value',axis.toFixed(2));
                }

                // console.log('gp',gp);
              }
            }

            const getAxesDirection = (x, y) => {
              let dir;
              let magnitude;

              if (x < -0.5 && y < -0.5) dir = "up-left";
              else if (x < -0.5 && y >= -0.5 && y <= 0.5) dir = "left";
              else if (x < -0.5 && y > 0.5) dir = "down-left";
              else if (x >= -0.5 && x <= 0.5 && y < -0.5) dir = "up";
              else if (x >= -0.5 && x <= 0.5 && y >= -0.5 && y <= 0.5) dir = "neutral";
              else if (x >= -0.5 && x <= 0.5 && y > 0.5) dir = "down";
              else if (x > 0.5 && y < -0.5) dir = "up-right";
              else if (x > 0.5 && y >= -0.5 && y <= 0.5) dir = "right";
              else if (x > 0.5 && y > 0.5) dir = "down-right";

              // ALTERNATE METHOD, 2ND W/ MAGNITUDE
              // if (Math.abs(x) > Math.abs(y)) {
              //   if (x < -0.5 && y < -0.5) dir = 'up-left';
              //   else if (x < -0.5 && y > 0.5) dir = 'down-left';
              //   else if (x > 0.5 && y < -0.5) dir = 'up-right';
              //   else if (x > 0.5 && y > 0.5) dir = 'down-right';
              //   else if (x < -0.5) dir = 'left';
              //   else dir = 'right';
              // } else {
              //   if (x < -0.5 && y < -0.5) dir = 'up-left';
              //   else if (x < -0.5 && y > 0.5) dir = 'down-left';
              //   else if (x > 0.5 && y < -0.5) dir = 'up-right';
              //   else if (x > 0.5 && y > 0.5) dir = 'down-right';
              //   else if (y < -0.5) dir = 'up';
              //   else dir = 'down';
              // }
              //
              // if (Math.abs(x) > Math.abs(y)) {
              //    if (x < -0.5 && y < -0.5) {
              //       dir = 'up-left';
              //       magnitude = Math.sqrt(x*x + y*y);
              //     }
              //    else if (x < -0.5 && y > 0.5) {
              //       dir = 'down-left';
              //       magnitude = Math.sqrt(x*x + y*y);
              //     }
              //    else if (x > 0.5 && y < -0.5) {
              //       dir = 'up-right';
              //       magnitude = Math.sqrt(x*x + y*y);
              //     }
              //    else if (x > 0.5 && y > 0.5) {
              //       dir = 'down-right';
              //       magnitude = Math.sqrt(x*x + y*y);
              //     }
              //    else if (x < -0.5) {
              //       dir = 'left';
              //       magnitude = Math.abs(x);
              //     }
              //    else {
              //       dir = 'right';
              //       magnitude = Math.abs(x);
              //     }
              //  } else {
              //    if (x < -0.5 && y < -0.5) {
              //       dir = 'up-left';
              //       magnitude = Math.sqrt(x*x + y*y);
              //     }
              //    else if (x < -0.5 && y > 0.5) {
              //       dir = 'down-left';
              //       magnitude = Math.sqrt(x*x + y*y);
              //     }
              //    else if (x > 0.5 && y < -0.5) {
              //       dir = 'up-right';
              //       magnitude = Math.sqrt(x*x + y*y);
              //     }
              //    else if (x > 0.5 && y > 0.5) {
              //       dir = 'down-right';
              //       magnitude = Math.sqrt(x*x + y*y);
              //     }
              //    else if (y < -0.5) {
              //       dir = 'up';
              //       magnitude = Math.abs(y);
              //     }
              //    else {
              //       dir = 'down';
              //       magnitude = Math.abs(y);
              //     }
              //  }

              // only return direction if magnitude is more than a a certain amount
              if (!dir) {
                dir = "neutral";
              }
              if (!magnitude) {
                magnitude = 0;
              }

              return { direction: dir, magnitude: magnitude };
            };
            let preDirection;
            let direction;
            let x;
            let y;

            // LEFT ANALOG STICK (MOVE, TURN, PUSH ETC)
            if (gp.axes[0] !== 0 || gp.axes[1] !== 0) {
              x = gp.axes[0];
              y = gp.axes[1];
              preDirection = getAxesDirection(x, y).direction;
              switch (preDirection) {
                case "up":
                case "up-right":
                  direction = "north";
                  break;
                case "left":
                case "up-left":
                  direction = "west";
                  break;
                case "down":
                case "down-left":
                  direction = "south";
                  break;
                case "right":
                case "down-right":
                  direction = "east";
                  break;
                default:
              }
              if (direction) {
                gamepadEngaged = true;
                keyPressed[keyPressedIndex].keyPressed[direction] = true;
              }
              // console.log('player ',currentGamepadPlayer,' gamepad left stick to ',preDirection,direction,' magnitude',getAxesDirection(x,y).magnitude);
            }

            // RIGHT ANALOG STICK (STAGE ROTATE)
            if (gp.axes[2] !== 0 || gp.axes[3] !== 0) {
              x = gp.axes[2];
              y = gp.axes[3];
              preDirection = getAxesDirection(x, y).direction;
              switch (preDirection) {
                case "up":
                case "up-right":
                  direction = "north";
                  break;
                case "left":
                case "up-left":
                  direction = "west";
                  break;
                case "down":
                case "down-left":
                  direction = "south";
                  break;
                case "right":
                case "down-right":
                  direction = "east";
                  break;
                default:
              }
              if (direction) {
                gamepadEngaged = true;
                // keyPressed[keyPressedIndex].keyPressed[direction] = true;
                if (direction === "east") {
                  keyPressed[keyPressedIndex].keyPressed.rotateRight = true;
                }
                if (direction == "west") {
                  keyPressed[keyPressedIndex].keyPressed.rotateLeft = true;
                }
              }

              // console.log('player ',currentGamepadPlayer,' gamepad right stick to ',preDirection,direction,' magnitude',getAxesDirection(x,y).magnitude);
            }
          }

          // NOT USING PRO CONTROLLER OR BOTH JOYCONS
          else {
            if (
              gp.id.substr(0, 11) === "Joy-Con (R)" ||
              gp.id.substr(0, 11) === "Joy-Con (L)"
            ) {
              console.log(
                "can't use single joycon. please re-configure controller/gamepad settings"
              );
              keyPressed[keyPressedIndex].state = false;
              keyPressed[keyPressedIndex].keyPressed = {
                north: false,
                south: false,
                east: false,
                west: false,
                attack: false,
                defend: false,
                strafe: false,
                dodge: false,
                pull: false,
                kick: false,
                cycleArmor: false,
                discardWeapon: false,
                discardArmor: false,
                uiMenu: false,
                playerMenu: false,
                rotateRight: false,
                rotateLeft: false,
              };
              showSettingsKeyPressState = true;
              this.connectedGamepadsInit = false;
            }
          }
        } else {
          // console.log('found a connected gamepad not assigned to a player. do nothing',gp.index);
        }
      }
    }

    let player = this.players[currentGamepadPlayer - 1];

    // if (player && gamepadEngaged === true) {
    if (player) {
      if (keyPressed[currentGamepadPlayer - 1].state === true) {
        this.keyPressed[currentGamepadPlayer - 1] =
          keyPressed[currentGamepadPlayer - 1].keyPressed;
        // console.log('xxx',this.keyPressed[currentGamepadPlayer-1]);
      }

      if (showSettingsKeyPressState === true) {
        this.showSettingsKeyPress.state = showSettingsKeyPressState;
      }

      if (player.defending.state === true && player.defending.count === 0) {
        if (this.keyPressed[currentGamepadPlayer - 1].defend === false) {
          console.log("player", player.number, " stop defending1 @ gamepad");
          // player.defending.state = false;
          // player.defending.count = 0;
          // player.defending.decay.state = false;
          // player.defending.decay.count = 0;
        }
      }

      // STRAFE CHECKS
      if (
        keyPressed[currentGamepadPlayer - 1].keyPressed.strafe === false &&
        this.players[currentGamepadPlayer - 1].moving.state === true &&
        this.players[currentGamepadPlayer - 1].strafing.state === true
      ) {
        this.players[currentGamepadPlayer - 1].strafeReleaseHook = true;
      }
      if (
        keyPressed[currentGamepadPlayer - 1].keyPressed.strafe === false &&
        this.players[currentGamepadPlayer - 1].moving.state !== true &&
        this.keyPressed[currentGamepadPlayer - 1].strafe === true
      ) {
        this.players[currentGamepadPlayer - 1].strafeReleaseHook = true;
      } else {
        this.players[currentGamepadPlayer - 1].strafing.state =
          keyPressed[currentGamepadPlayer - 1].keyPressed.strafe;
      }
    }
  };
  addListeners = (canvas, canvas2) => {
    // console.log('adding listeners');

    canvas2.addEventListener("click", (e) => {
      this.getCanvasClick(canvas2, e, "click");
    });

    window.addEventListener("gamepadconnected", (e) => {
      // console.log('new gamepad?',e);
      this.handleGamepadEvent(e, "connected");
    });

    window.addEventListener("gamepaddisconnected", (e) => {
      // console.log('Lost connection with the gamepad.');
      this.handleGamepadEvent(e, "disconnected");
    });

    // canvas3.addEventListener("click", e => {
    //   this.getSettingsCanvasClick(canvas3, e)
    // });

    // if (this.showSettingsCanvasData.state === true) {
    //   canvas3.addEventListener("click", e => {
    //     this.getSettingsCanvasClick(canvas3, e)
    //   });
    // }

    document.addEventListener("keydown", (e) => {
      this.handleKeyPress(e, true);
    });
    document.addEventListener("keyup", (e) => {
      this.handleKeyPress(e, false);
    });

    canvas2.addEventListener("mousemove", (e) => {
      this.getCanvasClick(canvas2, e, "mousemove");
    });
  };
  getCanvasClick = (canvas, event, type) => {
    const rect = canvas.getBoundingClientRect();
    const scale = rect.width / canvas.offsetWidth;
    // const scale = (rect.width / canvas.offsetWidth)*this.camera.zoom.x;
    // const scale = (rect.width / canvas.offsetWidth)*(this.camera.zoom.x-1);
    const x = (event.clientX - rect.left) * scale;
    const y = (event.clientY - rect.top) * scale;

    // ADJUSTED FOR CANVAS SCALE & TRANSFORM
    let newX = (x - this.camera.zoomFocusPan.x) / this.camera.zoom.x;
    let newY = (y - this.camera.zoomFocusPan.y) / this.camera.zoom.y;

    // console.log("clicked the canvas", 'x: ',x,'y: ',y,'newX',newX,'newY',newY,'zoom',this.camera.zoom.x.toFixed(2),'pan',this.camera.pan.x,this.camera.pan.y);

    let insideGrid = false;

    for (const cell of this.gridInfo) {
      let point = [newX, newY];
      let polygon = [];
      for (const vertex of cell.vertices) {
        let vertexPoint = [vertex.x + 10, vertex.y + 5];
        polygon.push(vertexPoint);
      }
      let pip = pointInPolygon(point, polygon);
      if (pip === true) {
        insideGrid = true;
        // console.log("clicked or moused over a cell", cell.center, "x: " + x + " y: " + y);
        let player = undefined;
        for (const plyr of this.players) {
          if (
            plyr.currentPosition.cell.number.x === cell.number.x &&
            plyr.currentPosition.cell.number.y === cell.number.y
          ) {
            player = plyr;
          }
        }
        if (type === "click" && this.cellInfoMouseOver !== true) {
          // console.log("clicked on a cell", cell.center, "x: " + x + " y: " + y);
          this.clicked.cell = cell;
          if (player) {
            this.clicked.player = player;
          } else {
            this.clicked.player = undefined;
          }
          this.showCellInfoBox = true;
          this.mouseOverCell = {
            state: true,
            cell: cell,
            count: 0,
            threshold: this.mouseOverCell.threshold,
          };
        }

        if (type === "mousemove") {
          // console.log("moused over a cell", cell.center, "x: " + x + " y: " + y);
          this.mouseMoving = true;

          if (this.mouseOverCellSwitchOff.state === true) {
            this.mouseOverCellSwitchOff.state = false;
          }

          if (this.cellInfoMouseOver !== true) {
            if (this.mouseOverCell.cell) {
              if (
                this.mouseOverCell.cell.number.x === cell.number.x &&
                this.mouseOverCell.cell.number.y === cell.number.y
              ) {
                if (this.mouseOverCell.state === true) {
                  // console.log('do nothing');
                } else {
                  if (this.mouseOverCell.count < this.mouseOverCell.threshold) {
                    this.mouseOverCell.count++;
                  }
                  if (this.mouseOverCell.count >= this.mouseOverCell.threshold) {
                    this.clicked.cell = cell;
                    if (player) {
                      this.clicked.player = player;
                    } else {
                      this.clicked.player = undefined;
                    }
                    this.showCellInfoBox = true;
                    this.mouseOverCell = {
                      state: true,
                      cell: cell,
                      count: 0,
                      threshold: this.mouseOverCell.threshold,
                    };
                  }
                }
              } else {
                this.mouseOverCell = {
                  state: false,
                  cell: cell,
                  count: 0,
                  threshold: this.mouseOverCell.threshold,
                };
              }
            } else {
              this.mouseOverCell = {
                state: false,
                cell: cell,
                count: 0,
                threshold: this.mouseOverCell.threshold,
              };
            }
          } else {
            // console.log("mouse in cell info box. do nothing");
          }
        }
      }
    }
    if (insideGrid === false) {
      // console.log("clicked or moused over the canvas out of bounds", 'x: ',x,'y: ',y);
      // console.log('clicked or mouse moved outside the grid',this.cellInfoMouseOver);
      if (type === "click") {
        // console.log("clicked on the canvas out of bounds", "x: ", x, "y: ", y);
        if (this.mouseOverCellSwitchOff.state === true) {
          this.mouseOverCellSwitchOff.state = false;
        }
        if (this.cellInfoMouseOver !== true) {
          this.showCellInfoBox = false;
          this.mouseOverCell = {
            state: false,
            cell: undefined,
            count: 0,
            threshold: this.mouseOverCell.threshold,
          };
        } else {
          this.showCellInfoBox = true;
        }
      } else if (type === "mousemove") {
        // console.log("moused over the canvas out of bounds", "x: ", x, "y: ", y);
        if (this.cellInfoMouseOver !== true) {
          if (this.mouseOverCellSwitchOff.state !== true) {
            this.mouseOverCellSwitchOff.state = true;
          }

          if (
            this.mouseOverCell.cell &&
            this.mouseOverCell.state !== true &&
            this.mouseOverCell.count > 1
          ) {
            this.mouseOverCell = {
              state: false,
              cell: undefined,
              count: 0,
              threshold: this.mouseOverCell.threshold,
            };
          }
        } else {
          // console.log("heeere!", this.cellInfoMouseOver);
          this.cellInfoMouseOver = false;

          this.showCellInfoBox = true;
          this.mouseOverCell.state = false;
          if (this.mouseOverCellSwitchOff.state === true) {
            this.mouseOverCellSwitchOff.state = false;
            this.mouseOverCellSwitchOff.count = 0;
          }
        }
      }
    }

    if (type === "mousemove") {
      this.mouseMoving = true;
    }
  };
  getSettingsCanvasClick = (canvas, event) => {
    // console.log('getSettingsCanvasClick');

    const rect = canvas.getBoundingClientRect();

    const x = event.clientX - rect.left;
    const y = event.clientY - rect.top;

    let insideGrid = false;

    for (const cell of this.settingsGridInfo) {
      let point = [x, y];
      let polygon = [];
      for (const vertex of cell.vertices) {
        let vertexPoint = [vertex.x + 10 / 2, vertex.y + 5 / 2];

        polygon.push(vertexPoint);
      }
      let pip = pointInPolygon(point, polygon);
      if (pip === true) {
        insideGrid = true;
        // console.log("clicked a cell",cell.number,"x: " + x + " y: " + y);
        this.settingsClicked = cell;
      }
    }
    if (insideGrid === false) {
      // console.log("clicked the settings canvas", 'x: ',x,'y: ',y);

      this.settingsClicked = {
        number: {
          x: 0,
          y: 0,
        },
        center: {
          x: 0,
          y: 0,
        },
        drawCenter: {
          x: 0,
          y: 0,
        },
        vertices: [
          {
            x: 0,
            y: 0,
          },
          {
            x: 0,
            y: 0,
          },
          {
            x: 0,
            y: 0,
          },
          {
            x: 0,
            y: 0,
          },
        ],
        side: 0,
        levelData: "",
        edge: {
          state: false,
          side: "",
        },
        terrain: {
          name: "",
          type: "",
          effect: "",
        },
        item: {
          name: "",
          type: "",
          subType: "",
          effect: "",
          initDrawn: false,
        },
        void: {
          state: false,
        },
        obstacle: {
          id: 0,
          trap: {},
          state: false,
          name: "",
          type: "",
          hp: 2,
          destructible: {
            state: false,
            weapons: [],
            leaveRubble: false,
          },
          locked: {
            state: false,
            key: "",
          },
          weight: 1,
          height: 0.5,
          items: [],
          effects: [],
          moving: {
            state: false,
            step: 0,
            origin: {
              number: {
                x: undefined,
                y: undefined,
              },
              center: {
                x: undefined,
                y: undefined,
              },
            },
            destination: {
              number: {
                x: undefined,
                y: undefined,
              },
              center: {
                x: undefined,
                y: undefined,
              },
            },
            currentPosition: {
              x: undefined,
              y: undefined,
            },
            nextPosition: {
              x: undefined,
              y: undefined,
            },
            moveSpeed: 0,
            pushable: true,
            pushed: false,
            pusher: undefined,
            falling: {
              state: false,
              count: 0,
              limit: 10,
            },
          },
        },
        barrier: {
          id: 0,
          trap: {},
          state: false,
          name: "",
          type: "",
          hp: 2,
          destructible: {
            state: false,
            weapons: [],
            leaveRubble: false,
          },
          locked: {
            state: false,
            key: "",
          },
          position: "",
          height: 1,
        },
        elevation: {
          number: 0,
          type: "",
          position: "",
        },
        rubble: false,
      };
    }

    if (this.showSettingsCanvasData.state === true) {
      let availibleCells =
        this.settingsFormPlyrStartPosList[this.settingsFormPlyrStartPosList.length - 1]
          .posArray;
      if (this.settingsFormPlyrStartPosList.length < 0) {
        availibleCells =
          this.settingsFormPlyrStartPosList[this.settingsFormPlyrStartPosList.length - 1]
            .posArray;
      }
      let validCell = false;
      for (const cell of availibleCells) {
        if (
          cell.x === this.settingsClicked.number.x &&
          cell.y === this.settingsClicked.number.y
        ) {
          validCell = true;
        }
      }

      if (validCell === true) {
        if (this.showSettingsCanvasData.field.split("_")[0] === "human") {
          let plyrNo = this.showSettingsCanvasData.plyrNo;

          let newArray = this.settingsFormPlyrStartPosList.map(
            (y) =>
              (y = {
                plyrNo: y.plyrNo,
                selected: y.selected,
              })
          );

          let plyrChange = newArray.find((x) => x.plyrNo === plyrNo);
          plyrChange.selected = {
            x: this.settingsClicked.number.x,
            y: this.settingsClicked.number.y,
          };

          this.getCustomPlyrStartPosList(newArray);

          let newArray2 = this.settingsFormAiStartPosList.map(
            (y) =>
              (y = {
                plyrNo: y.plyrNo,
                mission: y.mission,
                selected: y.selected,
              })
          );

          this.getCustomAiStartPosList(newArray2);
        }

        if (this.showSettingsCanvasData.field.split("_")[0] === "ai") {
          let plyrNo =
            this.showSettingsCanvasData.plyrNo - this.settingsFormPlyrStartPosList.length;
          let type = this.showSettingsCanvasData.type;
          let value = this.settingsClicked.number;

          let newArray3 = this.settingsFormAiStartPosList.map(
            (y) =>
              (y = {
                plyrNo: y.plyrNo,
                mission: y.mission,
                selected: y.selected,
              })
          );

          let plyrChange = newArray3.find((x) => x.plyrNo === plyrNo);

          if (plyrChange.selected.length === 0) {
            plyrChange.selected.push({
              type: type,
              cell: { x: value.x, y: value.y },
            });
          } else {
            // console.log('plyrChange',plyrChange);
            let selectedElem = plyrChange.selected.find((j) => j.type === type);
            let indx = newArray3.findIndex((j) => j.plyrNo === plyrChange.plyrNo);
            if (selectedElem) {
              selectedElem.cell = { x: value.x, y: value.y };
            } else {
              plyrChange.selected.push({
                type: type,
                cell: { x: value.x, y: value.y },
              });
            }
          }

          this.getCustomAiStartPosList(newArray3);
        }
      } else {
        // console.log('cant choose that cell',this.settingsClicked.number);
      }
    }

    this.setState({
      stateUpdater: "..",
    });
  };
  handleKeyPress = (event, state) => {
    // console.log('handling key press', event.key, state, event);

    let direction;
    let keyInput = event.key;

    switch (keyInput) {
      case "w":
        this.keyPressed[0].north = state;
        // direction = 'north';
        this.players[0].turnCheckerDirection = "north";
        this.currentPlayer = 1;
        break;
      case "a":
        this.keyPressed[0].west = state;
        // direction = 'west';
        this.players[0].turnCheckerDirection = "west";
        this.currentPlayer = 1;
        break;
      case "d":
        this.keyPressed[0].east = state;
        // direction = 'east';
        this.players[0].turnCheckerDirection = "east";
        this.currentPlayer = 1;
        break;
      case "s":
        this.keyPressed[0].south = state;
        // direction = 'south';
        this.players[0].turnCheckerDirection = "south";
        this.currentPlayer = 1;
        break;
      case "f":
        this.keyPressed[0].attack = state;
        this.currentPlayer = 1;
        break;
      case "v":
        this.keyPressed[0].defend = state;
        this.currentPlayer = 1;
        break;
      case "c":
        this.keyPressed[0].dodge = state;
        this.currentPlayer = 1;
        break;
      case "r":
        this.keyPressed[0].pull = state;
        this.currentPlayer = 1;
        break;
      case "Shift":
        if (event.code === "ShiftLeft") {
          this.keyPressed[0].kick = state;
          this.currentPlayer = 1;
        }
        break;
      case " ":
        if (
          state === false &&
          this.players[0].moving.state === true &&
          this.players[0].strafing.state === true
        ) {
          this.players[0].strafeReleaseHook = true;
        }
        if (
          state === false &&
          this.players[0].moving.state !== true &&
          this.keyPressed[0].strafe === true
        ) {
          this.players[0].strafeReleaseHook = true;
        } else {
          this.keyPressed[0].strafe = state;
          this.players[0].strafing.state = state;
          this.currentPlayer = 1;
        }
        break;
      case "q":
        this.keyPressed[0].cycleWeapon = state;
        this.currentPlayer = 1;
        break;
      case "e":
        this.keyPressed[0].cycleArmor = state;
        this.currentPlayer = 1;
        break;
      case "2":
        this.keyPressed[0].discardWeapon = state;
        this.currentPlayer = 1;
        break;
      case "3":
        this.keyPressed[0].discardArmor = state;
        this.currentPlayer = 1;
        break;
      case "Control":
        this.keyPressed[0].playerMenu = state;
        this.currentPlayer = 1;
        break;
      case "5":
        this.keyPressed[0].uiMenu = state;
        this.currentPlayer = 1;
        break;
      case "4":
        this.showSettingsKeyPress.state = state;
        this.currentPlayer = 1;
        break;
      case "1":
        if (this.players[0].dead.state === true) {
          this.respawn(this.players[0]);
        }
        break;
      case "z":
        this.keyPressed[0].rotateLeft = state;
        this.currentPlayer = 1;
        break;
      case "x":
        this.keyPressed[0].rotateRight = state;
        this.currentPlayer = 1;
        break;

      case "6":
        this.toggleCameraMode = state;
        break;
      case "7":
        this.addAiPlayerKeyPress = state;
        break;
      case "`":
        this.gameReset("soft");
        break;

      case "i":
        this.keyPressed[1].north = state;
        // direction = 'north';
        this.players[1].turnCheckerDirection = "north";
        this.currentPlayer = 2;
        break;

      case "j":
        this.keyPressed[1].west = state;
        // direction = 'west';
        this.players[1].turnCheckerDirection = "west";
        this.currentPlayer = 2;
        break;
      case "k":
        this.keyPressed[1].south = state;
        // direction = 'south';
        this.players[1].turnCheckerDirection = "south";
        this.currentPlayer = 2;
        break;
      case "l":
        this.keyPressed[1].east = state;
        // direction = 'east';
        this.players[1].turnCheckerDirection = "east";
        this.currentPlayer = 2;
        break;
      case ";":
        this.keyPressed[1].attack = state;
        this.currentPlayer = 2;
        break;
      case ".":
        this.keyPressed[1].defend = state;
        this.currentPlayer = 2;
        break;
      case "'":
        this.keyPressed[1].dodge = state;
        this.currentPlayer = 2;
        break;
      case "p":
        this.keyPressed[1].pull = state;
        this.currentPlayer = 2;
        break;
      case "Enter":
        this.keyPressed[1].kick = state;
        this.currentPlayer = 2;
        break;
      case "/":
        if (
          state === false &&
          this.players[1].moving.state === true &&
          this.players[1].strafing.state === true
        ) {
          this.players[1].strafeReleaseHook = true;
        }
        if (
          state === false &&
          this.players[1].moving.state !== true &&
          this.keyPressed[1].strafe === true
        ) {
          this.players[1].strafeReleaseHook = true;
        } else {
          this.keyPressed[1].strafe = state;
          this.players[1].strafing.state = state;
          this.currentPlayer = 2;
        }
        break;

      case "u":
        this.keyPressed[1].cycleWeapon = state;
        this.currentPlayer = 2;
        break;
      case "o":
        this.keyPressed[1].cycleArmor = state;
        this.currentPlayer = 2;
        break;
      case "8":
        this.keyPressed[1].discardWeapon = state;
        this.currentPlayer = 2;
        break;
      case "9":
        this.keyPressed[1].discardArmor = state;
        this.currentPlayer = 2;
        break;
      case "Shift":
        if (event.code === "ShiftRight") {
          this.keyPressed[1].playerMenu = state;
          this.currentPlayer = 2;
        }
        break;
      case "0":
        this.keyPressed[1].uiMenu = state;
        this.currentPlayer = 2;
        break;

      case "=":
        if (this.players[1].dead.state === true) {
          this.respawn(this.players[1]);
        }
        break;
      case "-":
        this.showSettingsKeyPress.state = state;
        this.currentPlayer = 2;
        break;
      case "[":
        this.keyPressed[1].rotateLeft = state;
        this.currentPlayer = 2;
        break;
      case "]":
        this.keyPressed[1].rotateRight = state;
        this.currentPlayer = 2;
        break;
      default:
        break;
    }

    let player = this.players[this.currentPlayer - 1];

    // STEP GAME ON KEYPRESS FOR DEBUGGING
    // for (const player of this.players) {
    //   this.playerUpdate(player, this.state.canvas, this.state.context, this.state.canvas2, this.state.context2);
    // }
    // this.time++
    // this.setState({
    //   stateUpdater: '..'
    // })
  };
  handleGamepadEvent = (event, type) => {
    if (type === "disconnected") {
      this.connectedGamepadsInit = false;
      this.showSettingsKeyPress.state = true;
      console.log(
        "connected gamepads state change! please re-configure controller/gamepad settings"
      );
    }
  };

  setCellInfoMouseOver = (state, origin) => {
    // console.log('setCellInfoMouseOver',state,origin);

    this.cellInfoMouseOver = state;
    if (state === true) {
      this.showCellInfoBox = true;
      if (this.mouseOverCellSwitchOff.state === true) {
        this.mouseOverCellSwitchOff.state = false;
      }
      if (this.mouseOverCell.cell && this.mouseOverCell.state !== true) {
        this.mouseOverCell = {
          state: false,
          cell: undefined,
          count: 0,
          threshold: this.mouseOverCell.threshold,
        };
      }
    } else {
    }
  };
  closeCellInfoBox = () => {
    this.cellInfoMouseOver = false;
    this.showCellInfoBox = !this.showCellInfoBox;
    if (this.mouseOverCellSwitchOff.state === true) {
      this.mouseOverCellSwitchOff.state = false;
    }

    if (this.mouseOverCell.cell && this.mouseOverCell.state !== true) {
      // this.mouseOverCell.cell = {
      //   state: false,
      //   cell: undefined,
      //   count: 0,
      //   threshold: this.mouseOverCell.threshold,
      // };
    }
  };
  loadSettings = (event) => {
    event.preventDefault();

    let gridSize = event.target.gridSize.value;

    let playerNumber = event.target.humanPlayers.value;
    let aiPlayerNumber = event.target.aiCount.value;

    switch (gridSize) {
      case "3":
        this.gridWidth = 3;
        this.sceneY = this.state.sceneY.three;
        break;
      case "6":
        this.gridWidth = 6;
        this.sceneY = this.state.sceneY.six;
        break;
      case "9":
        this.gridWidth = 9;
        this.sceneY = this.state.sceneY.nine;
        break;
      case "12":
        this.gridWidth = 12;
        this.sceneY = this.state.sceneY.twelve;
        break;
    }

    if (this.gridWidth >= 12) {
      if (window.innerWidth < 1100) {
        this.zoomThresh = -0.25;
      } else {
        this.zoomThresh = -0.05;
      }
    } else {
      // this.zoomThresh = -.05;
      this.zoomThresh = 0;
    }

    this.gamepadConfig = [];
    for (const plyr2 of this.settingsFormPlayerData.input) {
      this.gamepadConfig.push({
        plyrNo: plyr2.plyrNo,
        input: plyr2.input,
        type: "",
        id: "",
        mapping: "",
        gamepadIndex: undefined,
      });
      if (plyr2.input === "Gamepad") {
        this.gamepad = true;
      }
      this.players[plyr2.plyrNo - 1].input = plyr2.input;
    }
    if (!this.settingsFormPlayerData.input.find((x) => x.input === "Gamepad")) {
      this.gamepad = false;
    }
    this.connectedGamepadsInit = false;

    for (const plyr3 of this.settingsFormPlayerData.team) {
      this.players[plyr3.plyrNo - 1].team = plyr3.team;
    }

    // console.log('load settings this.gamepadConfig',this.gamepadConfig);

    if (playerNumber < 2) {
      this.players.splice(1, 1);
      this.playerNumber = 1;
    } else {
      this.playerNumber = 2;
    }

    for (const plyr of this.settingsFormPlyrStartPosList) {
      this.players[plyr.plyrNo - 1].startPosition.cell.number = plyr.selected;
    }

    if (this.updateSettingsFormAiDataData.startItems === true) {
      this.disableInitItems = false;
    } else {
      this.disableInitItems = true;
    }

    this.gameReset("hard");

    // this.placeItems({init: true, items: ''});

    if (aiPlayerNumber > 0) {
      this.loadAiSettings();
    } else {
      this.updateSettingsFormAiDataData = {
        // count: {
        //   count: '0'
        // }
      };
      this.settingsFormAiStartPosList = [];
      this.setState({
        showSettings: false,
      });
      this.showSettingsCanvasData.state = false;
    }

    // console.log('this.settingsFormPlyrStartPosList',this.settingsFormPlyrStartPosList);
    // console.log('this.updateSettingsFormAiData',this.updateSettingsFormAiDataData);
    // console.log('this.settingsFormAiStartPosList',this.settingsFormAiStartPosList);
  };
  loadAiSettings = () => {
    // console.log('this.settingsFormAiStartPosList.length',this.settingsFormAiStartPosList.length);

    // if (this.settingsFormAiStartPosList.length > 0) {

    let initArray = this.updateSettingsFormAiDataData.random.map(
      (x) =>
        (x = {
          plyrNo: x.plyrNo,
          random: x.random,
          mode: null,
          weapon: null,
          armor: null,
          team: null,
          mission: null,
          startPos: null,
          otherPositions: [],
        })
    );

    for (const plyr of initArray) {
      for (const elem of this.updateSettingsFormAiDataData.mode) {
        if (elem.plyrNo === plyr.plyrNo) {
          if (elem.mode === "random") {
            let whatMode = this.rnJesus(1, 2);

            switch (whatMode) {
              case 1:
                elem.mode = "aggressive";
                break;
              case 2:
                elem.mode = "careful";
                break;
            }
          }

          plyr.mode = elem.mode;
        }
      }

      for (const elem2 of this.updateSettingsFormAiDataData.weapon) {
        if (elem2.plyrNo === plyr.plyrNo) {
          plyr.weapon = elem2.weapons;
        }
      }

      for (const elem5 of this.updateSettingsFormAiDataData.armor) {
        if (elem5.plyrNo === plyr.plyrNo) {
          plyr.armor = elem5.armor;
        }
      }

      for (const elem3 of this.updateSettingsFormAiDataData.mission) {
        if (elem3.plyrNo === plyr.plyrNo) {
          plyr.mission = elem3.mission;
        }
      }

      for (const elem6 of this.updateSettingsFormAiDataData.team) {
        if (elem6.plyrNo === plyr.plyrNo) {
          plyr.team = elem6.team;
        }
      }

      for (const elem4 of this.settingsFormAiStartPosList) {
        if (elem4.plyrNo === plyr.plyrNo) {
          for (const cell of elem4.selected) {
            if (cell.type === "start") {
              plyr.startPos = cell.cell;
            } else {
              plyr.otherPositions.push(cell.cell);
            }
          }
        }
      }
    }

    if (this.updateSettingsFormAiDataData.startItems === true) {
      this.disableInitItems = false;
    } else {
      this.disableInitItems = true;
    }

    // console.log('initArray',initArray);

    for (let i = 1; i < initArray.length + 1; i++) {
      setTimeout(() => {
        // setTimeout(function timer() {

        let elem5 = initArray[i - 1];

        // console.log('plyr',elem5.plyrNo,'this.addAiCount.state',this.addAiCount.state);

        if (elem5.random === "random") {
          this.addAiRandomPlayer(elem5.random);
        } else {
          this.aiInitSettings = {
            randomStart: false,
            startPosition: {
              number: {
                x: elem5.startPos.x,
                y: elem5.startPos.y,
              },
            },
            primaryMission: elem5.mission,
            mission: undefined,
            mode: elem5.mode,
            partolArea: elem5.otherPositions,
            weapons: elem5.weapon,
            armor: elem5.armor,
            team: elem5.team,
          };

          this.addAiPlayer();
        }
      }, i * 1000);
    }

    // this.updateSettingsFormAiDataData = {};
    // this.settingsFormAiStartPosList = [];
    this.setState({
      showSettings: false,
    });

    // }
  };
  cancelSettings = () => {
    // this.updateSettingsFormAiDataData = {};
    this.settingsFormAiStartPosList = [];
    this.setState({
      showSettings: false,
    });
    this.showSettingsCanvasData.state = false;
  };
  openSettings = () => {
    this.setState({
      showSettings: true,
    });

    // if (this.showSettingsCanvasData.state === true) {
    //   this.settingsFormGridWidthUpdate(this.settingsGridWidth)
    // }
    //
    // this.settingsFormAiGridInfo = this.gridInfo;
    //
    // this.getCustomPlyrStartPosList(
    //   [
    //     {
    //       plyrNo: 1,
    //       selected: undefined,
    //       posArray: []
    //     },
    //     {
    //       plyrNo: 2,
    //       selected: undefined,
    //       posArray: []
    //     }
    //   ]
    // )
  };
  expandDebugBox = (plyrNo) => {
    if (plyrNo === 1) {
      this.debugBoxStyle = "debugDisplay openDebug";
    }
    if (plyrNo === 2) {
      this.debugBoxStyle2 = "debugDisplay2 openDebug";
    }
  };
  minimizeDebugBox = (plyrNo) => {
    if (plyrNo === 1) {
      this.debugBoxStyle = "debugDisplay closedDebug";
    }
    if (plyrNo === 2) {
      this.debugBoxStyle2 = "debugDisplay2 closedDebug";
    }
  };

  getCustomPlyrStartPosList = (args) => {
    // console.log('getCustomPlyrStartPosList',this.gridInfo.length,args);
    this.settingsFormPlyrGridInfo = this.gridInfo;

    this.playerNumber = args.length;

    let avoidCells = [];

    this.settingsFormPlyrStartPosList = [];

    for (const plyr of args) {
      let array1 = [];

      // AVOID ALREADY SELECTRED POSITIONS
      if (plyr.selected) {
        avoidCells.push(plyr.selected);
      }

      // NO POSITION SELECTED, GAME STARTING. USE DEFAULT START POSITIONS
      if (!plyr.selected) {
        if (
          !this.gridInfo.find(
            (x) =>
              x.number.x === this.players[plyr.plyrNo - 1].startPosition.cell.number.x &&
              x.number.y === this.players[plyr.plyrNo - 1].startPosition.cell.number.y
          )
        ) {
          let cll = { x: undefined, y: undefined };
          let randomFreeCellChosen = false;

          while (randomFreeCellChosen !== true) {
            cll.x = this.rnJesus(0, this.gridWidth);
            cll.y = this.rnJesus(0, this.gridWidth);
            randomFreeCellChosen = this.checkCell(cll);
          }

          if (randomFreeCellChosen === true) {
            this.players[plyr.plyrNo - 1].startPosition.cell.number = cll;
          }
        }

        let playerStartPos = this.players[plyr.plyrNo - 1].startPosition.cell.number;

        avoidCells.push({ x: playerStartPos.x, y: playerStartPos.y });
      }

      // CHECK FOR AI POSITIONS TO ADD TO CELLS TO AVOID
      if (this.updateSettingsFormAiDataData.count) {
        if (parseInt(this.updateSettingsFormAiDataData.count.count) > 0) {
          for (const plyr2 of this.settingsFormAiStartPosList) {
            for (const selected of plyr2.selected) {
              avoidCells.push(selected.cell);
            }
          }
        }
      }

      // BUILD AVALIBLE POSITION ARRAY EXCLUDING CELLS TO AVOID

      for (const elem of this.settingsFormPlyrGridInfo) {
        if (
          this.plyrStartPosCheckCell({ x: elem.number.x, y: elem.number.y }) === true &&
          !avoidCells.find(
            (elem2) => elem2.x === elem.number.x && elem2.y === elem.number.y
          )
        ) {
          array1.push({ x: elem.number.x, y: elem.number.y });
        }
      }

      // NO POSITION SELECTED, GAME STARTING. MARK PLAYR POSITION SELECTED
      if (!plyr.selected) {
        let playerStartPos = this.players[plyr.plyrNo - 1].startPosition.cell.number;

        plyr.selected = { x: playerStartPos.x, y: playerStartPos.y };
      }

      // PUSH TO SETTINGS PLAYER POSITION DATA
      this.settingsFormPlyrStartPosList.push({
        plyrNo: plyr.plyrNo,
        posArray: array1,
        selected: plyr.selected,
      });

      // FORCE STATE UPDATE FOR SETTINGS COMPONENT
      this.setState({
        stateUpdater: "..",
      });
    }
    // console.log('this.settingsFormPlyrStartPosList',this.settingsFormPlyrStartPosList);

    // ADD 'RANDOM' CHOICE TO NEW POSITION AVAILIBLE ARRAY
    let lastAvailiblePosArray =
      this.settingsFormPlyrStartPosList[this.settingsFormPlyrStartPosList.length - 1]
        .posArray;
    let hasRandomCell = lastAvailiblePosArray.find((x) => x === "random");
    if (!hasRandomCell) {
      lastAvailiblePosArray.push("random");
    }
    // console.log('lastAvailiblePosArray',lastAvailiblePosArray);
    for (const elem of this.settingsFormPlyrStartPosList) {
      // console.log('elem',elem);
      elem.posArray = lastAvailiblePosArray;
    }

    this.setState({
      stateUpdater: "..",
    });

    this.settingsFormGridWidthUpdate(this.settingsGridWidth);

    // console.log('this.settingsFormPlyrStartPosList',this.settingsFormPlyrStartPosList);
  };
  plyrStartPosCheckCell = (cell) => {
    let cellFree = true;
    let cell2 = this.gridInfo.find(
      (elem) => elem.number.x === cell.x && elem.number.y === cell.y
    );
    // if (
    //   cell2.levelData.charAt(0) ===  'z' ||
    //   cell2.levelData.charAt(0) ===  'y'
    // ) {
    //   cellFree = false;
    // }
    // if (cell2.item.name !== '') {
    //   cellFree = false;
    // }
    // if (
    //   cell2.terrain.type === 'deep' ||
    //   cell2.terrain.type === 'hazard'
    // ) {
    //   cellFree = false;
    // }

    if (
      cell2.obstacle.state === true ||
      // cell2.barrier.state === true ||
      cell2.item.name !== "" ||
      cell2.terrain.type === "deep" ||
      cell2.terrain.type === "hazard"
    ) {
      cellFree = false;
    }

    // PLAYERS 1&2 ALT RESPAWN POINTS!
    if (cell.x === this.gridWidth && cell.y === this.gridWidth) {
      cellFree = false;
    }
    if (cell.x === this.gridWidth && cell.y === 0) {
      cellFree = false;
    }

    return cellFree;
  };
  getCustomAiStartPosList = (args) => {
    // console.log('getCustomAiStartPosList',args);

    let avoidCells = [];

    if (args.length === 0) {
      this.settingsFormAiStartPosList = [];

      this.setState({
        stateUpdater: "..",
      });
    } else {
      avoidCells = [];
      this.settingsFormAiStartPosList = [];
      for (const plyr of args) {
        // switch(plyr.mission) {
        //   case 'pursue':
        //
        //   break;
        //   case 'patrol':
        //   break;
        //   case 'defend':
        //   break;
        // }

        let array1 = [];
        if (plyr.selected.length > 0) {
          for (const selected of plyr.selected) {
            avoidCells.push(selected.cell);
          }
        }

        if (this.settingsFormPlyrStartPosList[0]) {
          for (const plyr2 of this.settingsFormPlyrStartPosList) {
            avoidCells.push(plyr2.selected);
          }
        }

        for (const elem of this.settingsFormAiGridInfo) {
          if (
            this.checkCell({ x: elem.number.x, y: elem.number.y }) === true &&
            !avoidCells.find(
              (elem2) => elem2.x === elem.number.x && elem2.y === elem.number.y
            )
          ) {
            array1.push({ x: elem.number.x, y: elem.number.y });
          }
        }
        // console.log('this.settingsFormAiGridInfo',this.settingsFormAiGridInfo);
        // console.log('array1',array1);

        if (plyr.selected.length === 0) {
          let doubleCheckArray = array1;

          if (plyr.mission === "patrol") {
            avoidCells.push({ x: array1[0].x, y: array1[0].y });
            avoidCells.push({ x: array1[1].x, y: array1[1].y });
            avoidCells.push({ x: array1[2].x, y: array1[2].y });

            plyr.selected.push({
              type: "start",
              cell: { x: array1[0].x, y: array1[0].y },
            });
            plyr.selected.push({
              type: "patrol1",
              cell: { x: array1[1].x, y: array1[1].y },
            });
            plyr.selected.push({
              type: "patrol2",
              cell: { x: array1[2].x, y: array1[2].y },
            });

            doubleCheckArray = array1.filter((i) => i !== array1[0]);
            doubleCheckArray = doubleCheckArray.filter((i) => i !== array1[1]);
            doubleCheckArray = doubleCheckArray.filter((i) => i !== array1[2]);
          }
          if (plyr.mission === "defend") {
            avoidCells.push({ x: array1[0].x, y: array1[0].y });
            avoidCells.push({ x: array1[1].x, y: array1[1].y });

            plyr.selected.push({
              type: "start",
              cell: { x: array1[0].x, y: array1[0].y },
            });
            plyr.selected.push({
              type: "defend",
              cell: { x: array1[1].x, y: array1[1].y },
            });

            doubleCheckArray = array1.filter((i) => i !== array1[0]);
            doubleCheckArray = doubleCheckArray.filter((i) => i !== array1[1]);
          }
          if (plyr.mission === "pursue") {
            avoidCells.push({ x: array1[0].x, y: array1[0].y });

            plyr.selected.push({
              type: "start",
              cell: { x: array1[0].x, y: array1[0].y },
            });

            doubleCheckArray = array1.filter((i) => i !== array1[0]);
          }

          array1 = doubleCheckArray;
        }

        this.settingsFormAiStartPosList.push({
          plyrNo: plyr.plyrNo,
          mission: plyr.mission,
          posArray: array1,
          selected: plyr.selected,
        });

        this.setState({
          stateUpdater: "..",
        });
      }

      let lastAvailiblePosArray =
        this.settingsFormAiStartPosList[this.settingsFormAiStartPosList.length - 1]
          .posArray;
      let hasRandomCell = lastAvailiblePosArray.find((x) => x === "random");
      if (!hasRandomCell) {
        lastAvailiblePosArray.push("random");
      }

      for (const elem of this.settingsFormAiStartPosList) {
        // console.log('elem',elem);
        elem.posArray = lastAvailiblePosArray;
      }

      this.setState({
        stateUpdater: "..",
      });
    }
    // console.log('updateSettingsFormAiData',this.updateSettingsFormAiDataData);
    this.settingsFormGridWidthUpdate(this.settingsGridWidth);
  };
  settingsFormGridWidthUpdate = (args) => {
    // console.log('settingsFormGridWidthUpdate args',args);

    // this.showSettingsCanvasData = {
    //   state: true,
    //   field: 'human_start',
    //   plyrNo: 1,
    //   type: 'start',
    // }

    if (this.gridWidth <= 9) {
      this.camera.zoom.x = 1;
      this.camera.zoom.y = 1;
    }

    let prevGridWidth = this.gridWidth;
    let canvas = this.state.canvas;

    this.gridWidth = args;

    let gridInfo;

    // ----------------
    this.startProcessLevelData(this.state.canvas);
    gridInfo = this.gridInfo;
    this.processLevelData(gridInfo);
    // ----------------

    // this.settingsFormAiGridInfo = this.gridInfo;
    this.settingsFormAiGridInfo = this.settingsGridInfo;

    // console.log('post process barrier check settings',this.settingsGridInfo.filter(x => x.barrier.state === true).map(y => y = y.barrier.position));

    this.settingsGridWidth = args;

    if (this.settingsGridWidth === 12) {
      this.settingsCanvasWidth = 700;
      this.settingsCanvasHeight = 400;
      this.settingsSceneX = 350;
      this.settingsSceneY = 50;
    }
    if (this.settingsGridWidth === 9) {
      this.settingsCanvasWidth = 500;
      this.settingsCanvasHeight = 300;
      this.settingsSceneX = 250;
      this.settingsSceneY = 40;
    }
    if (this.settingsGridWidth === 6) {
      this.settingsCanvasWidth = 400;
      this.settingsCanvasHeight = 250;
      this.settingsSceneX = 200;
      this.settingsSceneY = 50;
    }
    if (this.settingsGridWidth === 3) {
      this.settingsCanvasWidth = 300;
      this.settingsCanvasHeight = 150;
      this.settingsSceneX = 150;
      this.settingsSceneY = 40;
    }

    if (this.state.showSettings === true && this.showSettingsCanvasData.state === true) {
      let canvas3 = this.canvasRef3.current;
      let context3 = canvas3.getContext("2d");

      canvas3.addEventListener("click", (e) => {
        this.getSettingsCanvasClick(canvas3, e);
      });

      let canvas4;
      let context4;

      if (this.showSettingsCanvasData.field.split("_")[0] === "ai") {
        canvas4 = this.canvasRef4.current;
        context4 = canvas4.getContext("2d");
        canvas4.addEventListener("click", (e) => {
          this.getSettingsCanvasClick(canvas4, e);
        });
      }

      setTimeout(() => {
        this.redrawSettingsGrid(canvas3, context3, canvas4, context4);
      }, 30);
    }

    // this.redrawSettingsGrid(this.state.canvas3,this.state.context3);

    // this.gridWidth = prevGridWidth;

    // ----------------
    // this.startProcessLevelData(this.state.canvas);
    // gridInfo = this.gridInfo;
    // this.processLevelData(gridInfo);
    // ----------------

    // this.setState({
    //   stateUpdater: '..'
    // })
  };
  updateSettingsFormAiData = (args) => {
    this.updateSettingsFormAiDataData = {
      startItems: args.startItems,
      count: args.count,
      random: args.random,
      mode: args.mode,
      weapon: args.weapon,
      armor: args.armor,
      team: args.team,
      mission: args.mission,
    };
    this.setState({
      stateUpdater: "..",
    });
    // console.log('updateSettingsFormAiData',this.updateSettingsFormAiDataData);
    this.settingsFormGridWidthUpdate(this.settingsGridWidth);
  };
  redrawSettingsGrid = (canvas3, context3, canvas4, context4) => {
    // console.log('redrawSettingsGrid',this.settingsFormPlyrStartPosList);

    let takenSpaces = [];
    for (const elem of this.settingsFormPlyrStartPosList) {
      takenSpaces.push({
        plyrNo: elem.plyrNo,
        type: "start",
        pos: {
          x: elem.selected.x,
          y: elem.selected.y,
        },
      });
    }
    for (const elem2 of this.settingsFormAiStartPosList) {
      let humanPlyrCount = this.settingsFormPlyrStartPosList.length;
      let plyrNo = humanPlyrCount + elem2.plyrNo;

      for (const elem3 of elem2.selected) {
        takenSpaces.push({
          plyrNo: plyrNo,
          type: elem3.type,
          pos: {
            x: elem3.cell.x,
            y: elem3.cell.y,
          },
        });
      }
    }

    let floorImageWidth = this.floorImageWidth;
    let floorImageHeight = this.floorImageHeight;
    let wallImageWidth = this.wallImageWidth;
    let wallImageHeight = this.wallImageHeight;
    let sceneX = this.settingsSceneX;
    let sceneY = this.settingsSceneY;
    let tileWidth = this.tileWidth;

    let wall = this.wallRef.current;
    let wall2 = this.wall2Ref.current;
    let wall3 = this.wall3Ref.current;

    let floorImgs = this.floorImgs;
    let obstacleImgs = this.obstacleImgs;
    let barrierImgs = this.barrierImgs;

    class Point {
      constructor(x, y) {
        this.x = x;
        this.y = y;
      }
    }

    for (var x = 0; x < this.settingsGridWidth + 1; x++) {
      for (var y = 0; y < this.settingsGridWidth + 1; y++) {
        let p2 = new Point();
        p2.x = x * (tileWidth / 2);
        p2.y = y * (tileWidth / 2);

        let iso2 = this.cartesianToIsometric(p2);
        let offset2 = { x: floorImageWidth / 2 / 2, y: floorImageHeight / 2 };

        // apply offset to center scene for a better view
        iso2.x += sceneX;
        iso2.y += sceneY;

        let center2 = {
          x: iso2.x - offset2.x / 2 + this.cellCenterOffsetX / 2,
          y: iso2.y - offset2.y / 2 - this.cellCenterOffsetY / 2,
        };

        let cell = this.settingsGridInfo.find(
          (elem) => elem.number.x === x && elem.number.y === y
        );
        let cellLevelData = this.settingsGridInfo.find(
          (elem) => elem.number.x === x && elem.number.y === y
        ).levelData;

        let floor = floorImgs[cell.terrain.name];

        if (cell.void.state === true) {
          // drawFloor = false;
          floor = floorImgs.void3;
        }

        if (x === this.gridWidth && y === this.gridWidth) {
          floor = floorImgs.void2;
        }
        if (x === this.gridWidth && y === 0) {
          floor = floorImgs.void2;
        }

        context3.drawImage(floor, iso2.x - offset2.x, iso2.y - offset2.y, 50, 50);

        context3.fillStyle = "black";
        context3.fillText(
          "" + x + "," + y + "",
          iso2.x - offset2.x / 2 + 5,
          iso2.y - offset2.y / 2 + 2
        );

        // context3.fillStyle = "black";
        // context3.fillRect(center2.x, center2.y,2.5,2.5);

        if (context4) {
          context4.drawImage(floor, iso2.x - offset2.x, iso2.y - offset2.y, 50, 50);
          context4.fillStyle = "black";
          context4.fillText(
            "" + x + "," + y + "",
            iso2.x - offset2.x / 2 + 5,
            iso2.y - offset2.y / 2 + 2
          );
        }

        let vertices = [
          { x: center2.x, y: center2.y + this.tileWidth / 4 },
          { x: center2.x + this.tileWidth / 2, y: center2.y },
          { x: center2.x, y: center2.y - this.tileWidth / 4 },
          { x: center2.x - this.tileWidth / 2, y: center2.y },
        ];

        for (const vertex of vertices) {
          context3.fillStyle = "yellow";
          context3.fillRect(vertex.x - 1.5, vertex.y - 1.5, 2.5, 2.5);
          if (context4) {
            context4.fillStyle = "yellow";
            context4.fillRect(vertex.x - 1.5, vertex.y - 1.5, 2.5, 2.5);
          }
        }

        // TAKEN POSITIONS HIGHLIGHT!!
        let floorHighlight;
        for (const space of takenSpaces) {
          if (x === space.pos.x && y === space.pos.y) {
            switch (space.plyrNo) {
              case 1:
                floorHighlight = "blue";
                break;
              case 2:
                floorHighlight = "red";
                break;
              case 3:
                floorHighlight = "green";
                break;
              case 4:
                floorHighlight = "purple";
                break;
              case 5:
                floorHighlight = "orange";
                break;
              case 6:
                floorHighlight = "black";
                break;
            }
            context3.lineWidth = 5;
            context3.beginPath();
            if (context4) {
              context4.lineWidth = 5;
              context4.beginPath();
            }
            for (const vertex of vertices) {
              context3.strokeStyle = floorHighlight;
              context3.lineTo(vertex.x, vertex.y);
              if (context4) {
                context4.strokeStyle = floorHighlight;
                context4.lineTo(vertex.x, vertex.y);
              }
            }
            context3.closePath();
            context3.stroke();
            if (context4) {
              context4.closePath();
              context4.stroke();
            }
          }
        }

        // BARRIERS & OBSTACLES

        if (cell.obstacle.state === true && cell.void.state !== true) {
          // let offset = {x: wallImageWidth/4, y: wallImageHeight/2}
          let obstacleImg = obstacleImgs[cell.obstacle.type];

          context3.drawImage(
            obstacleImg,
            iso2.x - offset2.x,
            iso2.y - obstacleImg.height / 2,
            obstacleImg.width / 2,
            obstacleImg.height / 2
          );
          if (context4) {
            context4.drawImage(
              obstacleImg,
              iso2.x - offset2.x,
              iso2.y - obstacleImg.height / 2,
              obstacleImg.width / 2,
              obstacleImg.height / 2
            );
          }
        }

        if (cell.barrier.state === true && cell.void.state !== true) {
          let barrierImg = barrierImgs[cell.barrier.type][cell.barrier.position];
          context3.drawImage(
            barrierImg,
            iso2.x - offset2.x,
            iso2.y - barrierImg.height / 2,
            barrierImg.width / 2,
            barrierImg.height / 2
          );
          if (context4) {
            context4.drawImage(
              barrierImg,
              iso2.x - offset2.x,
              iso2.y - barrierImg.height / 2,
              barrierImg.width / 2,
              barrierImg.height / 2
            );
          }
        }
      }
    }

    this.setState({
      stateUpdater: "..",
    });
  };
  updateSettingsCanvasData = (args) => {
    // console.log('updateSettingsCanvasData',args);

    let el = document.getElementsByClassName("settingsOverlay")[0];
    let el2 = document.getElementsByClassName("settingsContainer")[0];
    // console.log('xx',el.scrollLeft, el.scrollTop);
    // console.log('xx',el2.scrollLeft, el2.scrollTop);

    let humanPlyrCount = this.settingsFormPlyrStartPosList.length;
    let plyrNo = args.plyrNo;
    if (args.type.split("_")[0] === "ai") {
      plyrNo = humanPlyrCount + args.plyrNo;
    }

    this.showSettingsCanvasData = {
      state: true,
      field: args.type,
      plyrNo: plyrNo,
      type: args.type.split("_")[1],
    };

    this.setState({
      stateUpdater: "..",
    });

    setTimeout(() => {
      // this.redrawSettingsGrid(canvas3,context3,canvas4,context4);
      this.settingsFormGridWidthUpdate(this.settingsGridWidth);
    }, 30);
    // this.settingsFormGridWidthUpdate(this.settingsGridWidth)

    // this.setState({
    //   stateUpdater: '..'
    // })
  };
  updateSettingsFormPlayerData = (args) => {
    this.settingsFormPlayerData = args;

    this.setState({
      stateUpdater: "..",
    });
  };

  findFocusCell = (inputType, inputSubType, focus, canvas, context, speed) => {
    let cell = {
      x: undefined,
      y: undefined,
    };
    let direction = "";
    let cellOffsetX = 0;
    let cellOffsetY = 0;
    let centerCellRef = {
      x: 4,
      y: 4,
    };
    let newCell = {
      x: undefined,
      y: undefined,
    };

    if (inputType === "cellToPan") {
      let destCell = focus;
      let originCell = {
        x: this.camera.focusCell.x,
        y: this.camera.focusCell.y,
      };
      // let originCell = this.camera.cellToPanOrigin;
      let x1 = originCell.x;
      let y1 = originCell.y;
      let x2 = destCell.x;
      let y2 = destCell.y;
      let xSteps = 0;
      let ySteps = 0;
      let xDirection = "";
      let yDirection = "";
      let preInstructions = [];

      if (x1 > x2) {
        xDirection = "west";
        xSteps = x1 - x2;
      }
      if (x2 > x1) {
        xDirection = "east";
        xSteps = x2 - x1;
      }
      if (y1 > y2) {
        yDirection = "north";
        ySteps = y1 - y2;
      }
      if (y2 > y1) {
        yDirection = "south";
        ySteps = y2 - y1;
      }

      let sameCell = originCell.x === destCell.x && originCell.y === destCell.y;
      let cancelPath = false;
      let pathSet = [];
      this.updatePathArray();
      this.easyStar = new Easystar.js();
      this.easyStar.setGrid(this.pathArray);
      this.easyStar.setAcceptableTiles([0]);
      this.easyStar.enableDiagonals();

      let test2 = this.easyStar.findPath(
        originCell.x,
        originCell.y,
        destCell.x,
        destCell.y,
        function (path) {
          if (path === null) {
            cancelPath = true;
            console.log("Path was not found");
          } else {
            pathSet = path;
          }
        }
      );
      this.easyStar.setIterationsPerCalculation(1000);
      this.easyStar.calculate();
      setTimeout(() => {
        if (cancelPath === true) {
          console.log("cancel path");
          this.easyStar = new Easystar.js();
        } else {
          // console.log("path setA", pathSet);
          finish();
        }
      }, 30);

      const finish = () => {
        let indx = 0;

        for (const cell of pathSet) {
          if (indx < pathSet.length - 1) {
            let pointA = cell;
            let pointB = pathSet[indx + 1];
            let direction;

            if (pointA.x - pointB.x === 1 && pointA.y - pointB.y === 1) {
              direction = "north";
            }
            if (pointA.x - pointB.x === 0 && pointA.y - pointB.y === 1) {
              direction = "northEast";
            }
            if (pointA.x - pointB.x === -1 && pointA.y - pointB.y === 1) {
              direction = "east";
            }
            if (pointA.x - pointB.x === -1 && pointA.y - pointB.y === 0) {
              direction = "southEast";
            }
            if (pointA.x - pointB.x === -1 && pointA.y - pointB.y === -1) {
              direction = "south";
            }
            if (pointA.x - pointB.x === 0 && pointA.y - pointB.y === -1) {
              direction = "southWest";
            }
            if (pointA.x - pointB.x === 1 && pointA.y - pointB.y === -1) {
              direction = "west";
            }
            if (pointA.x - pointB.x === 1 && pointA.y - pointB.y === 0) {
              direction = "northWest";
            }

            preInstructions.push(direction);
            indx++;
          }
        }

        let a = 50;
        let b = 100;

        const setMoveAndZoom = () => {
          let zoomCount = parseInt(inputSubType.split("_")[2]);
          let zoomDirection = inputSubType.split("_")[1];
          let panCount = preInstructions.length;
          let incr = 0;
          let remainder = 0;
          let greater = "";

          let finalArray = [];
          let indx2 = 0;
          // zoomCount = 10;
          // panCount = 3;

          if (zoomCount > panCount) {
            greater = "zoom";
            incr = Math.floor(zoomCount / panCount);
            remainder = zoomCount % panCount;

            for (let index = 0; index < panCount; index++) {
              finalArray.push("pan");
              for (let index2 = 0; index2 < incr; index2++) {
                finalArray.push("zoom");
              }
            }
            if (remainder > 0) {
              for (let index = 0; index < remainder; index++) {
                finalArray.push("zoom");
              }
            }
          }

          if (panCount > zoomCount) {
            greater = "pan";
            incr = Math.floor(panCount / zoomCount);
            remainder = panCount % zoomCount;
            for (let index = 0; index < zoomCount; index++) {
              finalArray.push("zoom");
              for (let index2 = 0; index2 < incr; index2++) {
                finalArray.push("pan");
              }
            }
            if (remainder > 0) {
              for (let index = 0; index < remainder; index++) {
                finalArray.push("pan");
              }
            }
          }

          // for (const elem of finalArray) {
          //   if (elem === "zoom") {
          //     this.camera.instructions.push({
          //       action: "zoom_in",
          //       action2: "",
          //       count: 0,
          //       count2: 0,
          //       limit: 1,
          //       limit2: 0,
          //       speed: "",
          //     });
          //   }
          //   if (elem === "pan") {
          //     switch (preInstructions[indx2]) {
          //       case "north":
          //         this.camera.instructions.push({
          //           action: "pan_north",
          //           action2: "",
          //           count: 0,
          //           count2: 0,
          //           limit: a,
          //           limit2: 0,
          //           speed: speed,
          //         });
          //         break;
          //       case "northEast":
          //         this.camera.instructions.push({
          //           action: "pan_north",
          //           action2: "pan_east",
          //           count: 0,
          //           count2: 0,
          //           limit: a / 2,
          //           limit2: b / 2,
          //           speed: speed,
          //         });
          //         break;
          //       case "east":
          //         this.camera.instructions.push({
          //           action: "pan_east",
          //           action2: "",
          //           count: 0,
          //           count2: 0,
          //           limit: b,
          //           limit2: 0,
          //           speed: speed,
          //         });
          //         break;
          //       case "southEast":
          //         this.camera.instructions.push({
          //           action: "pan_south",
          //           action2: "pan_east",
          //           count: 0,
          //           count2: 0,
          //           limit: a / 2,
          //           limit2: b / 2,
          //           speed: speed,
          //         });
          //         break;
          //       case "south":
          //         this.camera.instructions.push({
          //           action: "pan_south",
          //           action2: "",
          //           count: 0,
          //           count2: 0,
          //           limit: a,
          //           limit2: 0,
          //           speed: speed,
          //         });
          //         break;
          //       case "southWest":
          //         this.camera.instructions.push({
          //           action: "pan_south",
          //           action2: "pan_west",
          //           count: 0,
          //           count2: 0,
          //           limit: a / 2,
          //           limit2: b / 2,
          //           speed: speed,
          //         });
          //         break;
          //       case "west":
          //         this.camera.instructions.push({
          //           action: "pan_west",
          //           action2: "",
          //           count: 0,
          //           count2: 0,
          //           limit: b,
          //           limit2: 0,
          //           speed: speed,
          //         });
          //         break;
          //       case "northWest":
          //         this.camera.instructions.push({
          //           action: "pan_north",
          //           action2: "pan_west",
          //           count: 0,
          //           count2: 0,
          //           limit: a / 2,
          //           limit2: b / 2,
          //           speed: speed,
          //         });
          //         break;
          //       default:
          //         break;
          //     }
          //     indx2++;
          //   }
          // }

          // console.log("finalArray", finalArray);

          let indx3 = 0;
          let limit = 0;
          let setCombinedInstruction = (args) => {
            let result = args;

            if (zoomCount > 0) {
              if (greater === "pan") {
                limit = zoomCount;
                if (indx3 < limit) {
                  if (result.action2 === "") {
                    result.action2 = "zoom_" + zoomDirection + "";
                    result.limit2 = 1;
                  } else {
                    result.action3 = "zoom_" + zoomDirection + "";
                    result.count3 = 0;
                    result.limit3 = 1;
                  }
                  indx3++;
                }
                if (indx3 >= limit) {
                  indx3 = 0;
                }
              }
              if (greater === "zoom") {
                limit = panCount;
                if (indx3 < limit) {
                  if (result.action2 === "") {
                    result.action2 = "zoom_" + zoomDirection + "";
                    result.limit2 = incr;
                  } else {
                    result.action3 = "zoom_" + zoomDirection + "";
                    result.count3 = 0;
                    result.limit3 = incr;
                  }
                  indx3++;
                }
                if (indx3 >= limit) {
                  indx3 = 0;
                }
              }
            }
            return result;
          };

          for (const preInstruction of preInstructions) {
            let completeInstruction = {};
            switch (preInstruction) {
              case "north":
                completeInstruction = setCombinedInstruction({
                  action: "pan_north",
                  action2: "",
                  count: 0,
                  count2: 0,
                  limit: a,
                  limit2: 0,
                  speed: speed,
                });
                break;
              case "northEast":
                completeInstruction = setCombinedInstruction({
                  action: "pan_north",
                  action2: "pan_east",
                  count: 0,
                  count2: 0,
                  limit: a / 2,
                  limit2: b / 2,
                  speed: speed,
                });
                break;
              case "east":
                completeInstruction = setCombinedInstruction({
                  action: "pan_east",
                  action2: "",
                  count: 0,
                  count2: 0,
                  limit: b,
                  limit2: 0,
                  speed: speed,
                });
                break;
              case "southEast":
                completeInstruction = setCombinedInstruction({
                  action: "pan_south",
                  action2: "pan_east",
                  count: 0,
                  count2: 0,
                  limit: a / 2,
                  limit2: b / 2,
                  speed: speed,
                });
                break;
              case "south":
                this.camera.instructions.push({
                  action: "pan_south",
                  action2: "",
                  count: 0,
                  count2: 0,
                  limit: a,
                  limit2: 0,
                  speed: speed,
                });
                break;
              case "southWest":
                completeInstruction = setCombinedInstruction({
                  action: "pan_south",
                  action2: "pan_west",
                  count: 0,
                  count2: 0,
                  limit: a / 2,
                  limit2: b / 2,
                  speed: speed,
                });
                break;
              case "west":
                completeInstruction = setCombinedInstruction({
                  action: "pan_west",
                  action2: "",
                  count: 0,
                  count2: 0,
                  limit: b,
                  limit2: 0,
                  speed: speed,
                });
                break;
              case "northWest":
                completeInstruction = setCombinedInstruction({
                  action: "pan_north",
                  action2: "pan_west",
                  count: 0,
                  count2: 0,
                  limit: a / 2,
                  limit2: b / 2,
                  speed: speed,
                });
                break;
              default:
                break;
            }
            this.camera.instructions.push(completeInstruction);
          }

          if (greater === "zoom" && remainder > 0) {
            if (
              this.camera.instructions[this.camera.instructions.length - 1].action2.split(
                "_"
              )[0] === "zoom"
            ) {
              this.camera.instructions[this.camera.instructions.length - 1].limit2 +=
                remainder;
            } else if (
              this.camera.instructions[this.camera.instructions.length - 1].action3.split(
                "_"
              )[0] === "zoom"
            ) {
              this.camera.instructions[this.camera.instructions.length - 1].limit3 +=
                remainder;
            }
          }
        };

        if (inputSubType.split("_")[0] === "move&&zoom") {
          setMoveAndZoom();
        } else {
          for (const instruction of preInstructions) {
            switch (instruction) {
              case "north":
                this.camera.instructions.push({
                  action: "pan_north",
                  action2: "",
                  count: 0,
                  count2: 0,
                  limit: a,
                  limit2: 0,
                  speed: speed,
                });
                break;
              case "northEast":
                this.camera.instructions.push({
                  action: "pan_north",
                  action2: "pan_east",
                  count: 0,
                  count2: 0,
                  limit: a / 2,
                  limit2: b / 2,
                  speed: speed,
                });
                break;
              case "east":
                this.camera.instructions.push({
                  action: "pan_east",
                  action2: "",
                  count: 0,
                  count2: 0,
                  limit: b,
                  limit2: 0,
                  speed: speed,
                });
                break;
              case "southEast":
                this.camera.instructions.push({
                  action: "pan_south",
                  action2: "pan_east",
                  count: 0,
                  count2: 0,
                  limit: a / 2,
                  limit2: b / 2,
                  speed: speed,
                });
                break;
              case "south":
                this.camera.instructions.push({
                  action: "pan_south",
                  action2: "",
                  count: 0,
                  count2: 0,
                  limit: a,
                  limit2: 0,
                  speed: speed,
                });
                break;
              case "southWest":
                this.camera.instructions.push({
                  action: "pan_south",
                  action2: "pan_west",
                  count: 0,
                  count2: 0,
                  limit: a / 2,
                  limit2: b / 2,
                  speed: speed,
                });
                break;
              case "west":
                this.camera.instructions.push({
                  action: "pan_west",
                  action2: "",
                  count: 0,
                  count2: 0,
                  limit: b,
                  limit2: 0,
                  speed: speed,
                });
                break;
              case "northWest":
                this.camera.instructions.push({
                  action: "pan_north",
                  action2: "pan_west",
                  count: 0,
                  count2: 0,
                  limit: a / 2,
                  limit2: b / 2,
                  speed: speed,
                });
                break;
              default:
                break;
            }
          }
        }

        // console.log("instructionsA", this.camera.instructions);
        if (this.camera.instructions.length > 0 || sameCell === true) {
          this.autoCamPanWaitingForPath = false;
        }
      };

      // console.log('auto camera instructions',this.camera.instructions);
    }

    if (inputType === "panToCell") {
      let focusCell;
      const rect = canvas.getBoundingClientRect();
      const scale = rect.width / canvas.offsetWidth;
      // console.log('rect.width',rect.width);

      const x = this.canvasWidth / 2;
      const y = this.canvasHeight / 2;

      // ADJUSTED FOR CANVAS SCALE & TRANSFORM
      let newX = (x - this.camera.zoomFocusPan.x) / this.camera.zoom.x;
      let newY = (y - this.camera.zoomFocusPan.y) / this.camera.zoom.y;
      // this.camera.focus.x = newX
      // this.camera.focus.y = newY

      let insideGrid = false;

      for (const cell of this.gridInfo) {
        let point = [newX, newY];
        // let point = [newX,newY];
        let polygon = [];
        for (const vertex of cell.vertices) {
          let vertexPoint = [vertex.x + 10, vertex.y + 5];
          polygon.push(vertexPoint);
        }
        let pip = pointInPolygon(point, polygon);
        if (pip === true) {
          insideGrid = true;
          // console.log("camera focus cell",cell.number,"x: " + x + " y: " + y);
          focusCell = cell;
        }
      }
      if (insideGrid === false) {
        // console.log("clicked the canvas", 'x: ',x,'y: ',y);
        // console.log('clicked outside the grid');
        // this.showCellInfoBox = false;
        focusCell = {
          number: {
            x: 0,
            y: 0,
          },
          center: {
            x: 0,
            y: 0,
          },
          drawCenter: {
            x: 0,
            y: 0,
          },
          vertices: [
            {
              x: 0,
              y: 0,
            },
            {
              x: 0,
              y: 0,
            },
            {
              x: 0,
              y: 0,
            },
            {
              x: 0,
              y: 0,
            },
          ],
          side: 0,
          levelData: "",
          edge: {
            state: false,
            side: "",
          },
          terrain: {
            name: "",
            type: "",
            effect: "",
          },
          item: {
            name: "",
            type: "",
            subType: "",
            effect: "",
            initDrawn: false,
          },
          void: {
            state: false,
          },
          obstacle: {
            id: 0,
            trap: {},
            state: false,
            name: "",
            type: "",
            hp: 2,
            destructible: {
              state: false,
              weapons: [],
              leaveRubble: false,
            },
            locked: {
              state: false,
              key: "",
            },
            weight: 1,
            height: 0.5,
            items: [],
            effects: [],
            moving: {
              state: false,
              step: 0,
              origin: {
                number: {
                  x: undefined,
                  y: undefined,
                },
                center: {
                  x: undefined,
                  y: undefined,
                },
              },
              destination: {
                number: {
                  x: undefined,
                  y: undefined,
                },
                center: {
                  x: undefined,
                  y: undefined,
                },
              },
              currentPosition: {
                x: undefined,
                y: undefined,
              },
              nextPosition: {
                x: undefined,
                y: undefined,
              },
              moveSpeed: 0,
              pushable: true,
              pushed: false,
              pusher: undefined,
              falling: {
                state: false,
                count: 0,
                limit: 10,
              },
            },
          },
          barrier: {
            id: 0,
            trap: {},
            state: false,
            name: "",
            type: "",
            hp: 2,
            destructible: {
              state: false,
              weapons: [],
              leaveRubble: false,
            },
            locked: {
              state: false,
              key: "",
            },
            position: "",
            height: 1,
          },
          elevation: {
            number: 0,
            type: "",
            position: "",
          },
          rubble: false,
        };
        this.cellsToHighlight2 = [];
      }

      // SEND FOCUS CELL TO cellsToHighlight

      if (insideGrid === true) {
        // console.log('panToCell using pointInPolygon',focusCell.number);
        this.camera.focusCell.x = focusCell.number.x;
        this.camera.focusCell.y = focusCell.number.y;
        // console.log('panToCell camera.focusCell',this.camera.focusCell);
        if (this.highlightZoomPanFocusCell === true) {
          for (const cell2 of this.cellsToHighlight2) {
            if (
              cell2.number.x !== focusCell.number.x ||
              cell2.number.y !== focusCell.number.y
            ) {
              let indx = this.cellsToHighlight2.indexOf(cell2);
              this.cellsToHighlight2.splice(indx, 1);
            }
          }
          if (
            !this.cellsToHighlight2.find(
              (x) =>
                x.number.x === focusCell.number.x && x.number.y === focusCell.number.y
            )
          ) {
            this.cellsToHighlight2.push({
              number: {
                x: focusCell.number.x,
                y: focusCell.number.y,
              },
              count: 0,
              limit: 0,
            });
          }
          // console.log('this.cellsToHighlight2',this.cellsToHighlight2);
        }
      }

      if (this.camera.pan.x < 0) {
        direction = "east";
        cellOffsetX = parseInt((this.camera.pan.x / 50).toFixed(0));
      }
      if (this.camera.pan.x > 0) {
        direction = "west";
        cellOffsetX = parseInt((this.camera.pan.x / 50).toFixed(0));
      }
      if (this.camera.pan.y > 0) {
        direction = "north";
        cellOffsetY = parseInt((this.camera.pan.y / 25).toFixed(0));
      }
      if (this.camera.pan.y < 0) {
        direction = "south";
        cellOffsetY = parseInt((this.camera.pan.y / 25).toFixed(0));
      }

      if (this.camera.pan.x === -1) {
        cellOffsetX = 0;
      }
      if (this.camera.pan.y === -1) {
        cellOffsetY = 0;
      }

      // console.log('cellOffsetX',cellOffsetX,'cellOffsetY',cellOffsetY);
    }
  };
  toggleCameraModeUI = (mode) => {
    this.camera.mode = mode;
  };
  closeCamera = () => {
    this.camera.state = false;
    this.camera.fixed = false;

    if (
      this.camera.customView.state !== true &&
      this.settingAutoCamera === false &&
      this.camera.preInstructions.length === 0 &&
      this.camera.instructions.length === 0
      // (this.camera.zoom.x-1) > this.zoomThresh
    ) {
      this.setAutoCamera("zoomReset", this.players[0]);
    }
  };
  preResetCamera = () => {
    this.resetCameraSwitch = true;
  };
  setAutoCamera = (args, player) => {
    this.camera.state = false;
    this.camera.fixed = false;
    this.settingAutoCamera = true;
    // console.log("setting auto camera instructions: ", args);

    let weaponType = "";
    if (player !== "") {
      if (
        player.currentWeapon.type === "spear" ||
        player.currentWeapon.type === "sword" ||
        player.currentWeapon.type === ""
      ) {
        weaponType = "melee";
      }
      if (
        player.currentWeapon.type === "crossbow" ||
        player.currentWeapon.type === "bow"
      ) {
        weaponType = "ranged";
      }
    }

    let parsedPreInstructions = [];

    let getPath = () => {
      this.autoCamPanWaitingForPath = true;
      return new Promise((resolve, reject) => {
        let originCell = {
          x: player.currentPosition.cell.number.x,
          y: player.currentPosition.cell.number.y,
        };
        let destCell = {
          x: this.players[1].currentPosition.cell.number.x,
          y: this.players[1].currentPosition.cell.number.y,
        };

        let pathSet = [];
        this.updatePathArray();
        this.easyStar = new Easystar.js();
        this.easyStar.setGrid(this.pathArray);
        this.easyStar.setAcceptableTiles([0]);
        this.easyStar.enableDiagonals();
        this.easyStar.findPath(
          originCell.x,
          originCell.y,
          destCell.x,
          destCell.y,
          function (path) {
            if (path === null) {
              // console.log("Path was not found");
              reject("Path was not found");
            } else {
              pathSet = path;
              resolve(pathSet);
            }
          }
        );
        this.easyStar.setIterationsPerCalculation(1000);
        this.easyStar.calculate();
      });
    };

    let reset = false;
    let attackFocusBreakZoomCorrection = "";
    let zoomSteps = ((this.camera.zoom.x - 1 - this.zoomThresh) / 0.02).toFixed(0);
    zoomSteps = parseInt(zoomSteps);
    if (zoomSteps === 0) {
      zoomSteps = 1;
    }
    if (zoomSteps < 0) {
      zoomSteps = zoomSteps * -1;
    }

    if (this.camera.preInstructions.length > 0 || this.camera.instructions.length > 0) {
      if (
        args === "attackFocusBreak" ||
        args === "defendFocusBreak" ||
        args === "zoomreset"
      ) {
        if (this.camera.instructions.length > 0) {
          if (
            this.camera.instructions[this.camera.instructions.length - 1].action ===
              "zoom_in" ||
            this.camera.instructions[this.camera.instructions.length - 1].action ===
              "zoom_out"
          ) {
            // attackFocusBreakZoomCorrection = `zoom_out_${this.camera.instructions[this.camera.instructions.length-1].count}`
            attackFocusBreakZoomCorrection = `zoom_out_${zoomSteps}`;
          }

          // this.camera.preInstructions = [];
          // this.camera.instructions = [];
          // this.camera.currentInstruction = 0;
          // this.settingAutoCamera = false;
          // reset = true;
        }
        // this.autoCamPanWaitingForPath = false;
        this.camera.preInstructions = [];
        this.camera.currentPreInstruction = 0;
        this.camera.instructions = [];
        this.camera.currentInstruction = 0;
        this.settingAutoCamera = false;
        reset = true;
      }
    }

    let zoom = this.camera.zoom.x;
    let prePanZoom = false;
    let prePanZoomAmount = 0;
    if (zoom - 1 <= this.zoomThresh) {
      prePanZoomAmount = ((this.zoomThresh - (zoom - 1)) / 0.02).toFixed(0);
      prePanZoomAmount++;
      prePanZoom = true;
    }

    let getZoom = (args2) => {
      let zoomSteps2 = 0;
      let thresh = 0;
      if (args2 === "melee") {
        // thresh = .5;
        thresh = 0.35;
        // thresh = this.zoomThresh;

        if (this.camera.zoom.x - 1 < thresh) {
          zoomSteps2 = ((thresh - (this.camera.zoom.x - 1)) / 0.02).toFixed(0);
          if (zoomSteps2 === 0) {
            zoomSteps2 = 1;
          }
          if (zoomSteps2 < 0) {
            zoomSteps2 = zoomSteps2 * -1;
          }
          this.camera.preInstructions.push("zoom_in_" + zoomSteps2 + "");
        }
        if (this.camera.zoom.x - 1 > thresh) {
          zoomSteps2 = ((this.camera.zoom.x - 1 - thresh) / 0.02).toFixed(0);
          if (zoomSteps2 === 0) {
            zoomSteps2 = 1;
          }
          if (zoomSteps2 < 0) {
            zoomSteps2 = zoomSteps2 * -1;
          }
          this.camera.preInstructions.push("zoom_out_" + zoomSteps2 + "");
        }
      }

      if (args2 === "ranged") {
        // thresh = .35;
        thresh = 0.15;
        // thresh = this.zoomThresh;

        if (this.camera.zoom.x - 1 < thresh) {
          zoomSteps2 = ((thresh - (this.camera.zoom.x - 1)) / 0.02).toFixed(0);
          if (zoomSteps2 === 0) {
            zoomSteps2 = 1;
          }
          if (zoomSteps2 < 0) {
            zoomSteps2 = zoomSteps2 * -1;
          }
          this.camera.preInstructions.push("zoom_in_" + zoomSteps2 + "");
        }

        if (this.camera.zoom.x - 1 > thresh) {
          zoomSteps2 = ((this.camera.zoom.x - 1 - thresh) / 0.02).toFixed(0);
          if (zoomSteps2 === 0) {
            zoomSteps2 = 1;
          }
          if (zoomSteps2 < 0) {
            zoomSteps2 = zoomSteps2 * -1;
          }
          this.camera.preInstructions.push("zoom_out_" + zoomSteps2 + "");
        }
      }
      // console.log('zoomSteps2',zoomSteps2);
    };

    let boltId;
    if (args.split("_")[0]) {
      if (args.split("_")[0] === "followBolt") {
        boltId = args.split("_")[1];
        args = "followBolt";
      }
    }
    let livingHumanPlayerCount = this.players.filter(
      (x) => x.ai.state !== true && x.dead.state !== true
    ).length;
    switch (args) {
      case "test":
        this.camera.preInstructions.push(
          "zoom_in_" + 1 + "",
          // "moveTo_" + 4 + "_" + 2 + "_fast"
          // "zoom_in_" + 10 + ""

          // "moveTo_" + 1 + "_" + 8 + "_fast",
          // "waitFor_20",
          // "moveTo_" + 1 + "_" + 1 + "_fast",
          // "waitFor_20",
          // "moveTo_" + 8 + "_" + 1 + "_fast",
          // "waitFor_20",
          // "moveTo_" + 8 + "_" + 8 + "_fast",
          // "waitFor_20",
          // "moveTo_" + 6 + "_" + 6 + "_fast",
          // "waitFor_20",
          // "moveTo_" + 6 + "_" + 3 + "_slow",
          // "waitFor_20",
          // "moveTo_" + 3 + "_" + 3 + "_slow",
          // "waitFor_20",
          // "moveTo_" + 3 + "_" + 6 + "_slow",
          // "waitFor_20",
          // "moveTo_" + 6 + "_" + 6 + "_slow"
          // "zoom_in_" + 5 + ""
          // "zoom_outToInit"
          // "move&&zoom_in_" + 1 + "_" + 5 + "_slow_" + 5
          "move&&zoom_in_" + 5 + "_" + 1 + "_fast_" + 8
        );

        break;
      case "attackFocus":
        if (prePanZoom === true) {
          this.camera.preInstructions.push("zoom_in_" + prePanZoomAmount + "");
        }

        if (livingHumanPlayerCount === 1) {
          this.camera.preInstructions.push(
            "moveTo_" +
              player.currentPosition.cell.number.x +
              "_" +
              player.currentPosition.cell.number.y +
              "_fast"
            // 'waitFor_50',
          );

          if (weaponType === "melee") {
            getZoom(weaponType);
          }

          if (weaponType === "ranged") {
            getZoom(weaponType);
          }
        }

        if (livingHumanPlayerCount === 2) {
          // twoPlayerCalc();
          getPath()
            .then((pathSet) => {
              // console.log('Path set:', pathSet);
              parsedPreInstructions = pathSet;

              finish();
            })
            .catch((error) => {
              console.error("Error:", error);
            });

          let finish = () => {
            this.autoCamPanWaitingForPath = false;
            // console.log('parsedPreInstructions',parsedPreInstructions);

            if (parsedPreInstructions.length < 4) {
              // console.log('attack focus auto cam: 2 players in close range');

              if (prePanZoom === true) {
                this.camera.preInstructions.push("zoom_in_" + prePanZoomAmount + "");
              }

              if (weaponType === "melee") {
                this.camera.preInstructions.push(
                  "moveTo_" +
                    player.currentPosition.cell.number.x +
                    "_" +
                    player.currentPosition.cell.number.y +
                    "_fast"
                );

                getZoom(weaponType);
              }

              if (weaponType === "ranged") {
                getZoom(weaponType);
              }
            } else {
              // console.log('attack focus auto cam: 2 players at a distance');

              // console.log('preInstructions',parsedPreInstructions,parsedPreInstructions[(parsedPreInstructions.length/2).toFixed(0)]);

              let intermediateCell =
                this.getIntermediateCellByArea(parsedPreInstructions);

              this.camera.preInstructions.push(
                "moveTo_" + intermediateCell.x + "_" + intermediateCell.y + "_fast"
                // 'waitFor_50',
              );

              getZoom("ranged");
            }
          };
        }

        break;
      case "defendFocus":
        weaponType = "melee";
        if (prePanZoom === true) {
          this.camera.preInstructions.push("zoom_in_" + prePanZoomAmount + "");
        }

        if (livingHumanPlayerCount === 1) {
          this.camera.preInstructions.push(
            "moveTo_" +
              player.currentPosition.cell.number.x +
              "_" +
              player.currentPosition.cell.number.y +
              "_fast"
            // 'waitFor_50',
          );

          if (weaponType === "melee") {
            getZoom(weaponType);
          }
        }

        if (livingHumanPlayerCount === 2) {
          // twoPlayerCalc();
          getPath()
            .then((pathSet) => {
              // console.log('Path set:', pathSet);
              parsedPreInstructions = pathSet;

              finish();
            })
            .catch((error) => {
              console.error("Error:", error);
            });

          let finish = () => {
            this.autoCamPanWaitingForPath = false;
            // console.log('parsedPreInstructions',parsedPreInstructions);

            if (parsedPreInstructions.length < 4) {
              // console.log('attack focus auto cam: 2 players in close range');

              if (prePanZoom === true) {
                this.camera.preInstructions.push("zoom_in_" + prePanZoomAmount + "");
              }

              if (weaponType === "melee") {
                this.camera.preInstructions.push(
                  "moveTo_" +
                    player.currentPosition.cell.number.x +
                    "_" +
                    player.currentPosition.cell.number.y +
                    "_fast"
                );

                getZoom(weaponType);
              }
            } else {
              // console.log('attack focus auto cam: 2 players at a distance');

              // console.log('preInstructions',parsedPreInstructions,parsedPreInstructions[(parsedPreInstructions.length/2).toFixed(0)]);

              let intermediateCell =
                this.getIntermediateCellByArea(parsedPreInstructions);

              this.camera.preInstructions.push(
                "moveTo_" + intermediateCell.x + "_" + intermediateCell.y + "_fast"
                // 'waitFor_50',
              );

              getZoom("ranged");
            }
          };
        }

        break;
      case "attackFocusBreak":
        this.autoCamPanWaitingForPath = false;
        if (this.camera.zoom.x - 1 > this.zoomThresh) {
          if (reset === true && attackFocusBreakZoomCorrection !== "") {
            this.camera.preInstructions.push(attackFocusBreakZoomCorrection);
          } else {
            let zoomDifference = 0;
            this.camera.preInstructions.push("zoom_outToInit");
          }
        }
        break;
      case "defendFocusBreak":
        this.autoCamPanWaitingForPath = false;
        if (this.camera.zoom.x - 1 > this.zoomThresh) {
          if (reset === true && attackFocusBreakZoomCorrection !== "") {
            this.camera.preInstructions.push(attackFocusBreakZoomCorrection);
          } else {
            let zoomDifference = 0;
            this.camera.preInstructions.push("zoom_outToInit");
          }
        }
        break;
      case "zoomReset":
        if (zoom - 1 < this.zoomThresh) {
          this.camera.preInstructions.push("zoom_inToInit");
        }
        if (zoom - 1 > this.zoomThresh) {
          this.camera.preInstructions.push("zoom_outToInit");
        }
        if (this.settingAutoCameraFollowBolt === true) {
          this.settingAutoCameraFollowBolt = false;
        }

        break;
      case "playerSpawnFocus":
        if (prePanZoom === true) {
          this.camera.preInstructions.push("zoom_in_" + prePanZoomAmount + "");
        }

        if (livingHumanPlayerCount === 1) {
          this.camera.preInstructions.push(
            "moveTo_" +
              player.currentPosition.cell.number.x +
              "_" +
              player.currentPosition.cell.number.y +
              "_fast"
            // 'waitFor_50',
          );

          getZoom("melee");

          this.camera.preInstructions.push("waitFor_50");

          this.camera.preInstructions.push("zoom_outToInit");
        }

        if (livingHumanPlayerCount === 2) {
          getPath()
            .then((pathSet) => {
              // console.log('Path set:', pathSet);
              parsedPreInstructions = pathSet;

              finish();
            })
            .catch((error) => {
              console.error("Error:", error);
            });

          let finish = () => {
            this.autoCamPanWaitingForPath = false;
            if (parsedPreInstructions.length < 4) {
              // console.log('plyr spawn focus auto cam: 2 players in close range');

              this.camera.preInstructions.push(
                "moveTo_" +
                  this.players[0].currentPosition.cell.number.x +
                  "_" +
                  this.players[0].currentPosition.cell.number.y +
                  "_fast"
              );

              getZoom("melee");
            } else {
              // console.log('plyr spawn focus auto cam: 2 players at a distance','zoomadjust',Math.ceil((((this.camera.zoom.x-1)-.35)*10)*5));

              // console.log('preInstructions',parsedPreInstructions,parsedPreInstructions[(parsedPreInstructions.length/2).toFixed(0)]);

              let intermediateCell =
                this.getIntermediateCellByArea(parsedPreInstructions);

              this.camera.preInstructions.push(
                "moveTo_" + intermediateCell.x + "_" + intermediateCell.y + "_fast"
              );

              getZoom("ranged");
            }

            this.camera.preInstructions.push("waitFor_50");

            this.camera.preInstructions.push("zoom_outToInit");
          };
        }

        // console.log('player spawn focus preInstructions',this.camera.preInstructions);
        break;
      case "aiSpawnFocus":
        if (prePanZoom === true) {
          this.camera.preInstructions.push("zoom_in_" + prePanZoomAmount + "");
        }

        this.camera.preInstructions.push(
          "moveTo_" +
            player.currentPosition.cell.number.x +
            "_" +
            player.currentPosition.cell.number.y +
            "_fast"
          // 'waitFor_50',
        );

        getZoom("ranged");

        this.camera.preInstructions.push("waitFor_50");

        this.camera.preInstructions.push("zoom_outToInit");

        // console.log('aiSpawnFocus this.camera.preInstructions',this.camera.preInstructions);

        break;
      case "pushbackPan":
        // pan to pushback target
        break;
      case "followBolt":
        this.settingAutoCameraFollowBolt = true;
        if (prePanZoom === true) {
          this.camera.preInstructions.push("zoom_in_" + prePanZoomAmount + "");
        }
        let bolt = this.projectiles.find((x) => x.id === boltId);
        this.camera.preInstructions.push(
          "moveTo_" + bolt.origin.number.x + "_" + bolt.origin.number.y + "_fast"
        );
        let endCell = {
          x: 0,
          y: 0,
        };
        switch (bolt.direction) {
          case "north":
            endCell.x = bolt.origin.number.x;
            endCell.y = 0;
            break;
          case "south":
            endCell.x = bolt.origin.number.x;
            endCell.y = this.gridWidth;
            break;
          case "west":
            endCell.x = 0;
            endCell.y = bolt.origin.number.y;
            break;
          case "west":
            endCell.x = this.gridWidth;
            endCell.y = bolt.origin.number.y;
            break;
          default:
            break;
        }
        this.camera.preInstructions.push(
          "moveTo_" + endCell.x + "_" + endCell.y + "_fast"
        );

        break;
      default:
    }

    if (
      this.camera.preInstructions.length === 0 &&
      this.autoCamPanWaitingForPath !== true
    ) {
      this.settingAutoCamera = false;
    }
  };
  setCameraFocus = (focusType, canvas, context, canvas2, context2) => {
    console.log(
      "setting camera focus",
      "zoom",
      this.camera.zoom.x,
      "pan",
      this.camera.pan
    );

    if (focusType === "init" || focusType === "reset") {
      if (this.camera.mode === "pan") {
        this.camera.focus.x = canvas.width / 2;
        this.camera.focus.y = canvas.height / 2;
      }

      if (this.camera.mode === "zoom") {
        this.camera.focus.x = canvas.width / 2;
        this.camera.focus.y = canvas.height / 2;
      }
    }

    if (focusType === "input") {
      class Point {
        constructor(x, y) {
          this.x = x;
          this.y = y;
        }
      }

      let zoom = this.camera.zoom.x;
      if (this.camera.mode === "pan") {
        // console.log('beep');
        switch (this.camera.panDirection) {
          case "north":
            this.camera.focus.y -= 10;
            break;
          case "south":
            this.camera.focus.y += 10;
            break;
          case "east":
            this.camera.focus.x += 10;
            break;
          case "west":
            this.camera.focus.x -= 10;
            break;
          default:
        }
      }

      if (this.camera.mode === "zoom") {
        // if (this.camera.zoomDirection === 'out' && this.camera.zoom.x > 1) {
        //
        //
        //
        //     if (this.camera.pan.x !== -1) {
        //
        //       if (this.camera.pan.x < 1) {
        //         // this.camera.focus.x -= 10;
        //         this.camera.focus.x -= (10*this.camera.zoom.x);
        //       }
        //       if (this.camera.pan.x > 1) {
        //         // this.camera.focus.x += 10;
        //         this.camera.focus.x += (10*this.camera.zoom.x);
        //       }
        //
        //     }
        //     if (this.camera.pan.y !== -1) {
        //
        //       if (this.camera.pan.y < 1) {
        //         // this.camera.focus.y -= 10;
        //         this.camera.focus.y -= (5*this.camera.zoom.x);
        //       }
        //       if (this.camera.pan.y > 1) {
        //         // this.camera.focus.y += 10;
        //         this.camera.focus.y += (5*this.camera.zoom.x);
        //       }
        //
        //     }
        //
        //
        this.camera.focus.x =
          (canvas.width / 2 - this.camera.zoomFocusPan.x) / this.camera.zoom.x;
        this.camera.focus.y =
          (canvas.height / 2 - this.camera.zoomFocusPan.y) / this.camera.zoom.y;
        // const x = this.canvasWidth/2;
        // const y = this.canvasHeight/2;
        // this.camera.focus.x = (x-this.camera.zoomFocusPan.x)/this.camera.zoom.x;
        // this.camera.focus.y = (y-this.camera.zoomFocusPan.y)/this.camera.zoom.y;
        //
        // }
        //
        // if (this.camera.zoomDirection === 'in') {
        //
        //
        // }
      }
    }

    // console.log('camera focus set',this.camera.focus,focusType,'zoom',this.camera.zoom,'pan',this.camera.pan);
  };
  menuToggleCamera = () => {
    let canStart = true;
    if (
      this.camera.instructions.length > 0 ||
      this.camera.preInstructions.length > 0 ||
      this.settingAutoCamera === true ||
      this.autoCamPanWaitingForPath === true
      // this.toggleCameraMode === false
    ) {
      canStart = false;
    }
    if (this.camera.customView.state === false) {
      if (
        this.camera.zoom.x - 1 > this.zoomThresh ||
        this.camera.zoom.x - 1 < this.zoomThresh
      ) {
        canStart = false;
      }
      if (
        this.camera.zoom.x - 1 > this.zoomThresh + 0.01 ||
        this.camera.zoom.x - 1 < this.zoomThresh - 0.01
      ) {
        canStart = false;
      }
      if (this.camera.pan.x < -1 || this.camera.pan.x > -1) {
        canStart = false;
      }
      if (this.camera.pan.y < -1 || this.camera.pan.y > -1) {
        canStart = false;
      }
    }

    if (canStart === true) {
      this.camera.startCount = 0;
      this.camera.state = true;
      this.camera.fixed = true;
    }
    if (canStart === false) {
      console.log("auto cam is probably engaged. Can't start input cam");
    }
  };
  setZoomPan = (canvas) => {
    // console.log('setZoomPan');
    // ADJUST PAN AND ZOOM RELATIVE TO EACH OTHER TO KEEP CENTERED WHEN ZOOMING IN
    // AND CENTERING THE GRID WHEN ZOOMING OUT

    let zoom = this.camera.zoom.x;

    let diff;

    // if (parseFloat(zoom.toFixed(2)) === zoomThresh) {
    if (zoom - 1 === this.zoomThresh) {
      // console.log('at zoomThresh');
      this.camera.pan.x = -1;
      this.camera.pan.y = -1;

      this.camera.adjustedPan.x = -1;
      this.camera.adjustedPan.y = -1;

      this.camera.zoomFocusPan.x =
        (canvas.width / 2) * (1 - zoom) + 1 + this.camera.pan.x * zoom;
      this.camera.zoomFocusPan.y =
        (canvas.height / 2) * (1 - zoom) + 1 + this.camera.pan.y * zoom;

      // this.camera.limits.pan.x.max = 400;
      // this.camera.limits.pan.x.min = -400;
    }

    // ZOOMING IN & OUT ABOVE THRESHOLD
    if (zoom - 1 < this.zoomThresh) {
      // console.log('above zoomThresh');

      if (this.camera.mode === "zoom" && this.camera.zoomDirection === "in") {
        this.camera.zoomFocusPan.x =
          (canvas.width / 2) * (1 - zoom) + 1 + this.camera.pan.x * zoom;
        this.camera.zoomFocusPan.y =
          (canvas.height / 2) * (1 - zoom) + 1 + this.camera.pan.y * zoom;
      }

      if (this.camera.mode === "zoom" && this.camera.zoomDirection === "out") {
        // ADJUST PAN INCREMENT FOR ZOOM OUT CENTERING

        let increment = 70;

        if (this.camera.pan.x > -1) {
          increment = this.camera.pan.x;
          this.camera.pan.x -= increment;
          this.camera.adjustedPan.x -= 20 * (this.camera.zoom.x - 1);
          this.camera.panDirection = "east";
        }
        if (this.camera.pan.x < -1) {
          increment = this.camera.pan.x * -1;
          this.camera.pan.x += increment;
          this.camera.adjustedPan.x += 20 * (this.camera.zoom.x - 1);
          this.camera.panDirection = "west";
        }

        if (this.camera.pan.y < -1) {
          increment = this.camera.pan.y * -1;
          this.camera.pan.y += increment;
          // this.camera.pan.y += 45;
          this.camera.adjustedPan.y += 1.5 * (this.camera.zoom.x - 1);
          this.camera.panDirection = "north";
        }
        if (this.camera.pan.y > -1) {
          increment = this.camera.pan.y;
          this.camera.pan.y -= increment;
          // this.camera.pan.y -= 45;
          this.camera.adjustedPan.y -= 1.5 * (this.camera.zoom.x - 1);
          this.camera.panDirection = "south";
        }

        // console.log(
        //   "increment2 ",
        //   increment,
        //   "zoom",
        //   zoom - 1,
        //   "pan x,y",
        //   this.camera.pan.x,
        //   this.camera.pan.y
        // );
        this.camera.zoomFocusPan.x =
          (canvas.width / 2) * (1 - zoom) + 1 + this.camera.pan.x * zoom;
        this.camera.zoomFocusPan.y =
          (canvas.height / 2) * (1 - zoom) + 1 + this.camera.pan.y * zoom;
      }

      // this.camera.zoomFocusPan.x = ((canvas.width/2)*(1-zoom)+1)+(this.camera.pan.x*zoom);
      // this.camera.zoomFocusPan.y = ((canvas.height/2)*(1-zoom)+1)+(this.camera.pan.y*zoom);
    }

    // ZOOMING BELOW THRESHOLD
    if (zoom - 1 > this.zoomThresh) {
      // console.log('below zoomThresh');
      diff = zoom - 1;
      let diffx;
      let diffy;

      if (this.camera.mode === "pan") {
        this.camera.zoomFocusPan.x =
          (canvas.width / 2) * (1 - zoom) + 1 + this.camera.pan.x * zoom;
        this.camera.zoomFocusPan.y =
          (canvas.height / 2) * (1 - zoom) + 1 + this.camera.pan.y * zoom;
      }
      if (this.camera.mode === "zoom") {
        // ZOOM INTO WHAT CAMERA IS CENTERED ON (MAGIC FORMULA!!!)
        if (this.camera.zoomDirection === "in") {
          // this.camera.zoomFocusPan.x = (canvas.width / 2) - (this.players[0].currentPosition.cell.center.x * zoom);
          // this.camera.zoomFocusPan.y = (canvas.height / 2) - (this.players[0].currentPosition.cell.center.y * zoom);

          // this.camera.zoomFocusPan.x = (canvas.width / 2) - (this.players[0].currentPosition.cell.center.x * zoom-1);
          // this.camera.zoomFocusPan.y = (canvas.height / 2) - (this.players[0].currentPosition.cell.center.y * zoom-1);

          // this.camera.zoomFocusPan.x = (diff*(canvas.width/2));
          // this.camera.zoomFocusPan.y = (diff*(canvas.width/2))-(diff*(canvas.width/6));

          // this.camera.zoomFocusPan.x = ((canvas.width/2)*(1-zoom)+1)+(this.camera.pan.x*zoom);
          // this.camera.zoomFocusPan.y = ((canvas.height/2)*(1-zoom)+1)+(this.camera.pan.y*zoom);

          this.camera.zoomFocusPan.x =
            (canvas.width / 2) * (1 - zoom) + 1 + this.camera.pan.x * zoom;
          this.camera.zoomFocusPan.y =
            (canvas.height / 2) * (1 - zoom) + 1 + this.camera.pan.y * zoom;
        }

        // WHEN ZOOMING OUT INSIDE THRESHOLD, TEND TOWARDS A CENTER ALIGNMENT
        if (this.camera.zoomDirection === "out") {
          let zoomSteps = ((zoom - 1 - this.zoomThresh) / 0.02).toFixed(0);
          zoomSteps = parseInt(zoomSteps);
          if (zoomSteps === 0) {
            zoomSteps = 1;
          }

          // ADJUST PAN INCREMENT FOR ZOOM OUT CENTERING

          let xIncrement = 10;
          let yIncrement = 3.5;

          if (this.camera.pan.x > -1) {
            if (this.camera.pan.x !== 0 && zoomSteps !== 0) {
              xIncrement = (this.camera.pan.x / zoomSteps).toFixed(0);
            } else {
              // console.log('1 pan',this.camera.pan.x,'zoomSteps',zoomSteps);
              xIncrement = 0;
            }
            this.camera.pan.x -= xIncrement;
            this.camera.adjustedPan.x -= 20 * (this.camera.zoom.x - 1);
            this.camera.panDirection = "east";
          }
          if (this.camera.pan.x < -1) {
            if (this.camera.pan.x !== 0 && zoomSteps !== 0) {
              xIncrement = (this.camera.pan.x / zoomSteps).toFixed(0) * -1;
            } else {
              // console.log('2 pan',this.camera.pan.x,'zoomSteps',zoomSteps);
              xIncrement = 0;
            }
            this.camera.pan.x += xIncrement;
            this.camera.adjustedPan.x += 20 * (this.camera.zoom.x - 1);
            this.camera.panDirection = "west";
          }

          if (this.camera.pan.y < -1) {
            if (this.camera.pan.y !== 0 && zoomSteps !== 0) {
              yIncrement = (this.camera.pan.y / zoomSteps).toFixed(0) * -1;
            } else {
              // console.log('3 pan',this.camera.pan.y,'zoomSteps',zoomSteps);
              yIncrement = 0;
            }
            this.camera.pan.y += yIncrement;
            this.camera.adjustedPan.y += 1.5 * (this.camera.zoom.x - 1);
            this.camera.panDirection = "north";
          }
          if (this.camera.pan.y > -1) {
            if (this.camera.pan.y !== 0 && zoomSteps !== 0) {
              yIncrement = (this.camera.pan.y / zoomSteps).toFixed(0);
            } else {
              // console.log('4 pan',this.camera.pan.y,'zoomSteps',zoomSteps);
              yIncrement = 0;
            }
            this.camera.pan.y -= yIncrement;
            this.camera.adjustedPan.y -= 1.5 * (this.camera.zoom.x - 1);
            this.camera.panDirection = "south";
          }

          // console.log('increment x,y',xIncrement,yIncrement,'zoom',zoom-1,'pan x,y',this.camera.pan.x,this.camera.pan.y);
          this.camera.zoomFocusPan.x =
            (canvas.width / 2) * (1 - zoom) + 1 + this.camera.pan.x * zoom;
          this.camera.zoomFocusPan.y =
            (canvas.height / 2) * (1 - zoom) + 1 + this.camera.pan.y * zoom;
        }
      }

      // SET PAN LIMITS BASED ON ZOOM
      let zoomMod;
      if (zoom - 1 > 0) {
        zoomMod = zoom - 1;
      } else {
        zoomMod = 0.01;
        // zoomMod = 1;
      }
      let baseLimit = 0;
      let baseLimitMod = 0;

      // console.log('zoomMod',zoomMod);

      let panAmount;
      switch (this.camera.panDirection) {
        case "north":
          baseLimit = 200;
          if (this.gridWidth >= 12) {
            baseLimit = 250;
          }
          if (
            this.camera.state !== true &&
            this.camera.fixed !== true &&
            this.camera.instructions[this.camera.currentInstruction]
          ) {
            baseLimit += 100;
          }
          panAmount = this.camera.pan.y;
          this.camera.limits.pan.y.max = baseLimit + (zoomMod / 5) * panAmount;
          // console.log('1',baseLimit,panAmount,zoomMod);
          break;
        case "south":
          baseLimit = -200;
          if (this.gridWidth >= 12) {
            baseLimit = -200;
          }
          if (
            this.camera.state !== true &&
            this.camera.fixed !== true &&
            this.camera.instructions[this.camera.currentInstruction]
          ) {
            baseLimit -= 100;
          }
          panAmount = this.camera.pan.y;
          this.camera.limits.pan.y.min = baseLimit + (zoomMod / 5) * panAmount;
          // console.log('2',baseLimit,panAmount,zoomMod);
          break;
        case "east":
          // baseLimit = -400;
          baseLimit = -300;
          if (this.gridWidth >= 12) {
            baseLimit = -400;
          }
          if (
            this.camera.state !== true &&
            this.camera.fixed !== true &&
            this.camera.instructions[this.camera.currentInstruction]
          ) {
            baseLimit -= 100;
          }
          panAmount = this.camera.pan.x;
          this.camera.limits.pan.x.min = baseLimit + (zoomMod / 5) * panAmount;
          // console.log('3',baseLimit,panAmount,zoomMod);
          break;
        case "west":
          // baseLimit = 400;
          baseLimit = 300;
          if (this.gridWidth >= 12) {
            baseLimit = 400;
          }
          if (
            this.camera.state !== true &&
            this.camera.fixed !== true &&
            this.camera.instructions[this.camera.currentInstruction]
          ) {
            baseLimit += 100;
          }
          panAmount = this.camera.pan.x;
          this.camera.limits.pan.x.max = baseLimit + (zoomMod / 5) * panAmount;
          // console.log('4',baseLimit,panAmount,zoomMod);
          break;
        default:
          break;
      }
      // console.log('baseLimit',baseLimit);
      // console.log('panAmount',panAmount);
      // console.log('x: min ',this.camera.limits.pan.x.min,' max ',this.camera.limits.pan.x.max);
      // console.log('y: min ',this.camera.limits.pan.y.min,' max ',this.camera.limits.pan.y.max);
    }

    const x = this.canvasWidth / 2;
    const y = this.canvasHeight / 2;
    let newX = (x - this.camera.zoomFocusPan.x) / this.camera.zoom.x;
    let newY = (y - this.camera.zoomFocusPan.y) / this.camera.zoom.y;
    this.camera.focus.x = newX;
    this.camera.focus.y = newY;

    // console.log('ZFP!',this.camera.zoomFocusPan.x.toFixed(2),',',this.camera.zoomFocusPan.y.toFixed(2));
  };
  toggleCameraCustomView = () => {
    if (this.camera.customView.state === false) {
      this.camera.customView = {
        state: true,
        zoom: this.camera.zoom.x,
        pan: {
          x: this.camera.pan.x,
          y: this.camera.pan.y,
        },
        keyPressCount: {
          start: 0,
          limit: 4,
        },
      };
    } else {
      this.camera.customView = {
        state: false,
        zoom: 0,
        pan: {
          x: 0,
          y: 0,
        },
        keyPressCount: {
          start: 0,
          limit: 4,
        },
      };
    }
  };
  getIntermediateCellByArea = (pathCoords) => {
    let playerOneCell = pathCoords[0];
    let playerTwoCell = pathCoords[pathCoords.length - 1];
    let xPath = {
      start: playerOneCell,
      end: {
        x: playerTwoCell.x,
        y: playerOneCell.y,
      },
    };
    let xMidpoint = {
      // x: Math.floor((Math.abs(xPath.start.x - xPath.end.x) + 1) / 2),
      x: Math.floor((xPath.start.x + xPath.end.x) / 2),
      y: xPath.start.y,
    };
    let yPath = {
      start: playerOneCell,
      end: {
        x: playerOneCell.x,
        y: playerTwoCell.y,
      },
    };
    let yMidpoint = {
      x: yPath.start.x,
      // y: Math.floor((Math.abs(yPath.start.y - yPath.end.y) + 1) / 2),
      y: Math.floor((yPath.start.y + yPath.end.y) / 2),
    };
    let finalCell = {
      x: xMidpoint.x,
      y: yMidpoint.y,
    };

    return {
      x: finalCell.x,
      y: finalCell.y,
    };
  };

  lineCrementer = (player) => {
    // console.log(
    //   "line crementer",
    //   player.number,
    //   player.moving.step,
    //   player.moveCancel.state,
    //   player.nextPosition
    // );

    let currentPosition = player.currentPosition.cell.center;
    let target = player.target;
    let moveSpeed = player.speed.move;
    if (player.moveCancel.state === true) {
      currentPosition = player.moving.origin.center;
    }
    if (player.terrainMoveSpeed.state === true) {
      // console.log('terrain speed mod',player.terrainMoveSpeed.speed);
      moveSpeed = player.terrainMoveSpeed.speed;
    }
    if (player.jumping.state === true) {
      moveSpeed = 0.1;
    }
    if (player.stamina.current < 1) {
      moveSpeed = 0.05;
    }

    if (player.flanking.state === true) {
      // moveSpeed = .1
      moveSpeed = 0.2;
      // if (moveSpeed === .05) {
      //   moveSpeed = .1
      // }
      // else if (moveSpeed === .1) {
      //   moveSpeed = .125
      // }
      // else if (moveSpeed === .125) {
      //   moveSpeed = .2
      // }
    }

    if (player.pushing.state === true) {
      moveSpeed = player.pushing.moveSpeed;
      // console.log('player ',player.number,' pushing speed',moveSpeed);
    }
    if (player.pulling.state === true) {
      moveSpeed = player.pulling.moveSpeed;
      // console.log('player ',player.number,' pulling speed',moveSpeed);
    }
    if (player.pulled.state === true) {
      moveSpeed = player.pulled.moveSpeed;
      // console.log('player ',player.number,' pulled speed',moveSpeed);
    }
    if (player.pushed.state === true) {
      moveSpeed = player.pushed.moveSpeed;
      // console.log('player ',player.number,' pushed speed',moveSpeed);
    }

    // console.log('mover stepper',player.moving.step);
    player.moving.step = +(
      Math.round(player.moving.step + moveSpeed + "e+" + 3) +
      "e-" +
      3
    );
    // player.moving.step = player.moving.step + moveSpeed;

    let newPosition;

    // line: percent is 0-1
    let startPt = currentPosition;
    let endPt;
    if (player.jumping.state === true) {
      endPt = target.cell2.center;
    } else {
      endPt = target.cell1.center;

      // endPt = player.moving.destination;
    }

    let percent = player.moving.step;

    function getLineXYatPercent(startPt, endPt, percent) {
      let dx = endPt.x - startPt.x;
      let dy = endPt.y - startPt.y;
      let X = startPt.x + dx * percent;
      let Y = startPt.y + dy * percent;
      // newPosition = {x:X,y:Y}
      newPosition = { x: Math.round(X), y: Math.round(Y) };
    }
    getLineXYatPercent(startPt, endPt, percent);

    if (player.falling.state === true) {
      player.falling.count++;

      newPosition = {
        x: target.cell1.center.x,
        y: target.cell1.center.y + player.falling.count * 5,
      };
      player.currentPosition.cell.center = newPosition;
    }

    player.nextPosition = newPosition;

    this.players[player.number - 1] = player;

    return newPosition;
  };
  boltCrementer = (bolt) => {
    // console.log('boltCrementer');

    // let index = this.projectiles.findIndex(blt => blt.id === bolt.id);
    let distanceFactor = bolt.target.path.length;
    // if (distanceFactor == 1) {
    //   distanceFactor = 2;
    // }

    let moveSpeed = bolt.speed;
    // moveSpeed = bolt.speed/distanceFactor;
    moveSpeed = bolt.speed / (distanceFactor / 5);
    // moveSpeed = bolt.speed/(distanceFactor/10);

    bolt.moving.step += moveSpeed;
    // console.log('boltCrementer',bolt.moving.step,bolt.speed,moveSpeed,distanceFactor);
    let newPosition;

    // line: percent is 0-1
    let startPt = bolt.moving.origin.center;
    let endPt = bolt.target.path[bolt.target.path.length - 1].center;
    let percent = bolt.moving.step;
    // if (distanceFactor == 1) {
    //   endPt.x+=2
    //   endPt.y+=2
    // }

    // console.log('bolt crement',startPt,endPt,percent);
    // console.log('percent',percent,'time',this.time);
    //
    function getLineXYatPercent(startPt, endPt, percent) {
      let dx = endPt.x - startPt.x;
      let dy = endPt.y - startPt.y;
      let X = startPt.x + dx * percent;
      let Y = startPt.y + dy * percent;
      // newPosition = {
      //   x: X,
      //   y: Y
      // }
      newPosition = {
        x: Math.round(X),
        y: Math.round(Y),
      };
    }
    getLineXYatPercent(startPt, endPt, percent);

    // bolt.nextPosition = newPosition;

    // this.projectiles[index] = bolt;
    // console.log('bolt crementer new position',newPosition);
    return newPosition;
  };
  arcBoltCrementer = () => {};
  obstacleMoveCrementer = (obstacleCell, destCell) => {
    // console.log('obstacle line crementer',obstacle.moving.step,obstacle.moving.moveSpeed);

    let currentPosition = obstacleCell.obstacle.moving.currentPosition;
    let moveSpeed = obstacleCell.obstacle.moving.moveSpeed;

    let step = +(
      Math.round(obstacleCell.obstacle.moving.step + moveSpeed + "e+" + 3) +
      "e-" +
      3
    );

    // player.moving.step = player.moving.step + moveSpeed;
    // console.log('mover stepper',player.moving.step);
    let newPosition;

    // line: percent is 0-1
    let startPt = currentPosition;
    let endPt;
    endPt = destCell.center;

    let percent = step;

    function getLineXYatPercent(startPt, endPt, percent) {
      let dx = endPt.x - startPt.x;
      let dy = endPt.y - startPt.y;
      let X = startPt.x + dx * percent;
      let Y = startPt.y + dy * percent;
      // newPosition = {x:X,y:Y}
      newPosition = { x: Math.round(X), y: Math.round(Y) };
    }
    getLineXYatPercent(startPt, endPt, percent);
    // console.log("obstacle moving crementer", moveSpeed, step, newPosition);

    return { pos: newPosition, step: step };
  };
  drawPopupBubble = (ctx, x, y, w, h, radius, px, py, color) => {
    var r = x + w;
    var b = y + h;
    if (py < y || py > y + h) {
      var con1 = Math.min(Math.max(x + radius, px - 10), r - radius - 20);
      var con2 = Math.min(Math.max(x + radius + 20, px + 10), r - radius);
    } else {
      var con1 = Math.min(Math.max(y + radius, py - 10), b - radius - 20);
      var con2 = Math.min(Math.max(y + radius + 20, py + 10), b - radius);
    }
    var dir;
    if (py < y) dir = 2;
    if (py > y) dir = 3;
    if (px < x && py >= y && py <= b) dir = 0;
    if (px > x && py >= y && py <= b) dir = 1;
    if (px >= x && px <= r && py >= y && py <= b) dir = -1;
    ctx.clearRect(x, y, this.popupSize, this.popupSize);
    ctx.beginPath();
    ctx.strokeStyle = color;
    ctx.lineWidth = "1";
    ctx.moveTo(x + radius, y);
    if (dir == 2) {
      ctx.lineTo(con1, y);
      ctx.lineTo(px, py);
      ctx.lineTo(con2, y);
      ctx.lineTo(r - radius, y);
    } else ctx.lineTo(r - radius, y);
    ctx.quadraticCurveTo(r, y, r, y + radius);
    if (dir == 1) {
      ctx.lineTo(r, con1);
      ctx.lineTo(px, py);
      ctx.lineTo(r, con2);
      ctx.lineTo(r, b - radius);
    } else ctx.lineTo(r, b - radius);
    ctx.quadraticCurveTo(r, b, r - radius, b);
    if (dir == 3) {
      ctx.lineTo(con2, b);
      ctx.lineTo(px, py);
      ctx.lineTo(con1, b);
      ctx.lineTo(x + radius, b);
    } else ctx.lineTo(x + radius, b);
    ctx.quadraticCurveTo(x, b, x, b - radius);
    if (dir == 0) {
      ctx.lineTo(x, con2);
      ctx.lineTo(px, py);
      ctx.lineTo(x, con1);
      ctx.lineTo(x, y + radius);
    } else ctx.lineTo(x, y + radius);
    ctx.quadraticCurveTo(x, y, x + radius, y);
    ctx.fillStyle = "white";
    ctx.fill();
    ctx.stroke();
    // ctx.globalCompositeOperation = "source-over";
    ctx.closePath();
  };
  popupDrawCalc = (position, playerOrigin, plyrNo) => {
    let offset = (this.playerDrawWidth - this.popupSize) / 2;
    let pointerLength = this.popupSize / 3;
    let offset2 = pointerLength + offset;

    let playerCorners = [
      { x: playerOrigin.x, y: playerOrigin.y },
      { x: undefined, y: undefined },
      { x: undefined, y: undefined },
      { x: undefined, y: undefined },
    ];

    playerCorners[1] = {
      x: playerCorners[0].x + this.playerDrawWidth,
      y: playerCorners[0].y,
    };
    playerCorners[2] = {
      x: playerCorners[1].x,
      y: playerCorners[1].y + this.playerDrawHeight,
    };
    playerCorners[3] = {
      x: playerCorners[0].x,
      y: playerCorners[0].y + this.playerDrawHeight,
    };

    let popupCoords = {
      playerOrigin: playerCorners[0],
      origin: { x: undefined, y: undefined },
      pt2: { x: undefined, y: undefined },
      pt3: { x: undefined, y: undefined },
      pt4: { x: undefined, y: undefined },
      anchor: { x: undefined, y: undefined },
      midpoint: { x: undefined, y: undefined },
    };
    let midpoint;

    switch (position) {
      case "northWest":
        popupCoords.origin = {
          x: playerCorners[0].x + offset,
          y: playerCorners[0].y - (this.popupSize + offset2),
        };
        popupCoords.pt2 = {
          x: popupCoords.origin.x + this.popupSize,
          y: popupCoords.origin.y,
        };
        popupCoords.pt3 = {
          x: popupCoords.pt2.x,
          y: popupCoords.pt2.y + this.popupSize,
        };
        popupCoords.pt4 = {
          x: popupCoords.origin.x,
          y: popupCoords.origin.y + this.popupSize,
        };
        midpoint = {
          x: popupCoords.pt3.x + (popupCoords.pt4.x - popupCoords.pt3.x) * 0.5,
          y: popupCoords.pt3.y + (popupCoords.pt4.y - popupCoords.pt3.y) * 0.5,
        };
        popupCoords.anchor = {
          x: midpoint.x,
          y: midpoint.y + pointerLength,
        };
        popupCoords.midpoint = {
          x: midpoint.x,
          y: midpoint.y,
        };
        break;
      case "southEast":
        popupCoords.origin = {
          x: playerCorners[3].x + offset,
          y: playerCorners[3].y + offset2,
        };
        popupCoords.pt2 = {
          x: popupCoords.origin.x + this.popupSize,
          y: popupCoords.origin.y,
        };
        popupCoords.pt3 = {
          x: popupCoords.pt2.x,
          y: popupCoords.pt2.y + this.popupSize,
        };
        popupCoords.pt4 = {
          x: popupCoords.origin.x,
          y: popupCoords.origin.y + this.popupSize,
        };
        midpoint = {
          x: popupCoords.origin.x + (popupCoords.pt2.x - popupCoords.origin.x) * 0.5,
          y: popupCoords.origin.y + (popupCoords.pt2.y - popupCoords.origin.y) * 0.5,
        };
        popupCoords.anchor = {
          x: midpoint.x,
          y: midpoint.y - pointerLength,
        };
        popupCoords.midpoint = {
          x: midpoint.x,
          y: midpoint.y,
        };
        break;
      case "northEast":
        popupCoords.origin = {
          x: playerCorners[1].x + offset2,
          y: playerCorners[1].y + offset,
        };
        popupCoords.pt2 = {
          x: popupCoords.origin.x + this.popupSize,
          y: popupCoords.origin.y,
        };
        popupCoords.pt3 = {
          x: popupCoords.pt2.x,
          y: popupCoords.pt2.y + this.popupSize,
        };
        popupCoords.pt4 = {
          x: popupCoords.origin.x,
          y: popupCoords.origin.y + this.popupSize,
        };
        midpoint = {
          x: popupCoords.origin.x + (popupCoords.pt4.x - popupCoords.origin.x) * 0.5,
          y: popupCoords.origin.y + (popupCoords.pt4.y - popupCoords.origin.y) * 0.5,
        };
        popupCoords.anchor = {
          x: midpoint.x - pointerLength,
          y: midpoint.y,
        };
        popupCoords.midpoint = {
          x: midpoint.x,
          y: midpoint.y,
        };
        break;
      case "southWest":
        popupCoords.origin = {
          x: playerCorners[0].x - (offset2 + this.popupSize),
          y: playerCorners[0].y + offset,
        };
        popupCoords.pt2 = {
          x: popupCoords.origin.x + this.popupSize,
          y: popupCoords.origin.y,
        };
        popupCoords.pt3 = {
          x: popupCoords.pt2.x,
          y: popupCoords.pt2.y + this.popupSize,
        };
        popupCoords.pt4 = {
          x: popupCoords.origin.x,
          y: popupCoords.origin.y + this.popupSize,
        };
        midpoint = {
          x: popupCoords.pt2.x + (popupCoords.pt3.x - popupCoords.pt2.x) * 0.5,
          y: popupCoords.pt2.y + (popupCoords.pt3.y - popupCoords.pt2.y) * 0.5,
        };
        popupCoords.anchor = {
          x: midpoint.x + pointerLength,
          y: midpoint.y,
        };
        popupCoords.midpoint = {
          x: midpoint.x,
          y: midpoint.y,
        };
        break;
      case "west":
        popupCoords.origin = {
          x: playerCorners[0].x - (offset2 + this.popupSize),
          // y: playerCorners[0].y,
          y: playerCorners[0].y - this.popupSize - 5,
        };
        popupCoords.pt2 = {
          x: popupCoords.origin.x + this.popupSize,
          y: popupCoords.origin.y,
        };
        popupCoords.pt3 = {
          x: popupCoords.pt2.x,
          y: popupCoords.pt2.y + this.popupSize,
        };
        popupCoords.pt4 = {
          x: popupCoords.origin.x,
          y: popupCoords.origin.y + this.popupSize,
        };
        midpoint = {
          x: popupCoords.pt2.x + (popupCoords.pt3.x - popupCoords.pt2.x) * 0.5,
          y: popupCoords.pt2.y + (popupCoords.pt3.y - popupCoords.pt2.y) * 0.5,
        };
        popupCoords.anchor = {
          x: popupCoords.pt3.x + pointerLength,
          y: popupCoords.pt3.y,
        };
        popupCoords.midpoint = {
          x: midpoint.x,
          y: midpoint.y,
        };
        break;
      case "north":
        popupCoords.origin = {
          x: playerCorners[1].x + offset2,
          y: playerCorners[1].y - this.popupSize - 5,
        };
        popupCoords.pt2 = {
          x: popupCoords.origin.x + this.popupSize,
          y: popupCoords.origin.y,
        };
        popupCoords.pt3 = {
          x: popupCoords.pt2.x,
          y: popupCoords.pt2.y + this.popupSize,
        };
        popupCoords.pt4 = {
          x: popupCoords.origin.x,
          y: popupCoords.origin.y + this.popupSize,
        };
        midpoint = {
          x: popupCoords.pt2.x + (popupCoords.pt3.x - popupCoords.pt2.x) * 0.5,
          y: popupCoords.pt2.y + (popupCoords.pt3.y - popupCoords.pt2.y) * 0.5,
        };
        popupCoords.anchor = {
          x: popupCoords.pt4.x - pointerLength,
          y: popupCoords.pt4.y,
        };
        popupCoords.midpoint = {
          x: midpoint.x,
          y: midpoint.y,
        };
        break;
      case "south":
        popupCoords.origin = {
          x: playerCorners[3].x - (this.popupSize + offset2),
          y: playerCorners[3].y + 5,
        };
        popupCoords.pt2 = {
          x: popupCoords.origin.x + this.popupSize,
          y: popupCoords.origin.y,
        };
        popupCoords.pt3 = {
          x: popupCoords.pt2.x,
          y: popupCoords.pt2.y + this.popupSize,
        };
        popupCoords.pt4 = {
          x: popupCoords.origin.x,
          y: popupCoords.origin.y + this.popupSize,
        };
        midpoint = {
          x: popupCoords.pt2.x + (popupCoords.pt3.x - popupCoords.pt2.x) * 0.5,
          y: popupCoords.pt2.y + (popupCoords.pt3.y - popupCoords.pt2.y) * 0.5,
        };
        popupCoords.anchor = {
          x: popupCoords.pt2.x + pointerLength,
          y: popupCoords.pt2.y,
        };
        popupCoords.midpoint = {
          x: midpoint.x,
          y: midpoint.y,
        };
        break;
      case "east":
        popupCoords.origin = {
          x: playerCorners[2].x + offset2,
          y: playerCorners[2].y + 5,
        };
        popupCoords.pt2 = {
          x: popupCoords.origin.x + this.popupSize,
          y: popupCoords.origin.y,
        };
        popupCoords.pt3 = {
          x: popupCoords.pt2.x,
          y: popupCoords.pt2.y + this.popupSize,
        };
        popupCoords.pt4 = {
          x: popupCoords.origin.x,
          y: popupCoords.origin.y + this.popupSize,
        };
        midpoint = {
          x: popupCoords.pt2.x + (popupCoords.pt3.x - popupCoords.pt2.x) * 0.5,
          y: popupCoords.pt2.y + (popupCoords.pt3.y - popupCoords.pt2.y) * 0.5,
        };
        popupCoords.anchor = {
          x: popupCoords.origin.x - pointerLength,
          y: popupCoords.origin.y,
        };
        popupCoords.midpoint = {
          x: midpoint.x,
          y: midpoint.y,
        };
        break;
    }

    return popupCoords;
  };
  playerPopupProgressCalc = (player, popup) => {
    // this.popupProgressSvgRef.current.children[2].setAttribute("height","0")
    // this.popupProgressSvgRef.current.children[2].setAttribute("fill","white")

    let path = this.popupProgressSvgRef.current.children[1];
    let rect = this.popupProgressSvgRef.current.children[2];

    let phase = "";
    let perc = 0;
    let arr = this.popupProgressBorderSvgPath.split(" ");
    path.setAttribute("fill", "blue");
    let start = 0;
    let end = 0;
    let count = 0;
    let upperIndex = Math.ceil(arr.length * (perc / 100));
    let fillPath = false;
    let emptyPath = true;

    // plyr.prePush.state === true ||
    // plyr.prePull.state === true ||

    if (player.action === "defending") {
      if (
        player.defending.count < player.defending.peakCount &&
        player.defending.decay.state !== true
      ) {
        phase = "windup";
        perc = (player.defending.count / player.defending.peakCount) * 100;
      } else if (
        player.defending.count === player.defending.peakCount &&
        player.defending.decay.state !== true
      ) {
        phase = "peak";
      }
      if (player.defending.decay.state === true) {
        if (player.defending.decay.count < 5) {
          phase = "peak";
        }
        if (
          player.defending.decay.count < player.defending.decay.limit &&
          player.defending.decay.count > 5
        ) {
          phase = "peak";
          // phase = "cooldown";
          // perc = (player.defending.decay.count / player.defending.decay.limit) * 100;
        }
      }
      if (
        player.defending.count > player.defending.peakCount &&
        player.defending.count < player.defending.limit &&
        player.defending.decay.state !== true
      ) {
        phase = "cooldown";
        perc =
          ((player.defending.count - player.defending.peakCount) /
            (player.defending.limit - player.defending.peakCount)) *
          100;
      }
      if (player.defending.count >= player.defending.limit) {
        phase = "off";
      }
      if (phase === "") {
        phase = "peak";
      }
      // console.log("perkies: def", phase, perc, player.defending.count);
    }
    if (player.action === "attacking") {
      let end = player.attacking.limit;

      if (
        player.attacking.peak === true ||
        player.attacking.chargePeak === true ||
        player.attacking.count === player.attacking.peakCount
      ) {
        phase = "peak";
      } else if (player.attacking.count < end) {
        // if count is less or > peak!!!

        if (player.attacking.count < player.attacking.peakCount) {
          phase = "windup";
          if (popup.msg === "charging") {
          } else {
            perc = (player.attacking.count / player.attacking.peakCount) * 100;
          }
        }
        if (player.attacking.count > player.attacking.peakCount) {
          phase = "cooldown";
          perc =
            ((player.attacking.count - player.attacking.peakCount) /
              (player.attacking.limit - player.attacking.peakCount)) *
            100;
        }
        // console.log("perkies: atk", phase, perc, player.attacking.count);
      }
      if (player.attacking.count >= end) {
        phase = "off";
      }
    }
    if (player.action === "dodging") {
      // console.log('popup progress dodging',this.time);
      let dodgeCondition = false;
      if (
        player.dodging.countState === true &&
        player.dodging.count <= player.dodging.peak.start - player.crits.dodge &&
        this.keyPressed[player.number - 1].dodge === true
      ) {
        // console.log('dodge condition 1: true');
        dodgeCondition = true;
      }
      if (
        player.dodging.countState === true &&
        player.dodging.count > player.dodging.peak.start - player.crits.dodge
      ) {
        // console.log('dodge condition 2: true');
        dodgeCondition = true;
      }

      let startMod = player.crits.dodge;
      let endMod = player.crits.dodge;
      if (player.crits.dodge > 5) {
        player.crits.dodge = 5;
      }
      if (player.dodging.peak.start - startMod < 2) {
        startMod = player.dodging.peak.start - 2;
      }
      if (player.dodging.peak.end + endMod > player.dodging.limit - 2) {
        endMod = player.dodging.limit - (2 + player.dodging.peak.end);
      }
      if (dodgeCondition === true) {
      }

      if (player.dodging.count === 0) {
        // console.log('windup',player.dodging.count);
        phase = "windup";
        perc = (player.dodging.count / (player.dodging.peak.start - startMod)) * 100;
      }
      if (
        player.dodging.count >= 1 &&
        player.dodging.count < player.dodging.peak.start - startMod
      ) {
        // console.log('windup start:',1,'count:',player.dodging.count,'limit:',(player.dodging.peak.start - startMod));
        phase = "windup";
        perc = (player.dodging.count / (player.dodging.peak.start - startMod)) * 100;
      }
      if (
        player.dodging.count >= player.dodging.peak.start - startMod &&
        player.dodging.count < player.dodging.peak.end + endMod
      ) {
        // console.log('peak start:',(player.dodging.peak.start - startMod),'count:',player.dodging.count,'limit:',(player.dodging.peak.end + endMod));
        phase = "peak";
      }

      if (player.dodging.count > player.dodging.peak.end + endMod) {
        // console.log('cooldown start:',(player.dodging.peak.end + endMod),'count:',player.dodging.count,'limit:',player.dodging.limit);
        phase = "cooldown";
        // perc = ((player.dodging.count-(player.dodging.peak.end + endMod))/(player.dodging.limit-(player.dodging.peak.end + endMod)))*100;
        perc = (player.dodging.count / player.dodging.limit) * 100;
      }
      if (player.dodging.count >= player.dodging.limit) {
        // console.log('end count',player.dodging.count);
        phase = "off";
      }
    }
    if (player.prePush.state === true) {
      if (player.prePush.count < player.prePush.limit) {
        phase = "windup";
        perc = (player.prePush.count / player.prePush.limit) * 100;
      }
      if (player.prePush.count >= player.prePush.limit) {
        phase = "off";
      }
    }
    if (player.prePull.state === true) {
      if (player.prePull.count < player.prePull.limit) {
        phase = "windup";
        perc = (player.prePull.count / player.prePull.limit) * 100;
      }
      if (player.prePull.count >= player.prePull.limit) {
        phase = "off";
      }
    }
    if (popup.msg === "charging") {
      phase = "windup";
      perc = (player.attacking.charge / 33) * 100;
    }

    if (phase === "windup") {
      fillPath = true;
    }
    if (phase === "peak") {
      perc = 100;
      path.setAttribute("d", arr.join(" "));
      fillPath = false;
      emptyPath = false;
    }
    if (phase === "cooldown") {
      perc = 100 - perc;
      emptyPath = true;
    }
    if (phase === "off") {
      perc = 0;
      // perc = 100;
      path.setAttribute("d", arr.join(" "));
      fillPath = false;
      emptyPath = false;
    }
    switch (phase) {
      case "windup":
        path.setAttribute("fill", "red");
        break;
      case "peak":
        path.setAttribute("fill", "green");
        break;
      case "cooldown":
        path.setAttribute("fill", "blue");
        break;
      case "off":
        path.setAttribute("fill", "yellow");
        break;
      default:
    }

    // SET MOVING BG COLOR
    let baseColor = "";
    if (perc >= 0 && perc <= 40) {
      rect.setAttribute("fill", "red");
      baseColor = "red";
    }
    if (perc >= 40 && perc <= 60) {
      rect.setAttribute("fill", "orange");
      baseColor = "orange";
    }
    if (perc >= 60 && perc <= 70) {
      rect.setAttribute("fill", "yellow");
      baseColor = "yellow";
    }
    if (perc >= 70 && perc <= 80) {
      rect.setAttribute("fill", "blue");
      baseColor = "blue";
    }
    if (perc >= 80) {
      rect.setAttribute("fill", "green");
      baseColor = "green";
    }
    if (player.action === "defending" && phase === "cooldown") {
      baseColor = "green";
    }

    // Gradients:
    // rect.setAttribute("fill","url(#grad)");
    this.popupProgressImgGradColor1 = baseColor;
    switch (phase) {
      case "windup" || "off":
        this.popupProgressImgGradColor2 = "red";
        break;
      case "peak":
        this.popupProgressImgGradColor2 = "green";
        break;
      case "cooldown":
        this.popupProgressImgGradColor2 = "blue";
        break;
      default:
    }

    // if (fillPath === true) {
    //   let newArr = [];
    //   for (var i = 0; i < upperIndex+1; i++) {
    //     newArr.push(arr[i]);
    //   }
    //   this.popupProgressSvgRef.current.children[2].setAttribute("d",newArr.join(" "));
    // }
    // if (emptyPath === true) {
    //   let newArr = arr;
    //   this.popupProgressSvgRef.current.children[2].setAttribute("d",arr.join(" "));
    //   for (var i = 0; i < upperIndex+1; i++) {
    //     newArr.pop();
    //   }
    //   this.popupProgressSvgRef.current.children[2].setAttribute("d",newArr.join(" "));
    // }

    // function svgToPng(svg, callback) {
    //   const url = getSvgUrl(svg);
    // }
    // function getSvgUrl(svg) {
    //   return URL.createObjectURL(new Blob([svg], {
    //     type: 'image/svg+xml'
    //   }));
    // }
    // svgToPng(svg, (imgData) => {
    //   pngImage.src = imgData;
    // });

    // SET SVG IMAGE filter
    // var xml = new XMLSerializer().serializeToString(this.popupProgressSvgRef.current);
    // var svg64 = btoa(xml); //for utf8: btoa(unescape(encodeURIComponent(xml)))
    // var b64start = 'data:image/svg+xml;base64,';
    // var image64 = b64start + svg64;
    // this.popupProgressImgRef.current.src = image64;

    // console.log("playerPopupProgressCalc perc: ",((100-perc)/100).toFixed(2) ,(perc/100).toFixed(2));

    // return (100-perc)/100;
    return -(perc / 100).toFixed(2);
  };
  cartesianToIsometric = (cartPt) => {
    class Point {
      constructor(x, y) {
        this.x = x;
        this.y = y;
      }
    }

    var tempPt = new Point();
    tempPt.x = cartPt.x - cartPt.y;
    tempPt.y = (cartPt.x + cartPt.y) / 2;
    return tempPt;
  };
  setElasticCounter = (type, subType, pause, player) => {
    // console.log('setElasticCounter');

    if (type === "deflected") {
      let point = {
        x: player.currentPosition.cell.center.x,
        y: player.currentPosition.cell.center.y,
      };

      let countCalcPause = player.success.deflected.limit / 2;
      let countCalc = countCalcPause / 2;

      if (countCalc > 6) {
        countCalc = 6;
        countCalcPause = player.success.deflected.limit - 12;
      }

      player.elasticCounter = {
        state: true,
        direction: this.getOppositeDirection(player.direction),
        type: "deflected",
        subType: "",
        countUp: {
          state: false,
          count: 0,
          limit: countCalc,
        },
        countDown: {
          state: false,
          count: 0,
          limit: countCalc,
        },
        coords: {
          // x: point.x - this.playerDrawWidth / 2,
          // y: point.y - this.playerDrawHeight / 2,
          x: player.nextPosition.x - this.floorImageHeight / 2,
          y: player.nextPosition.y - this.floorImageHeight,
        },
        pause: {
          preState: pause,
          state: false,
          type: "peak",
          count: 0,
          limit: countCalcPause,
        },
      };
    }

    if (type === "dodging") {
      let point = {
        x: player.currentPosition.cell.center.x,
        y: player.currentPosition.cell.center.y,
      };

      let startMod = player.crits.dodge;
      let endMod = player.crits.dodge;
      if (player.crits.dodge > 5) {
        player.crits.dodge = 5;
      }
      if (player.dodging.peak.start - startMod < 2) {
        startMod = player.dodging.peak.start - 2;
      }
      if (player.dodging.peak.end + endMod > player.dodging.limit - 2) {
        endMod = player.dodging.limit - (2 + player.dodging.peak.end);
      }

      // console.log('count up: ',player.dodging.peak.start - startMod);
      // console.log('pause: ',(player.dodging.peak.end + endMod)-(player.dodging.peak.start - startMod));
      // console.log('count down',player.dodging.limit-(player.dodging.peak.end + endMod));
      // console.log('limit',player.dodging.limit);

      let countCalcPause =
        player.dodging.peak.end + endMod - (player.dodging.peak.start - startMod);
      let countCalcUp = player.dodging.peak.start - startMod;
      let countCalcDown = player.dodging.limit - (player.dodging.peak.end + endMod);

      // if (countCalc > 6) {
      //   countCalc = 6;
      //   countCalcPause = (player.success.deflected.limit-12);
      // }

      player.elasticCounter = {
        state: true,
        direction: player.dodging.direction,
        type: "dodging",
        subType: "",
        countUp: {
          state: false,
          count: 0,
          limit: countCalcUp,
        },
        countDown: {
          state: false,
          count: 0,
          limit: countCalcUp,
          // limit: countCalcDown,
        },
        coords: {
          // x: point.x - this.playerDrawWidth / 2,
          // y: point.y - this.playerDrawHeight / 2,
          x: player.nextPosition.x - this.floorImageHeight / 2,
          y: player.nextPosition.y - this.floorImageHeight,
        },
        pause: {
          preState: pause,
          state: false,
          type: "peak",
          count: 0,
          limit: countCalcPause,
        },
      };
    }

    if (type === "attacking") {
      let point = {
        x: player.currentPosition.cell.center.x,
        y: player.currentPosition.cell.center.y,
      };

      let countCalcUp = Math.floor((player.attacking.limit - player.attacking.count) / 2);
      // console.log("beep", countCalcUp);
      // if (countCalcUp > 10) {
      //   countCalcUp = 10;
      // }
      if (subType === "windup") {
        let dirInputThresh = Math.ceil(
          player[type].animRef.peak.unarmed.thrust.normal / 2
        );
        countCalcUp = Math.floor(dirInputThresh / 2);
      }

      let direction = player.attacking.direction;
      if (direction === "none") {
        direction = player.direction;
      }

      player.elasticCounter = {
        state: true,
        direction: direction,
        type: "attacking",
        subType: subType,
        countUp: {
          state: false,
          count: 0,
          limit: countCalcUp,
        },
        countDown: {
          state: false,
          count: 0,
          limit: countCalcUp,
        },
        coords: {
          // x: point.x - this.playerDrawWidth / 2,
          // y: point.y - this.playerDrawHeight / 2,
          x: player.nextPosition.x - this.floorImageHeight / 2,
          y: player.nextPosition.y - this.floorImageHeight,
        },
        pause: {
          preState: pause,
          state: false,
          type: "",
          count: 0,
          limit: 0,
        },
      };
    }

    if (type === "defending") {
      let direction = player.defending.direction;

      if (subType === "windup") {
        let countCalcUp = Math.floor(
          (player.defending.peakCount - player.defending.count) / 2
        );
        // Math.floor(
        //   (player.defending.limit - player.defending.peakCount) / 2
        // );

        if (direction === "none") {
          direction = player.direction;
        }

        player.elasticCounter = {
          state: true,
          direction: direction,
          type: "defending",
          subType: subType,
          countUp: {
            state: false,
            count: 0,
            limit: countCalcUp,
          },
          countDown: {
            state: false,
            count: 0,
            limit: countCalcUp,
          },
          coords: {
            // x: point.x - this.playerDrawWidth / 2,
            // y: point.y - this.playerDrawHeight / 2,
            x: player.nextPosition.x - this.floorImageHeight / 2,
            y: player.nextPosition.y - this.floorImageHeight,
          },
          pause: {
            preState: pause,
            state: false,
            type: "",
            count: 0,
            limit: 0,
          },
        };
      }
      if (subType === "peak") {
        let point = {
          x: player.currentPosition.cell.center.x,
          y: player.currentPosition.cell.center.y,
        };

        let countCalcUp = Math.floor(
          (player.defending.limit - player.defending.peakCount) / 2
        );
        // let countCalcUp = Math.floor(
        //   (player.defending.limit - (defendPeak + player.defending.decay.limit)) / 2
        // );
        // console.log("beep", countCalcUp);
        // if (countCalcUp > 10) {
        //   countCalcUp = 10;
        // }

        if (direction === "none") {
          direction = player.direction;
        }

        player.elasticCounter = {
          state: true,
          direction: direction,
          type: "defending",
          subType: subType,
          countUp: {
            state: false,
            count: 0,
            limit: countCalcUp,
          },
          countDown: {
            state: false,
            count: 0,
            limit: countCalcUp,
          },
          coords: {
            // x: point.x - this.playerDrawWidth / 2,
            // y: point.y - this.playerDrawHeight / 2,
            x: player.nextPosition.x - this.floorImageHeight / 2,
            y: player.nextPosition.y - this.floorImageHeight,
          },
          pause: {
            preState: pause,
            state: false,
            type: "",
            count: 0,
            limit: 0,
          },
        };
      }

      if (subType === "decay") {
        let remainder = player.defending.limit - player.defending.count;
        if (direction === "none") {
          direction = player.direction;
        }
        if (player.elasticCounter.direction !== direction) {
          player.elasticCounter.direction = direction;
          player.elasticCounter.subType = subType;

          let countCalcUp = Math.floor(remainder / 2);
          player.elasticCounter.countUp.limit = countCalcUp;
          player.elasticCounter.countDown.limit = countCalcUp;
          player.elasticCounter.countUp.count = 0;
          player.elasticCounter.countDown.count = 0;
          if (player.elasticCounter.countDown.state === true) {
            player.elasticCounter.countUp.state = true;
            player.elasticCounter.countDown.state = false;
          }
        }
      }
    }

    if (type === "test") {
      player.elasticCounter = {
        state: true,
        direction: player.direction,
        type: "attacking",
        subType: "",
        countUp: {
          state: false,
          count: 0,
          limit: 15,
        },
        countDown: {
          state: false,
          count: 0,
          limit: 15,
        },
        coords: {
          x: player.nextPosition.x - this.floorImageHeight / 2,
          y: player.nextPosition.y - this.floorImageHeight,
        },
        pause: {
          preState: pause,
          state: false,
          type: subType, //start, peak, end
          count: 0,
          limit: 0,
        },
      };
    }

    return player;
    // console.log("player elasticCounter set", player.elasticCounter);
  };
  calcElasticCountCoords = (type, subType, data) => {
    let drawCell;
    let mod = {
      x: undefined,
      y: undefined,
    };
    let finalCoords = {
      x: undefined,
      y: undefined,
    };

    const getMod = (direction, unit2) => {
      let mod2 = mod;
      switch (direction) {
        case "north":
          mod2 = {
            x: unit2 * 2,
            y: -unit2,
          };
          break;
        case "south":
          mod2 = {
            x: -(unit2 * 2),
            y: unit2,
          };
          break;
        case "east":
          mod2 = {
            x: unit2 * 2,
            y: unit2,
          };
          break;
        case "west":
          mod2 = {
            x: -(unit2 * 2),
            y: -unit2,
          };
          break;
        default:
      }

      return mod2;
    };

    const finish = (base2, unit3) => {
      switch (this.gridWidth) {
        case 12:
          unit3 = base2 / 1.5;
          break;
        case 9:
          unit3 = base2;
          break;
        case 6:
          unit3 = base2 * 2;
          break;
        case 3:
          unit3 = base2 * 6;
          break;
        default:
      }

      let dir = data.elasticCounter.direction;
      let baseCoords = {
        x: data.elasticCounter.coords.x,
        y: data.elasticCounter.coords.y,
      };

      if (data.elasticCounter.countUp.state === true) {
        dir = data.elasticCounter.direction;
      }
      if (data.elasticCounter.countDown.state === true) {
        dir = this.getOppositeDirection(data.elasticCounter.direction);
      }

      mod = getMod(dir, unit3);

      if (data.elasticCounter.pause.state !== true) {
        finalCoords = {
          x: baseCoords.x + mod.x,
          y: baseCoords.y + mod.y,
        };
      } else {
        finalCoords = {
          x: baseCoords.x,
          y: baseCoords.y,
        };
      }

      let targetCell;
      data.elasticCounter.coords = finalCoords;
      targetCell = this.getCellFromDirection(1, data.currentPosition.cell.number, dir);
      let targetCellRef = this.gridInfo.find(
        (x) => x.number.x === targetCell.x && x.number.y === targetCell.y
      );
      drawCell = { x: undefined, y: undefined };

      if (data.elasticCounter.countUp.state === true) {
        if (targetCellRef) {
          drawCell = targetCellRef.number;
        } else {
          drawCell = data.currentPosition.cell.number;
        }
      }
      if (
        data.elasticCounter.pause.state === true &&
        data.elasticCounter.pause.type === "peak"
      ) {
        if (targetCellRef) {
          drawCell = targetCellRef.number;
        } else {
          drawCell = data.currentPosition.cell.number;
        }
      }
      if (data.elasticCounter.countDown.state === true) {
        drawCell = data.currentPosition.cell.number;
      }
      if (
        (data.elasticCounter.pause.state === true &&
          data.elasticCounter.pause.type === "start") ||
        (data.elasticCounter.pause.state === true &&
          data.elasticCounter.pause.type === "end")
      ) {
        drawCell = data.currentPosition.cell.number;
      }
    };

    if (type === "halfPushBack") {
      let base = 0.015;
      let unit;
      let baseCoords = {
        x: undefined,
        y: undefined,
      };
      let dir = "";

      if (subType === "player") {
        switch (this.gridWidth) {
          case 12:
            unit = base / 3;
            break;
          case 9:
            unit = base;
            break;
          case 6:
            unit = base * 1.2;
            break;
          case 3:
            unit = base * 3;
            break;
          default:
        }

        baseCoords = {
          x: data.halfPushBack.coords.x,
          y: data.halfPushBack.coords.y,
        };

        if (data.halfPushBack.countUp.state === true) {
          dir = data.halfPushBack.direction;
        }
        if (data.halfPushBack.countDown.state === true) {
          dir = this.getOppositeDirection(data.halfPushBack.direction);
        }
      }

      if (subType === "obstacle") {
        unit = 2;

        baseCoords = {
          x: data.coords.x,
          y: data.coords.y,
        };

        if (data.countUp.state === true) {
          dir = data.direction;
        }
        if (data.countDown.state === true) {
          dir = this.getOppositeDirection(data.direction);
        }
      }

      mod = getMod(dir, unit);

      finalCoords = {
        x: baseCoords.x + mod.x,
        y: baseCoords.y + mod.y,
      };
      let targetCell;

      if (subType === "player") {
        data.halfPushBack.coords = finalCoords;

        targetCell = this.getCellFromDirection(
          1,
          data.currentPosition.cell.number,
          data.halfPushBack.direction
        );
      }
      if (subType === "obstacle") {
        data.coords = finalCoords;

        targetCell = this.getCellFromDirection(1, data.myCellNo, data.direction);
      }

      let targetCellRef = this.gridInfo.find(
        (x) => x.number.x === targetCell.x && x.number.y === targetCell.y
      );
      drawCell = { x: undefined, y: undefined };

      if (subType === "player") {
        if (data.halfPushBack.countUp.state === true) {
          if (targetCellRef) {
            drawCell = targetCellRef.number;
          } else {
            drawCell = data.currentPosition.cell.number;
          }
        }
        if (data.halfPushBack.countDown.state === true) {
          drawCell = data.currentPosition.cell.number;
        }

        // this.players[data.number - 1] = data;
      }
      if (subType === "obstacle") {
        if (data.countUp.state === true) {
          if (targetCellRef) {
            drawCell = targetCellRef.number;
          } else {
            drawCell = data.myCellNo;
          }
        }
        if (data.countDown.state === true) {
          drawCell = data.myCellNo;
        }
      }
    }

    if (type === "deflected") {
      let base = 0.002;
      let unit;

      if (data.elasticCounter.countUp.count <= 3) {
        base = 0.007;
      }
      if (
        data.elasticCounter.countUp.count > 3 &&
        data.elasticCounter.countUp.count < 6
      ) {
        base = 0.005;
      }
      if (data.elasticCounter.countUp.count > 6) {
        base = 0.002;
      }

      finish(base, unit);
    }

    if (type === "dodging") {
      let base = 0.002;
      let unit;

      if (data.elasticCounter.countUp.count <= 3) {
        base = 0.007;
      }
      if (
        data.elasticCounter.countUp.count > 3 &&
        data.elasticCounter.countUp.count < 6
      ) {
        base = 0.005;
      }
      if (data.elasticCounter.countUp.count > 6) {
        base = 0.002;
      }

      finish(base, unit);
    }

    if (type === "attacking" || type === "defending") {
      let base = 0.002;
      let unit;

      if (data.elasticCounter.countUp.count <= 3) {
        if (data[type].directionType === "thrust") {
          base = 0.003;
        }
        if (data[type].directionType === "slash") {
          base = 0.005;
        }
      }
      if (
        data.elasticCounter.countUp.count > 3 &&
        data.elasticCounter.countUp.count < 6
      ) {
        if (data[type].directionType === "thrust") {
          base = 0.001;
        }
        if (data[type].directionType === "slash") {
          base = 0.003;
        }
      }
      if (data.elasticCounter.countUp.count > 6) {
        if (data[type].directionType === "thrust") {
          base = 0.0008;
        }
        if (data[type].directionType === "slash") {
          base = 0.002;
        }
      }

      finish(base, unit);
    }

    // console.log("calcElasticCountCoords", finalCoords);
    return {
      coords: finalCoords,
      drawCell: drawCell,
      player: data,
    };
  };

  rnJesus = (min, max) => {
    min = Math.ceil(min);
    max = Math.floor(max);
    return Math.floor(Math.random() * (max - min + 1)) + min;
  };
  getTarget = (player) => {
    // console.log('checking target',player.number,'dir',player.direction);

    let canvas = this.canvasRef.current;
    let context = canvas.getContext("2d");

    let gridInfo = this.gridInfo;
    // let player = this.players[this.currentPlayer-1];
    let currentPosition = player.currentPosition.cell.number;
    let direction = player.direction;
    let voidDirection;
    let target = this.resetTarget();
    let midGridVoid1 = false;
    let midGridVoid2 = false;
    let edgeVoid1 = false;
    let edgeVoid2 = false;

    if (player.moveCancel.state === true) {
      currentPosition = player.target.cell1.number;
    }

    // DIRECTION MOD: STRAFING
    if (player.strafing.state === true && player.strafing.direction !== "") {
      direction = player.strafing.direction;
    }

    // DIRECTION MOD: FLANKING!!
    if (player.flanking.checking === true) {
      if (player.flanking.step === 0) {
        direction = player.flanking.direction;
      }
    }
    if (player.flanking.state === true) {
      if (player.flanking.step === 1) {
        direction = player.flanking.preFlankDirection;
      }
    }
    if (player.flanking.state === true) {
      if (player.flanking.step === 2) {
        direction = player.direction;
        // direction = player.flanking.preFlankDirection;
      }
    }

    if (player.jumping.checking === true) {
      direction = player.direction;
    }
    if (player.pulling.state === true) {
      direction = player.prePull.direction;
    }
    // if (player.pulled.state === true) {
    //   direction = this.players[player.pulled.puller-1].prePull.direction;
    // }

    // SET CELL 1 & 2 NUMBERS

    target.cell1.number = this.getCellFromDirection(1, currentPosition, direction);
    target.cell2.number = this.getCellFromDirection(2, currentPosition, direction);

    let targetCell1Ref = this.gridInfo.find(
      (x) => x.number.x === target.cell1.number.x && x.number.y === target.cell1.number.y
    );
    let targetCell2Ref = this.gridInfo.find(
      (x) => x.number.x === target.cell2.number.x && x.number.y === target.cell2.number.y
    );

    // CHECK SET VOID AND CENTERS
    voidDirection = direction;
    if (player.strafing.state === true) {
      voidDirection = player.strafing.direction;
    }
    if (!targetCell1Ref) {
      target.cell1.void = true;
      edgeVoid1 = true;
      target.cell1.center = this.getVoidCenter(
        1,
        voidDirection,
        player.currentPosition.cell.center
      );
      // this.testDraw.push({color:'red',x:target.cell1.center.x,y:target.cell1.center.y})
    }
    if (targetCell1Ref) {
      target.cell1.center = targetCell1Ref.center;
      if (targetCell1Ref.void.state === true) {
        target.cell1.void = true;
        midGridVoid1 = true;
      }
    }
    if (!targetCell2Ref) {
      target.cell2.void = true;
      edgeVoid2 = true;
      target.cell2.center = this.getVoidCenter(
        2,
        voidDirection,
        player.currentPosition.cell.center
      );
      // this.testDraw.push({color:'red',x:target.cell2.center.x,y:target.cell2.center.y})
    }
    if (targetCell2Ref) {
      target.cell2.center = targetCell2Ref.center;
      if (targetCell2Ref.void.state === true) {
        target.cell2.void = true;
        midGridVoid2 = true;
      }
    }

    let myCell = this.gridInfo.find(
      (elem2) =>
        elem2.number.x === player.currentPosition.cell.number.x &&
        elem2.number.y === player.currentPosition.cell.number.y
    );

    target.myCellBlock = this.checkMyCellBarrier(direction, myCell);
    // let fwdBarrier = this.checkForwardBarrier(direction,cellRef);

    for (const plyr of this.players) {
      if (plyr.number !== player.number) {
        if (
          target.cell1.number.x === plyr.currentPosition.cell.number.x &&
          target.cell1.number.y === plyr.currentPosition.cell.number.y
        ) {
          target.cell1.occupant.type = "player";
          target.cell1.occupant.player = plyr.number;
          target.cell1.free = false;
        }
        if (
          target.cell2.number.x === plyr.currentPosition.cell.number.x &&
          target.cell2.number.y === plyr.currentPosition.cell.number.y
        ) {
          target.cell2.occupant.type = "player";
          target.cell2.occupant.player = plyr.number;
          target.cell2.free = false;
        }
      }
    }

    if (targetCell1Ref) {
      if (targetCell1Ref.obstacle.state === true) {
        target.cell1.occupant.type = "obstacle";
        target.cell1.free = false;
      }

      if (targetCell1Ref.barrier.state === true) {
        if (targetCell1Ref.barrier.position === this.getOppositeDirection(direction)) {
          target.cell1.occupant.type = "barrier";
          target.cell1.free = false;
        }

        if (targetCell2Ref) {
          if (
            targetCell1Ref.barrier.position === direction ||
            targetCell2Ref.barrier.position === this.getOppositeDirection(direction)
          ) {
            target.cell2.occupant.type = "barrier";
            target.cell2.free = false;
          }
        }

        if (!targetCell2Ref && targetCell1Ref.barrier.position === direction) {
          // target.cell1.occupant.type = "barrier";
          // target.cell1.free = false;

          target.cell2.occupant.type = "barrier";
          target.cell2.free = false;
        }
      }

      if (targetCell1Ref.item.name !== "" && target.cell1.occupant.type !== "player") {
        target.cell1.occupant.type = "item";
      }

      if (targetCell1Ref.rubble === true) {
        target.cell1.occupant.type = "rubble";
      }

      if (targetCell1Ref.elevation.number > myCell.elevation.number) {
        target.cell1.occupant.type = "higherElevation";
        target.cell1.free = false;
      }
    }
    if (targetCell2Ref) {
      if (targetCell2Ref.obstacle.state === true) {
        target.cell2.occupant.type = "obstacle";
        target.cell2.free = false;
      }

      if (targetCell2Ref.barrier.position === this.getOppositeDirection(direction)) {
        target.cell2.occupant.type = "barrier";
        target.cell2.free = false;
      }

      if (targetCell2Ref.item.name !== "" && target.cell2.occupant.type !== "player") {
        target.cell2.occupant.type = "item";
      }

      if (targetCell2Ref.rubble === true) {
        target.cell2.occupant.type = "rubble";
      }

      if (targetCell2Ref.elevation.number > myCell.elevation.number) {
        target.cell2.occupant.type = "higherElevation";
        target.cell2.free = false;
      }
    }

    // console.log('target',target);
    player.target = target;
    this.players[player.number - 1] = player;

    return target;
  };
  resetTarget = () => {
    return {
      cell1: {
        number: {
          x: 0,
          y: 0,
        },
        center: {
          x: 0,
          y: 0,
        },
        free: true,
        occupant: {
          type: "",
          player: "",
        },
        void: false,
      },
      cell2: {
        number: {
          x: 0,
          y: 0,
        },
        center: {
          x: 0,
          y: 0,
        },
        free: true,
        occupant: {
          type: "",
          player: "",
        },
        void: false,
      },
      myCellBlock: false,
    };
  };
  checkCell = (cell) => {
    // console.log('check cell',cell);

    let cellFree = true;
    let cell2 = this.gridInfo.find(
      (elem) => elem.number.x === cell.x && elem.number.y === cell.y
    );
    if (
      // cell2.levelData.charAt(0) ===  'z' ||
      // cell2.levelData.charAt(0) ===  'y'
      cell2.obstacle.state === true
    ) {
      cellFree = false;
    }
    if (cell2.item.name !== "") {
      cellFree = false;
    }
    if (cell2.void.state === true) {
      cellFree = false;
    }
    if (
      cell2.terrain.type === "deep" ||
      cell2.terrain.type === "hazard" ||
      cell2.terrain.type === "void"
    ) {
      cellFree = false;
    }

    // PLAYERS 1&2 ALT RESPAWN POINTS!
    if (this.gridWidth > 6) {
      if (cell.x === this.gridWidth && cell.y === this.gridWidth) {
        cellFree = false;
      }
      if (cell.x === this.gridWidth && cell.y === 0) {
        cellFree = false;
      }
    }

    for (const player of this.players) {
      if (this.init === true) {
        if (
          player.startPosition.cell.number.x === cell.x &&
          player.startPosition.cell.number.y === cell.y
        ) {
          cellFree = false;
        }
      } else {
        if (
          player.currentPosition.cell.number.x === cell.x &&
          player.currentPosition.cell.number.y === cell.y
        ) {
          cellFree = false;
        }
      }
    }

    return cellFree;
  };
  getRandomFreeCell = () => {
    let cell = {
      number: { x: undefined, y: undefined },
      center: { x: undefined, y: undefined },
    };
    let randomFreeCellChosen = false;
    let noMoreCells = false;
    let trashCells = [];

    while (randomFreeCellChosen !== true) {
      cell.number.x = this.rnJesus(0, this.gridWidth);
      cell.number.y = this.rnJesus(0, this.gridWidth);
      randomFreeCellChosen = this.checkCell(cell.number);

      if (randomFreeCellChosen !== true) {
        // console.log('getRandomFreeCell: not free',cell.number);
        trashCells.push(cell);
        if (
          trashCells.length +
            this.gridInfo.filter(
              (x) =>
                x.obstacle.state === true ||
                x.terrain.type === "deep" ||
                // x.terrain.type === "void" ||
                x.void.state === true
            ).length +
            this.playerNumber >=
          this.gridInfo.length
        ) {
          // console.log('getRandomFreeCell. no more cells!');
          noMoreCells = true;
          // randomFreeCellChosen = true
          cell = {
            number: { x: undefined, y: undefined },
            center: { x: undefined, y: undefined },
          };
          break;
        }
      }
      if (randomFreeCellChosen === true) {
        // console.log('getRandomFreeCell: free cell',cell.number);

        break;
      }
    }

    if (noMoreCells === true) {
      // console.log('no more cells 2');
      return null;
    }

    if (randomFreeCellChosen === true) {
      // console.log('getRandomFreeCell: set free cell',cell.number);
      let refCell = this.gridInfo.find(
        (x) => x.number.x === cell.number.x && x.number.y === cell.number.y
      );
      cell.number = refCell.number;
      cell.center = refCell.center;
      return cell;
    }
  };
  getDirectionFromCells = (cell1Number, cell2Number) => {
    let direction = "";

    if (cell2Number.x === cell1Number.x && cell2Number.y === cell1Number.y - 1) {
      direction = "north";
    }
    if (cell2Number.x === cell1Number.x - 1 && cell2Number.y === cell1Number.y - 1) {
      direction = "northWest";
    }
    if (cell2Number.x === cell1Number.x - 1 && cell2Number.y === cell1Number.y) {
      direction = "west";
    }
    if (cell2Number.x === cell1Number.x - 1 && cell2Number.y === cell1Number.y + 1) {
      direction = "southWest";
    }
    if (cell2Number.x === cell1Number.x && cell2Number.y === cell1Number.y + 1) {
      direction = "south";
    }
    if (cell2Number.x === cell1Number.x + 1 && cell2Number.y === cell1Number.y + 1) {
      direction = "southEast";
    }
    if (cell2Number.x === cell1Number.x + 1 && cell2Number.y === cell1Number.y) {
      direction = "east";
    }
    if (cell2Number.x === cell1Number.x + 1 && cell2Number.y === cell1Number.y - 1) {
      direction = "northEast";
    }
    if (direction === "") {
      if (cell1Number.x === cell2Number.x && cell1Number.y > cell2Number.y) {
        direction = "north";
      }
      if (cell1Number.x === cell2Number.x && cell1Number.y < cell2Number.y) {
        direction = "south";
      }
      if (cell1Number.x > cell2Number.x && cell2Number.y === cell1Number.y) {
        direction = "west";
      }
      if (cell1Number.x < cell2Number.x && cell1Number.y === cell2Number.y) {
        direction = "east";
      }
    }

    return direction;
  };
  getVoidCenter = (range, direction, originCenter) => {
    let voidCenter = {
      x: undefined,
      y: undefined,
    };
    let xMod = this.floorImageWidth / 2;
    let yMod = this.floorImageHeight / 2;
    if (range === 2) {
      xMod = this.floorImageWidth;
      yMod = this.floorImageHeight;
    }
    switch (direction) {
      case "north":
        voidCenter = {
          x: originCenter.x + xMod,
          y: originCenter.y - yMod,
        };
        break;
      case "south":
        voidCenter = {
          x: originCenter.x - xMod,
          y: originCenter.y + yMod,
        };
        break;
      case "west":
        voidCenter = {
          x: originCenter.x - xMod,
          y: originCenter.y - yMod,
        };
        break;
      case "east":
        voidCenter = {
          x: originCenter.x + xMod,
          y: originCenter.y + yMod,
        };
        break;
    }

    return voidCenter;
  };
  getCellFromDirection = (range, originCellNumber, direction) => {
    let cellNumber = {
      x: undefined,
      y: undefined,
    };

    switch (direction) {
      case "north":
        cellNumber = {
          x: originCellNumber.x,
          y: originCellNumber.y - range,
        };
        break;
      case "east":
        cellNumber = {
          x: originCellNumber.x + range,
          y: originCellNumber.y,
        };
        break;
      case "west":
        cellNumber = {
          x: originCellNumber.x - range,
          y: originCellNumber.y,
        };
        break;
      case "south":
        cellNumber = {
          x: originCellNumber.x,
          y: originCellNumber.y + range,
        };
        break;
      default:
        break;
    }

    return cellNumber;
  };
  getSurroundingCells = (originCellNo, count, option, items, rubble) => {
    // option can be 'all' free' or 'walkable'
    let availibleCells = [];

    let baseDirs = ["south", "west", "north", "east"];
    let multiple = 1;
    let baseDirIndx = 0;
    let refPos = {
      x: originCellNo.x,
      y: originCellNo.y,
    };
    let cellToCheck = {
      x: undefined,
      y: undefined,
    };
    let instructions = [];
    let instructionRef = {
      north: {
        x: 0,
        y: -1,
      },
      south: {
        x: 0,
        y: 1,
      },
      east: {
        x: 1,
        y: 0,
      },
      west: {
        x: -1,
        y: 0,
      },
    };
    let stepsA = 0;
    let stepsB = 0;

    while (availibleCells.length < count) {
      for (let i = 0; i < multiple; i++) {
        instructions.push(baseDirs[baseDirIndx]);
        // console.log('set instructions baseDirIndx',baseDirIndx,'multiple',multiple,'baseDir',baseDirs[baseDirIndx]);
      }
      // console.log('item drop instructions',instructions);

      for (const instruct of instructions) {
        cellToCheck = {
          x: refPos.x + instructionRef[instruct].x,
          y: refPos.y + instructionRef[instruct].y,
        };
        // console.log('ctc instruct ',instruct,instructionRef[instruct],'cell to check',cellToCheck,'steps',stepsA,stepsB);

        let ctcRef = this.gridInfo.find(
          (x) => x.number.x === cellToCheck.x && x.number.y === cellToCheck.y
        );

        let cellFree = true;

        // if (
        //   ctcRef.number.x < 0 ||
        //   ctcRef.number.x > this.gridWidth-1 ||
        //   ctcRef.number.y < 0 ||
        //   ctcRef.number.y > this.gridWidth-1
        // ) {
        //   cellFree = false;
        // }
        if (ctcRef) {
          // console.log("ab", cellToCheck, ctcRef.obstacle.state);
          if (items === true) {
            if (ctcRef.item.name !== "") {
              cellFree = false;
            }
          }
          if (rubble === true) {
            if (ctcRef.rubble === true) {
              cellFree = false;
            }
          }
          if (option === "walkable") {
            if (
              ctcRef.obstacle.state === true ||
              ctcRef.void.state === true ||
              ctcRef.terrain.type === "deep" ||
              ctcRef.terrain.name === "lava"
            ) {
              cellFree = false;
            }
          }

          if (option === "free" || option === "walkable") {
            for (const plyr of this.players) {
              if (
                plyr.currentPosition.cell.number.x === ctcRef.number.x &&
                plyr.currentPosition.cell.number.y === ctcRef.number.y
              ) {
                cellFree = false;
              }
            }
          }
        } else {
          cellFree = false;
        }

        if (cellFree === true) {
          count--;
          availibleCells.push(cellToCheck);
          // console.log("xy", cellToCheck);
          // console.log('cell free',cellToCheck,'item count1',itemCount,'item count2',itemCount2,'availibleCells',availibleCells.length,'steps',stepsA,stepsB);
          // console.log('availibleCells',availibleCells.length,availibleCells);
        } else {
          // console.log('cell not free',cellToCheck,'availibleCells',availibleCells.length,'steps',stepsA,stepsB);
          // console.log('availibleCells',availibleCells.length,availibleCells);
        }
        refPos = {
          x: cellToCheck.x,
          y: cellToCheck.y,
        };
        stepsA++;
        stepsB++;

        if (availibleCells.length === count) {
          break;
        }
      }

      instructions = [];

      // if (steps%2 === 0) {
      //   stepsA = 0;
      //   multiple++;
      // }
      if (stepsB === multiple * 2) {
        multiple++;
        stepsB = 0;
      }
      if (baseDirIndx >= 3) {
        // console.log('a');
        baseDirIndx = 0;
      } else {
        baseDirIndx++;
      }
    }

    return availibleCells;
  };
  checkForwardBarrier = (direction, cell) => {
    let fwdBarrier = false;
    if (cell.barrier.state === true) {
      if (direction === this.getOppositeDirection(cell.barrier.position)) {
        fwdBarrier = true;
      }
    }
    return fwdBarrier;
  };
  checkMyCellBarrier = (direction, myCell) => {
    let myCellBarrier = false;
    if (myCell.barrier.state === true) {
      if (myCell.barrier.position === direction) {
        myCellBarrier = true;
      }
    }

    return myCellBarrier;
  };
  getOppositeDirection = (originalDirection) => {
    let oppositeDirection = "";
    switch (originalDirection) {
      case "north":
        oppositeDirection = "south";
        break;
      case "south":
        oppositeDirection = "north";
        break;
      case "east":
        oppositeDirection = "west";
        break;
      case "west":
        oppositeDirection = "east";
        break;
      default:
    }
    return oppositeDirection;
  };

  projectileTester = (cell) => {
    let result = this.projectileCreator(
      "custom",
      {
        direction: "south",
        originCell: cell,
      },
      "bolt"
    );
    this.projectiles.push(result.projectile);
    this.getBoltTarget(result.projectile);

    if (
      this.camera.customView.state !== true &&
      this.settingAutoCamera === false &&
      player.ai.state !== true &&
      this.camera.preInstructions.length === 0 &&
      this.camera.instructions.length === 0
    ) {
      // if (this.players[0].dead.state !== true) {
      //   if (player.number === 1) {
      //     this.setAutoCamera("attackFocus", player);
      //   }
      // } else if (player.number === 2) {
      //   this.setAutoCamera("attackFocus", player);
      // }
      this.setAutoCamera(`followBolt_${result.projectile.id}`, "");
    } else {
      console.log("no setting auto cam: followBolt");
    }
  };
  projectileCreator = (ownerType, owner, projectileType) => {
    // console.log("projectileCreator", owner.id);
    // other projectile type is "arc"
    let projectile;
    if (ownerType === "custom") {
      let origin = {
        number: owner.originCell.number,
        center: owner.originCell.center,
      };
      let nextPosition = origin.center;
      projectile = {
        id: "000" + this.projectiles.length + "",
        type: projectileType,
        owner: "",
        ownerType: "custom",
        origin: origin,
        direction: owner.direction,
        moving: {
          state: false,
          step: 0,
          course: "",
          origin: {
            number: origin.number,
            center: origin.center,
          },
          destination: {
            x: 0,
            y: 0,
          },
        },
        currentPosition: {
          number: origin.number,
          center: origin.center,
        },
        nextPosition: {
          x: nextPosition.x,
          y: nextPosition.y,
        },
        target: {
          path: [],
          free: true,
          occupant: {
            type: "",
            player: "",
          },
          void: false,
        },
        speed: this.projectileSpeed,
        elevation: owner.originCell.elevation.number,
        kill: false,
        charge: 0,
      };
    } else {
      if (projectileType === "bolt") {
        if (ownerType === "player") {
          let origin = owner.currentPosition.cell;
          let currentPosition = owner.currentPosition.cell;
          let nextPosition = owner.currentPosition.cell.center;
          let elevation = this.gridInfo.find(
            (elem) =>
              elem.number.x === owner.currentPosition.cell.number.x &&
              elem.number.y === owner.currentPosition.cell.number.y
          ).elevation.number;

          projectile = {
            id: "000" + this.projectiles.length + "",
            type: projectileType,
            owner: owner.number,
            ownerType: "player",
            origin: origin,
            direction: owner.direction,
            moving: {
              state: false,
              step: 0,
              course: "",
              origin: {
                number: currentPosition.number,
                center: currentPosition.center,
              },
              destination: {
                x: 0,
                y: 0,
              },
            },
            currentPosition: {
              number: currentPosition.number,
              center: currentPosition.center,
            },
            nextPosition: {
              x: nextPosition.x,
              y: nextPosition.y,
            },
            target: {
              path: [],
              free: true,
              occupant: {
                type: "",
                player: "",
              },
              void: false,
            },
            speed: this.projectileSpeed,
            elevation: elevation,
            kill: false,
            charge: owner.attacking.charge,
          };

          owner.items.ammo--;
          owner.currentWeapon.effect = "ammo+0";

          if (!owner.popups.find((x) => x.msg === "attacking")) {
            owner.popups.push({
              state: false,
              count: 0,
              limit:
                owner.attacking.animRef.limit[owner.currentWeapon.type] -
                owner.attacking.animRef.peak[owner.currentWeapon.type],
              type: "",
              position: "",
              msg: "attacking",
              img: "",
            });
          }
        }

        let refCell;
        let direction = "";
        if (ownerType === "obstacle") {
          refCell = this.gridInfo.find(
            (x) => x.obstacle.state === true && x.obstacle.id === owner.id
          );
          let origin = {
            number: refCell.number,
            center: refCell.center,
          };
          let nextPosition = refCell.center;
          direction = this.getDirectionFromCells(origin.number, owner.trap.target);
          projectile = {
            id: "000" + this.projectiles.length + "",
            type: projectileType,
            owner: owner.id,
            ownerType: "obstacle",
            origin: origin,
            direction: direction,
            moving: {
              state: false,
              step: 0,
              course: "",
              origin: {
                number: origin.number,
                center: origin.center,
              },
              destination: {
                x: 0,
                y: 0,
              },
            },
            currentPosition: {
              number: origin.number,
              center: origin.center,
            },
            nextPosition: {
              x: nextPosition.x,
              y: nextPosition.y,
            },
            target: {
              path: [],
              free: true,
              occupant: {
                type: "",
                player: "",
              },
              void: false,
            },
            speed: this.projectileSpeed,
            elevation: refCell.elevation.number,
            kill: false,
            charge: 0,
          };
        }

        if (ownerType === "barrier") {
          refCell = this.gridInfo.find(
            (x) => x.barrier.state === true && x.barrier.id === owner.id
          );
          let origin = {
            number: refCell.number,
            center: refCell.center,
          };
          let nextPosition = refCell.center;
          direction = this.getDirectionFromCells(origin.number, owner.trap.target);
          projectile = {
            id: "000" + this.projectiles.length + "",
            type: projectileType,
            owner: owner.id,
            ownerType: "barrier",
            origin: origin,
            direction: direction,
            moving: {
              state: false,
              step: 0,
              course: "",
              origin: {
                number: origin.number,
                center: origin.center,
              },
              destination: {
                x: 0,
                y: 0,
              },
            },
            currentPosition: {
              number: origin.number,
              center: origin.center,
            },
            nextPosition: {
              x: nextPosition.x,
              y: nextPosition.y,
            },
            target: {
              path: [],
              free: true,
              occupant: {
                type: "",
                player: "",
              },
              void: false,
            },
            speed: this.projectileSpeed,
            elevation: refCell.elevation.number,
            kill: false,
            charge: 0,
          };

          // owner.items.ammo--;
          // owner.currentWeapon.effect = "ammo+0";
          // remove trap ammo and set weapon effect
        }
      }
    }

    return {
      owner: owner,
      projectile: projectile,
    };
  };
  projectileTracker = () => {
    for (const bolt of this.projectiles) {
      if (bolt.kill === true) {
        let index = this.projectiles.findIndex((blt) => blt.id === bolt.id);
        this.projectiles.splice(index, 1);
        // console.log(
        //   "kill bolt",
        //   bolt.currentPosition.number,
        //   // this.players[bolt.owner - 1].currentPosition.cell.number,
        //   this.projectiles,
        //   this.settingAutoCamera,
        //   this.settingAutoCameraFollowBolt
        // );
        if (this.settingAutoCameraFollowBolt === true) {
          this.setAutoCamera("zoomReset", "");
        }
      }

      if (bolt.type === "bolt" && bolt.moving.state === true && bolt.kill !== true) {
        // console.log("traking projectile", bolt.id);

        let index = this.projectiles.findIndex((blt) => blt.id === bolt.id);
        bolt.currentPosition.center = bolt.nextPosition;

        let boltNextPosition = this.boltCrementer(bolt);
        bolt.nextPosition = boltNextPosition;
        // console.log('moving bolt nxt pos',bolt.nextPosition);

        // CHECK WHICH CELL BOLT IS AT
        for (const cell of bolt.target.path) {
          let point = [bolt.currentPosition.center.x, bolt.currentPosition.center.y];
          let polygon = [];
          for (const vertex of cell.vertices) {
            let vertexPoint = [vertex.x - 10, vertex.y - 5];
            // let vertexPoint = [vertex.x,vertex.y];
            polygon.push(vertexPoint);
          }
          let pip = pointInPolygon(point, polygon);
          if (pip === true) {
            // console.log("bolt passing through cell", cell.number);
            bolt.currentPosition.number = cell.number;

            let infoCell = this.gridInfo.find(
              (x) => x.number.x === cell.number.x && x.number.y === cell.number.y
            );

            let boltOwner;
            if (bolt.ownerType === "player") {
              boltOwner = this.players[bolt.owner - 1];
            }
            if (bolt.ownerType === "obstacle" || bolt.ownerType === "barrier") {
              boltOwner = this.gridInfo.find(
                (x) =>
                  x[bolt.ownerType].state === true && x[bolt.ownerType].id === bolt.owner
              )[bolt.ownerType];
            }
            if (bolt.ownerType === "custom") {
              boltOwner = bolt.owner;
            }

            // PATH HIGHLIGHT
            if (
              cell.number.x === bolt.origin.number.x &&
              cell.number.y === bolt.origin.number.y
            ) {
            } else {
              this.cellsUnderAttack.push({
                number: {
                  x: cell.number.x,
                  y: cell.number.y,
                },
                count: 1,
                limit: 5,
              });
            }

            if (infoCell.elevation.number === bolt.elevation) {
              let fwdBarrier = false;

              if (infoCell.barrier.state === true && infoCell.barrier.height >= 1) {
                // if (infoCell.barrier.position === bolt.direction) {
                //   fwdBarrier = true;
                // }
                fwdBarrier = this.checkForwardBarrier(bolt.direction, infoCell);
              }

              if (bolt.target.path.length === 1) {
                if (
                  infoCell.barrier.state === true &&
                  infoCell.barrier.position === bolt.direction
                ) {
                  this.attackCellContents(
                    "bolt",
                    bolt.ownerType,
                    boltOwner,
                    infoCell,
                    undefined,
                    undefined,
                    bolt
                  );
                }
              }

              if (infoCell.barrier.position === bolt.direction) {
                fwdBarrier = true;
              }
              let dodged = false;

              // CHECK FOR PLAYERS
              if (fwdBarrier !== true) {
                if (bolt.ownerType === "player") {
                  for (const plyr of this.players) {
                    if (
                      plyr.currentPosition.cell.number.x === cell.number.x &&
                      plyr.currentPosition.cell.number.y === cell.number.y &&
                      plyr.dead.state !== true &&
                      plyr.number !== bolt.owner
                    ) {
                      this.projectileAttackParse(bolt, "player", "player", plyr);
                    }
                  }
                }
                if (
                  bolt.ownerType === "obstacle" ||
                  bolt.ownerType === "barrier" ||
                  bolt.ownerType === "custom"
                ) {
                  for (const plyr of this.players) {
                    if (
                      plyr.currentPosition.cell.number.x === cell.number.x &&
                      plyr.currentPosition.cell.number.y === cell.number.y &&
                      plyr.dead.state !== true
                    ) {
                      this.projectileAttackParse(bolt, bolt.ownerType, "player", plyr);
                    }
                  }
                }

                // CHECK FOR OBSTACLE &  REAR BARRIER COLLISION

                if (infoCell.obstacle.state === true && infoCell.obstacle.height >= 1) {
                  if (
                    bolt.ownerType !== "player" &&
                    `obstacle_${infoCell.obstacle.id}` !==
                      `${bolt.ownerType}_${boltOwner.id}`
                  ) {
                    this.attackCellContents(
                      "bolt",
                      bolt.ownerType,
                      boltOwner,
                      infoCell,
                      undefined,
                      undefined,
                      bolt
                    );
                  }
                  if (bolt.ownerType === "player") {
                    this.attackCellContents(
                      "bolt",
                      bolt.ownerType,
                      boltOwner,
                      infoCell,
                      undefined,
                      undefined,
                      bolt
                    );
                  }
                } else if (
                  infoCell.barrier.state === true &&
                  infoCell.barrier.height >= 1
                ) {
                  this.attackCellContents(
                    "bolt",
                    bolt.ownerType,
                    boltOwner,
                    infoCell,
                    undefined,
                    undefined,
                    bolt
                  );
                }
              } else {
                // HANDLE FWD BARRIER BOLT COLLISION
                if (infoCell.barrier.state === true && infoCell.barrier.height >= 1) {
                  if (
                    `barrier_${infoCell.barrier.id}` !==
                    `${bolt.ownerType}_${boltOwner.id}`
                  ) {
                    let myCell = this.gridInfo.find(
                      (x) =>
                        x.number.x === bolt.origin.number.x &&
                        x.number.y === bolt.origin.number.y
                    );
                    this.attackCellContents(
                      "bolt",
                      bolt.ownerType,
                      boltOwner,
                      infoCell,
                      undefined,
                      myCell,
                      bolt
                    );
                  } else {
                    console.log("this barrier is the same as the bolt owner. do nothing");
                  }
                }
              }
            } else {
              if (infoCell.elevation.number < bolt.elevation) {
                console.log("bolt moving over lower cell. ");

                this.attackCellContents(
                  "flyOverBolt",
                  bolt.ownerType,
                  boltOwner,
                  infoCell,
                  undefined,
                  undefined,
                  bolt
                );
              }
              if (infoCell.elevation.number > bolt.elevation) {
                console.log("bolt hit cell of higher elevation.");
                bolt.kill = true;
              }
            }
          }
        }

        // BOLT WENT OUT OF CANVAS BOUNDS
        if (
          bolt.currentPosition.center.x < 0 ||
          bolt.currentPosition.center.y < 0 ||
          bolt.currentPosition.center.x > this.canvasWidth ||
          bolt.currentPosition.center.y > this.canvasHeight
        ) {
          console.log("bolt went out of canvas bounds");
          bolt.kill = true;
        }
      }

      if (bolt.type === "arc" && bolt.moving.state === true && bolt.kill !== true) {
      }
    }
  };
  aiBoltPathCheck = (aiPlayer) => {
    // console.log('aiPlayer.ai.targetPlayer',aiPlayer.ai.targetPlayer);
    let rangeElemCells2 = [];
    let rangeElem = aiPlayer.currentPosition.cell.number;
    let targetPos = aiPlayer.ai.targetPlayer.currentPosition;

    let dirToFire;
    let diff = 0;
    if (rangeElem.x === targetPos.x && rangeElem.y > targetPos.y) {
      dirToFire = "north";
      diff = rangeElem.y - targetPos.y;
      for (var i = 0; i < diff; i++) {
        rangeElemCells2.push({ x: rangeElem.x, y: rangeElem.y - i });
        // this.cellsToHighlight.push({x:rangeElem.x, y: rangeElem.y - i})
      }
    }
    if (rangeElem.x > targetPos.x && rangeElem.y === targetPos.y) {
      dirToFire = "west";
      diff = rangeElem.x - targetPos.x;
      for (var i = 0; i < diff; i++) {
        rangeElemCells2.push({ x: rangeElem.x - i, y: rangeElem.y });
        // this.cellsToHighlight.push({x:rangeElem.x - i, y: rangeElem.y})
      }
    }
    if (rangeElem.x === targetPos.x && rangeElem.y < targetPos.y) {
      dirToFire = "south";
      diff = targetPos.y - rangeElem.y;
      for (var i = 0; i < diff; i++) {
        rangeElemCells2.push({ x: rangeElem.x, y: rangeElem.y + i });
        // this.cellsToHighlight.push({x:rangeElem.x, y: rangeElem.y + i})
      }
    }
    if (rangeElem.x < targetPos.x && rangeElem.y === targetPos.y) {
      dirToFire = "east";
      diff = targetPos.x - rangeElem.x;
      for (var i = 0; i < diff; i++) {
        rangeElemCells2.push({ x: rangeElem.x + i, y: rangeElem.y });
        // this.cellsToHighlight.push({x:rangeElem.x + i, y: rangeElem.y})
      }
    }

    // IS SIGHT OBSTRUCTED?
    // let clearToShoot = true;
    let obstructions = [];
    for (const cellx of rangeElemCells2) {
      // console.log('cellx',cellx);
      let cellRef4 = this.gridInfo.find(
        (elemb) => elemb.number.x === cellx.x && elemb.number.y === cellx.y
      );
      if (cellRef4.obstacle.state === true && cellRef4.obstacle.height >= 1) {
        // clearToShoot = false;
        obstructions.push(cellx);
      }
      if (cellRef4.barrier.state === true) {
        // clearToShoot = false;
        obstructions.push(cellx);
      }

      if (
        // cellRef4.levelData.charAt(0) !==  'y' &&
        // cellRef4.levelData.charAt(0) !==  'z'
        (cellRef4.obstacle.state !== true && cellRef4.barrier.state !== true) ||
        (cellRef4.obstacle.state === true && cellRef4.obstacle.height < 1)
      ) {
        // clearToShoot = true;
        // obstructions.push(cellx)
      }
    }

    // console.log('aiBoltPathCheck obstructions',obstructions);
    if (obstructions.length === 0) {
      return true;
    } else {
      return false;
    }

    // return clearToShoot
  };
  getBoltTarget = (bolt) => {
    // console.log('get bolt target');

    let index = this.projectiles.findIndex((blt) => blt.id === bolt.id);

    let path = [];
    let originCell = {
      x: bolt.moving.origin.number.x,
      y: bolt.moving.origin.number.y,
    };

    bolt.target.path.push({
      number: {
        x: originCell.x,
        y: originCell.y,
      },
      center: {
        x: 0,
        y: 0,
      },
      vertices: [],
    });

    let nextCell = {
      number: {
        x: 0,
        y: 0,
      },
      center: {
        x: 0,
        y: 0,
      },
      vertices: [],
    };
    while (
      nextCell.number.x >= 0 &&
      nextCell.number.y >= 0 &&
      nextCell.number.x <= this.gridWidth &&
      nextCell.number.y <= this.gridWidth
    ) {
      // console.log(originCell.x,originCell.y);
      let cell = {
        number: {
          x: 0,
          y: 0,
        },
        center: {
          x: 0,
          y: 0,
        },
        vertices: [],
      };

      // cell.number = this.getCellFromDirection(1,originCell.number,this.players[bolt.owner-1].direction);
      cell.number = this.getCellFromDirection(1, originCell, bolt.direction);

      nextCell = cell;
      originCell = nextCell.number;
      bolt.target.path.push(cell);
    }
    if (bolt.target.path.length > 1) {
      bolt.target.path.splice(bolt.target.path.length - 1, 1);
    }

    // console.log('bolt path',bolt.target.path);

    for (const cell2 of bolt.target.path) {
      let cell = this.gridInfo.find(
        (elem) => elem.number.x === cell2.number.x && elem.number.y === cell2.number.y
      );

      if (cell) {
        cell2.center.x = cell.center.x;
        cell2.center.y = cell.center.y;
        cell2.vertices = cell.vertices;
      }
    }
    if (bolt.target.path.length === 1) {
      bolt.target.path.push({
        number: this.getCellFromDirection(1, bolt.target.path[0].number, bolt.direction),
        center: this.getVoidCenter(1, bolt.direction, bolt.target.path[0].center),
        vertices: [],
      });
    }

    bolt.moving.state = true;

    this.projectiles[index] = bolt;
  };
  isBoltInCell = (cellNumber) => {
    let bolt = false;
    for (const bolt2 of this.projectiles) {
      if (
        cellNumber.x === bolt2.currentPosition.number.x &&
        cellNumber.y === bolt2.currentPosition.number.y
      ) {
        bolt = true;
      }
    }

    return bolt;
  };

  checkDestination = (player, pickupOnly) => {
    // console.log('checking for item or enviro effect');

    this.players[player.number - 1].terrainMoveSpeed.state = false;
    let pickUp = false;
    let cell = this.gridInfo.find(
      (elem) =>
        elem.number.x === player.currentPosition.cell.number.x &&
        elem.number.y === player.currentPosition.cell.number.y
    );

    let gearAmount = 0;
    for (const weapon of player.items.weapons) {
      if (weapon.name && weapon.name !== "") {
        gearAmount++;
      }
    }
    for (const armor of player.items.armor) {
      if (armor.name && armor.name !== "") {
        gearAmount++;
      }
    }

    let haveSpace = false;
    if (gearAmount < player.inventorySize) {
      haveSpace = true;
    }
    // console.log('gearAmount', gearAmount, 'inventorySize',player.inventorySize);

    // if (haveSpace === true && ) {

    // console.log('check dest cell',cell);

    // let cell = this.gridInfo.find(elem => elem.number.x === player.currentPosition.cell.number.x && elem.number.y === player.currentPosition.cell.number.y)
    if (cell.item.name !== "") {
      // console.log('picked up an item');

      // GEAR
      if (cell.item.type === "weapon") {
        if (haveSpace === true) {
          // NO CUREENT WEAPON, EQUIP
          if (player.currentWeapon.name === "" || !player.currentWeapon.name) {
            this.players[player.number - 1].currentWeapon = {
              name: cell.item.name,
              type: cell.item.subType,
              effect: cell.item.effect,
            };
            this.players[player.number - 1].items.weapons.push({
              name: cell.item.name,
              type: cell.item.subType,
              effect: cell.item.effect,
            });
            if (cell.item.subType === "crossbow") {
              let ammo = parseInt(cell.item.effect.split("+")[1]);
              // console.log('picked up a crossbow checking ammo',ammo);
              if (
                !this.players[player.number - 1].popups.find((x) => x.msg === "crossbow")
              ) {
                this.players[player.number - 1].popups.push({
                  state: false,
                  count: 0,
                  limit: 25,
                  type: "",
                  position: "",
                  msg: "crossbow",
                  img: "",
                });
              }

              this.players[player.number - 1].items.ammo =
                this.players[player.number - 1].items.ammo + ammo;
              // console.log('new ammo amt',this.players[player.number-1].items.ammo);
            }

            if (
              !this.players[player.number - 1].popups.find(
                (x) => x.msg === "pickupWeapon"
              )
            ) {
              this.players[player.number - 1].popups.push({
                state: false,
                count: 0,
                limit: 25,
                type: "",
                position: "",
                msg: "pickupWeapon",
                img: "",
              });
            }

            pickUp = true;
          }

          // STASH IN INVENTORY
          else {
            // DON'T ALREADY HAVE WEPAON
            if (
              player.items.weapons
                .map((weapon) => weapon.name)
                .includes(cell.item.name) !== true
            ) {
              this.players[player.number - 1].items.weapons.push({
                name: cell.item.name,
                type: cell.item.subType,
                effect: cell.item.effect,
              });

              if (cell.item.subType === "crossbow") {
                let ammo = parseInt(cell.item.effect.split("+")[1]);
                // console.log('picked up a crossbow checking ammo',ammo);
                if (
                  !this.players[player.number - 1].popups.find(
                    (x) => x.msg === "crossbow"
                  )
                ) {
                  this.players[player.number - 1].popups.push({
                    state: false,
                    count: 0,
                    limit: 25,
                    type: "",
                    position: "",
                    msg: "crossbow",
                    img: "",
                  });
                }
                this.players[player.number - 1].items.ammo =
                  this.players[player.number - 1].items.ammo + ammo;
                // console.log('new ammo amt',this.players[player.number-1].items.ammo);
              }
              pickUp = true;

              this.players[player.number - 1].statusDisplay = {
                state: true,
                status: "weapon accquired",
                count: 1,
                limit: this.players[player.number - 1].statusDisplay.limit,
              };

              if (
                !this.players[player.number - 1].popups.find(
                  (x) => x.msg === "pickupWeapon"
                )
              ) {
                this.players[player.number - 1].popups.push({
                  state: false,
                  count: 0,
                  limit: 25,
                  type: "",
                  position: "",
                  msg: "pickupWeapon",
                  img: "",
                });
              }
            }

            // ALREADY HAVE WEAPON
            else {
              if (cell.item.subType === "crossbow") {
                let ammo = parseInt(cell.item.effect.split("+")[1]);
                this.players[player.number - 1].items.ammo =
                  this.players[player.number - 1].items.ammo + ammo;
                console.log("you already have a crossbow but take the ammo", ammo);
                cell.item.effect = "ammo+0";

                if (
                  !this.players[player.number - 1].popups.find(
                    (x) => x.msg === "pickupAmmo"
                  )
                ) {
                  this.players[player.number - 1].popups.push({
                    state: false,
                    count: 0,
                    limit: 25,
                    type: "",
                    position: "",
                    msg: "pickupAmmo",
                    img: "",
                  });
                }
              } else {
                console.log("you already have this weapon");
                this.players[player.number - 1].statusDisplay = {
                  state: true,
                  status: "Already have this weapon!",
                  count: 1,
                  limit: this.players[player.number - 1].statusDisplay.limit,
                };

                if (
                  !this.players[player.number - 1].popups.find((x) => x.msg === "stop")
                ) {
                  this.players[player.number - 1].popups.push({
                    state: false,
                    count: 0,
                    limit: 25,
                    type: "",
                    position: "",
                    msg: "stop",
                    img: "",
                  });
                }
              }
            }
          }
        }

        // NO SPACE TO PICKUP
        else if (cell.item.name !== "") {
          console.log("Not enough space!!");

          this.players[player.number - 1].statusDisplay = {
            state: true,
            status: "Not enough space!!",
            count: 1,
            limit: this.players[player.number - 1].statusDisplay.limit,
          };

          if (
            !this.players[player.number - 1].popups.find((x) => x.msg === "inventoryFull")
          ) {
            this.players[player.number - 1].popups.push({
              state: false,
              count: 0,
              limit: 25,
              type: "",
              position: "",
              msg: "inventoryFull",
              img: "",
            });
          }
        }
      }

      if (cell.item.type === "armor") {
        // console.log('picked up armor',player.currentArmor);

        if (haveSpace === true) {
          // EQUIP
          if (player.currentArmor.name === "" || !player.currentArmor.name) {
            // console.log('gg',cell.item.effect);
            this.players[player.number - 1].currentArmor = {
              name: cell.item.name,
              type: cell.item.subType,
              effect: cell.item.effect,
            };
            this.players[player.number - 1].items.armor.push({
              name: cell.item.name,
              type: cell.item.subType,
              effect: cell.item.effect,
            });

            this.applyRemoveEffect(player, "apply", "pickup", "armor", cell.item);

            pickUp = true;
          }

          // STASH TO INVENTORY
          else {
            if (
              player.items.armor.map((armor) => armor.name).includes(cell.item.name) !==
              true
            ) {
              this.players[player.number - 1].items.armor.push({
                name: cell.item.name,
                type: cell.item.subType,
                effect: cell.item.effect,
              });
              pickUp = true;

              this.players[player.number - 1].statusDisplay = {
                state: true,
                status: "armor accquired",
                count: 1,
                limit: this.players[player.number - 1].statusDisplay.limit,
              };

              if (
                !this.players[player.number - 1].popups.find(
                  (x) => x.msg === "pickupArmor"
                )
              ) {
                this.players[player.number - 1].popups.push({
                  state: false,
                  count: 0,
                  limit: 25,
                  type: "",
                  position: "",
                  msg: "pickupArmor",
                  img: "",
                });
              }
            } else {
              console.log("you already have this armor");
              this.players[player.number - 1].statusDisplay = {
                state: true,
                status: "Already have this armor!",
                count: 1,
                limit: this.players[player.number - 1].statusDisplay.limit,
              };

              if (!this.players[player.number - 1].popups.find((x) => x.msg === "stop")) {
                this.players[player.number - 1].popups.push({
                  state: false,
                  count: 0,
                  limit: 25,
                  type: "",
                  position: "",
                  msg: "stop",
                  img: "",
                });
              }
            }
          }
        }
        // INVENTORY FULL
        else if (cell.item.name !== "") {
          console.log("Not enough space!!");

          this.players[player.number - 1].statusDisplay = {
            state: true,
            status: "Not enough space!!",
            count: 1,
            limit: this.players[player.number - 1].statusDisplay.limit,
          };

          if (
            !this.players[player.number - 1].popups.find((x) => x.msg === "inventoryFull")
          ) {
            this.players[player.number - 1].popups.push({
              state: false,
              count: 0,
              limit: 25,
              type: "",
              position: "",
              msg: "inventoryFull",
              img: "",
            });
          }
        }
      }

      // ITEM
      else if (cell.item.type !== "weapon" && cell.item.type !== "armor") {
        // console.log('item',cell.item);

        pickUp = this.applyRemoveEffect(player, "apply", "pickup", "item", cell.item);
      }

      if (pickUp === true) {
        // PICKUP ANIM!!
        if (cell.item.type === "item") {
          this.players[player.number - 1].itemPickup = {
            state: true,
            count: 0,
            limit: 10,
            item: {
              name: cell.item.name,
            },
            gear: {
              type: "",
            },
          };
        } else if (cell.item.type === "weapon" || cell.item.type === "armor") {
          this.players[player.number - 1].itemPickup = {
            state: true,
            count: 0,
            limit: 10,
            item: {
              name: "",
            },
            gear: {
              type: cell.item.subType,
            },
          };
        }

        cell.item = {
          name: "",
          type: "",
          subType: "",
          effect: "",
          initDrawn: false,
        };
      }
    }

    // }
    // else if (cell.item.name !== '') {
    //   console.log('Not enough space!!');
    //
    //   this.players[player.number-1].statusDisplay = {
    //     state: true,
    //     status: 'Not enough space!!',
    //     count: 1,
    //     limit: this.players[player.number-1].statusDisplay.limit,
    //   }
    // }

    let nextPosition;
    switch (cell.terrain.type) {
      case "stone":
        // console.log('player',player.number,' stepped in',cell.terrain.name,'type',cell.terrain.type);
        break;
      case "grass":
        // console.log('player',player.number,' stepped in',cell.terrain.name,'type',cell.terrain.type);
        break;
      case "deep":
        this.players[player.number - 1].falling.state = true;
        this.players[player.number - 1].action = "falling";
        this.players[player.number - 1].drowning = true;

        if (!this.players[player.number - 1].popups.find((x) => x.msg === "drowning")) {
          this.players[player.number - 1].popups.push({
            state: false,
            count: 0,
            limit: 25,
            type: "",
            position: "",
            msg: "drowning",
            img: "",
          });
        }

        // this.moveSpeed = plyr.speed.move;
        // this.players[player.number-1].target = this.resetTarget();
        this.players[player.number - 1].target.cell1.number =
          player.currentPosition.cell.number;
        this.players[player.number - 1].target.cell1.center =
          player.currentPosition.cell.center;

        this.players[player.number - 1].moving = {
          state: true,
          step: 0,
          course: "",
          origin: {
            number: player.currentPosition.cell.number,
            center: player.currentPosition.cell.center,
          },
          destination: {
            x: player.currentPosition.cell.center.x,
            y: player.currentPosition.cell.center.y,
          },
        };

        nextPosition = this.lineCrementer(player);
        this.players[player.number - 1].nextPosition = nextPosition;

        // console.log('player',player.number,' stepped in',cell.terrain.name,'type',cell.terrain.type);
        break;
      case "void":
        this.players[player.number - 1].falling.state = true;
        this.players[player.number - 1].action = "falling";

        if (!this.players[player.number - 1].popups.find((x) => x.msg === "falling")) {
          this.players[player.number - 1].popups.push({
            state: false,
            count: 0,
            limit: 25,
            type: "",
            position: "",
            msg: "falling",
            img: "",
          });
        }

        // this.moveSpeed = plyr.speed.move;
        // this.players[player.number-1].target = this.resetTarget();
        this.players[player.number - 1].target.cell1.number =
          player.currentPosition.cell.number;
        this.players[player.number - 1].target.cell1.center =
          player.currentPosition.cell.center;

        this.players[player.number - 1].moving = {
          state: true,
          step: 0,
          course: "",
          origin: {
            number: player.currentPosition.cell.number,
            center: player.currentPosition.cell.center,
          },
          destination: {
            x: player.currentPosition.cell.center.x,
            y: player.currentPosition.cell.center.y,
          },
        };

        nextPosition = this.lineCrementer(player);
        this.players[player.number - 1].nextPosition = nextPosition;

        // console.log('player',player.number,' stepped in',cell.terrain.name,'type',cell.terrain.type);
        break;
      case "road":
        // console.log('player',player.number,' stepped in',cell.terrain.name,'type',cell.terrain.type);
        break;
      case "shallow":
        // console.log('player',player.number,' stepped in',cell.terrain.name,'type',cell.terrain.type);
        this.players[player.number - 1].terrainMoveSpeed.state = true;
        this.players[player.number - 1].terrainMoveSpeed.speed =
          this.terrainMoveSpeedRef[cell.terrain.type];
        break;
      case "sticky":
        // console.log('player',player.number,' stepped in',cell.terrain.name,'type',cell.terrain.type);
        this.players[player.number - 1].terrainMoveSpeed.state = true;
        this.players[player.number - 1].terrainMoveSpeed.speed =
          this.terrainMoveSpeedRef[cell.terrain.type];

        if (!player.popups.find((x) => x.msg === "terrainSlowdown")) {
          this.players[player.number - 1].popups.push({
            state: false,
            count: 0,
            limit: 25,
            type: "",
            position: "",
            msg: "terrainSlowdown",
            img: "",
          });
        }

        break;
      case "slippery":
        // console.log('player',player.number,' stepped in',cell.terrain.name,'type',cell.terrain.type);
        this.players[player.number - 1].terrainMoveSpeed.state = true;
        this.players[player.number - 1].terrainMoveSpeed.speed =
          this.terrainMoveSpeedRef[cell.terrain.type];

        if (!player.popups.find((x) => x.msg === "terrainSpeedup")) {
          this.players[player.number - 1].popups.push({
            state: false,
            count: 0,
            limit: 25,
            type: "",
            position: "",
            msg: "terrainSpeedup",
            img: "",
          });
        }

        break;
      case "hazard":
        // console.log('player',player.number,' stepped in',cell.terrain.name,'type',cell.terrain.type);
        let applyHazard;
        if (cell.terrain.name === "lava") {
          applyHazard = this.rnJesus(1, 2);
        } else {
          applyHazard = this.rnJesus(1, 3);
        }
        if (applyHazard === 1) {
          // if (!this.players[player.number-1].popups.find(x=>x.msg === 'alarmed')) {
          //   this.players[player.number-1].popups.push(
          //     {
          //       state: false,
          //       count: 0,
          //       limit:25,
          //       type: '',
          //       position: '',
          //       msg: 'alarmed',
          //       img: '',
          //
          //     }
          //   )
          // }

          this.handleMiscPlayerDamage(player, "applyHazard");
        }
        break;
    }

    if (pickupOnly !== true) {
      if (cell.rubble === true) {
        // console.log('stepped on rubble @ check destination. removing it too');

        let applyHazard = this.rnJesus(1, 3);

        if (applyHazard === 1) {
          this.handleMiscPlayerDamage(player, "applyHazard");
        }

        this.gridInfo.find(
          (x) => x.number.x === cell.number.x && x.number.y === cell.number.y
        ).rubble = false;
      }
    } else {
      console.log("check Destination pickuponly");
    }
  };
  obstacleCheckDestination = (targetCell, player) => {
    // let targetCell = this.gridInfo.find(
    //   (x) => x.number.x === cell.number.x && x.number.y === cell.number.y
    // );
    let damage = 0;
    if (targetCell.terrain.name === "lava") {
      damage = targetCell.obstacle.hp;
    }
    if (targetCell.terrain.type === "hazard" || targetCell.rubble === true) {
      if (targetCell.terrain.name !== "lava") {
        damage = this.rnJesus(1, targetCell.obstacle.hp - 1);
        if (damage === 0) {
          damage = 1;
        }
      }
    }
    if (targetCell.obstacle.trap.state === true) {
      // if (!targetCell.obstacle.trap.target.x || targetCell.obstacle.trap.target.x === undefined) {

      // }
      let availibleCells = [];
      if (targetCell.obstacle.trap.direction === "") {
        availibleCells = this.getSurroundingCells(
          targetCell.number,
          30,
          "walkable",
          false,
          false
        );
        if (availibleCells.length > 0) {
          if (targetCell.obstacle.trap.item.subType === "crossbow") {
            targetCell.obstacle.trap.target = availibleCells
              .slice()
              .reverse()
              .find((x) => x.x === targetCell.number.x || x.y === targetCell.number.y);
          } else {
            if (targetCell.obstacle.trap.item.subType === "spear") {
              // targetCell.obstacle.trap.target = availibleCells[1];
              targetCell.obstacle.trap.target = availibleCells
                .slice()
                .find(
                  (x) =>
                    (x.x === targetCell.number.x &&
                      (x.y === targetCell.number.y + 2 ||
                        x.y === targetCell.number.y - 2)) ||
                    (x.y === targetCell.number.y &&
                      (x.x === targetCell.number.x + 2 ||
                        x.x === targetCell.number.x - 2))
                );
            }
            if (targetCell.obstacle.trap.item.subType === "sword") {
              // targetCell.obstacle.trap.target = availibleCells[0];
              targetCell.obstacle.trap.target = availibleCells
                // .slice()
                // .find((x) => x.x === targetCell.number.x || x.y === targetCell.number.y);
                .slice()
                .find(
                  (x) =>
                    (x.x === targetCell1.number.x &&
                      (x.y === targetCell.number.y + 1 ||
                        x.y === targetCell.number.y - 1)) ||
                    (x.y === targetCell.number.y &&
                      (x.x === targetCell.number.x + 1 ||
                        x.x === targetCell.number.x - 1))
                );
            }
          }
          console.log("trap target reset after moving trap");
        } else {
          targetCell.obstacle.trap.state = false;
          console.log(
            `Obstacle trap disables because there is no appropriate target cell`
          );
        }
      } else {
        let cell;
        if (targetCell.obstacle.trap.item.subType === "crossbow") {
          cell = this.getCellFromDirection(
            3,
            targetCell.number,
            targetCell.obstacle.trap.direction
          );
        }
        if (targetCell.obstacle.trap.item.subType === "spear") {
          cell = this.getCellFromDirection(
            2,
            targetCell.number,
            targetCell.obstacle.trap.direction
          );
        }
        if (targetCell.obstacle.trap.item.subType === "sword") {
          cell = this.getCellFromDirection(
            1,
            targetCell.number,
            targetCell.obstacle.trap.direction
          );
        }
        if (!this.gridInfo.find((x) => cell.x === x.number.x && cell.y === x.number.y)) {
          targetCell.obstacle.trap.state = false;
          console.log(
            `obstacletrap disabled because there is no appropriate target cell`,
            data.number
          );
        } else {
          targetCell.obstacle.trap.target = cell;
          // console.log("trap target set", data.number, targetCell.obstacle.trap.target, targetCell.obstacle.trap.ammo);
        }
      }
    }

    // DAMAGE/DESTROY OBSTACLE?
    if (targetCell.obstacle.destructible.state === true && damage > 0) {
      // WEAPON CHECK
      if (targetCell.obstacle.hp - damage > 0) {
        let hp = targetCell.obstacle.hp - damage;

        targetCell.obstacle = {
          id: targetCell.obstacle.id,
          trap: targetCell.obstacle.trap,
          state: targetCell.obstacle.state,
          name: targetCell.obstacle.name,
          type: targetCell.obstacle.type,
          hp: hp,
          destructible: targetCell.obstacle.destructible,
          locked: targetCell.obstacle.locked,
          weight: targetCell.obstacle.weight,
          height: targetCell.obstacle.height,
          items: targetCell.obstacle.items,
          effects: targetCell.obstacle.effects,
          moving: targetCell.obstacle.moving,
        };
        this.obstacleBarrierToDestroy.push({
          type: "obstacle",
          action: "damage",
          count: 0,
          limit: 30,
          complete: false,
          cell: targetCell,
        });
      }

      // DESTROY OBSTACLE W/ OR W/O RUBBLE
      else if (targetCell.obstacle.hp - damage <= 0) {
        let itemsToDrop = [];
        if (
          targetCell.obstacle.destructible.leaveRubble === true &&
          targetCell.rubble !== true
        ) {
          // console.log('leave rubble on ',targetCell.number,'removing obstacle');
          if (targetCell.obstacle.items[0]) {
            itemsToDrop = targetCell.obstacle.items;
          }
          // let cellRef = this.gridInfo.find(elem => elem.number.x === targetCell.number.x && elem.number.y === targetCell.number.y);
          targetCell.rubble = true;
          // targetCell.terrain.type = 'hazard';

          targetCell.obstacle = {
            id: targetCell.obstacle.id,
            trap: targetCell.obstacle.trap,
            state: false,
            name: targetCell.obstacle.name,
            type: targetCell.obstacle.type,
            hp: 0,
            destructible: targetCell.obstacle.destructible,
            locked: targetCell.obstacle.locked,
            weight: targetCell.obstacle.weight,
            height: targetCell.obstacle.height,
            items: targetCell.obstacle.items,
            effects: targetCell.obstacle.effects,
            moving: targetCell.obstacle.moving,
          };

          this.players[player.number - 1].statusDisplay = {
            state: true,
            status: "Destroyed " + targetCell.obstacle.name + "!",
            count: 1,
            limit: this.players[player.number - 1].statusDisplay.limit,
          };

          if (!player.popups.find((x) => x.msg === "destroyedItem")) {
            player.popups.push({
              state: false,
              count: 0,
              limit: 30,
              type: "",
              position: "",
              msg: "destroyedItem",
              img: "",
            });
          }
        } else {
          // console.log('no rubble. Just remove obstacle');
          if (targetCell.obstacle.items[0]) {
            itemsToDrop = targetCell.obstacle.items;
          }

          targetCell.obstacle = {
            id: targetCell.obstacle.id,
            trap: targetCell.obstacle.trap,
            state: false,
            name: targetCell.obstacle.name,
            type: targetCell.obstacle.type,
            hp: 0,
            destructible: targetCell.obstacle.destructible,
            locked: targetCell.obstacle.locked,
            weight: targetCell.obstacle.weight,
            height: targetCell.obstacle.height,
            items: targetCell.obstacle.items,
            effects: targetCell.obstacle.effects,
            moving: targetCell.obstacle.moving,
          };

          this.players[player.number - 1].statusDisplay = {
            state: true,
            status: "Destroyed " + targetCell.obstacle.name + "!",
            count: 1,
            limit: this.players[player.number - 1].statusDisplay.limit,
          };

          if (!player.popups.find((x) => x.msg === "destroyedItem")) {
            player.popups.push({
              state: false,
              count: 0,
              limit: 30,
              type: "",
              position: "",
              msg: "destroyedItem",
              img: "",
            });
          }
        }

        // DROP OBSTACLE ITEMS?
        if (itemsToDrop[0]) {
          // console.log('dropping obstacle items bolt',itemsToDrop);

          this.obstacleItemDrop(targetCell, player);
        }
        this.obstacleBarrierToDestroy.push({
          type: "obstacle",
          action: "destroy",
          count: 0,
          limit: 30,
          complete: false,
          cell: targetCell,
        });
      }
    }

    // DESTROY ITEM?
    if (targetCell.item.name !== "") {
      targetCell.item = {
        name: "",
        type: "",
        subType: "",
        effect: "",
        initDrawn: false,
      };
    }
    if (targetCell.rubble === true) {
      targetCell.rubble = false;
    }
  };
  customCellToVoid = (cell) => {
    console.log("void specific cell");

    this.cellToVoid.state = true;
    this.cellToVoid.x = cell.x;
    this.cellToVoid.y = cell.y;
    this.cellToVoid.count = 1;

    this.openVoid = true;
    this.voidCustomCell = true;
  };
  voidSummon = (cell) => {
    // console.log('opening void');

    let foundPlayer;
    let player;
    let cl = this.gridInfo.find(
      (elem) => elem.number.x === cell.x && elem.number.y === cell.y
    );

    if (cl.number.x === this.gridWidth && cl.number.y === 0) {
      // console.log('dont void this');
    }
    if (cl.number.x === this.gridWidth && cl.number.y === this.gridWidth) {
      // console.log('dont void this');
    } else {
      cl.item = {
        name: "",
        type: "",
        subType: "",
        effect: "",
        initDrawn: false,
      };
      cl.void.state = true;

      if (this.bloodSacrificeEvent.state === true) {
        // console.log('bloodSacrificeVoidedCells',cl);
        this.bloodSacrificeVoidedCells.push(cl);
      }
      // console.log('voiding',cl.number.x,cl.number.y);

      // if (
      //   cl.levelData.charAt(0) === 'y'
      // ) {
      //   let x = cl.levelData.slice(1,3)
      //   cl.levelData = "x"+x+"";
      // }
      // if (
      //   cl.levelData.charAt(0) === 'z'
      // ) {
      //   let x = cl.levelData.slice(1,3)
      //   cl.levelData = "x"+x+"";
      // }
    }

    for (const plyr of this.players) {
      if (
        plyr.currentPosition.cell.number.x === cell.x &&
        plyr.currentPosition.cell.number.y === cell.y
      ) {
        foundPlayer = true;
        this.players[plyr.number - 1].falling.state = true;
        this.players[plyr.number - 1].action = "falling";

        this.players[plyr.number - 1].popups.push({
          state: false,
          count: 0,
          limit: 25,
          type: "",
          position: "",
          msg: "falling",
          img: "",
        });

        this.moveSpeed = plyr.speed.move;
        this.players[plyr.number - 1].target = this.resetTarget();

        this.players[plyr.number - 1].moving = {
          state: true,
          step: 0,
          course: "",
          origin: {
            number: plyr.currentPosition.cell.number,
            center: plyr.currentPosition.cell.center,
          },
          destination: {
            x: plyr.currentPosition.cell.center.x,
            y: plyr.currentPosition.cell.center.y,
          },
        };

        let nextPosition = this.lineCrementer(plyr);
        this.players[plyr.number - 1].nextPosition = nextPosition;
      }
    }

    this.updatePathArray();

    this.easyStar.avoidAdditionalPoint(cell.x, cell.y);

    for (const plyr2 of this.players) {
      if (plyr2.ai.state === true) {
        plyr2.ai.targetAcquired = false;
      }
    }
  };
  jumpCollisionCheck = (type, subType, player) => {
    // console.log('jumpCollisionCheck',type,subType);

    let jumpComplete = true;
    let cellRef = undefined;
    let otherPlayer = undefined;

    if (subType === "cell1") {
      cellRef = this.gridInfo.find(
        (x) =>
          x.number.x === player.target.cell1.number.x &&
          x.number.y === player.target.cell1.number.y
      );
    }
    if (subType === "cell2") {
      cellRef = this.gridInfo.find(
        (x) =>
          x.number.x === player.target.cell2.number.x &&
          x.number.y === player.target.cell2.number.y
      );
    }
    if (type === "player") {
      for (const plyr of this.players) {
        if (
          plyr.currentPosition.cell.number.x === cellRef.number.x &&
          plyr.currentPosition.cell.number.y === cellRef.number.y
        ) {
          otherPlayer = plyr;
        }
      }
    }

    let obstacle = undefined;
    let barrier = undefined;
    if (type === "barrier" && cellRef.barrier.state === true) {
      barrier = cellRef.barrier;
    }
    if (type === "obstacle" && cellRef.obstacle.state === true) {
      obstacle = cellRef.obstacle;
    }

    let shouldDamageObstacle = (args) => {
      if (args.destructible.state === true) {
        let hp = args.hp - 1;
        let state = true;
        if (hp <= 0) {
          state = false;
        }
        cellRef.obstacle = {
          state: state,
          name: cellRef.obstacle.name,
          type: cellRef.obstacle.type,
          hp: hp,
          destructible: cellRef.obstacle.destructible,
          locked: cellRef.obstacle.locked,
          weight: cellRef.obstacle.weight,
          height: cellRef.obstacle.height,
          items: cellRef.obstacle.items,
          effects: cellRef.obstacle.effects,
          moving: cellRef.obstacle.moving,
        };
      } else {
        if (
          !this.cellPopups.find(
            (x) =>
              x.msg === "unbreakable" &&
              x.cell.number.x === cellRef.number.x &&
              x.cell.number.y === cellRef.number.y
          )
        ) {
          this.cellPopups.push({
            state: false,
            count: 0,
            limit: 35,
            type: "",
            position: "",
            msg: "unbreakable",
            color: "",
            img: "",
            cell: this.gridInfo.find(
              (x) => x.number.x === cellRef.number.x && x.number.y === cellRef.number.y
            ),
          });
        }
      }

      if (cellRef.obstacle.hp <= 0) {
        animateDamageDestroy("obstacle", "destroy", cellRef.obstacle);
      } else {
        animateDamageDestroy("obstacle", "damage", cellRef.obstacle);
      }

      return cellRef.obstacle;
    };

    let shouldDamageBarrier = (args) => {
      if (args.destructible.state === true) {
        let hp = args.hp - 1;
        let state = true;
        if (hp <= 0) {
          state = false;
        }
        cellRef.barrier = {
          state: state,
          name: cellRef.barrier.name,
          type: cellRef.barrier.type,
          hp: hp,
          destructible: cellRef.barrier.destructible,
          locked: cellRef.barrier.locked,
          position: cellRef.barrier.position,
          height: cellRef.barrier.height,
        };
      } else {
        if (
          !this.cellPopups.find(
            (x) =>
              x.msg === "unbreakable" &&
              x.cell.number.x === cellRef.number.x &&
              x.cell.number.y === cellRef.number.y
          )
        ) {
          this.cellPopups.push({
            state: false,
            count: 0,
            limit: 35,
            type: "",
            position: "",
            msg: "unbreakable",
            color: "",
            img: "",
            cell: this.gridInfo.find(
              (x) => x.number.x === cellRef.number.x && x.number.y === cellRef.number.y
            ),
          });
        }
      }

      if (cellRef.barrier.hp <= 0) {
        animateDamageDestroy("barrier", "destroy", cellRef.barrier);
      } else {
        animateDamageDestroy("barrier", "damage", cellRef.barrier);
      }

      return cellRef.barrier;
    };

    let animateDamageDestroy = (type, action, args) => {
      if (action === "damage") {
        this.obstacleBarrierToDestroy.push({
          type: type,
          action: "damage",
          count: 0,
          limit: 30,
          complete: false,
          cell: cellRef,
        });
        this.players[player.number - 1].statusDisplay = {
          state: true,
          status: "Damaged " + cellRef[type].name + "!",
          count: 1,
          limit: player.statusDisplay.limit,
        };
      }
      if (action === "destroy") {
        this.obstacleBarrierToDestroy.push({
          type: type,
          action: "destroy",
          count: 0,
          limit: 30,
          complete: false,
          cell: cellRef,
        });
        this.players[player.number - 1].statusDisplay = {
          state: true,
          status: "Destroyed " + cellRef[type].name + "!",
          count: 1,
          limit: player.statusDisplay.limit,
        };

        if (!player.popups.find((x) => x.msg === "destroyedItem")) {
          player.popups.push({
            state: false,
            count: 0,
            limit: 30,
            type: "",
            position: "",
            msg: "destroyedItem",
            img: "",
          });
        }

        if (cellRef.obstacle.items[0]) {
          this.obstacleItemDrop(cellRef, player);
        }

        if (
          cellRef.obstacle.destructible.leaveRubble === true ||
          cellRef.barrier.destructible.leaveRubble === true
        ) {
          if (cellRef.terrain.type !== "void" && cellRef.terrain.type !== "deep") {
            cellRef.rubble = true;
          }
        }
      }
    };

    let interruptJump = () => {
      player.jumping.state = false;
      player.strafing.state = false;
      player.action = "idle";

      jumpComplete = false;

      if (type === "barrier") {
        player.moving = {
          state: false,
          step: 0,
          course: "",
          origin: {
            number: {
              x: player.target.cell1.number.x,
              y: player.target.cell1.number.y,
            },
            center: {
              x: player.target.cell1.center.x,
              y: player.target.cell1.center.y,
            },
          },
          destination: {
            x: 0,
            y: 0,
          },
        };
        player.currentPosition.cell.number = player.target.cell1.number;
        player.currentPosition.cell.center = player.target.cell1.center;

        this.checkDestination(player, false);
      }

      if (type === "obstacle" || type === "player") {
        player.jumping.state = false;
        player.strafing.state = false;
        player.action = "idle";
        player.moving = {
          state: false,
          step: 0,
          course: "",
          origin: {
            number: {
              x: player.target.cell2.number.x,
              y: player.target.cell2.number.y,
            },
            center: {
              x: player.target.cell2.center.x,
              y: player.target.cell2.center.y,
            },
          },
          destination: {
            x: 0,
            y: 0,
          },
        };

        player.currentPosition.cell.number = player.target.cell2.number;
        player.currentPosition.cell.center = player.target.cell2.center;

        this.pushBack(player, this.getOppositeDirection(player.direction));
      }
    };

    let completeJump = () => {
      if (type === "obstacle" || type === "player") {
        this.players[player.number - 1].jumping.checking = false;
        player.jumping.state = false;
        player.currentPosition.cell.number = player.target[subType].number;
        player.currentPosition.cell.center = player.target[subType].center;
        player.strafing.state = false;
        player.action = "idle";
        player.moving = {
          state: false,
          step: 0,
          course: "",
          origin: {
            number: {
              x: player.target.cell2.number.x,
              y: player.target.cell2.number.y,
            },
            center: {
              x: player.target.cell2.center.x,
              y: player.target.cell2.center.y,
            },
          },
          destination: {
            x: 0,
            y: 0,
          },
        };

        this.checkDestination(player, false);
      }

      if (type === "barrier") {
        this.players[player.number - 1].jumping.checking = false;
        this.players[player.number - 1].jumping.state = true;
        player.action = "jumping";
        player.moving = {
          state: true,
          step: player.moving.step,
          course: "",
          origin: {
            // number: player.target.cell1.number,
            // center: player.target.cell1.center,
            number: player.currentPosition.cell.number,
            center: player.currentPosition.cell.center,
          },
          destination: player.target.cell2.center,
        };
        // player.currentPosition.cell.number = player.target.cell2.number;
        // player.currentPosition.cell.center = player.target.cell2.center;

        let nextPosition = this.lineCrementer(player);
        // nextPosition = this.jumpCrementer(player);
        player.nextPosition = nextPosition;
      }
    };

    switch (type) {
      case "barrier":
        barrier = shouldDamageBarrier(barrier);
        // this.handleMiscPlayerDamage(player,"jumpCollision")

        player = this.players[player.number - 1];

        if (player.dead.state === true) {
          // DO NOTHING
        } else {
          if (subType === "cell1") {
            let cell2Ref = this.gridInfo.find(
              (x) =>
                x.number.x === player.target.cell2.number.x &&
                x.number.y === player.target.cell2.number.y
            );

            if (
              cell2Ref.barrier.state === true &&
              cell2Ref.barrier.position === this.getOppositeDirection(player.direction)
            ) {
              interruptJump();
            } else {
              if (barrier.hp > 0) {
                interruptJump();
              } else {
                // DO NOTHING, COMPLETE JUMP
                completeJump();
              }
            }
          }
          if (subType === "cell2") {
            if (barrier.hp > 0) {
              interruptJump();
            } else {
              // DO NOTHING, COMPLETE JUMP
              completeJump();
            }
          }
        }

        break;
      case "obstacle":
        obstacle = shouldDamageObstacle(obstacle);
        this.handleMiscPlayerDamage(player, "jumpCollision");

        player = this.players[player.number - 1];
        if (player.dead.state === true) {
          // DO NOTHING
        } else {
          if (obstacle.hp > 0) {
            if (player.hp >= obstacle.hp) {
              let canPush = this.canPushObstacle(player, cellRef, "jumpCollision");

              if (canPush === true) {
                // DO NOTHING, COMPLETE JUMP

                completeJump();
              } else {
                interruptJump();
              }
            } else {
              interruptJump();
            }
          } else {
            completeJump();
            // DO NOTHING, COMPLETE JUMP
          }
        }

        break;
      case "player":
        let damageBoth = false;
        this.handleMiscPlayerDamage(player, "jumpCollision");
        this.handleMiscPlayerDamage(otherPlayer, "jumpCollision");

        player = this.players[player.number - 1];

        otherPlayer = this.players[otherPlayer.number - 1];
        if (player.dead.state !== true) {
          if (otherPlayer.dead.state === true) {
            // COMPLETE JUMP
            completeJump();
          } else {
            if (player.hp > otherPlayer.hp) {
              // COMPLETE JUMP
              this.pushBack(
                otherPlayer,
                this.getOppositeDirection(otherPlayer.direction)
              );
              completeJump();
            } else {
              if (this.rnJesus(0, 5) === 0) {
                completeJump();
                this.pushBack(
                  otherPlayer,
                  this.getOppositeDirection(otherPlayer.direction)
                );
              } else {
                interruptJump();
              }
            }
          }
        }

        break;
      default:
    }
  };
  obstaclePlayerOverlap = (type, cell, player, obstacle) => {
    console.log("obstaclePlayerOverlap");

    let obstacleDirection = this.getOppositeDirection(
      this.getDirectionFromCells(
        obstacle.moving.origin.number,
        obstacle.moving.destination.number
      )
    );

    let pushPull = false;
    if (
      player.pulling.state === true ||
      player.pushing.state === true
      // player.postPull.state
    ) {
      pushPull = true;
    }
    if (pushPull !== true) {
      if (type === "player") {
        if (this.rnJesus(0, 5) === 0) {
          if (this.rnJesus(0, 2) === 0) {
            this.pushBack(player, this.getOppositeDirection(player.direction));
          } else {
            this.canPushObstacle(player, cell, `overlap_${obstacleDirection}`);
          }
        } else {
          this.canPushObstacle(player, cell, `overlap_${obstacleDirection}`);
          this.pushBack(player, this.getOppositeDirection(player.direction));
        }
      }

      if (type === "obstacle") {
        if (this.rnJesus(0, 5) === 0) {
          if (this.rnJesus(0, 2) === 0) {
            this.pushBack(player, this.getOppositeDirection(player.direction));
          } else {
            this.canPushObstacle(player, cell, `overlap_${obstacleDirection}`);
          }
        } else {
          this.canPushObstacle(player, cell, `overlap_${obstacleDirection}`);
          this.pushBack(player, this.getOppositeDirection(player.direction));
        }
      }
    }
  };
  obstacleBarrierTrapChecker = (locationCell, ownerType) => {
    let trap = locationCell[ownerType].trap;
    // console.log("obstacleBarrierTrapChecker", trap.trigger);
    const executeTrapAction = () => {
      // console.log("executeTrapAction");
      if (trap.acting.state === true) {
        // console.log("trap is acting");
        if (trap.action === "attack") {
          if (trap.acting.count === trap.acting.peak) {
            // console.log("trap is acting: attack peak");

            let whatDirection = this.rnJesus(0, 4);
            switch (whatDirection) {
              case 0:
                trap.acting.direction = "none";
                trap.acting.directionType = "thrust";
                break;
              case 1:
                trap.acting.direction = "north";
                trap.acting.directionType = "slash";
                break;
              case 2:
                trap.acting.direction = "south";
                trap.acting.directionType = "slash";
                break;
              case 3:
                trap.acting.direction = "east";
                trap.acting.directionType = "slash";
                break;
              case 4:
                trap.acting.direction = "west";
                trap.acting.directionType = "slash";
                break;
              default:
                break;
            }
            if (trap.item.subType === "crossbow") {
              trap.acting.direction = "none";
              trap.acting.directionType = "thrust";
              if (trap.ammo > 0) {
                trap.ammo--;
                let result = this.projectileCreator(
                  ownerType,
                  locationCell[ownerType],
                  "bolt"
                );
                this.projectiles.push(result.projectile);
                this.getBoltTarget(result.projectile);
                trap = result.owner.trap;
              } else {
                console.log(
                  "This trap is meant to fire a projectile but has no ammo. Do nothing"
                );
              }
            }
            if (trap.item.subType === "sword" || trap.item.subType === "spear") {
              this.meleeAttackPeak(ownerType, locationCell[ownerType]);
            }
          }
          if (trap.acting.count < trap.acting.limit) {
            trap.acting.count++;
            if (trap.acting.count < trap.acting.peak) {
              // console.log("trap is acting: windup", trap.acting.count);
              higlightCell();
            }
            if (trap.acting.count > trap.acting.peak) {
              // console.log("trap is acting: cooldown", trap.acting.count);
            }

            if (
              !this.cellPopups.find(
                (x) =>
                  x.msg === "attacking" &&
                  x.cell.number.x === locationCell.number.x &&
                  x.cell.number.y === locationCell.number.y
              )
            ) {
              this.cellPopups.push({
                state: false,
                count: 0,
                limit: trap.acting.limit,
                type: "",
                position: "",
                msg: "attacking",
                color: "",
                img: "",
                cell: this.gridInfo.find(
                  (x) =>
                    x.number.x === locationCell.number.x &&
                    x.number.y === locationCell.number.y
                ),
              });
            }
          }
          if (trap.acting.count >= trap.acting.limit) {
            trap.acting.count = 0;
            trap.acting.state = false;
            // trap.acting.direction = "";
            // trap.acting.directionType = "";
            console.log("trap action complete");
            this.cellPopups.splice(
              this.cellPopups.indexOf(
                this.cellPopups.find(
                  (x) =>
                    x.msg === "attacking" &&
                    x.cell.number.x === locationCell.number.x &&
                    x.cell.number.y === locationCell.number.y
                )
              ),
              1
            );
          }
        } else {
          // apply non attack action here
          trap.acting.count = 0;
          trap.acting.state = false;
        }
      } else {
        trap.acting.state = true;
        // console.log("trap was triggered but hasnt started its action. start");
      }
    };
    const higlightCell = () => {
      if (
        !this.cellsToHighlight2.find(
          (x) => x.number.x === trap.target.x && x.number.y === trap.target.y
        )
      ) {
        this.cellsToHighlight2.push({
          number: {
            x: trap.target.x,
            y: trap.target.y,
          },
          count: 0,
          limit: 10,
        });
      }
    };
    const triggerTrap = (triggerType) => {
      if (trap.persistent) {
        if (trap.timer.enabled) {
          if (trap.timer.state === false) {
            trap.timer.state = true;
          }
          if (trap.timer.state === true) {
            if (trap.timer.count < trap.timer.limit) {
              trap.timer.count++;
              higlightCell();
              // console.log("persistent trap timer count up", trap.timer.count);
              if (trap.timer.count === 1) {
                // console.log("trap has been triggered at ", trap.target, "by", triggerType);
              }
              if (
                !this.cellPopups.find(
                  (x) =>
                    x.msg === "timer" &&
                    x.cell.number.x === locationCell.number.x &&
                    x.cell.number.y === locationCell.number.y
                )
              ) {
                this.cellPopups.push({
                  state: false,
                  count: 0,
                  limit: 35,
                  type: "",
                  position: "",
                  msg: "timer",
                  color: "",
                  img: "",
                  cell: this.gridInfo.find(
                    (x) =>
                      x.number.x === locationCell.number.x &&
                      x.number.y === locationCell.number.y
                  ),
                });
              }
            }
            if (trap.timer.count >= trap.timer.limit) {
              trap.timer.count = 0;
              trap.timer.state = false;
              // console.log("persistent trap timer count finish", trap.timer.count);
              executeTrapAction();
              if (
                this.cellPopups.find(
                  (x) =>
                    x.msg === "timer" &&
                    x.cell.number.x === locationCell.number.x &&
                    x.cell.number.y === locationCell.number.y
                )
              ) {
                this.cellPopups.splice(
                  this.cellPopups.indexOf(
                    this.cellPopups.find(
                      (x) =>
                        x.msg === "timer" &&
                        x.cell.number.x === locationCell.number.x &&
                        x.cell.number.y === locationCell.number.y
                    )
                  ),
                  1
                );
              }
            }
          }
        }
        if (!trap.timer.enabled) {
          executeTrapAction();
          higlightCell();
          // console.log("trap has been triggered at ", trap.target, "by", triggerType);
        }
      }
      if (trap.persistent === false) {
        if (trap.remaining <= 0) {
          trap.state = false;
          console.log(
            `This ${ownerType} trap is not persistent and has no fires remaining. Disabling`
          );
        }
        if (trap.remaining > 0) {
          if (trap.timer.enabled) {
            if (trap.timer.state === false) {
              trap.timer.state = true;
            }
            if (trap.timer.state === true) {
              if (trap.timer.count < trap.timer.limit) {
                trap.timer.count++;
                higlightCell();
                // console.log("limited trap timer count up", trap.timer.count);
                if (trap.timer.count === 1) {
                  // console.log("trap has been triggered at ", trap.target, "by", triggerType);
                }
                if (
                  !this.cellPopups.find(
                    (x) =>
                      x.msg === "timer" &&
                      x.cell.number.x === locationCell.number.x &&
                      x.cell.number.y === locationCell.number.y
                  )
                ) {
                  this.cellPopups.push({
                    state: false,
                    count: 0,
                    limit: 10,
                    type: "",
                    position: "",
                    msg: "timer",
                    color: "",
                    img: "",
                    cell: this.gridInfo.find(
                      (x) =>
                        x.number.x === locationCell.number.x &&
                        x.number.y === locationCell.number.y
                    ),
                  });
                }
              }
              if (trap.timer.count >= trap.timer.limit) {
                trap.timer.count = 0;
                trap.timer.state = false;
                executeTrapAction();
                trap.remaining--;
                if (
                  this.cellPopups.find(
                    (x) =>
                      x.msg === "timer" &&
                      x.cell.number.x === locationCell.number.x &&
                      x.cell.number.y === locationCell.number.y
                  )
                ) {
                  this.cellPopups.splice(
                    this.cellPopups.indexOf(
                      this.cellPopups.find(
                        (x) =>
                          x.msg === "timer" &&
                          x.cell.number.x === locationCell.number.x &&
                          x.cell.number.y === locationCell.number.y
                      )
                    ),
                    1
                  );
                }
              }
            }
          }
          if (!trap.timer.enabled) {
            executeTrapAction();
            higlightCell();
            trap.remaining--;
          }
        }
      }
    };
    if (trap.state === true) {
      if (trap.acting.state === true) {
        executeTrapAction();
      } else {
        let triggered = false;
        for (const plyr of this.players) {
          if (plyr.ai.state !== true || plyr.team === this.players[0].team) {
            if (
              plyr.currentPosition.cell.number.x === trap.target.x &&
              plyr.currentPosition.cell.number.y === trap.target.y
            ) {
              triggerTrap("player");
              triggered = true;
            }
          }
        }
        if (trap.trigger.type !== "player") {
          for (const elem of this.gridInfo) {
            if (
              elem.obstacle.state === true &&
              elem.number.x === trap.target.x &&
              elem.number.y === trap.target.y
            ) {
              triggerTrap("obstacle");
              triggered = true;
            }
          }
        }

        if (triggered === false && trap.timer.enabled && trap.timer.state === true) {
          console.log("trap trigger disengaged at", trap.target, " reset timer");
          trap.timer.count = 0;
          trap.timer.state = false;
          if (
            this.cellPopups.find(
              (x) =>
                x.msg === "timer" &&
                x.cell.number.x === locationCell.number.x &&
                x.cell.number.y === locationCell.number.y
            )
          ) {
            this.cellPopups.splice(
              this.cellPopups.indexOf(
                this.cellPopups.find(
                  (x) =>
                    x.msg === "timer" &&
                    x.cell.number.x === locationCell.number.x &&
                    x.cell.number.y === locationCell.number.y
                )
              ),
              1
            );
          }
        }
      }
    }
    locationCell[ownerType].trap = trap;
    return locationCell;
  };
  obstacleBarrierTrapInitSet = (superType, type, data) => {
    // console.log("  obstacleBarrierTrapInitSet", data[type].trap.state);
    let trap = data[type].trap;

    let item = this.itemList.find((x) => x.name === trap.itemNameRef);
    trap.item = {
      name: item.name,
      amount: item.amount,
      total: item.total,
      type: item.type,
      subType: item.subType,
      effect: item.effect,
    };
    if (trap.item.effect.split("+")[0] === "ammo") {
      trap.ammo = parseInt(trap.item.effect.split("+")[1]);
      // trap.ammo = 100;
      // trap.item.effect = "ammo+0";
    }
    if (trap.action === "attack" && trap.acting.limit === 0) {
      trap.acting.peak = this.obstacleBarrierTrapAttackAnimRef.peak[trap.item.subType];
      trap.acting.limit = this.obstacleBarrierTrapAttackAnimRef.limit[trap.item.subType];
      // console.log("setting attack trap windup & cooldown", trap.acting.peak, trap.acting.limit);
    }

    let availibleCells = [];

    if (trap.state === true) {
      if (!trap.target.x || trap.target.x === undefined) {
        if (type === "obstacle") {
          if (trap.direction === "") {
            availibleCells = this.getSurroundingCells(
              data.number,
              30,
              "walkable",
              false,
              false
            );
            if (availibleCells.length > 0) {
              if (trap.item.subType === "crossbow") {
                trap.target = availibleCells
                  .slice()
                  .reverse()
                  .find((x) => x.x === data.number.x || x.y === data.number.y);
              } else {
                if (trap.item.subType === "spear") {
                  // trap.target = availibleCells[1];
                  trap.target = availibleCells
                    // .slice()
                    // .find((x) => x.x === data.number.x || x.y === data.number.y);
                    .slice()
                    .find(
                      (x) =>
                        (x.x === data.number.x &&
                          (x.y === data.number.y + 2 || x.y === data.number.y - 2)) ||
                        (x.y === data.number.y &&
                          (x.x === data.number.x + 2 || x.x === data.number.x - 2))
                    );
                }
                if (trap.item.subType === "sword") {
                  // trap.target = availibleCells[0];
                  trap.target = availibleCells
                    // .slice()
                    // .find((x) => x.x === data.number.x || x.y === data.number.y);
                    .slice()
                    .find(
                      (x) =>
                        (x.x === data.number.x &&
                          (x.y === data.number.y + 1 || x.y === data.number.y - 1)) ||
                        (x.y === data.number.y &&
                          (x.x === data.number.x + 1 || x.x === data.number.x - 1))
                    );
                }
              }
              // console.log("availibleCells", data.number, availibleCells, trap.target);
              // console.log("obstacle trap target set", data.number, trap.target, trap.ammo);
            } else {
              trap.state = false;
              console.log(
                `${type} trap disabled because there is no appropriate target cell`,
                data.number
              );
            }
          } else {
            let cell;
            if (trap.item.subType === "crossbow") {
              cell = this.getCellFromDirection(3, data.number, trap.direction);
            }
            if (trap.item.subType === "spear") {
              cell = this.getCellFromDirection(2, data.number, trap.direction);
            }
            if (trap.item.subType === "sword") {
              cell = this.getCellFromDirection(1, data.number, trap.direction);
            }
            if (
              !this.gridInfo.find((x) => cell.x === x.number.x && cell.y === x.number.y)
            ) {
              trap.state = false;
              console.log(
                `${type} trap disabled because there is no appropriate target cell`,
                data.number
              );
            } else {
              trap.target = cell;
              // console.log("onstacle trap target set", data.number, trap.target, trap.ammo);
            }
          }
        }
        if (type === "barrier") {
          let cell;
          let xDirection;
          if (trap.direction === "") {
            xDirection = this.getOppositeDirection(data[type].position);
          } else {
            xDirection = trap.direction;
          }
          if (trap.item.subType === "crossbow") {
            cell = this.getCellFromDirection(3, data.number, xDirection);
          }
          if (trap.item.subType === "spear") {
            cell = this.getCellFromDirection(2, data.number, xDirection);
          }
          if (trap.item.subType === "sword") {
            cell = this.getCellFromDirection(1, data.number, xDirection);
          }
          if (
            !this.gridInfo.find((x) => cell.x === x.number.x && cell.y === x.number.y)
          ) {
            trap.state = false;
            console.log(
              `${type} trap disabled because there is no appropriate target cellx`,
              data.number
            );
          } else {
            trap.target = cell;
            // console.log("barrier trap target set", data.number, trap.target, trap.ammo);
          }
        }
      } else {
        if (trap.target.x) {
          // console.log("this traps target is already set", trap.target, data.number, type);
        }
      }
    }
    return trap;
  };
  customObstacleBarrierTrapSet = (instructionType, data) => {
    // when externalized, call and update gridinfo function
    let localGridInfo = [];
    console.log("customObstacleBarrierTrapSet", instructionType);
    let type;
    let trapsToSet = [];
    const trapRandomizer = (trap) => {
      trap.persistent = this.rnJesus(0, 3) === 1;
      if (trap.persistent !== true) {
        switch (this.rnJesus(0, 3)) {
          case 0:
            trap.remaining = 5;
            break;
          case 1:
            trap.remaining = 10;
            break;
          case 2:
            trap.remaining = 15;
            break;
          case 3:
            trap.remaining = 25;
            break;
          default:
            break;
        }
      } else {
        trap.remaining = 0;
      }

      trap.direction = "";
      trap.action = "attack";
      trap.timer.enabled = this.rnJesus(1, 0) === 1;
      switch (this.rnJesus(0, 2)) {
        case 0:
          if (this.rnJesus(0, 1) === 1) {
            trap.timer.limit = 30;
          } else {
            trap.timer.limit = 40;
          }
          break;
        case 1:
          if (this.rnJesus(0, 1) === 1) {
            trap.timer.limit = 40;
          } else {
            trap.timer.limit = 60;
          }
          break;
        case 2:
          if (this.rnJesus(0, 1) === 1) {
            trap.timer.limit = 60;
          } else {
            trap.timer.limit = 80;
          }
          break;
        default:
          break;
      }
      if (this.rnJesus(0, 2) === 1) {
        trap.trigger.type = "player";
      } else {
        trap.trigger.type = "any";
      }
      let weapons = this.itemList.filter((x) => x.type === "weapon");
      let indx = this.rnJesus(0, weapons.length - 1);
      trap.itemNameRef = weapons[indx].name;
      return trap;
    };
    if (instructionType === "activateInactive") {
      for (let elem of this.gridInfo) {
        if (elem.obstacle.state === true) {
          type = "obstacle";
          if (
            elem[type].trap?.state !== true &&
            elem[type].trap?.persistent !== undefined &&
            elem[type].trap?.action !== "" &&
            elem[type].trap?.timer.enabled !== undefined
          ) {
            elem[type].trap.state = true;
            elem[type].trap = this.obstacleBarrierTrapInitSet("", type, elem);
            // console.log("1", elem.number, elem[type].trap);
            trapsToSet.push({
              type: type,
              location: elem.number,
              trap: elem[type].trap,
            });
          }
        }
        if (elem.barrier.state === true) {
          type = "barrier";
          if (
            elem[type].trap.state !== true &&
            elem[type].trap.persistent !== undefined &&
            elem[type].trap.action !== "" &&
            elem[type].trap.timer.enabled !== undefined
          ) {
            elem[type].trap.state = true;
            elem[type].trap = this.obstacleBarrierTrapInitSet("", type, elem);
            // console.log("2", elem.number, elem[type].trap);
            trapsToSet.push({
              type: type,
              location: elem.number,
              trap: elem[type].trap,
            });
          }
        }
      }
    }
    if (instructionType === "shuffleActive") {
      for (let elem of this.gridInfo) {
        if (elem.obstacle.state === true) {
          if (elem.obstacle.trap.state === true) {
            elem.obstacle.trap = trapRandomizer(elem.obstacle.trap, "obstacle");
            elem.obstacle.trap = this.obstacleBarrierTrapInitSet("", "obstacle", elem);
            trapsToSet.push({
              type: "obstacle",
              location: elem.number,
              trap: elem.obstacle.trap,
            });
          }
        }
        if (elem.barrier.state === true) {
          if (elem.barrier.trap.state === true) {
            elem.barrier.trap = trapRandomizer(elem.barrier.trap, "barrier");
            elem.barrier.trap = this.obstacleBarrierTrapInitSet("", "barrier", elem);
            trapsToSet.push({
              type: "barrier",
              location: elem.number,
              trap: elem.barrier.trap,
            });
          }
        }
      }
    }
    if (instructionType === "refreshActive") {
      for (let elem of this.gridInfo) {
        if (elem.obstacle.state === true) {
          type = "obstacle";
          if (elem[type].trap.state === true) {
            if (elem[type].trap.persistent !== true) {
              switch (this.rnJesus(0, 3)) {
                case 0:
                  elem[type].trap.remaining = 5;
                  break;
                case 1:
                  elem[type].trap.remaining = 10;
                  break;
                case 2:
                  elem[type].trap.remaining = 15;
                  break;
                case 3:
                  elem[type].trap.remaining = 25;
                  break;
                default:
                  break;
              }
            } else {
              elem[type].trap.remaining = 0;
            }
            elem[type].trap = this.obstacleBarrierTrapInitSet("", type, elem);
            trapsToSet.push({
              type: type,
              location: elem.number,
              trap: elem.trap,
            });
          }
          if (
            elem[type].trap.state !== true &&
            elem[type].trap.persistent !== true &&
            elem[type].trap.remaining === 0
          ) {
            elem[type].trap.state = true;
            switch (this.rnJesus(0, 3)) {
              case 0:
                elem[type].trap.remaining = 5;
                break;
              case 1:
                elem[type].trap.remaining = 10;
                break;
              case 2:
                elem[type].trap.remaining = 15;
                break;
              case 3:
                elem[type].trap.remaining = 25;
                break;
              default:
                break;
            }
            elem[type].trap = this.obstacleBarrierTrapInitSet("", type, elem);
            trapsToSet.push({
              type: type,
              location: elem.number,
              trap: elem[type].trap,
            });
          }
        }
        if (elem.barrier.state === true) {
          type = "barrier";
          if (elem[type].trap.state === true) {
            if (elem[type].trap.persistent !== true) {
              switch (this.rnJesus(0, 3)) {
                case 0:
                  elem[type].trap.remaining = 5;
                  break;
                case 1:
                  elem[type].trap.remaining = 10;
                  break;
                case 2:
                  elem[type].trap.remaining = 15;
                  break;
                case 3:
                  elem[type].trap.remaining = 25;
                  break;
                default:
                  break;
              }
            } else {
              elem[type].trap.remaining = 0;
            }
            elem[type].trap = this.obstacleBarrierTrapInitSet("", type, elem);
            trapsToSet.push({
              type: type,
              location: elem.number,
              trap: elem.trap,
            });
          }
          if (
            elem[type].trap.state !== true &&
            elem[type].trap.persistent !== true &&
            elem[type].trap.remaining === 0
          ) {
            elem[type].trap.state = true;
            switch (this.rnJesus(0, 3)) {
              case 0:
                elem[type].trap.remaining = 5;
                break;
              case 1:
                elem[type].trap.remaining = 10;
                break;
              case 2:
                elem[type].trap.remaining = 15;
                break;
              case 3:
                elem[type].trap.remaining = 25;
                break;
              default:
                break;
            }
            elem[type].trap = this.obstacleBarrierTrapInitSet("", type, elem);
            trapsToSet.push({
              type: type,
              location: elem.number,
              trap: elem[type].trap,
            });
          }
        }
      }
    }
    if (instructionType === "setNewRandom") {
      let obsBarList = this.gridInfo.filter(
        (x) => x.obstacle.state === true || x.barrier.state === true
      );
      let toSetCount = 0;
      let usedIndices = [];
      switch (this.rnJesus(0, 3)) {
        case 0:
          toSetCount = Math.floor(obsBarList.length * 0.25);
          break;
        case 1:
          toSetCount = Math.floor(obsBarList.length * 0.5);
          break;
        case 2:
          toSetCount = Math.floor(obsBarList.length * 0.75);
          break;
        case 3:
          toSetCount = obsBarList.length;
          break;
        default:
          break;
      }
      for (let index = 0; index < toSetCount; index++) {
        let indx2 = this.rnJesus(0, toSetCount);
        let indx2Unset = true;
        while (indx2Unset === true) {
          indx2 = this.rnJesus(0, toSetCount);
          indx2Unset = usedIndices.includes(indx2);
        }
        if (indx2Unset !== true) {
          usedIndices.push(indx2);
          // console.log("here", indx2, usedIndices);
          let elem = obsBarList[indx2];
          if (elem.obstacle.state === true) {
            type = "obstacle";
            elem[type].trap = trapRandomizer(elem[type].trap, type);
            elem[type].trap.state = true;
            elem[type].trap = this.obstacleBarrierTrapInitSet("", type, elem);
            trapsToSet.push({
              type: type,
              location: elem.number,
              trap: elem[type].trap,
            });
          }
          if (elem.barrier.state === true) {
            type = "barrier";
            elem[type].trap = trapRandomizer(elem[type].trap, type);
            elem[type].trap.state = true;
            elem[type].trap = this.obstacleBarrierTrapInitSet("", type, elem);
            trapsToSet.push({
              type: type,
              location: elem.number,
              trap: elem[type].trap,
            });
          }
        }
      }
    }
    if (instructionType === "setNewCustom") {
      for (const elem of data) {
        let cellRef = this.gridInfo.find(
          (x) => x.number.x === elem.location.x && x.number.y === elem.location.y
        );
        if (cellRef.obstacle.state === true) {
          if (elem.type === "obstacle") {
            cellRef[elem.type].trap = {
              state: true,
              persistent: elem.persistent,
              remaining: elem.remaining,
              direction: "",
              target: {},
              timer: {
                enabled: elem.timerEnabled,
                state: false,
                count: 0,
                limit: elem.timerLimit,
              },
              trigger: {
                type: elem.triggerType,
              },
              action: "attack",
              acting: {
                state: false,
                count: 0,
                peak: 0,
                limit: 0,
              },
              itemNameRef: elem.itemNameRef,
              item: {},
              ammo: 0,
            };
            cellRef[elem.type].trap = this.obstacleBarrierTrapInitSet(
              "",
              elem.type,
              cellRef
            );
            trapsToSet.push({
              type: elem.type,
              location: elem.location,
              trap: cellRef[elem.type].trap,
            });
          } else {
            console.log(
              "custom trap type is ",
              elem.type,
              " but no ",
              elem.type,
              " is in this location",
              elem.location,
              ". Invalid selection. Ignoring..."
            );
          }
        }
        if (cellRef.barrier.state === true) {
          if (elem.type === "barrier") {
            cellRef[elem.type].trap = {
              state: true,
              persistent: elem.persistent,
              remaining: elem.remaining,
              direction: "",
              target: {},
              timer: {
                enabled: elem.timerEnabled,
                state: false,
                count: 0,
                limit: elem.timerLimit,
              },
              trigger: {
                type: elem.triggerType,
              },
              action: "attack",
              acting: {
                state: false,
                count: 0,
                peak: 0,
                limit: 0,
              },
              itemNameRef: elem.itemNameRef,
              item: {},
              ammo: 0,
            };
            cellRef[elem.type].trap = this.obstacleBarrierTrapInitSet(
              "",
              elem.type,
              cellRef
            );
            trapsToSet.push({
              type: elem.type,
              location: elem.location,
              trap: cellRef[elem.type].trap,
            });
          } else {
            console.log(
              "custom trap type is ",
              elem.type,
              " but no ",
              elem.type,
              " is in this location",
              elem.location,
              ". Invalid selection. Ignoring..."
            );
          }
        }
        if (cellRef.obstacle.state !== true && cellRef.barrier.state !== true) {
          console.log("custom obs/bar trap location invalid. Ignoring...");
        }
      }
    }
    console.log("trapsToSet", trapsToSet);
    // return trapsToSet;
  };
  checkSetAttackDefendDirectionalInput = (mode, action, player) => {
    // stage is either 'init' or 'windup'
    let charging = false;
    let input = false;
    let inputDirection = "";
    let directionalInputThresh = 0;
    let directionalDefendThresh = 0;
    if (this.keyPressed[player.number - 1].north === true) {
      input = true;
      inputDirection = "north";
    }
    if (this.keyPressed[player.number - 1].south === true) {
      input = true;
      inputDirection = "south";
    }
    if (this.keyPressed[player.number - 1].east === true) {
      input = true;
      inputDirection = "east";
    }
    if (this.keyPressed[player.number - 1].west === true) {
      input = true;
      inputDirection = "west";
    }

    const charge = () => {
      charging = true;
      player[action].charge++;
      if (!player.popups.find((x) => x.msg === "charging")) {
        player.popups.push({
          state: false,
          count: 0,
          limit: 10,
          type: "",
          position: "",
          msg: "charging",
          img: "",
        });
      }
      // console.log("charging attack", player[action].charge);
    };

    const feintAttack = () => {
      let chargeType = "normal";
      if (charging === true) {
        chargeType = "charged";
      }

      let atkPeak;
      let atkType = player.currentWeapon.type;
      let blunt = "normal";
      if (player.currentWeapon.name === "") {
        atkType = "unarmed";
      }
      if (player.attacking.blunt === true) {
        blunt = "blunt";
      }
      atkPeak =
        player.attacking.animRef.peak[atkType][player.attacking.directionType][
          chargeType
        ];

      if (player.attacking.count < player.attacking.peakCount) {
        // console.log('attack windup key release before peak. feinting. refund stamina part');

        player.action = "idle";
        player.attacking = {
          state: false,
          count: 0,
          limit: player.attacking.limit,
          strength: 0,
          direction: "",
          directionType: "", //thrust or slash
          animRef: player.attacking.animRef,
          peak: false,
          peakCount: 0,
          charge: 0,
          chargePeak: false,
          blunt: false,
          clashing: {
            state: false,
            count: 0,
            limit: player.attacking.clashing.limit,
          },
        };
        player.stamina.current += this.staminaCostRef.attack[atkType][blunt].pre;

        // RESET ELASTIC COUNTER
        if (
          player.elasticCounter.state === true &&
          player.elasticCounter.type === "attacking"
        ) {
          player.elasticCounter.state = false;
        }

        let popup = player.popups.find((x) => x.msg === "attacking");
        if (popup) {
          player.popups.splice(
            player.popups.findIndex((x) => x.msg === "attacking"),
            1
          );
        }

        if (this.camera.customView.state !== true && player.ai.state !== true) {
          this.setAutoCamera("attackFocusBreak", player);
        }
      }
    };

    if (action === "attacking") {
      directionalInputThresh = Math.ceil(
        player[action].animRef.peak.unarmed.thrust.normal / 2
      );
      if (player.currentWeapon.type === "crossbow") {
        if (mode === "init") {
          player[action].direction = "none";
          player[action].directionType = "thrust";
        }
        if (mode === "windup") {
          if (player[action].count < directionalInputThresh) {
            if (input === true) {
              if (inputDirection === player.direction) {
                player[action].direction = inputDirection;
                player[action].directionType = "slash";
              } else {
                console.log(
                  "crossbow directional atk & charge can only be in player direction"
                );
              }
            }
          } else {
            if (input === true) {
              // console.log("input thresh passed.");
              if (inputDirection !== player[action].direction) {
                console.log("input after thresh w/ different direction. feint attack");
                feintAttack();
              }
              if (inputDirection === player[action].direction) {
                if (player[action].count > player[action].peakCount) {
                  console.log("past peak. no charging");
                } else {
                  charge();
                }
              }
            }
          }
        }
      } else {
        if (mode === "init") {
          if (input === true) {
            if (player[action].direction === "" || player[action].directionType === "") {
              player[action].direction = inputDirection;
              player[action].directionType = "slash";
            } else {
              // console.log("do nothing");
            }
          } else {
            if (player[action].direction === "" || player[action].directionType === "") {
              player[action].direction = "none";
              player[action].directionType = "thrust";
            }
          }
        }
        if (mode === "windup") {
          if (player[action].count < directionalInputThresh) {
            if (input === true) {
              // console.log("y");
              if (inputDirection === player[action].direction) {
                // charge();
              } else {
                console.log(
                  "still time to set attack direction. changing direction",
                  player[action].direction,
                  inputDirection
                );
                player[action].direction = inputDirection;
                player[action].directionType = "slash";
              }
            } else {
              if (
                player[action].direction === "" ||
                player[action].directionType === ""
              ) {
                console.log("winding up within input thresh but no input. set to thrust");
                player[action].direction = "none";
                player[action].directionType = "thrust";
              }
              // console.log(" direction and type should already be set, do nothing");
            }
          } else {
            if (input === true) {
              // console.log("input thresh passed.");
              if (inputDirection !== player[action].direction) {
                console.log("input after thresh w/ different direction. feint attack");
                feintAttack();
              }
              if (inputDirection === player[action].direction) {
                if (player[action].count > player[action].peakCount) {
                  console.log("past peak. no charging");
                } else {
                  charge();
                }
              }
            }
          }
        }
      }
      console.log("directional input thresh", directionalInputThresh);
    }

    if (action === "defending") {
      if (mode === "init") {
        if (input === true) {
          if (player[action].direction === "" || player[action].directionType === "") {
            player[action].direction = inputDirection;
            player[action].directionType = "slash";
          } else {
            // console.log("do nothing");
          }
        } else {
          if (player[action].direction === "" || player[action].directionType === "") {
            player[action].direction = "none";
            player[action].directionType = "thrust";
          }
        }
      }
      if (mode === "windup") {
        let defendType = player.currentWeapon.type;
        if (player.currentWeapon.name === "") {
          defendType = "unarmed";
        }
        let defendPeak =
          player.defending.animRef.peak[defendType][player.defending.directionType];
        let defendDecayLimit = player.defending.decay.limit;
        let defendInputThresh = defendDecayLimit + defendPeak - this.defendPeakAllowance;
        if (player[action].count <= defendInputThresh) {
          if (input === true) {
            if (player[action].direction === inputDirection) {
            } else {
              console.log(
                "changing defend direction before thresh. from",
                player[action].direction,
                "to",
                inputDirection
              );
              player[action].direction = inputDirection;
              player[action].directionType = "slash";
            }
          } else {
            player[action].direction = "none";
            player[action].directionType = "thrust";
          }
        } else {
          if (input === true) {
            console.log("too late to change defend direction: count");
          } else {
            if (player[action].direction === "" || player[action].directionType === "") {
              player[action].direction = "none";
              player[action].directionType = "thrust";
            }
          }
        }
        console.log("directional input thresh", defendInputThresh);
      }
    }

    // console.log(
    //   "set attack defend directional input",
    //   mode,
    //   input,
    //   player[action].direction,
    //   player[action].directionType,
    //   directionalInputThresh,
    //   player[action].count
    // );

    return {
      player: player,
      charging: charging,
    };
  };
  meleeAttackPeak = (ownerType, owner) => {
    // console.log("meleeAttackPeak");

    let myCellBlock;
    let ownerWeaponName;
    let ownerWeaponType;
    let targetCell1;
    let targetCell2;
    let cell1Free;
    let cell2Free;
    let myCell;
    let ownerDirection;
    let cell1Item;
    let cell1Rubble;
    let cell2Item;
    let cell2Rubble;

    let playerAttackStamType;

    if (ownerType === "player") {
      myCell = this.gridInfo.find(
        (elem) =>
          elem.number.x === owner.currentPosition.cell.number.x &&
          elem.number.y === owner.currentPosition.cell.number.y
      );
      targetCell1 = this.gridInfo.find(
        (x) =>
          x.number.x === owner.target.cell1.number.x &&
          x.number.y === owner.target.cell1.number.y
      );
      targetCell2 = this.gridInfo.find(
        (x) =>
          x.number.x === owner.target.cell2.number.x &&
          x.number.y === owner.target.cell2.number.y
      );
      cell1Free = owner.target.cell1.free;
      cell2Free = owner.target.cell2.free;
      myCellBlock = owner.target.myCellBlock;
      ownerDirection = owner.direction;
      ownerWeaponType = owner.currentWeapon.type;
      ownerWeaponName = owner.currentWeapon.name;
      cell1Item = owner.target.cell1.occupant.type === "item";
      cell1Rubble = owner.target.cell1.occupant.type === "rubble";
      cell2Item = owner.target.cell2.occupant.type === "item";
      cell2Rubble = owner.target.cell2.occupant.type === "rubble";
    } else {
      myCell = this.gridInfo.find(
        (x) => x[ownerType].state === true && x[ownerType].id === owner.id
      );
      ownerDirection = this.getDirectionFromCells(myCell.number, owner.trap.target);
      let cell1 = this.getCellFromDirection(1, myCell.number, ownerDirection);
      let cell2 = this.getCellFromDirection(2, myCell.number, ownerDirection);
      targetCell1 = this.gridInfo.find(
        (x) => x.number.x === cell1.x && x.number.y === cell1.y
      );
      targetCell2 = this.gridInfo.find(
        (x) => x.number.x === cell2.x && x.number.y === cell2.y
      );
      cell1Free = this.checkCell(targetCell1.number);
      cell2Free = this.checkCell(targetCell2.number);
      myCellBlock = this.checkMyCellBarrier(ownerDirection, myCell);

      ownerWeaponType = owner.trap.item.subType;
      ownerWeaponName = owner.trap.item.name;
      cell1Item = targetCell1.item.name !== "";
      cell1Rubble = targetCell1.rubble === true;
      cell2Item = targetCell2.item.name !== "";
      cell2Rubble = targetCell2.rubble === true;
    }

    if (myCellBlock !== true) {
      let boltTarget1 = false;
      let boltTarget2 = false;
      boltTarget1 = this.isBoltInCell(targetCell1.number);
      if (targetCell2?.number) {
        boltTarget2 = this.isBoltInCell(targetCell2.number);
      }

      // SET STAM TYPE
      if (ownerType === "player") {
        if (owner.currentWeapon.name === "") {
          playerAttackStamType = this.staminaCostRef.attack.unarmed.normal;
          if (owner.attacking.blunt === true) {
            playerAttackStamType = this.staminaCostRef.attack.unarmed.blunt;
          }
        }
        if (owner.attacking.blunt === true && owner.currentWeapon.name !== "") {
          playerAttackStamType =
            this.staminaCostRef.attack[owner.currentWeapon.type].blunt;
        }
        if (owner.currentWeapon.name !== "") {
          playerAttackStamType =
            this.staminaCostRef.attack[owner.currentWeapon.type].normal;
        }
      }

      if (ownerWeaponType === "spear") {
        this.cellsUnderAttack.push(
          {
            number: {
              x: targetCell1.number.x,
              y: targetCell1.number.y,
            },
            count: 1,
            limit: 8,
          },
          {
            number: {
              x: targetCell2.number.x,
              y: targetCell2.number.y,
            },
            count: 1,
            limit: 8,
          }
        );
        // TARGET CELL 1 IS NOT FREE, ITEM, BOLT, RUBBLE, ATTACK CELL1

        if (targetCell1.barrier.state === true) {
          if (
            // targetCell1.barrier.position === ownerDirection ||
            targetCell1.barrier.position === this.getOppositeDirection(ownerDirection)
          ) {
            // console.log(
            //   "melee attack peak:",
            //   ownerType,
            //   owner.number,
            //   owner.id,
            //   "hit barrier w/ ",
            //   ownerWeaponType,
            //   " @ ",
            //   targetCell1.number
            // );
            this.attackCellContents(
              "melee",
              ownerType,
              owner,
              targetCell1,
              targetCell2,
              myCell,
              undefined
            );
          }
        }
        if (
          cell1Free !== true ||
          cell1Item === true ||
          cell1Rubble === true ||
          boltTarget1 === true
        ) {
          // console.log(
          //   "melee attack peak:",
          //   ownerType,
          //   owner.number,
          //   owner.id,
          //   "hit player, obstacle, bolt, item or rubble w/ ",
          //   ownerWeaponType,
          //   " @ ",
          //   targetCell1.number
          // );
          this.meleeAttackParse(ownerType, owner, 1);
        }

        // TARGET CELL 1 IS FREE NOT ITEM, BOLT, RUBBLE
        if (
          cell1Free === true &&
          cell1Item !== true &&
          cell1Rubble !== true &&
          boltTarget1 !== true
        ) {
          if (
            targetCell1.barrier.state === true &&
            targetCell1.barrier.position === ownerDirection
          ) {
            // console.log(
            //   "melee attack peak:",
            //   ownerType,
            //   owner.number,
            //   owner.id,
            //   "hit barrier w/ ",
            //   ownerWeaponType,
            //   " @ ",
            //   targetCell1.number
            // );
            this.attackCellContents(
              "melee",
              ownerType,
              owner,
              targetCell1,
              targetCell2,
              myCell,
              undefined
            );
          }

          if (
            targetCell2.barrier.state === true &&
            targetCell2.barrier.position === this.getOppositeDirection(ownerDirection)
          ) {
            // console.log(
            //   "melee attack peak:",
            //   ownerType,
            //   owner.number,
            //   owner.id,
            //   "hit barrier w/ ",
            //   ownerWeaponType,
            //   " @ ",
            //   targetCell2.number
            // );
            this.attackCellContents(
              "melee",
              ownerType,
              owner,
              targetCell1,
              targetCell2,
              myCell,
              undefined
            );
          }

          // TARGET CELL 2 IS NOT FREE HAS ITEM, BOLT, RUBBLE ATTACK
          if (
            cell2Free !== true ||
            cell2Item === true ||
            cell2Rubble === true ||
            boltTarget2 === true
          ) {
            // console.log(
            //   "melee attack peak:",
            //   ownerType,
            //   owner.number,
            //   owner.id,
            //   "hit player, obstacle, bolt, item or rubble w/ ",
            //   ownerWeaponType,
            //   " @ ",
            //   targetCell2.number
            // );
            this.meleeAttackParse(ownerType, owner, 2);
          }

          // TARGET CELL2 IS FREE AND NOT ITEM, BOLT, RUBBLE, MISS
          if (
            cell2Free === true &&
            cell2Item !== true &&
            cell2Rubble !== true &&
            boltTarget2 !== true
          ) {
            if (ownerType === "player") {
              if (!owner.popups.find((x) => x.msg === "missedAttack2")) {
                owner.popups.push({
                  state: false,
                  count: 0,
                  limit: 30,
                  type: "",
                  position: "",
                  msg: "missedAttack2",
                  img: "",
                });
              }
              owner.stamina.current -= playerAttackStamType.pre;
              console.log(
                "melee attack peak:",
                ownerType,
                owner.number,
                owner.id,
                " attacked empty cell @ ",
                targetCell2.number,
                "w/",
                ownerWeaponType
              );
            }
          }
        }
      }

      if (ownerWeaponType === "sword") {
        this.cellsUnderAttack.push({
          number: {
            x: targetCell1.number.x,
            y: targetCell1.number.y,
          },
          count: 1,
          limit: 8,
        });
        // if (
        //   targetCell1.barrier.state === true &&
        //   (targetCell1.barrier.position === ownerDirection ||
        //     targetCell1.barrier.position === this.getOppositeDirection(ownerDirection))
        // ) {
        //   console.log(
        //     "melee attack peak:",
        //     ownerType,
        //     owner.number,
        //     owner.id,
        //     "hit barrier w/ ",
        //     ownerWeaponType,
        //     " @ ",
        //     targetCell1.number
        //   );
        //   this.attackCellContents(
        //     "melee",
        //     ownerType,
        //     owner,
        //     targetCell1,
        //     targetCell2,
        //     myCell,
        //     undefined
        //   );
        // }
        // TAGET CELL 1 IS FREE NO ITEM OR BOLT, MISS
        if (
          cell1Free === true &&
          cell1Item !== true &&
          cell1Rubble !== true &&
          boltTarget1 !== true
        ) {
          if (ownerType === "player") {
            if (!owner.popups.find((x) => x.msg === "missedAttack2")) {
              owner.popups.push({
                state: false,
                count: 0,
                limit: 30,
                type: "",
                position: "",
                msg: "missedAttack2",
                img: "",
              });
            }
            owner.stamina.current -= playerAttackStamType.pre;
            console.log(
              "melee attack peak: ",
              ownerType,
              owner.number,
              owner.id,
              " attacked empty cell @ ",
              targetCell1.number,
              "w/",
              ownerWeaponType
            );
          }
        }

        // TARGET CELL 1 IS NOT FREE OR HAS BOLT OR ITEM, ATTACK
        if (
          cell1Free !== true ||
          cell1Item === true ||
          cell1Rubble === true ||
          boltTarget1 === true
        ) {
          this.meleeAttackParse(ownerType, owner, 1);
          // console.log(
          //   "melee attack peak: ",
          //   ownerType,
          //   owner.number,
          //   owner.id,
          //   " hit player, obstacle, barrier, bolt, item or rubble w/ ",
          //   ownerWeaponType,
          //   " @ ",
          //   targetCell1.number
          // );
        }
      }

      // UNARMED ATTACK
      // CROSSBOW BLUNT ATTACK
      if (ownerType === "player") {
        // UNARMED ATTACK
        if (owner.currentWeapon?.name === "") {
          this.cellsUnderAttack.push({
            number: {
              x: owner.target.cell1.number.x,
              y: owner.target.cell1.number.y,
            },
            count: 1,
            limit: 8,
          });

          // TAGET CELL 1 IS FREE NO ITEM OR BOLT, MISS
          if (
            cell1Free === true &&
            cell1Item !== true &&
            cell1Rubble !== true &&
            boltTarget1 !== true
          ) {
            if (!owner.popups.find((x) => x.msg === "missedAttack2")) {
              owner.popups.push({
                state: false,
                count: 0,
                limit: 30,
                type: "",
                position: "",
                msg: "missedAttack2",
                img: "",
              });
            }

            owner.stamina.current -= playerAttackStamType.pre;
            console.log(
              "melee attack peak: ",
              ownerType,
              owner.number,
              owner.id,
              " attacked empty cell @ ",
              targetCell1.number,
              "unarmed"
            );
          }

          // TARGET CELL 1 IS NOT FREE OR HAS BOLT OR ITEM, ATTACK
          if (
            cell1Free !== true ||
            cell1Item === true ||
            cell1Rubble === true ||
            boltTarget1 === true
          ) {
            this.meleeAttackParse(ownerType, owner, 1);
            // console.log(
            //   "melee attack peak: ",
            //   ownerType,
            //   owner.number,
            //   owner.id,
            //   " hit player, obstacle, barrier, bolt, item or rubble unarmed  @ ",
            //   targetCell1.number
            // );
          }
        }

        // CROSSBOW BLUNT ATTACK
        if (
          owner.currentWeapon.type === "crossbow" ||
          owner.currentWeapon.type === "longbow"
        ) {
          // CROSSBOW BLUNT ATTACK
          if (owner.attacking.blunt === true) {
            this.cellsUnderAttack.push({
              number: {
                x: owner.target.cell1.number.x,
                y: owner.target.cell1.number.y,
              },
              count: 1,
              limit: 8,
            });

            // if (
            //   targetCell1.barrier.state === true &&
            //   (targetCell1.barrier.position === ownerDirection ||
            //     targetCell1.barrier.position === this.getOppositeDirection(ownerDirection))
            // ) {
            //   console.log(
            //     "melee attack peak:",
            //     ownerType,
            //     owner.number,
            //     owner.id,
            //     "blunt attacked barrier w/ ",
            //     ownerWeaponType,
            //     " @ ",
            //     targetCell21.number
            //   );
            //   this.attackCellContents(
            //     "melee",
            //     ownerType,
            //     owner,
            //     targetCell1,
            //     targetCell2,
            //     myCell,
            //     undefined
            //   );
            // }

            // TARGET CELL 1 FREE NO ITEM OR BOLT
            if (cell1Free === true && cell1Item === true && boltTarget1 !== true) {
              if (!owner.popups.find((x) => x.msg === "missedAttack2")) {
                owner.popups.push({
                  state: false,
                  count: 0,
                  limit: 30,
                  type: "",
                  position: "",
                  msg: "missedAttack2",
                  img: "",
                });
              }

              owner.stamina.current -= playerAttackStamType.pre;
              console.log(
                "melee attack peak: ",
                ownerType,
                owner.number,
                owner.id,
                " blunt attacked empty cell @ ",
                targetCell1.number,
                "w/",
                owner.currentWeapon.type
              );
            }

            // TARGET CELL 1 NOT FREE, OR ITEM OR BOLT
            if (
              cell1Free !== true ||
              player.target.cell1.occupant.type === "item" ||
              boltTarget1 === true
            ) {
              this.meleeAttackParse(ownerType, owner, 1);
              // console.log(
              //   "melee attack peak: ",
              //   ownerType,
              //   owner.number,
              //   owner.id,
              //   " blunt attacked bolt, item or w/ ",
              //   ownerWeaponType,
              //   " @ ",
              //   targetCell1.number
              // );
            }
          }
        }
      }
    }

    // ATTACK MY CELL BARRIER
    else {
      console.log(
        "melee attak peak: ",
        ownerType,
        owner.number,
        owner.id,
        "s mycell barrier is in the way at",
        myCell.number
      );
      this.attackCellContents(
        "melee",
        ownerType,
        owner,
        targetCell1,
        targetCell2,
        myCell,
        undefined
      );
    }
    if (ownerType === "player") {
      this.players[owner.number - 1] = owner;
    }
  };
  meleeAttackParse = (ownerType, owner, cellNo) => {
    // console.log("meleeAttackParse");

    let targetPlayerRef = undefined;

    let targetCell1;
    let targetCell2;
    let myCell;
    let ownerWeaponName;
    let ownerWeaponType;
    let ownerDirection;
    let cell1Item;
    let cell1Rubble;
    let cell2Item;
    let cell2Rubble;
    let faceToFace;
    let sideAttack;
    let backAttack;
    let logCellNo;
    let attackPosition;
    let advantage;

    // ATTACK STAM UNARMED CHECK & AND POPUPS SET
    let playerAttackStamType;

    if (ownerType === "player") {
      myCell = this.gridInfo.find(
        (elem) =>
          elem.number.x === owner.currentPosition.cell.number.x &&
          elem.number.y === owner.currentPosition.cell.number.y
      );
      targetCell1 = this.gridInfo.find(
        (x) =>
          x.number.x === owner.target.cell1.number.x &&
          x.number.y === owner.target.cell1.number.y
      );
      targetCell2 = this.gridInfo.find(
        (x) =>
          x.number.x === owner.target.cell2.number.x &&
          x.number.y === owner.target.cell2.number.y
      );
      ownerDirection = owner.direction;
      ownerWeaponType = owner.currentWeapon.type;
      ownerWeaponName = owner.currentWeapon.name;
      cell1Item = owner.target.cell1.occupant.type === "item";
      cell1Rubble = owner.target.cell1.occupant.type === "rubble";
      cell2Item = owner.target.cell2.occupant.type === "item";
      cell2Rubble = owner.target.cell2.occupant.type === "rubble";
    } else {
      myCell = this.gridInfo.find(
        (x) => x[ownerType].state === true && x[ownerType].id === owner.id
      );
      ownerDirection = this.getDirectionFromCells(myCell.number, owner.trap.target);
      let cell1 = this.getCellFromDirection(1, myCell.number, ownerDirection);
      let cell2 = this.getCellFromDirection(2, myCell.number, ownerDirection);
      targetCell1 = this.gridInfo.find(
        (x) => x.number.x === cell1.x && x.number.y === cell1.y
      );
      targetCell2 = this.gridInfo.find(
        (x) => x.number.x === cell2.x && x.number.y === cell2.y
      );
      ownerWeaponType = owner.trap.item.subType;
      ownerWeaponType = owner.trap.item.name;
      cell1Item = targetCell1.item.name !== "";
      cell1Rubble = targetCell1.rubble === true;
      cell2Item = targetCell2.item.name !== "";
      cell2Rubble = targetCell2.rubble === true;
    }
    let defendType;

    // SET ATTACK STAM TYPE AND POPUPS/ ATK SUCCESS
    if (ownerType === "player") {
      if (ownerWeaponName !== "") {
        playerAttackStamType = this.staminaCostRef.attack[ownerWeaponType].normal;
      }

      if (owner.attacking.blunt === true && ownerWeaponName !== "") {
        playerAttackStamType = this.staminaCostRef.attack[ownerWeaponType].blunt;
      }
      if (ownerWeaponName === "") {
        playerAttackStamType = this.staminaCostRef.attack.unarmed.normal;
        if (owner.attacking.blunt === true) {
          playerAttackStamType = this.staminaCostRef.attack.unarmed.blunt;
        }
        defendType = "unarmed";
        ownerWeaponType = "unarmed";

        if (owner.attacking.blunt === true) {
          if (!owner.popups.find((x) => x.msg === "attackingBlunt")) {
            owner.popups.push({
              state: false,
              count: 0,
              limit:
                owner.attacking.animRef.limit[ownerWeaponType] -
                owner.attacking.animRef.peak[ownerWeaponType],
              type: "",
              position: "",
              msg: "attackingBlunt",
              img: "",
            });
          }
        } else {
          if (!owner.popups.find((x) => x.msg === "attackingUnarmed")) {
            owner.popups.push({
              state: false,
              count: 0,
              limit:
                owner.attacking.animRef.limit.unarmed -
                owner.attacking.animRef.peak.unarmed,
              type: "",
              position: "",
              msg: "attackingUnarmed",
              img: "",
            });
          }
        }
      } else {
        if (owner.attacking.blunt === true) {
          if (!owner.popups.find((x) => x.msg === "attackingBlunt")) {
            owner.popups.push({
              state: false,
              count: 0,
              limit:
                owner.attacking.animRef.limit[ownerWeaponType] -
                owner.attacking.animRef.peak[ownerWeaponType],
              type: "",
              position: "",
              msg: "attackingBlunt",
              img: "",
            });
          }
        } else {
          if (!owner.popups.find((x) => x.msg === "attacking")) {
            owner.popups.push({
              state: false,
              count: 0,
              limit:
                owner.attacking.animRef.limit[ownerWeaponType] -
                owner.attacking.animRef.peak[ownerWeaponType],
              type: "",
              position: "",
              msg: "attacking",
              img: "",
            });
          }
        }
      }
    }

    const setTargetDefending = () => {
      defendType = targetPlayerRef.currentWeapon.type;
      if (targetPlayerRef.currentWeapon.name === "") {
        defendType = "unarmed";
      }
      let defendPeak = targetPlayerRef.defending.animRef.peak[defendType];
      if (
        targetPlayerRef.defending.count === defendPeak ||
        targetPlayerRef.defending.decay.state === true
      ) {
        return true;
      } else {
        return false;
      }
    };
    const setAdvantage = () => {
      let adv;
      if (ownerType === "player") {
        adv = this.checkCombatAdvantage(owner, targetPlayerRef);
      } else {
        if (targetPlayerRef.currentWeapon.name === "") {
          adv = 1;
        } else {
          adv = 0;
        }
      }
      return adv;
    };
    const executeAttack = () => {
      // PLAYER BLUNT ATK SUCCESS, TARGET DEFLECTED
      if (ownerType === "player") {
        if (owner.attacking.blunt === true) {
          console.log(
            "executing melee attack: ",
            ownerType,
            owner.number,
            owner.id,
            "blunt attacked a player",
            targetPlayerRef.number,
            "from the",
            attackPosition,
            " w/ ",
            ownerWeaponType,
            "@",
            logCellNo,
            "successfully. deflect target/defender"
          );
          this.setDeflection(targetPlayerRef, "bluntAttacked", false);
          owner.success.attackSuccess = {
            state: true,
            count: 1,
            limit: owner.success.attackSuccess.limit,
          };
        }
        // PLAYER ATK SUCCESS, TARGET DEFLECTED + DAMAGE
        else {
          console.log(
            "executing melee attack: ",
            ownerType,
            owner.number,
            owner.id,
            "attacked a player",
            targetPlayerRef.number,
            "from the",
            attackPosition,
            " w/ ",
            ownerWeaponType,
            "@",
            logCellNo,
            "successfully. damage,deflect target/defender"
          );
          this.handleMeleeDamage(ownerType, owner, targetPlayerRef);

          this.setDeflection(targetPlayerRef, "attacked", false);
          owner.success.attackSuccess = {
            state: true,
            count: 1,
            limit: owner.success.attackSuccess.limit,
          };
        }
      } else {
        console.log(
          "executing melee attack: ",
          ownerType,
          owner.number,
          owner.id,
          "attacked a player",
          targetPlayerRef.number,
          "from the",
          attackPosition,
          " w/ ",
          ownerWeaponType,
          "@",
          logCellNo,
          "successfully. damage,deflect target/defender",
          owner.trap.acting.direction
        );
        this.handleMeleeDamage(ownerType, owner, targetPlayerRef);

        this.setDeflection(targetPlayerRef, "attacked", false);
      }
    };
    const handleTargetDodging = () => {
      console.log(
        "target dodging: ",
        ownerType,
        owner.number,
        owner.id,
        "attacked a player",
        targetPlayerRef.number,
        "from the",
        attackPosition,
        " w/ ",
        ownerWeaponType,
        "@",
        logCellNo,
        "but they dodged successfully"
      );

      if (ownerType === "player") {
        if (!owner.popups.find((x) => x.msg === "missedAttack2")) {
          owner.popups.push({
            state: false,
            count: 0,
            limit: 30,
            type: "",
            position: "",
            msg: "missedAttack2",
            img: "",
          });
        }

        if (owner.attacking.blunt === true) {
          owner.attacking.blunt = false;
        }

        owner.stamina.current -= playerAttackStamType.pre;
        targetPlayerRef.stamina.current += this.staminaCostRef.dodge.pre;
      } else {
        if (
          !this.cellPopups.find(
            (x) =>
              x.msg === "missedAttack2" &&
              x.cell.number.x === myCell.number.x &&
              x.cell.number.y === myCell.number.y
          )
        ) {
          this.cellPopups.push({
            state: false,
            count: 0,
            limit: 35,
            type: "",
            position: "",
            msg: "missedAttack2",
            color: "",
            img: "",
            cell: this.gridInfo.find(
              (x) => x.number.x === myCell.number.x && x.number.y === myCell.number.y
            ),
          });
        }
      }
    };
    const handleTargetDefending = () => {
      // BLUNT ATTACK IS MADE FOR BREAKING DEFENSE
      if (ownerType === "player" && owner.attacking.blunt === true) {
        console.log(
          "target defending:",
          ownerType,
          owner.number,
          owner.id,
          "blunt attacked a player",
          targetPlayerRef.number,
          "from the",
          attackPosition,
          " w/ ",
          ownerWeaponType,
          " @",
          logCellNo,
          ". they defended but blunt attack is an auto defense break. Deflect target"
        );
        this.setDeflection(targetPlayerRef, "bluntAttacked", false);
        owner.success.attackSuccess = {
          state: true,
          count: 1,
          limit: owner.success.attackSuccess.limit,
        };
      }

      // ATTACKER NON-BLUNT ATTACK
      else {
        // DEFENDER ADVANTAGE/evenly matched
        if (advantage === 2 || advantage === 0) {
          // console.log(
          //   "target defending: attacker",
          //   ownerType,
          //   owner.number,
          //   owner.id,
          //   " & defender player",
          //   targetPlayerRef.number,
          //   "are evenly matched in combat advantage"
          // );

          // SIDE ATTACK OR FACE TO FACE
          // PEAK DEFEND/PARRY
          if (sideAttack === true || faceToFace === true) {
            if (targetPlayerRef.defending.peak === true) {
              console.log(
                "target defending:",
                ownerType,
                owner.number,
                owner.id,
                "attacked a player",
                targetPlayerRef.number,
                "from the",
                attackPosition,
                " w/ ",
                ownerWeaponType,
                " @",
                logCellNo,
                ". they parried successfully. Deflect/pushback (high chance) attacker?"
              );

              // PUSHBACK AND/OR DEFLECT ATTACKER/PLAYER?
              if (ownerType === "player") {
                if (faceToFace === true) {
                  this.setDeflection(owner, "parried", true);
                }
                if (sideAttack === true) {
                  if (this.rnJesus(1, 0) === 1) {
                    this.setDeflection(owner, "parried", true);
                  }
                  // JUST DEFLECT
                  else {
                    this.setDeflection(owner, "parried", false);
                  }
                }
              }
              // PUSHBACK OBSTACLE
              else {
                if (ownerType === "obstacle") {
                  if (faceToFace === true) {
                    this.canPushObstacle("player", targetPlayerRef, myCell, `hitPush`);
                  }
                  if (sideAttack === true) {
                    if (
                      this.rnJesus(1, (owner.height + owner.weight) * this.rnJesus(1, 3))
                    ) {
                      this.canPushObstacle("player", targetPlayerRef, myCell, `hitPush`);
                    }
                  }
                }
              }

              targetPlayerRef.stamina.current += this.staminaCostRef.defend.peak;
              targetPlayerRef.success.defendSuccess = {
                state: true,
                count: 1,
                limit: targetPlayerRef.success.defendSuccess.limit,
              };
              targetPlayerRef.statusDisplay = {
                state: true,
                status: "Parry!",
                count: 1,
                limit: targetPlayerRef.statusDisplay.limit,
              };
              if (!targetPlayerRef.popups.find((x) => x.msg === "attackParried")) {
                targetPlayerRef.popups.push({
                  state: false,
                  count: 0,
                  limit: 30,
                  type: "",
                  position: "",
                  msg: "attackParried",
                  img: "",
                });
              }

              if (sideAttack === true) {
                if (this.rnJesus(0, 4) === 1) {
                  this.pushBack(
                    targetPlayerRef,
                    this.getOppositeDirection(targetPlayerRef.direction)
                  );
                }
              }
              if (faceToFace === true) {
                if (this.rnJesus(0, 6) === 1) {
                  this.pushBack(
                    targetPlayerRef,
                    this.getOppositeDirection(targetPlayerRef.direction)
                  );
                }
              }
            }
          }

          // OFF PEAK DEFEND. DEFENSE NOT GUARANTEED
          // if (targetPlayerRef.defending.decay.state === true && targetPlayerRef.defending.peak !== true) {
          if (targetPlayerRef.defending.peak !== true) {
            if (sideAttack === true) {
              if (this.rnJesus(1, targetPlayerRef.crits.guardBreak) !== 1) {
                console.log(
                  "target defending:",
                  ownerType,
                  owner.number,
                  owner.id,
                  "attacked a player",
                  targetPlayerRef.number,
                  "from the",
                  attackPosition,
                  " w/ ",
                  ownerWeaponType,
                  " @",
                  logCellNo,
                  ". they off peak defended successfully. Deflect attacker?"
                );
                // DEFLECT ATTACKER?
                if (ownerType === "player") {
                  if (this.rnJesus(1, owner.crits.pushBack) === 1) {
                    this.setDeflection(owner, "defended", false);
                  }
                }

                targetPlayerRef.success.defendSuccess = {
                  state: true,
                  count: 1,
                  limit: targetPlayerRef.success.defendSuccess.limit,
                };
                targetPlayerRef.statusDisplay = {
                  state: true,
                  status: "Defend",
                  count: 1,
                  limit: targetPlayerRef.statusDisplay.limit,
                };
                if (!targetPlayerRef.popups.find((x) => x.msg === "defendSuccess")) {
                  targetPlayerRef.popups.push({
                    state: false,
                    count: 0,
                    limit: 25,
                    type: "",
                    position: "",
                    msg: "defendSuccess",
                    img: "",
                  });
                }

                if (this.rnJesus(0, 3) === 1) {
                  this.pushBack(
                    targetPlayerRef,
                    this.getOppositeDirection(targetPlayerRef.direction)
                  );
                }
              }

              // DEFEND FAILURE
              else {
                console.log(
                  "target defending:",
                  ownerType,
                  owner.number,
                  owner.id,
                  "attacked a player",
                  targetPlayerRef.number,
                  "from the",
                  attackPosition,
                  " w/ ",
                  ownerWeaponType,
                  " @",
                  logCellNo,
                  ". they off peak defended unsuccessfully. Damage, deflect target/defender?"
                );
                this.setDeflection(targetPlayerRef, "attacked", false);
                this.handleMeleeDamage(ownerType, owner, targetPlayerRef);
              }
            }
            //FACE TO FACE OFF PEAK DEFEND IS GUARANTEED SUCCESS
            if (faceToFace === true) {
              console.log(
                "target defending:",
                ownerType,
                owner.number,
                owner.id,
                "attacked a player",
                targetPlayerRef.number,
                "from the",
                attackPosition,
                " w/ ",
                ownerWeaponType,
                " @",
                logCellNo,
                ". they off peak defended successfully. Deflect/pushback attacker?"
              );
              if (this.rnJesus(1, targetPlayerRef.crits.guardBreak) !== 1) {
                // PUSHBACK AND/OR DEFLECT ATTACKER/PLAYER?
                if (ownerType === "player") {
                  if (this.rnJesus(1, owner.crits.pushBack) === 1) {
                    this.setDeflection(owner, "defended", true);
                  }
                  // JUST DEFLECT
                  else {
                    this.setDeflection(owner, "defended", false);
                  }
                }
                // PUSHBACK OBSTACLE
                else {
                  if (ownerType === "obstacle") {
                    if (
                      this.rnJesus(1, (owner.height + owner.weight) * this.rnJesus(1, 3))
                    ) {
                      this.canPushObstacle("player", targetPlayerRef, myCell, `hitPush`);
                    }
                  }
                }
              }
              targetPlayerRef.success.defendSuccess = {
                state: true,
                count: 1,
                limit: targetPlayerRef.success.defendSuccess.limit,
              };
              targetPlayerRef.statusDisplay = {
                state: true,
                status: "Defend",
                count: 1,
                limit: targetPlayerRef.statusDisplay.limit,
              };
              if (!targetPlayerRef.popups.find((x) => x.msg === "defendSuccess")) {
                targetPlayerRef.popups.push({
                  state: false,
                  count: 0,
                  limit: 25,
                  type: "",
                  position: "",
                  msg: "defendSuccess",
                  img: "",
                });
              }
              if (this.rnJesus(0, 2) === 1) {
                this.pushBack(
                  targetPlayerRef,
                  this.getOppositeDirection(targetPlayerRef.direction)
                );
              }
            }
          }
        }

        // ATTACKER/PLAYER ADVANTAGE
        else if (advantage === 1) {
          // console.log(
          //   "target defending: attacker",
          //   ownerType,
          //   owner.number,
          //   owner.id,
          //   " & defender player",
          //   targetPlayerRef.number,
          //   ". the attacker outmatches defender in comabt advantage (defender is likely unarmed). Damage deflect target/defender"
          // );
          this.handleMeleeDamage(ownerType, owner, targetPlayerRef);
          this.setDeflection(targetPlayerRef, "attacked", false);

          if (ownerType === "player") {
            owner.success.attackSuccess = {
              state: true,
              count: 1,
              limit: owner.success.attackSuccess.limit,
            };
          }
        }
      }
    };

    const handleTargetAttacking = () => {
      // EVENLY MATCHED. CLASHING
      if (advantage === 0) {
        console.log(
          "target attacking: attacker",
          ownerType,
          owner.number,
          owner.id,
          " & defender player",
          targetPlayerRef.number,
          "are evenly matched in combat advantage. clashing!! pushback one or both players w/o damage"
        );

        if (ownerType === "player") {
          targetPlayerRef.attacking.clashing.state = true;
          owner.attacking.clashing.state = true;
        }

        // PUSHBACK ATTACKER/PLAYER
        let set = false;
        let pushWho = this.rnJesus(0, 2);
        if (pushWho === 0 && set !== true) {
          if (ownerType === "obstacle") {
            this.canPushObstacle("player", targetPlayerRef, myCell, `hitPush`);
            set = true;
          }
          if (ownerType === "player") {
            this.pushBack(owner, this.getOppositeDirection(owner.direction));
            set = true;
          }
        }
        // PUSHBACK DEFENDER/TARGET
        if (pushWho === 1 && set !== true) {
          this.pushBack(
            targetPlayerRef,
            this.getOppositeDirection(targetPlayerRef.direction)
          );
          set = true;
        }
        // PUSHBACK BOTH PLAYERS
        if (pushWho === 2 && set !== true) {
          if (ownerType === "obstacle") {
            this.canPushObstacle("player", targetPlayerRef, myCell, `hitPush`);
            set = true;
          }
          if (ownerType === "player") {
            this.pushBack(owner, this.getOppositeDirection(owner.direction));
            set = true;
          }
          this.pushBack(
            targetPlayerRef,
            this.getOppositeDirection(targetPlayerRef.direction)
          );
          set = true;
        }
      }

      // PLAYER ADVANTAGE
      if (advantage === 1) {
        console.log(
          "target attacking: attacker",
          ownerType,
          owner.number,
          owner.id,
          " & defender player",
          targetPlayerRef.number,
          "are unevenly matched in combat advantage. attacker advantage (defender is likely unarmed) damage, deflect target/defender"
        );
        if (ownerType === "player") {
          owner.success.attackSuccess = {
            state: true,
            count: 1,
            limit: owner.success.attackSuccess.limit,
          };
        }

        this.handleMeleeDamage(ownerType, owner, targetPlayerRef);
        this.setDeflection(targetPlayerRef, "attacked", false);
      }

      // TARGET ADVANTAGE
      if (advantage === 2) {
        console.log(
          "target attacking: attacker",
          ownerType,
          owner.number,
          owner.id,
          " & defender player",
          targetPlayerRef.number,
          "are unevenly matched in combat advantage. target/defender advantage (attacker is likely unarmed) damage, deflect attacker"
        );
        if (ownerType === "player") {
          this.handleMeleeDamage("player", targetPlayerRef, owner);
          this.setDeflection(owner, "attacked", false);
        } else {
          this.attackCellContents(
            "melee",
            "player",
            targetPlayerRef,
            targetCell,
            targetCell2,
            myCell,
            undefined
          );
        }

        targetPlayerRef.success.attackSuccess = {
          state: true,
          count: 1,
          limit: targetPlayerRef.success.attackSuccess.limit,
        };
      }
    };

    // PROJECTILE, ITEM, RUBBLE, OBSTACLE, BARRIER TARGETS
    if (cellNo === 1) {
      logCellNo = targetCell1.number;
      //TARGET IS PROJECTILE!!
      if (this.isBoltInCell(targetCell1.number) === true) {
        console.log(
          ownerType,
          owner.number,
          owner.id,
          "attacked and destroyed a bolt projectile @",
          targetCell1.number,
          "w/ ",
          ownerWeaponType,
          ". pushback?"
        );
        this.projectiles.find(
          (x) =>
            x.currentPosition.number.x === targetCell1.number.x &&
            x.currentPosition.number.y === targetCell1.number.y
        ).kill = true;

        if (ownerType === "player") {
          if (!owner.popups.find((x) => x.msg === "boltKilled")) {
            owner.popups.push({
              state: false,
              count: 0,
              limit: 30,
              type: "",
              position: "",
              msg: "boltKilled",
              img: "",
            });
          }
          if (this.rnJesus(0, owner.crits.pushBack)) {
            this.pushBack(owner, this.getOppositeDirection(owner.direction));
          }
        }
      }

      // TARGET IS BARRIER/OBSTACLE/ITEM/RUBBLE
      if (this.isBoltInCell(targetCell1.number) !== true) {
        if (
          cell1Item === true ||
          cell1Rubble === true ||
          targetCell1.obstacle.state === true ||
          targetCell1.barrier.state === true
        ) {
          // console.log(
          //   ownerType,
          //   owner.number,
          //   owner.id,
          //   "attacked an obstacle, barrier, item or rubble @",
          //   targetCell1.number,
          //   "w/ ",
          //   ownerWeaponType,
          //   ". attackCellContents"
          // );
          this.attackCellContents(
            "melee",
            ownerType,
            owner,
            targetCell1,
            targetCell2,
            myCell,
            undefined
          );
        }
      }
    }
    if (cellNo === 2) {
      logCellNo = targetCell2.number;
      //TARGET IS PROJECTILE!!
      if (this.isBoltInCell(targetCell2.number) === true) {
        console.log(
          ownerType,
          owner.number,
          owner.id,
          "attacked and destroyed a bolt projectile @",
          targetCell2.number,
          "w/ ",
          ownerWeaponType,
          ". pushback?"
        );
        this.projectiles.find(
          (x) =>
            x.currentPosition.number.x === targetCell2.number.x &&
            x.currentPosition.number.y === targetCell2.number.y
        ).kill = true;

        if (ownerType === "player") {
          if (!owner.popups.find((x) => x.msg === "boltKilled")) {
            owner.popups.push({
              state: false,
              count: 0,
              limit: 30,
              type: "",
              position: "",
              msg: "boltKilled",
              img: "",
            });
          }
          if (this.rnJesus(0, owner.crits.pushBack)) {
            this.pushBack(owner, this.getOppositeDirection(owner.direction));
          }
        }
      }

      // TARGET IS BARRIER/OBSTACLE/ITEM/RUBBLE
      if (this.isBoltInCell(targetCell2.number) !== true) {
        if (
          cell2Item === true ||
          cell2Rubble === true ||
          targetCell2.obstacle.state === true ||
          targetCell2.barrier.state === true
        ) {
          // console.log(
          //   ownerType,
          //   owner.number,
          //   owner.id,
          //   "attacked an obstacle, barrier, item or rubble @",
          //   targetCell2.number,
          //   "w/ ",
          //   ownerWeaponType,
          //   ". attackCellContents"
          // );
          this.attackCellContents(
            "melee",
            ownerType,
            owner,
            targetCell1,
            targetCell2,
            myCell,
            undefined
          );
        }
      }
    }

    // TARGET IS A PLAYER
    for (const plyr of this.players) {
      if (cellNo === 1) {
        if (
          plyr.currentPosition.cell.number.x === targetCell1.number.x &&
          plyr.currentPosition.cell.number.y === targetCell1.number.y
        ) {
          targetPlayerRef = plyr;
        }
      }
      if (cellNo === 2) {
        if (
          plyr.currentPosition.cell.number.x === targetCell2.number.x &&
          plyr.currentPosition.cell.number.y === targetCell2.number.y
        ) {
          targetPlayerRef = plyr;
        }
      }
    }
    if (targetPlayerRef) {
      // IS TARGET DEFENDING?
      let targetDefending = setTargetDefending();
      advantage = setAdvantage();

      // BACK ATTACK
      if (ownerDirection === targetPlayerRef.direction) {
        backAttack = true;
        attackPosition = "back";
        // TARGET DODGING BACK ATTACK
        if (targetPlayerRef.dodging.state === true) {
          handleTargetDodging();

          if (ownerType === "player") {
            this.players[owner.number - 1] = owner;
          }
          this.players[targetPlayerRef.number - 1] = targetPlayerRef;
          return;
        }

        //TARGET NOT DODGING. VULNERABLE TO BACK ATTACK
        else {
          executeAttack();

          if (ownerType === "player") {
            this.players[owner.number - 1] = owner;
          }
          this.players[targetPlayerRef.number - 1] = targetPlayerRef;
          return;
        }
      }

      // SIDE ATTACK
      if (
        targetPlayerRef.direction !== ownerDirection &&
        targetPlayerRef.direction !== this.getOppositeDirection(ownerDirection)
      ) {
        sideAttack = true;
        attackPosition = "side";
        // TARGET PLAYER IS DODGING
        if (targetPlayerRef.dodging.state === true) {
          handleTargetDodging();

          if (ownerType === "player") {
            this.players[owner.number - 1] = owner;
          }
          this.players[targetPlayerRef.number - 1] = targetPlayerRef;
          return;
        }

        // TARGET PLAYER DEFENDING
        if (targetDefending === true) {
          handleTargetDefending();

          if (ownerType === "player") {
            this.players[owner.number - 1] = owner;
          }
          this.players[targetPlayerRef.number - 1] = targetPlayerRef;
          return;
        }

        // TARGET PLAYER NOT DODGING OR DEFENDING
        else {
          executeAttack();

          if (ownerType === "player") {
            this.players[owner.number - 1] = owner;
          }
          this.players[targetPlayerRef.number - 1] = targetPlayerRef;
          return;
        }
      }

      // TARGET & PLAYER ARE FACE TO FACE
      if (ownerDirection === this.getOppositeDirection(targetPlayerRef.direction)) {
        faceToFace = true;
        attackPosition = "front";
        // TARGET DODGING
        if (targetPlayerRef.dodging.state === true) {
          handleTargetDodging();

          if (ownerType === "player") {
            this.players[owner.number - 1] = owner;
          }
          this.players[targetPlayerRef.number - 1] = targetPlayerRef;
          return;
        }

        let defenderWeaponType = targetPlayerRef.currentWeapon.type;
        if (targetPlayerRef.currentWeapon.name === "") {
          defenderWeaponType = "unarmed";
        }
        let simultaneousAttack = false;
        // console.log(
        //   "here",
        //   owner.attacking.count,
        //   targetPlayerRef.attacking.count,
        //   targetPlayerRef.attacking.animRef.peak[defenderWeaponType] - this.simultaneousAttackAllowance
        // );
        if (
          targetPlayerRef.attacking.peak === true ||
          (targetPlayerRef.attacking.count >=
            targetPlayerRef.attacking.animRef.peak[defenderWeaponType] -
              this.simultaneousAttackAllowance &&
            targetPlayerRef.attacking.count <=
              targetPlayerRef.attacking.animRef.peak[defenderWeaponType])
        ) {
          simultaneousAttack = true;
        }
        // TARGET ALSO ATTACKING
        if (simultaneousAttack === true) {
          handleTargetAttacking();

          if (ownerType === "player") {
            this.players[owner.number - 1] = owner;
          }
          this.players[targetPlayerRef.number - 1] = targetPlayerRef;
          return;
        }

        // TARGET DEFENDING
        if (targetDefending === true) {
          handleTargetDefending();

          if (ownerType === "player") {
            this.players[owner.number - 1] = owner;
          }
          this.players[targetPlayerRef.number - 1] = targetPlayerRef;
          return;
        }

        // TARGET NOT DEFENDING, DODGING OR ATTACKING, DAMAGE
        if (
          targetPlayerRef.dodging.state !== true &&
          // targetPlayerRef.attacking.peak !== true &&
          simultaneousAttack !== true &&
          targetDefending !== true
        ) {
          executeAttack();

          if (ownerType === "player") {
            this.players[owner.number - 1] = owner;
          }
          this.players[targetPlayerRef.number - 1] = targetPlayerRef;
          return;
        }
      }

      // this.players[targetPlayerRef.number - 1] = targetPlayerRef;
    }

    // if (ownerType === "player") {
    //   this.players[owner.number - 1] = owner;
    // }
  };
  projectileAttackParse = (bolt, ownerType, targetType, target) => {
    // console.log("projectileAttackParse");

    let deflected = false;
    let x;

    this.cellsUnderAttack.push({
      number: {
        x: target.currentPosition.cell.number.x,
        y: target.currentPosition.cell.number.y,
      },
      count: 1,
      limit: 8,
    });

    if (targetType === "player") {
      let weapon = target.currentWeapon.type;

      // ATTACK STAM UNARMED CHECK & AND POPUPS SET
      let playerAttackStamType;

      if (target.currentWeapon.name !== "") {
        playerAttackStamType =
          this.staminaCostRef.attack[target.currentWeapon.type].normal;
      }

      if (target.attacking.blunt === true && target.currentWeapon.name !== "") {
        playerAttackStamType =
          this.staminaCostRef.attack[target.currentWeapon.type].blunt;
      }
      if (target.currentWeapon.name === "") {
        playerAttackStamType = this.staminaCostRef.attack.unarmed.normal;
        if (target.attacking.blunt === true) {
          playerAttackStamType = this.staminaCostRef.attack.unarmed.blunt;
        }
        weapon = "unarmed";
      }

      // IS TARGET DEFENDING?
      let playerDefending = false;
      let defendType = target.currentWeapon.type;
      if (target.currentWeapon.name === "") {
        defendType = "unarmed";
      }
      let defendPeak = target.defending.animRef.peak[defendType];
      if (
        target.defending.count === defendPeak ||
        target.defending.decay.state === true
      ) {
        playerDefending = true;
      }

      //BOLT TARGET DODGING
      if (target.dodging.state === true) {
        console.log(
          "player ",
          target.number,
          " just dodged a bolt from ",
          bolt.ownerType,
          bolt.owner
        );
        target.stamina.current += this.staminaCostRef.dodge.pre;
        // FINISH
        x = this.projectiles.find((x) => x.id === bolt.id);
        x = bolt;
        this.players[target.number - 1] = target;
        return;
      } else {
        // BOLT NOT DODGED MUST HIT PLAYER
        bolt.kill = true;
        // BOLT TARGET NOT DODGING
        // BACK ATTACK
        if (target.direction === bolt.direction && deflected !== true) {
          console.log(
            "bolt hit plyr",
            target.number,
            "from the back by",
            bolt.ownerType,
            bolt.owner,
            "Damage & Deflect"
          );
          this.handleProjectileDamage(bolt, ownerType, "player", target);
          this.setDeflection(target, "attacked", false);
          deflected = true;
          // FINISH
          x = this.projectiles.find((x) => x.id === bolt.id);
          x = bolt;
          this.players[target.number - 1] = target;
          return;
        }

        // SIDE ATTACK
        if (
          target.direction !== bolt.direction &&
          target.direction !== this.getOppositeDirection(bolt.direction) &&
          deflected !== true
        ) {
          // PLAYER IS ATTACKING ARMED
          if (target.attacking.peak === true && weapon !== "unarmed") {
            // CHANCE TO KILL BOLT & PUSHBACK
            if (this.rnJesus(1, target.crits.pushBack) === 1) {
              console.log(
                "bolt hit plyr",
                target.number,
                "from the side. by",
                bolt.ownerType,
                bolt.owner,
                "but they attacked it successfully. Pushback?"
              );
              if (!target.popups.find((x) => x.msg === "boltKilled")) {
                target.popups.push({
                  state: false,
                  count: 0,
                  limit: 30,
                  type: "",
                  position: "",
                  msg: "boltKilled",
                  img: "",
                });
              }
              this.pushBack(target, this.getOppositeDirection(target.direction));
              target.success.attackSuccess = {
                state: true,
                count: 1,
                limit: target.success.attackSuccess.limit,
              };

              // FINISH
              x = this.projectiles.find((x) => x.id === bolt.id);
              x = bolt;
              this.players[target.number - 1] = target;
              return;
            }

            // OR BE INJURED
            else {
              console.log(
                "bolt hit plyr",
                target.number,
                "from the side. by",
                bolt.ownerType,
                bolt.owner,
                "but they attacked it unsuccessfully. Damage & Deflect?"
              );
              this.handleProjectileDamage(bolt, ownerType, "player", target);
              this.setDeflection(target, "attacked", false);
              deflected = true;
              // FINISH
              x = this.projectiles.find((x) => x.id === bolt.id);
              x = bolt;
              this.players[target.number - 1] = target;
              return;
            }
          }

          // PLAYER IS ATTACKING BUT UNARMED, TAKE DAMAGE
          if (target.attacking.peak === true && weapon === "unarmed") {
            console.log(
              "bolt hit plyr",
              target.number,
              "from the side. by",
              bolt.ownerType,
              bolt.owner,
              "but they attacked successfully but unarmed. Damage, Deflect?"
            );
            this.handleProjectileDamage(bolt, ownerType, "player", target);
            this.setDeflection(target, "attacked", false);
            deflected = true;
            // FINISH
            x = this.projectiles.find((x) => x.id === bolt.id);
            x = bolt;
            this.players[target.number - 1] = target;
            return;
          }

          // PLAYER DEFENDING
          if (playerDefending === true) {
            // UNARMED DEFENSE = DAMAGE.
            if (weapon === "unarmed" || defendType === "unarmed") {
              console.log(
                "bolt hit plyr",
                target.number,
                "from the side. by",
                bolt.ownerType,
                bolt.owner,
                "but they defended unarmed. Damage & Deflect"
              );
              this.handleProjectileDamage(bolt, ownerType, "player", target);
              this.setDeflection(target, "attacked", false);
              deflected = true;
              // FINISH
              x = this.projectiles.find((x) => x.id === bolt.id);
              x = bolt;
              this.players[target.number - 1] = target;
              return;
            }
            // ARMED DEFENSE
            else {
              // PEAK DEFEND
              if (target.defending.peak === true) {
                console.log(
                  "bolt hit plyr",
                  target.number,
                  "from the side. by",
                  bolt.ownerType,
                  bolt.owner,
                  "but they parried"
                );
                target.stamina.current += this.staminaCostRef.defend.peak;
                target.success.defendSuccess = {
                  state: true,
                  count: 1,
                  limit: target.success.defendSuccess.limit,
                };
                target.statusDisplay = {
                  state: true,
                  status: "Parry!",
                  count: 1,
                  limit: target.statusDisplay.limit,
                };
                if (!target.popups.find((x) => x.msg === "attackParried")) {
                  target.popups.push({
                    state: false,
                    count: 0,
                    limit: 30,
                    type: "",
                    position: "",
                    msg: "attackParried",
                    img: "",
                  });
                }
                if (this.rnJesus(1, target.crits.pushBack) === 1) {
                  this.pushBack(target, this.getOppositeDirection(target.direction));
                }

                // FINISH
                x = this.projectiles.find((x) => x.id === bolt.id);
                x = bolt;
                this.players[target.number - 1] = target;
                return;
              }
              // OFF PEAK DEFEND
              // if (target.defending.decay.state === true && target.defending.peak !== true) {
              if (target.defending.peak !== true) {
                // CHANCE FOR DEFEND SUCCESS
                if (this.rnJesus(1, target.crits.guardBreak) !== 1) {
                  console.log(
                    "bolt hit plyr",
                    target.number,
                    "from the side. by",
                    bolt.ownerType,
                    bolt.owner,
                    "but they off-peak defended successfully"
                  );
                  target.success.defendSuccess = {
                    state: true,
                    count: 1,
                    limit: target.success.defendSuccess.limit,
                  };
                  target.statusDisplay = {
                    state: true,
                    status: "Defend",
                    count: 1,
                    limit: target.statusDisplay.limit,
                  };
                  if (!target.popups.find((x) => x.msg === "defendSuccess")) {
                    target.popups.push({
                      state: false,
                      count: 0,
                      limit: 25,
                      type: "",
                      position: "",
                      msg: "defendSuccess",
                      img: "",
                    });
                  }
                  if (this.rnJesus(1, target.crits.pushBack) === 1) {
                    this.pushBack(target, this.getOppositeDirection(target.direction));
                  }
                  // FINISH
                  x = this.projectiles.find((x) => x.id === bolt.id);
                  x = bolt;
                  this.players[target.number - 1] = target;
                  return;
                }

                // DEFEND FAILURE DAMAGE, DEFLECT || DEFLECT + PUSHBACK
                else {
                  console.log(
                    "bolt hit plyr",
                    target.number,
                    "from the side. by",
                    bolt.ownerType,
                    bolt.owner,
                    "but they off-peak defended unsuccessfully. Damage, Deflect, Pushback?"
                  );
                  this.handleProjectileDamage(bolt, ownerType, "player", target);

                  deflected = true;
                  // FINISH
                  x = this.projectiles.find((x) => x.id === bolt.id);
                  x = bolt;
                  this.players[target.number - 1] = target;
                  return;
                }
              }
            }
          }

          //PLAYER NOT DEFENDING OR ATTACKING, TAKE DAMAGE
          if (playerDefending !== true && target.attacking.peak !== true) {
            console.log(
              "bolt hit plyr",
              target.number,
              "from the side. by",
              bolt.ownerType,
              bolt.owner,
              "but theyre not defending or attacking or dodging. Damage, Deflect?"
            );

            this.handleProjectileDamage(bolt, ownerType, "player", target);
            this.setDeflection(target, "attacked", false);
            deflected = true;
            // FINISH
            x = this.projectiles.find((x) => x.id === bolt.id);
            x = bolt;
            this.players[target.number - 1] = target;
            return;
          }
        }

        // FRONTAL ATTACK
        if (
          bolt.direction === this.getOppositeDirection(target.direction) &&
          deflected !== true
        ) {
          // PLAYER ARMED AND ATTACKING
          if (target.attacking.peak === true && weapon !== "unarmed") {
            console.log(
              "bolt hit plyr",
              target.number,
              "from the front. by",
              bolt.ownerType,
              bolt.owner,
              "but they attacked successfully. pushback target?"
            );
            if (!target.popups.find((x) => x.msg === "boltKilled")) {
              target.popups.push({
                state: false,
                count: 0,
                limit: 30,
                type: "",
                position: "",
                msg: "boltKilled",
                img: "",
              });
            }
            if (this.rnJesus(1, target.crits.pushBack) === 1) {
              this.pushBack(target, this.getOppositeDirection(target.direction));
            }
            target.success.attackSuccess = {
              state: true,
              count: 1,
              limit: target.success.attackSuccess.limit,
            };
            // FINISH
            x = this.projectiles.find((x) => x.id === bolt.id);
            x = bolt;
            this.players[target.number - 1] = target;
            return;
          }
          // PLAYER IS ATTACKING BUT UNARMED, TAKE DAMAGE
          if (target.attacking.peak === true && weapon === "unarmed") {
            console.log(
              "bolt hit plyr",
              target.number,
              "from the side. by",
              bolt.ownerType,
              bolt.owner,
              "but they attacked successfully but unarmed. Damage, Deflect?"
            );
            this.handleProjectileDamage(bolt, ownerType, "player", target);
            this.setDeflection(target, "attacked", false);
            deflected = true;
            // FINISH
            x = this.projectiles.find((x) => x.id === bolt.id);
            x = bolt;
            this.players[target.number - 1] = target;
            return;
          }

          // PLAYER DEFENDING
          if (playerDefending === true) {
            if (weapon === "unarmed") {
              // UNARMED PEAK DEFEND, SUCCESS
              if (target.defending.peak === true) {
                console.log(
                  "bolt hit plyr",
                  target.number,
                  "from the front. by",
                  bolt.ownerType,
                  bolt.owner,
                  "but they parried successfully unarmed."
                );
                // target.stamina.current += this.staminaCostRef.defend.peak;
                target.success.defendSuccess = {
                  state: true,
                  count: 1,
                  limit: target.success.defendSuccess.limit,
                };
                target.statusDisplay = {
                  state: true,
                  status: "Parry!",
                  count: 1,
                  limit: target.statusDisplay.limit,
                };
                if (!target.popups.find((x) => x.msg === "attackParried")) {
                  target.popups.push({
                    state: false,
                    count: 0,
                    limit: 30,
                    type: "",
                    position: "",
                    msg: "attackParried",
                    img: "",
                  });
                }
                // FINISH
                x = this.projectiles.find((x) => x.id === bolt.id);
                x = bolt;
                this.players[target.number - 1] = target;
                return;
              }

              // UNARMED OFF PEAK DEFEND, Take DAMAGE
              // if (target.defending.decay.state === true && target.defending.peak !== true) {
              if (target.defending.peak !== true) {
                console.log(
                  "bolt hit plyr",
                  target.number,
                  "from the front. by",
                  bolt.ownerType,
                  bolt.owner,
                  "but they off-peak defended successfully unarmed. Damage deflect?"
                );
                this.handleProjectileDamage(bolt, ownerType, "player", target);
                this.setDeflection(target, "attacked", false);
                deflected = true;
                // FINISH
                x = this.projectiles.find((x) => x.id === bolt.id);
                x = bolt;
                this.players[target.number - 1] = target;
                return;
              }
            }

            // PLAYER DEFENDING AND ARMED, GUARANTEED DEFEND W/ CHANCE TO PUSH BACK
            else {
              if (target.defending.peak === true) {
                console.log(
                  "bolt hit plyr",
                  target.number,
                  "from the front. by",
                  bolt.ownerType,
                  bolt.owner,
                  "but they parried successfully armed."
                );
                target.stamina.current += this.staminaCostRef.defend.peak;
                target.success.defendSuccess = {
                  state: true,
                  count: 1,
                  limit: target.success.defendSuccess.limit,
                };
                target.statusDisplay = {
                  state: true,
                  status: "Parry!",
                  count: 1,
                  limit: target.statusDisplay.limit,
                };
                if (!target.popups.find((x) => x.msg === "attackParried")) {
                  target.popups.push({
                    state: false,
                    count: 0,
                    limit: 30,
                    type: "",
                    position: "",
                    msg: "attackParried",
                    img: "",
                  });
                }
                if (this.rnJesus(1, target.crits.pushBack) === 1) {
                  this.pushBack(target, this.getOppositeDirection(target.direction));
                }
                // FINISH
                x = this.projectiles.find((x) => x.id === bolt.id);
                x = bolt;
                this.players[target.number - 1] = target;
                return;
              }

              // if (target.defending.decay.state === true && target.defending.peak !== true) {
              if (target.defending.peak !== true) {
                console.log(
                  "bolt hit plyr",
                  target.number,
                  "from the front. by",
                  bolt.ownerType,
                  bolt.owner,
                  "but they off-peak defended successfully armed. Pushback?"
                );
                target.success.defendSuccess = {
                  state: true,
                  count: 1,
                  limit: target.success.defendSuccess.limit,
                };
                target.statusDisplay = {
                  state: true,
                  status: "Defend",
                  count: 1,
                  limit: target.statusDisplay.limit,
                };
                if (!target.popups.find((x) => x.msg === "defendSuccess")) {
                  target.popups.push({
                    state: false,
                    count: 0,
                    limit: 25,
                    type: "",
                    position: "",
                    msg: "defendSuccess",
                    img: "",
                  });
                }
                if (this.rnJesus(1, target.crits.pushBack) === 1) {
                  this.pushBack(target, this.getOppositeDirection(target.direction));
                }
                // FINISH
                x = this.projectiles.find((x) => x.id === bolt.id);
                x = bolt;
                this.players[target.number - 1] = target;
                return;
              }
            }
          }

          //PLAYER NOT DEFENDING OR ATTACKING, TAKE DAMAGE
          if (playerDefending !== true && target.attacking.peak !== true) {
            console.log(
              "bolt hit plyr",
              target.number,
              "from the front. by",
              bolt.ownerType,
              bolt.owner,
              "but arent defending or attacking. Damage Deflect?"
            );
            this.handleProjectileDamage(bolt, ownerType, "player", target);
            this.setDeflection(target, "attacked", false);
            deflected = true;
            // FINISH
            x = this.projectiles.find((x) => x.id === bolt.id);
            x = bolt;
            this.players[target.number - 1] = target;
            return;
          }

          // PLAYER IS ATTACKING BUT UNARMED, TAKE DAMAGE
          if (target.attacking.peak === true && weapon === "unarmed") {
            console.log(
              "bolt hit plyr",
              target.number,
              "from the front. by",
              bolt.ownerType,
              bolt.owner,
              "but they attack successfully unarmed. Damage Deflect?"
            );
            this.handleProjectileDamage(bolt, ownerType, "player", target);
            this.setDeflection(target, "attacked", false);
            deflected = true;
            // FINISH
            x = this.projectiles.find((x) => x.id === bolt.id);
            x = bolt;
            this.players[target.number - 1] = target;
            return;
          }
        }
      }
    } else {
      let cell = this.gridInfo.find((x) => x[targetType].id === target.id);
      console.log(
        "bolt hit ",
        targetType,
        "at",
        target.number,
        " by",
        bolt.ownerType,
        bolt.owner,
        "attack cell contents"
      );
      this.attackCellContents(
        "bolt",
        bolt.ownerType,
        cell[targetType],
        cell,
        undefined,
        undefined,
        bolt
      );

      let x = this.projectiles.find((x) => x.id === bolt.id);
      x = bolt;
    }
  };
  setDeflection = (player, type, pushBack) => {
    // this.deflectedLengthRef = {
    //   outOfStamina: 50,
    //   attacked: 20,
    //   bluntAttacked: 25,
    //   defended: 10,
    // parried: 25
    // knockedOut: 65,
    // };
    this.attackedCancel(player);

    player.action = "deflected";
    player.success.deflected = {
      state: true,
      count: 0,
      limit: this.deflectedLengthRef[type],
      predeflect: player.success.deflected.predeflect,
      type: type,
    };
    player.stamina.current -= this.staminaCostRef.deflected[type];

    if (pushBack === true) {
      player.success.deflected.state = false;
      player.success.deflected.predeflect = true;

      this.pushBack(player, this.getOppositeDirection(player.direction));
    } else {
      player.success.deflected.predeflect = false;
      if (this.aiDeflectedCheck.includes(player.number) !== true) {
        this.aiDeflectedCheck.push(player.number);
      }
    }

    if (pushBack !== true) {
      player = this.setElasticCounter("deflected", "", true, player);
    }

    this.players[player.number - 1] = player;
  };
  unsetDeflection = (player) => {
    this.players[player.number - 1].success.deflected = {
      state: false,
      count: 0,
      limit: player.success.deflected.limit,
      predeflect: false,
      type: "",
    };

    if (player.ai.state === true) {
      let indx = this.aiDeflectedCheck.indexOf(player.number);
      // this.aiDeflectedCheck.splice(indx,1)
      let newArr = this.aiDeflectedCheck.filter((x) => x !== player.number);
      this.aiDeflectedCheck = newArr;
      console.log("this.aiDeflectedCheck", this.aiDeflectedCheck);
    }
  };
  handleMeleeDamage = (ownerType, owner, targetPlayer) => {
    // console.log('handleMeleeDamage');
    // DAMAGE THE TARGET!!!

    let damage = 0;
    let ownerWeaponName;
    let ownerWeaponType;
    let ownerDirection;
    let doubleHitChance;
    let singleHitChance;

    if (ownerType === "player") {
      ownerDirection = owner.direction;
      ownerWeaponType = owner.currentWeapon.type;
      ownerWeaponName = owner.currentWeapon.name;
      doubleHitChance = owner.crits.doubleHit;
      singleHitChance = owner.crits.singleHit;
    } else {
      let myCell = this.gridInfo.find(
        (x) => x[ownerType].state === true && x[ownerType].id === owner.id
      );
      ownerDirection = this.getDirectionFromCells(myCell.number, owner.trap.target);
      ownerWeaponType = owner.trap.item.subType;
      ownerWeaponType = owner.trap.item.name;
      doubleHitChance = 2;
      singleHitChance = 1;
    }

    if (targetPlayer.currentArmor.name !== "") {
      // console.log('opponent armour found');
      switch (targetPlayer.currentArmor.effect) {
        case "dblhit-5":
          doubleHitChance += 5;
          break;
        case "dblhit-10":
          doubleHitChance += 10;
          break;
        case "dblhit-15":
          doubleHitChance += 15;
          break;
        // case 'dblhit-30' :
        //   doubleHitChance = player.crits.doubleHit+30;
        // break;
        case "snghit-5":
          singleHitChance += 5;
          break;
        case "snghit-10":
          singleHitChance += 10;
          break;
      }
    }

    let doubleHit = this.rnJesus(1, doubleHitChance);
    let singleHit = this.rnJesus(1, singleHitChance);

    // BACK ATTACK
    if (ownerDirection === targetPlayer.direction) {
      damage = 2;
    }

    if (ownerWeaponName === "") {
      singleHit = 1;
      doubleHit = 0;
    }

    if (singleHit === 1) {
      damage = 1;
    }
    if (doubleHit === 1) {
      damage = 2;
    }

    if (ownerType === "player") {
      if (owner.attacking.blunt === true) {
        damage = 0;
      }

      owner.success.attackSuccess = {
        state: true,
        count: 1,
        limit: owner.success.attackSuccess.limit,
      };
    }

    if (!targetPlayer.popups.find((x) => x.msg.split("_")[0] === "hpDown")) {
      targetPlayer.popups.push({
        state: false,
        count: 0,
        limit: 30,
        type: "",
        position: "",
        msg: "hpDown_" + "-" + damage + "",
        img: "",
      });
    }

    targetPlayer.hp -= damage;
    if (targetPlayer.hp === 1) {
      targetPlayer.attacking.strength = 1;

      // ADJUST TARGET MOVE SPEED
      let currentMoveSpeedIndx = targetPlayer.speed.range.indexOf(
        targetPlayer.speed.move
      );
      if (currentMoveSpeedIndx > 0) {
        targetPlayer.speed.move = targetPlayer.speed.range[currentMoveSpeedIndx - 1];
      }
      // player.speed.move = .05;
    }

    if (targetPlayer.hp > 0) {
      this.attackedCancel(targetPlayer);
    }

    // KILL OPPONENT!
    else {
      this.killPlayer(targetPlayer);
      this.placeItems({
        init: false,
        item: this.itemList[this.rnJesus(0, this.itemList.length - 1)].name,
      });

      if (ownerType === "player") {
        owner.points++;
        this.pointChecker(owner);

        if (owner.ai.state === true && owner.ai.mode === "aggressive") {
          console.log(
            "check for evidence of retrieval here and resume retrieve if so",
            owner.ai.retrieving,
            owner.ai.mission
          );

          if (owner.ai.retrieving.checkin) {
            owner.ai.mission = "retrieve";

            if (!owner.popups.find((x) => x.msg === "missionRetrieve")) {
              owner.popups.push({
                state: false,
                count: 0,
                limit: 30,
                type: "",
                position: "",
                msg: "missionRetrieve",
                img: "",
              });
            }

            let targetSafeData = this.scanTargetAreaThreat({
              player: owner.number,
              point: {
                x: owner.ai.retrieving.point.x,
                y: owner.ai.retrieving.point.y,
              },
              range: 3,
            });

            owner.ai.retrieving.safe = targetSafeData.isSafe;
          }
        }
      }
    }

    if (ownerType === "player") {
      this.players[owner.number - 1] = owner;
    }

    this.players[targetPlayer.number - 1] = targetPlayer;
  };
  handleProjectileDamage = (bolt, ownerType, targetType, target) => {
    let boltOwner;
    let damage;
    let doubleHitChance;
    let singleHitChance;

    if (ownerType === "player") {
      if (targetType === "player") {
        boltOwner = this.players[bolt.owner - 1];
        damage = 0;
        doubleHitChance = boltOwner.crits.doubleHit;
        singleHitChance = boltOwner.crits.singleHit;

        if (target.currentArmor.name !== "") {
          // console.log('opponent armour found');
          switch (target.currentArmor.effect) {
            case "dblhit-5":
              doubleHitChance = boltOwner.crits.doubleHit + 5;
              break;
            case "dblhit-10":
              doubleHitChance = boltOwner.crits.doubleHit + 10;
              break;
            case "dblhit-15":
              doubleHitChance = boltOwner.crits.doubleHit + 15;
              break;
            // case 'dblhit-30' :
            //   doubleHitChance = target.crits.doubleHit+30;
            // break;
            case "snghit-5":
              singleHitChance = boltOwner.crits.singleHit + 5;
              break;
            case "snghit-10":
              singleHitChance = boltOwner.crits.singleHit + 10;
              break;
          }
        }

        let doubleHit = this.rnJesus(1, doubleHitChance);
        let singleHit = this.rnJesus(1, singleHitChance);

        // BACK ATTACK
        if (target.direction === bolt.direction) {
          damage = 2;
        }

        if (singleHit === 1) {
          damage = 1;
        }
        if (doubleHit === 1) {
          damage = 2;
        }
        boltOwner.success.attackSuccess = {
          state: true,
          count: 1,
          limit: boltOwner.success.attackSuccess.limit,
        };
        if (!target.popups.find((x) => x.msg.split("_")[0] === "hpDown")) {
          target.popups.push({
            state: false,
            count: 0,
            limit: 30,
            type: "",
            position: "",
            msg: "hpDown_" + "-" + damage + "",
            img: "",
          });
        }
        target.hp -= damage;
        if (target.hp === 1) {
          target.attacking.strength = 1;

          // ADJUST TARGET MOVE SPEED
          let currentMoveSpeedIndx = target.speed.range.indexOf(target.speed.move);
          if (currentMoveSpeedIndx > 0) {
            target.speed.move = target.speed.range[currentMoveSpeedIndx - 1];
          }
          // target.speed.move = .05;
        }

        if (target.hp > 0) {
          this.attackedCancel(target);
        }

        // KILL OPPONENT!
        else {
          this.killPlayer(target);
          this.placeItems({
            init: false,
            item: this.itemList[this.rnJesus(0, this.itemList.length - 1)].name,
          });
          boltOwner.points++;
          this.pointChecker(boltOwner);

          if (boltOwner.ai.state === true && boltOwner.ai.mode === "aggressive") {
            console.log(
              "check for evidence of retrieval here and resume retrieve if so",
              boltOwner.ai.retrieving,
              boltOwner.ai.mission
            );

            if (boltOwner.ai.retrieving.checkin) {
              boltOwner.ai.mission = "retrieve";

              if (!boltOwner.popups.find((x) => x.msg === "missionRetrieve")) {
                boltOwner.popups.push({
                  state: false,
                  count: 0,
                  limit: 30,
                  type: "",
                  position: "",
                  msg: "missionRetrieve",
                  img: "",
                });
              }

              let targetSafeData = this.scanTargetAreaThreat({
                player: boltOwner.number,
                point: {
                  x: boltOwner.ai.retrieving.point.x,
                  y: boltOwner.ai.retrieving.point.y,
                },
                range: 3,
              });

              boltOwner.ai.retrieving.safe = targetSafeData.isSafe;
            }
          }
        }

        if (bolt.kill !== true) {
          bolt.kill = true;
        }

        this.players[target.number - 1] = target;
        this.players[boltOwner.number - 1] = boltOwner;
        // this.projectiles.find(x => x.id === bolt.id) = bolt;
        let x = this.projectiles.find((x) => x.id === bolt.id);
        x = bolt;
      }
    } else {
      if (targetType === "player") {
        damage = 0;
        doubleHitChance = 2;
        singleHitChance = 1;

        if (target.currentArmor.name !== "") {
          // console.log('opponent armour found');
          switch (target.currentArmor.effect) {
            case "dblhit-5":
              doubleHitChance += 5;
              break;
            case "dblhit-10":
              doubleHitChance += 10;
              break;
            case "dblhit-15":
              doubleHitChance += 15;
              break;
            // case 'dblhit-30' :
            //   doubleHitChance = target.crits.doubleHit+30;
            // break;
            case "snghit-5":
              singleHitChance += 5;
              break;
            case "snghit-10":
              singleHitChance += 10;
              break;
          }
        }

        let doubleHit = this.rnJesus(1, doubleHitChance);
        let singleHit = this.rnJesus(1, singleHitChance);

        // BACK ATTACK
        if (target.direction === bolt.direction) {
          damage = 2;
        }

        if (singleHit === 1) {
          damage = 1;
        }
        if (doubleHit === 1) {
          damage = 2;
        }
        if (!target.popups.find((x) => x.msg.split("_")[0] === "hpDown")) {
          target.popups.push({
            state: false,
            count: 0,
            limit: 30,
            type: "",
            position: "",
            msg: "hpDown_" + "-" + damage + "",
            img: "",
          });
        }
        target.hp -= damage;
        if (target.hp === 1) {
          target.attacking.strength = 1;

          // ADJUST TARGET MOVE SPEED
          let currentMoveSpeedIndx = target.speed.range.indexOf(target.speed.move);
          if (currentMoveSpeedIndx > 0) {
            target.speed.move = target.speed.range[currentMoveSpeedIndx - 1];
          }
          // target.speed.move = .05;
        }

        if (target.hp > 0) {
          this.attackedCancel(target);
        }

        // KILL OPPONENT!
        else {
          this.killPlayer(target);
          this.placeItems({
            init: false,
            item: this.itemList[this.rnJesus(0, this.itemList.length - 1)].name,
          });
        }

        if (bolt.kill !== true) {
          bolt.kill = true;
        }

        this.players[target.number - 1] = target;
        // this.projectiles.find(x => x.id === bolt.id) = bolt;
        let x = this.projectiles.find((x) => x.id === bolt.id);
        x = bolt;
      }
    }
  };
  handleMiscPlayerDamage = (player, type) => {
    this.attackedCancel(this.players[player.number - 1]);
    if (type === "obstacleBarrierInvulnurable") {
      if (player.hp - 1 <= 0) {
        this.killPlayer(this.players[player.number - 1]);

        let randomItemIndex = this.rnJesus(0, this.itemList.length - 1);
        this.placeItems({
          init: false,
          item: this.itemList[randomItemIndex].name,
        });

        this.players[player.number - 1].points--;

        this.pointChecker(player);
      } else {
        this.players[player.number - 1].hp -= 1;

        if (player.hp > 0) {
          this.attackedCancel(player);
        }

        if (
          !this.players[player.number - 1].popups.find(
            (x) => x.msg.split("_")[0] === "hpDown"
          )
        ) {
          this.players[player.number - 1].popups.push({
            state: false,
            count: 0,
            limit: 30,
            type: "",
            position: "",
            msg: "hpDown_" + "-" + 1 + "",
            img: "",
          });
        }

        if (this.players[player.number - 1].hp === 1) {
          // ADJUST TARGET MOVE SPEED
          let currentMoveSpeedIndx = this.players[player.number - 1].speed.range.indexOf(
            this.players[player.number - 1].speed.move
          );
          if (currentMoveSpeedIndx > 0) {
            this.players[player.number - 1].speed.move =
              this.players[player.number - 1].speed.range[currentMoveSpeedIndx - 1];
          }
        }
      }
    }

    if (type === "applyHazard") {
      if (player.hp - 1 <= 0) {
        this.killPlayer(this.players[player.number - 1]);

        let randomItemIndex = this.rnJesus(0, this.itemList.length - 1);
        this.placeItems({
          init: false,
          item: this.itemList[randomItemIndex].name,
        });

        this.players[player.number - 1].points--;

        this.pointChecker(player);
      } else {
        this.players[player.number - 1].hp -= 1;

        this.setDeflection(player, "attacked", false);

        if (
          !this.players[player.number - 1].popups.find(
            (x) => x.msg.split("_")[0] === "hpDown"
          )
        ) {
          this.players[player.number - 1].popups.push({
            state: false,
            count: 0,
            limit: 30,
            type: "",
            position: "",
            msg: "hpDown_" + "-" + 1 + "",
            img: "",
          });
        }
        if (
          !this.players[player.number - 1].popups.find((x) => x.msg === "terrainInjured")
        ) {
          this.players[player.number - 1].popups.push({
            state: false,
            count: 0,
            limit: 25,
            type: "",
            position: "",
            msg: "terrainInjured",
            img: "",
          });
        }

        if (this.players[player.number - 1].hp === 1) {
          // ADJUST TARGET MOVE SPEED
          let currentMoveSpeedIndx = this.players[player.number - 1].speed.range.indexOf(
            this.players[player.number - 1].speed.move
          );
          if (currentMoveSpeedIndx > 0) {
            this.players[player.number - 1].speed.move =
              this.players[player.number - 1].speed.range[currentMoveSpeedIndx - 1];
          }
        }
      }
    }

    if (type === "jumpCollision") {
      if (player.hp - 1 <= 0) {
        this.killPlayer(this.players[player.number - 1]);

        let randomItemIndex = this.rnJesus(0, this.itemList.length - 1);
        this.placeItems({
          init: false,
          item: this.itemList[randomItemIndex].name,
        });

        this.players[player.number - 1].points--;

        this.pointChecker(player);
      } else {
        this.players[player.number - 1].hp -= 1;

        // this.setDeflection(player,'attacked',false);

        if (
          !this.players[player.number - 1].popups.find(
            (x) => x.msg.split("_")[0] === "hpDown"
          )
        ) {
          this.players[player.number - 1].popups.push({
            state: false,
            count: 0,
            limit: 30,
            type: "",
            position: "",
            msg: "hpDown_" + "-" + 1 + "",
            img: "",
          });
        }

        if (this.players[player.number - 1].hp === 1) {
          // ADJUST TARGET MOVE SPEED
          let currentMoveSpeedIndx = this.players[player.number - 1].speed.range.indexOf(
            this.players[player.number - 1].speed.move
          );
          if (currentMoveSpeedIndx > 0) {
            this.players[player.number - 1].speed.move =
              this.players[player.number - 1].speed.range[currentMoveSpeedIndx - 1];
          }
        }
      }
    }

    if (type.split("_")[1]) {
      let damage = 1;

      if (type.split("_")[0] === "halfPushBackImpactee") {
        switch (type.split("_")[1]) {
          case "obstacle":
            break;
          case "player":
            break;
          case "barrier":
            break;
          case "higherElevation":
            break;
          default:
        }
      }

      if (type.split("_")[0] === "halfPushBackImpactor") {
        switch (type.split("_")[1]) {
          case "obstacle":
            break;
          case "player":
            break;
          case "barrier":
            break;
          case "higherElevation":
            break;
          default:
        }
      }

      if (player.hp - damage <= 0) {
        this.killPlayer(this.players[player.number - 1]);

        let randomItemIndex = this.rnJesus(0, this.itemList.length - 1);
        this.placeItems({
          init: false,
          item: this.itemList[randomItemIndex].name,
        });

        this.players[player.number - 1].points--;

        this.pointChecker(player);
      } else {
        this.players[player.number - 1].hp -= damage;

        if (player.hp > 0) {
          this.attackedCancel(player);
        }

        if (
          !this.players[player.number - 1].popups.find(
            (x) => x.msg.split("_")[0] === "hpDown"
          )
        ) {
          this.players[player.number - 1].popups.push({
            state: false,
            count: 0,
            limit: 30,
            type: "",
            position: "",
            msg: "hpDown_" + "-" + damage + "",
            img: "",
          });
        }

        if (this.players[player.number - 1].hp === 1) {
          // ADJUST TARGET MOVE SPEED
          let currentMoveSpeedIndx = this.players[player.number - 1].speed.range.indexOf(
            this.players[player.number - 1].speed.move
          );
          if (currentMoveSpeedIndx > 0) {
            this.players[player.number - 1].speed.move =
              this.players[player.number - 1].speed.range[currentMoveSpeedIndx - 1];
          }
        }
      }
    }
  };
  checkCombatAdvantage = (player1, player2) => {
    let advantage = 0;
    let players = [0, 0];
    if (player1.currentWeapon.name !== "") {
      players[0] += 1;
    }
    if (player2.currentWeapon.name !== "") {
      players[1] += 1;
    }
    if (players[0] === players[1]) {
      advantage = 0;
    } else {
      let max = Math.max(players[0], players[1]);
      advantage = players.indexOf(max) + 1;
    }

    return advantage;
  };
  attackedCancel = (player) => {
    // console.log('player', player.number,' attacked. Cancel action!',player.action);

    if (
      player.elasticCounter.state === true &&
      player.elasticCounter.type === player.action
    ) {
      player.elasticCounter.state = false;
    }

    switch (player.action) {
      case "attacking":
        if (player.success.deflected.state !== true) {
          player.action = "idle";
        }

        player.attacking = {
          state: false,
          count: 0,
          limit: player.attacking.limit,
          strength: 0,
          direction: "",
          directionType: "", //thrust or slash
          animRef: player.attacking.animRef,
          peak: false,
          peakCount: 0,
          charge: 0,
          chargePeak: false,
          blunt: false,
          clashing: {
            state: false,
            count: 0,
            limit: player.attacking.clashing.limit,
          },
        };
        player.idleAnim = {
          state: false,
          count: 0,
          limit: 4,
        };
        this.players[player.number - 1].statusDisplay = {
          state: true,
          status: "attack break!",
          count: 1,
          limit: this.players[player.number - 1].statusDisplay.limit,
        };

        if (!player.popups.find((x) => x.msg === "attackCancelled")) {
          player.popups.push({
            state: false,
            count: 0,
            limit: 30,
            type: "",
            position: "",
            msg: "attackCancelled",
            img: "",
          });
        }
        if (this.camera.customView.state !== true && player.ai.state !== true) {
          this.setAutoCamera("attackFocusBreak", player);
        }

        break;
      case "defending":
        if (player.success.deflected.state !== true) {
          player.action = "idle";
        }
        player.defending = {
          state: false,
          count: 0,
          limit: player.defending.limit,
          animRef: player.defending.animRef,
          peak: false,
          peakCount: 0,
          decay: {
            state: false,
            count: 0,
            limit: player.defending.decay.limit,
          },
          direction: "",
          directionType: "", //thrust or slash
        };
        player.idleAnim = {
          state: false,
          count: 0,
          limit: 4,
        };
        this.players[player.number - 1].statusDisplay = {
          state: true,
          status: "guard break!",
          count: 1,
          limit: this.players[player.number - 1].statusDisplay.limit,
        };

        if (!player.popups.find((x) => x.msg === "attackCancelled")) {
          player.popups.push({
            state: false,
            count: 0,
            limit: 30,
            type: "",
            position: "",
            msg: "attackCancelled",
            img: "",
          });
        }
        if (this.camera.customView.state !== true && player.ai.state !== true) {
          this.setAutoCamera("defendFocusBreak", player);
        }

        break;
      case "strafe moving":
        if (player.success.deflected.state !== true) {
          player.action = "idle";
        }
        player.idleAnim = {
          state: false,
          count: 0,
          limit: 4,
        };
        player.strafing = {
          state: false,
          direction: "",
        };
        this.players[player.number - 1].statusDisplay = {
          state: true,
          status: "strafe break!",
          count: 1,
          limit: this.players[player.number - 1].statusDisplay.limit,
        };

        if (!player.popups.find((x) => x.msg === "attackCancelled")) {
          player.popups.push({
            state: false,
            count: 0,
            limit: 30,
            type: "",
            position: "",
            msg: "attackCancelled",
            img: "",
          });
        }

        break;
      case "dodging":
        if (player.success.deflected.state !== true) {
          player.action = "idle";
        }
        player.idleAnim = {
          state: false,
          count: 0,
          limit: 4,
        };
        player.dodging = {
          countState: false,
          state: false,
          count: 0,
          limit: player.dodging.limit,
          peak: {
            start: player.dodging.peak.start,
            end: player.dodging.peak.end,
          },
          direction: "",
        };
        this.players[player.number - 1].statusDisplay = {
          state: true,
          status: "dodge break!",
          count: 1,
          limit: this.players[player.number - 1].statusDisplay.limit,
        };

        if (!player.popups.find((x) => x.msg === "attackCancelled")) {
          player.popups.push({
            state: false,
            count: 0,
            limit: 30,
            type: "",
            position: "",
            msg: "attackCancelled",
            img: "",
          });
        }

        break;
      case "flanking":
        if (player.success.deflected.state !== true) {
          player.action = "idle";
        }
        player.idleAnim = {
          state: false,
          count: 0,
          limit: 4,
        };
        player.flanking = {
          checking: false,
          preFlankDirection: "",
          direction: "",
          state: false,
          step: 0,
          target1: { x: 0, y: 0 },
          target2: { x: 0, y: 0 },
        };
        this.players[player.number - 1].statusDisplay = {
          state: true,
          status: "flanking break!",
          count: 1,
          limit: this.players[player.number - 1].statusDisplay.limit,
        };

        if (!player.popups.find((x) => x.msg === "attackCancelled")) {
          player.popups.push({
            state: false,
            count: 0,
            limit: 30,
            type: "",
            position: "",
            msg: "attackCancelled",
            img: "",
          });
        }

        break;
      case "jumping":
        if (player.success.deflected.state !== true) {
          player.action = "idle";
        }
        player.idleAnim = {
          state: false,
          count: 0,
          limit: 4,
        };
        player.jumping = {
          checking: false,
          state: false,
        };
        this.players[player.number - 1].statusDisplay = {
          state: true,
          status: "jumping break!",
          count: 1,
          limit: this.players[player.number - 1].statusDisplay.limit,
        };

        if (!player.popups.find((x) => x.msg === "attackCancelled")) {
          player.popups.push({
            state: false,
            count: 0,
            limit: 30,
            type: "",
            position: "",
            msg: "attackCancelled",
            img: "",
          });
        }

        break;
      default:
    }

    if (player.prePush.state === true) {
      player.prePush = {
        state: false,
        count: 0,
        limit: player.prePush.limit,
        targetCell: undefined,
        direction: "",
        pusher: undefined,
      };
    }
    if (player.prePull.state === true) {
      player.prePull = {
        state: false,
        count: 0,
        limit: player.prePull.limit,
        targetCell: undefined,
        direction: "",
        puller: undefined,
      };
    }

    if (player.ai.state === true) {
      this.players[player.number - 1].ai.currentInstruction = 0;
      this.players[player.number - 1].ai.instructions = [];
    }
  };
  pushBack = (player, hitByPlayerDirection) => {
    // console.log('pushing back?');

    this.attackedCancel(player);

    let canPushBack = false;
    let halfPushBack = false;
    let halfPushBackType = "";
    let myCellBlock = false;
    let myCell = this.gridInfo.find(
      (x) =>
        x.number.x === player.currentPosition.cell.number.x &&
        x.number.y === player.currentPosition.cell.number.y
    );

    player.pushBack.prePushMoveSpeed = player.speed.move;
    player.speed.move = 0.125;

    if (player.stamina.current - this.staminaCostRef.pushBack < 0) {
      player.stamina.current = 0;
    } else {
      player.stamina.current = player.stamina.current - this.staminaCostRef.pushBack;
    }

    let pushBackDirection = hitByPlayerDirection;
    player.strafing = {
      state: true,
      direction: pushBackDirection,
    };
    let target = this.getTarget(player);
    let targetCell = this.gridInfo.find(
      (x) => x.number.x === target.cell1.number.x && x.number.y === target.cell1.number.y
    );

    if (myCell.barrier.state === true && myCell.barrier.position === pushBackDirection) {
      canPushBack = false;
      halfPushBack = true;
      myCellBlock = true;
    }

    if (target.cell1.free === false || myCellBlock === true) {
      // console.log('Pushback target is NOT free. Half push back?',myCellBlock);

      if (target.cell1.occupant.type === "obstacle") {
        canPushBack = false;
        halfPushBack = true;
        halfPushBackType = "obstacle";
      }

      if (target.cell1.occupant.type === "player") {
        canPushBack = false;
        halfPushBack = true;
        halfPushBackType = "player";
      }

      if (target.cell1.occupant.type === "higherElevation") {
        canPushBack = false;
        halfPushBack = true;
        halfPushBackType = "higherElevation";
      }

      if (myCellBlock === true || target.cell1.occupant.type === "barrier") {
        canPushBack = false;
        halfPushBack = true;
        halfPushBackType = "barrier";
      }

      player.pushBack.state = false;
      player.strafing = {
        state: false,
        direction: "",
      };
    } else {
      canPushBack = true;
    }

    if (player.target.cell1.free === true && canPushBack === true) {
      // console.log('proceed with pushback',player.number,'to',target.cell1.number);

      if (player.target.cell1.void === true) {
        // console.log('pushback target is VOID!!',target.cell1.center.x,target.cell1.center.y);
      }

      player.pushBack.state = true;
      player.action = "strafe moving";
      player.moving = {
        state: true,
        step: 0,
        course: "",
        origin: {
          number: player.currentPosition.cell.number,
          center: player.currentPosition.cell.center,
        },
        destination: target.cell1.center,
      };
      let nextPosition = this.lineCrementer(player);
      player.nextPosition = nextPosition;

      if (!player.popups.find((x) => x.msg === "pushedBack")) {
        player.popups.push({
          state: false,
          count: 0,
          limit: 30,
          type: "",
          position: "",
          msg: "pushedBack",
          img: "",
        });
      }
    }

    if (halfPushBack === true) {
      let dir = pushBackDirection;

      this.unsetDeflection(player);

      player.success.deflected.predeflect = false;
      this.startHalfPushBack("player", halfPushBackType, dir, player);
    }

    this.getTarget(player);

    this.players[player.number - 1] = player;
    return canPushBack;
  };
  startHalfPushBack = (object, blockType, direction, data) => {
    // console.log('startHalfPushback',object,blockType,direction);

    if (object === "player") {
      if (data.halfPushBack !== true) {
        let point = {
          x: data.currentPosition.cell.center.x,
          y: data.currentPosition.cell.center.y,
        };

        data.halfPushBack = {
          state: true,
          direction: direction,
          type: blockType,
          countUp: {
            state: true,
            count: 0,
            limit: 6,
          },
          countDown: {
            state: false,
            count: 0,
            limit: 6,
          },
          coords: {
            // x: point.x - this.playerDrawWidth / 2,
            // y: point.y - this.playerDrawHeight / 2,
            x: data.nextPosition.x - this.floorImageHeight / 2,
            y: data.nextPosition.y - this.floorImageHeight,
          },
        };

        this.players[data.number - 1] = data;
      } else {
        console.log("player already being 1/2 pushed back!!");
      }
    }

    if (object === "obstacle") {
      // if (this.halfPushBackObstacles.find((x) => x.state !== true && x.myCellNo !== data.number)) {
      if (
        !this.halfPushBackObstacles.find(
          (x) => x.state === true && x.myCellNo === data.number
        )
      ) {
        this.halfPushBackObstacles.push({
          state: true,
          myCellNo: data.number,
          blockCellNo: this.getCellFromDirection(1, data.number, direction),
          blockType: blockType,
          direction: direction,
          obstacle: data.obstacle,
          countUp: {
            state: true,
            count: 0,
            limit: 10,
          },
          countDown: {
            state: false,
            count: 0,
            limit: 10,
          },
          coords: {
            x: undefined,
            y: undefined,
          },
        });
      } else {
        console.log("obsatcle already being 1/2 pushed back!!");
      }
      // console.log("this.halfPushBackObstacles", this.halfPushBackObstacles);
    }
  };
  handleHalfPushBackResult = (type, data) => {
    // console.log("handleHalfPushBackResult", type, data);

    let direction = "";
    let impactor = type;
    let impactee = "";
    let impacteePlayerRef;
    let shouldDamageImpactor = false;
    let shouldDamageImpactee = false;
    let shouldDeflectImpactor = false;
    let shouldDeflectImpactee = false;
    let impactorDamage = 0;
    let impacteeDamage = 0;
    let shouldMoveImpactee = false;

    let moveObstacle = false;
    let movePlayer = false;

    let targetCellNumber = undefined;
    let targetCellRef = undefined;
    let myCellRef = undefined;

    let damageObstacle = (args) => {
      let damage = 1;
      if (this.rnJesus(1, 2) === 1) {
        damage = this.rnJesus(1, 2);
      }

      // IMPACTOR DAMAGE OR DESTROY, DON'T MOVE
      if (args === "impactor") {
        if (myCellRef.obstacle.destructible.state === true) {
          if (myCellRef.obstacle.hp - damage > 0) {
            let hp = myCellRef.obstacle.hp - damage;

            myCellRef.obstacle = {
              state: myCellRef.obstacle.state,
              name: myCellRef.obstacle.name,
              type: myCellRef.obstacle.type,
              hp: hp,
              destructible: myCellRef.obstacle.destructible,
              locked: myCellRef.obstacle.locked,
              weight: myCellRef.obstacle.weight,
              height: myCellRef.obstacle.height,
              items: myCellRef.obstacle.items,
              effects: myCellRef.obstacle.effects,
              moving: myCellRef.obstacle.moving,
            };

            this.obstacleBarrierToDestroy.push({
              type: "obstacle",
              action: "damage",
              count: 0,
              limit: 30,
              complete: false,
              cell: myCellRef,
            });
          }

          // DESTROY OBSTACLE W/ OR W/O RUBBLE
          else if (myCellRef.obstacle.hp - damage <= 0) {
            let itemsToDrop = [];

            if (myCellRef.obstacle.destructible.leaveRubble === true) {
              // console.log('leave rubble on ',targetCell.number,'removing obstacle');

              if (myCellRef.obstacle.items[0]) {
                itemsToDrop = myCellRef.obstacle.items;
              }
              myCellRef.rubble = true;
              // targetCell.terrain.type = 'hazard';

              myCellRef.obstacle = {
                state: false,
                name: myCellRef.obstacle.name,
                type: myCellRef.obstacle.type,
                hp: 0,
                destructible: myCellRef.obstacle.destructible,
                locked: myCellRef.obstacle.locked,
                weight: myCellRef.obstacle.weight,
                height: myCellRef.obstacle.height,
                items: myCellRef.obstacle.items,
                effects: myCellRef.obstacle.effects,
                moving: myCellRef.obstacle.moving,
              };
            } else {
              // console.log('no rubble. Just remove obstacle');
              if (myCellRef.obstacle.items[0]) {
                itemsToDrop = myCellRef.obstacle.items;
              }

              myCellRef.obstacle = {
                state: false,
                name: myCellRef.obstacle.name,
                type: myCellRef.obstacle.type,
                hp: 0,
                destructible: myCellRef.obstacle.destructible,
                locked: myCellRef.obstacle.locked,
                weight: myCellRef.obstacle.weight,
                height: myCellRef.obstacle.height,
                items: myCellRef.obstacle.items,
                effects: myCellRef.obstacle.effects,
                moving: myCellRef.obstacle.moving,
              };
            }

            // DROP OBSTACLE ITEMS?
            if (itemsToDrop[0]) {
              // console.log('dropping obstacle items melee',itemsToDrop);
              this.obstacleItemDrop(myCellRef, undefined);
            }

            this.obstacleBarrierToDestroy.push({
              type: "obstacle",
              action: "destroy",
              count: 0,
              limit: 30,
              complete: false,
              cell: myCellRef,
            });

            if (!this.cellPopups.find((x) => x.msg === "destroyedItem")) {
              this.cellPopups.push({
                state: false,
                count: 0,
                limit: 35,
                type: "",
                position: "",
                msg: "destroyedItem",
                img: "",
                cell: myCellRef,
              });
            }
          }
        } else {
          // moveObstacle = true;
        }
      }

      // IMPACTEE, DAMAGE, DESTROY AND MOVE?
      if (args === "impactee") {
        if (targetCellRef.obstacle.destructible.state === true) {
          if (targetCellRef.obstacle.hp - damage > 0) {
            let hp = targetCellRef.obstacle.hp - damage;

            targetCellRef.obstacle = {
              state: targetCellRef.obstacle.state,
              name: targetCellRef.obstacle.name,
              type: targetCellRef.obstacle.type,
              hp: hp,
              destructible: targetCellRef.obstacle.destructible,
              locked: targetCellRef.obstacle.locked,
              weight: targetCellRef.obstacle.weight,
              height: targetCellRef.obstacle.height,
              items: targetCellRef.obstacle.items,
              effects: targetCellRef.obstacle.effects,
              moving: targetCellRef.obstacle.moving,
            };

            this.obstacleBarrierToDestroy.push({
              type: "obstacle",
              action: "damage",
              count: 0,
              limit: 30,
              complete: false,
              cell: targetCellRef,
            });

            if (this.rnJesus(1, 4) === 1) {
              moveObstacle = true;
            }
          }

          // DESTROY OBSTACLE W/ OR W/O RUBBLE
          else if (targetCellRef.obstacle.hp - damage <= 0) {
            let itemsToDrop = [];

            if (targetCellRef.obstacle.destructible.leaveRubble === true) {
              // console.log('leave rubble on ',targetCell.number,'removing obstacle');

              if (targetCellRef.obstacle.items[0]) {
                itemsToDrop = targetCellRef.obstacle.items;
              }
              targetCellRef.rubble = true;
              // targetCell.terrain.type = 'hazard';

              targetCellRef.obstacle = {
                state: false,
                name: targetCellRef.obstacle.name,
                type: targetCellRef.obstacle.type,
                hp: 0,
                destructible: targetCellRef.obstacle.destructible,
                locked: targetCellRef.obstacle.locked,
                weight: targetCellRef.obstacle.weight,
                height: targetCellRef.obstacle.height,
                items: targetCellRef.obstacle.items,
                effects: targetCellRef.obstacle.effects,
                moving: targetCellRef.obstacle.moving,
              };
            } else {
              // console.log('no rubble. Just remove obstacle');
              if (targetCellRef.obstacle.items[0]) {
                itemsToDrop = targetCellRef.obstacle.items;
              }

              targetCellRef.obstacle = {
                state: false,
                name: targetCellRef.obstacle.name,
                type: targetCellRef.obstacle.type,
                hp: 0,
                destructible: targetCellRef.obstacle.destructible,
                locked: targetCellRef.obstacle.locked,
                weight: targetCellRef.obstacle.weight,
                height: targetCellRef.obstacle.height,
                items: targetCellRef.obstacle.items,
                effects: targetCellRef.obstacle.effects,
                moving: targetCellRef.obstacle.moving,
              };
            }

            // DROP OBSTACLE ITEMS?
            if (itemsToDrop[0]) {
              this.obstacleItemDrop(targetCellRef, undefined);
            }

            this.obstacleBarrierToDestroy.push({
              type: "obstacle",
              action: "destroy",
              count: 0,
              limit: 30,
              complete: false,
              cell: targetCellRef,
            });

            if (!this.cellPopups.find((x) => x.msg === "destroyedItem")) {
              this.cellPopups.push({
                state: false,
                count: 0,
                limit: 35,
                type: "",
                position: "",
                msg: "destroyedItem",
                img: "",
                cell: targetCellRef,
              });
            }
          }
        } else {
          moveObstacle = true;
        }
      }

      if (moveObstacle === true) {
        if (args === "impactee") {
          shouldMoveImpactee = true;
        }
      }
    };

    let damageBarrier = (args, myCell) => {
      let damage = 1;
      if (this.rnJesus(1, 2) === 1) {
        damage = this.rnJesus(1, 2);
      }

      if (myCell === true) {
        if (myCellRef.barrier.destructible.state === true) {
          if (myCellRef.barrier.hp - damage > 0) {
            let hp = myCellRef.barrier.hp - damage;

            myCellRef.barrier = {
              state: myCellRef.barrier.state,
              name: myCellRef.barrier.name,
              type: myCellRef.barrier.type,
              hp: hp,
              destructible: myCellRef.barrier.destructible,
              locked: myCellRef.barrier.locked,
              position: myCellRef.barrier.position,
              height: myCellRef.barrier.height,
            };

            this.obstacleBarrierToDestroy.push({
              type: "barrier",
              action: "damage",
              count: 0,
              limit: 30,
              complete: false,
              cell: myCellRef,
            });
          }

          // DESTROY FWD BARRIER W/ OR W/O RUBBLE
          else if (myCellRef.barrier.hp - damage <= 0) {
            if (
              myCellRef.barrier.destructible.leaveRubble === true &&
              myCellRef.obstacle.state !== true &&
              myCellRef.item.name === ""
            ) {
              myCellRef.rubble = true;

              myCellRef.barrier = {
                state: false,
                name: myCellRef.barrier.name,
                type: myCellRef.barrier.type,
                hp: 0,
                destructible: myCellRef.barrier.destructible,
                locked: myCellRef.barrier.locked,
                position: myCellRef.barrier.position,
                height: myCellRef.barrier.height,
              };

              if (
                !this.cellPopups.find(
                  (x) =>
                    x.msg === "destroyedItem" &&
                    x.cell.number.x === myCellRef.number.x &&
                    x.cell.number.y === myCellRef.number.y
                )
              ) {
                this.cellPopups.push({
                  state: false,
                  count: 0,
                  limit: 35,
                  type: "",
                  position: "",
                  msg: "destroyedItem",
                  img: "",
                  cell: myCellRef,
                });
              }
            } else {
              // console.log('no rubble. Just remove barrier');

              myCellRef.barrier = {
                state: false,
                name: myCellRef.barrier.name,
                type: myCellRef.barrier.type,
                hp: 0,
                destructible: myCellRef.barrier.destructible,
                locked: myCellRef.barrier.locked,
                position: myCellRef.barrier.position,
                height: myCellRef.barrier.height,
              };

              if (
                !this.cellPopups.find(
                  (x) =>
                    x.msg === "destroyedItem" &&
                    x.cell.number.x === myCellRef.number.x &&
                    x.cell.number.y === myCellRef.number.y
                )
              ) {
                this.cellPopups.push({
                  state: false,
                  count: 0,
                  limit: 35,
                  type: "",
                  position: "",
                  msg: "destroyedItem",
                  img: "",
                  cell: myCellRef,
                });
              }
            }

            this.obstacleBarrierToDestroy.push({
              type: "barrier",
              action: "destroy",
              count: 0,
              limit: 30,
              complete: false,
              cell: myCellRef,
            });
          }
        }
      } else {
        if (targetCellRef.barrier.position === this.getOppositeDirection(direction)) {
          if (targetCellRef.barrier.destructible.state === true) {
            if (targetCellRef.barrier.hp - damage > 0) {
              let hp = targetCellRef.barrier.hp - damage;

              targetCellRef.barrier = {
                state: targetCellRef.barrier.state,
                name: targetCellRef.barrier.name,
                type: targetCellRef.barrier.type,
                hp: hp,
                destructible: targetCellRef.barrier.destructible,
                locked: targetCellRef.barrier.locked,
                position: targetCellRef.barrier.position,
                height: targetCellRef.barrier.height,
              };

              this.obstacleBarrierToDestroy.push({
                type: "barrier",
                action: "damage",
                count: 0,
                limit: 30,
                complete: false,
                cell: targetCellRef,
              });
            }

            // DESTROY FWD BARRIER W/ OR W/O RUBBLE
            else if (targetCellRef.barrier.hp - damage <= 0) {
              if (
                targetCellRef.barrier.destructible.leaveRubble === true &&
                targetCellRef.obstacle.state !== true &&
                targetCellRef.item.name === ""
              ) {
                targetCellRef.rubble = true;

                targetCellRef.barrier = {
                  state: false,
                  name: targetCellRef.barrier.name,
                  type: targetCellRef.barrier.type,
                  hp: 0,
                  destructible: targetCellRef.barrier.destructible,
                  locked: targetCellRef.barrier.locked,
                  position: targetCellRef.barrier.position,
                  height: targetCellRef.barrier.height,
                };

                if (
                  !this.cellPopups.find(
                    (x) =>
                      x.msg === "destroyedItem" &&
                      x.cell.number.x === targetCellRef.number.x &&
                      x.cell.number.y === targetCellRef.number.y
                  )
                ) {
                  this.cellPopups.push({
                    state: false,
                    count: 0,
                    limit: 35,
                    type: "",
                    position: "",
                    msg: "destroyedItem",
                    img: "",
                    cell: targetCellRef,
                  });
                }
              } else {
                // console.log('no rubble. Just remove barrier');

                targetCellRef.barrier = {
                  state: false,
                  name: targetCellRef.barrier.name,
                  type: targetCellRef.barrier.type,
                  hp: 0,
                  destructible: targetCellRef.barrier.destructible,
                  locked: targetCellRef.barrier.locked,
                  position: targetCellRef.barrier.position,
                  height: targetCellRef.barrier.height,
                };

                if (
                  !this.cellPopups.find(
                    (x) =>
                      x.msg === "destroyedItem" &&
                      x.cell.number.x === targetCellRef.number.x &&
                      x.cell.number.y === targetCellRef.number.y
                  )
                ) {
                  this.cellPopups.push({
                    state: false,
                    count: 0,
                    limit: 35,
                    type: "",
                    position: "",
                    msg: "destroyedItem",
                    img: "",
                    cell: targetCellRef,
                  });
                }
              }

              this.obstacleBarrierToDestroy.push({
                type: "barrier",
                action: "destroy",
                count: 0,
                limit: 30,
                complete: false,
                cell: targetCellRef,
              });
            }
          }
        }
      }
    };

    // PLAYER HALF PUSHED BACK
    if (type === "player") {
      direction = data.halfPushBack.direction;
      targetCellNumber = this.getCellFromDirection(
        1,
        data.currentPosition.cell.number,
        data.halfPushBack.direction
      );
      targetCellRef = this.gridInfo.find(
        (x) => x.number.x === targetCellNumber.x && x.number.y === targetCellNumber.y
      );
      myCellRef = this.gridInfo.find(
        (x) =>
          x.number.x === data.currentPosition.cell.number.x &&
          x.number.y === data.currentPosition.cell.number.y
      );
      impactee = data.halfPushBack.type;
      shouldDamageImpactor = this.rnJesus(1, data.crits.guardBreak) === 1;
      shouldDeflectImpactor = this.rnJesus(1, data.crits.guardBreak) === 1;

      switch (impactee) {
        case "obstacle":
          // IMPACTOR DAMAGE, DEFLECT?
          if (shouldDamageImpactor === true) {
            this.handleMiscPlayerDamage(data, "halfPushBackImpactor_" + impactee + "");
          }

          if (shouldDeflectImpactor === true) {
            this.setDeflection(data, "attacked", false);
          }

          // IMPACTEE DAMAGE?
          shouldDamageImpactee =
            this.rnJesus(
              1,
              targetCellRef.obstacle.height +
                targetCellRef.obstacle.weight +
                targetCellRef.obstacle.hp
            ) === 1;
          if (shouldDamageImpactee === true) {
            damageObstacle("impactee");
          }

          if (this.halfPushBackChainingMoveAll === true) {
            moveObstacle = true;
          }

          break;
        case "player":
          // IMPACTOR DAMAGE, DEFLECT?
          if (shouldDamageImpactor === true) {
            this.handleMiscPlayerDamage(data, "halfPushBackImpactor_" + impactee + "");
          }

          if (shouldDeflectImpactor === true) {
            this.setDeflection(data, "attacked", false);
          }

          // IMPACTEE DAMAGE, DEFLECT/ PUSHBACK + DEFLECT?
          impacteePlayerRef = this.players.find(
            (x) =>
              x.currentPosition.cell.number.x === targetCellRef.number.x &&
              x.currentPosition.cell.number.y === targetCellRef.number.y
          );
          shouldDamageImpactee =
            this.rnJesus(1, impacteePlayerRef.crits.guardBreak) === 1;

          if (shouldDamageImpactee === true) {
            this.handleMiscPlayerDamage(
              impacteePlayerRef,
              "halfPushBackImpactee_" + impactor + ""
            );
          }

          shouldDeflectImpactee =
            this.rnJesus(1, impacteePlayerRef.crits.guardBreak) === 1;

          if (this.halfPushBackChainingMoveAll === true) {
            if (impacteePlayerRef.direction === direction) {
              movePlayer = true;
            } else {
              this.setDeflection(impacteePlayerRef, "attacked", true);
            }
          } else {
            if (shouldDeflectImpactee === true) {
              if (this.rnJesus(1, impacteePlayerRef.crits.pushBack) === 1) {
                this.setDeflection(impacteePlayerRef, "attacked", false);
              } else {
                if (impacteePlayerRef.direction === direction) {
                  movePlayer = true;
                } else {
                  this.setDeflection(impacteePlayerRef, "attacked", true);
                }
              }
            }
          }

          // if (impacteePlayerRef.direction === direction) {
          //   movePlayer = true;
          // }
          //
          // else {
          //   this.setDeflection(impacteePlayerRef,'attacked',true);
          // }

          break;
        case "barrier":
          // IMPACTOR DAMAGE, DEFLECT?
          if (shouldDamageImpactor === true) {
            this.handleMiscPlayerDamage(data, "halfPushBackImpactor_" + impactee + "");
          }

          if (shouldDeflectImpactor === true) {
            this.setDeflection(data, "attacked", false);
          }

          // IMPACTEE DAMAGE?
          let myCell = false;
          if (
            myCellRef.barrier.state === true &&
            myCellRef.barrier.position === data.halfPushBack.direction
          ) {
            myCell = true;
            shouldDamageImpactee =
              this.rnJesus(1, myCellRef.barrier.height + myCellRef.barrier.hp) === 1;
          } else {
            shouldDamageImpactee =
              this.rnJesus(1, targetCellRef.barrier.height + targetCellRef.barrier.hp) ===
              1;
          }

          if (shouldDamageImpactee === true) {
            damageBarrier("impactee", myCell);
          }

          break;
        case "higherElevation":
          // DAMAGE, DEFLECT IMPACTOR?
          if (shouldDamageImpactor === true) {
            this.handleMiscPlayerDamage(data, "halfPushBackImpactor_" + impactee + "");
          }

          if (shouldDeflectImpactor === true) {
            this.setDeflection(data, "attacked", false);
          }

          break;
        default:
      }
    }

    // OBSTACLE HALF PUSHED BACK
    if (type === "obstacle") {
      direction = data.direction;
      targetCellRef = this.gridInfo.find(
        (x) => x.number.x === data.blockCellNo.x && x.number.y === data.blockCellNo.y
      );
      myCellRef = this.gridInfo.find(
        (x) => x.number.x === data.myCellNo.x && x.number.y === data.myCellNo.y
      );
      impactee = data.blockType;
      shouldDamageImpactor =
        this.rnJesus(
          1,
          data.obstacle.height + data.obstacle.weight + data.obstacle.hp
        ) === 1;

      switch (impactee) {
        case "obstacle":
          // IMPACTOR
          if (shouldDamageImpactor === true) {
            damageObstacle("impactor");
          }

          // IMPACTEE
          shouldDamageImpactee =
            this.rnJesus(
              1,
              targetCellRef.obstacle.height + targetCellRef.obstacle.weight
            ) === 1;
          if (shouldDamageImpactee === true) {
            damageObstacle("impactee");
          }

          if (this.halfPushBackChainingMoveAll === true) {
            moveObstacle = true;
          }

          break;
        case "player":
          // IMPACTOR
          if (shouldDamageImpactor === true) {
            damageObstacle("impactor");
          }

          // IMPACTEE
          impacteePlayerRef = this.players.find(
            (x) =>
              x.currentPosition.cell.number.x === targetCellRef.number.x &&
              x.currentPosition.cell.number.y === targetCellRef.number.y
          );
          shouldDamageImpactee =
            this.rnJesus(1, impacteePlayerRef.crits.guardBreak) === 1;

          if (shouldDamageImpactee === true) {
            this.handleMiscPlayerDamage(
              impacteePlayerRef,
              "halfPushBackImpactee_" + impactor + ""
            );
          }

          shouldDeflectImpactee =
            this.rnJesus(1, impacteePlayerRef.crits.guardBreak) === 1;

          if (this.halfPushBackChainingMoveAll === true) {
            if (impacteePlayerRef.direction === direction) {
              movePlayer = true;
            } else {
              this.setDeflection(impacteePlayerRef, "attacked", true);
            }
          } else {
            if (shouldDeflectImpactee === true) {
              if (this.rnJesus(1, impacteePlayerRef.crits.pushBack) === 1) {
                this.setDeflection(impacteePlayerRef, "attacked", false);
              } else {
                if (impacteePlayerRef.direction === direction) {
                  movePlayer = true;
                } else {
                  this.setDeflection(impacteePlayerRef, "attacked", true);
                }
              }
            }
          }

          break;
        case "barrier":
          // IMPACTOR
          if (shouldDamageImpactor === true) {
            damageObstacle("impactor");
          }

          // IMPACTEE
          let myCell = false;
          if (
            myCellRef.barrier.state === true &&
            myCellRef.barrier.position === data.direction
          ) {
            myCell = true;
            shouldDamageImpactee =
              this.rnJesus(1, myCellRef.barrier.height + myCellRef.barrier.hp) === 1;
          } else {
            shouldDamageImpactee =
              this.rnJesus(1, targetCellRef.barrier.height + targetCellRef.barrier.hp) ===
              1;
          }

          if (shouldDamageImpactee === true) {
            damageBarrier("impactee", myCell);
          }

          break;
        case "higherElevation":
          if (shouldDamageImpactor === true) {
            damageObstacle("impactor");
          }

          break;
        default:
      }
    }

    // moveObstacle = true;
    // impactee = "obstacle";

    if (moveObstacle === true && impactee === "obstacle") {
      let destCell = this.getCellFromDirection(1, targetCellRef.number, direction);
      let destCellRef = this.gridInfo.find(
        (x) => x.number.x === destCell.x && x.number.y === destCell.y
      );
      let destCellOccupant = "";
      let preMoveSpeed = this.rnJesus(0, 5);
      let moveSpeed = 0;
      if (preMoveSpeed <= 1) {
        moveSpeed = 0.05;
      }
      if (preMoveSpeed === 2) {
        moveSpeed = 0.1;
      }
      if (preMoveSpeed > 2 && preMoveSpeed < 4) {
        moveSpeed = 0.125;
      }
      if (preMoveSpeed >= 4) {
        moveSpeed = 0.2;
      }
      if (this.terrainMoveSpeedRef[targetCellRef.terrain.type]) {
        moveSpeed = this.terrainMoveSpeedRef[targetCellRef.terrain.type];
      }

      let targetFree = true;
      if (
        targetCellRef.barrier.state === true &&
        targetCellRef.barrier.position === direction
      ) {
        targetFree = false;
        if (this.halfPushBackChaining === true) {
          this.startHalfPushBack("obstacle", "barrier", direction, targetCellRef);
        }
      }
      if (destCellRef) {
        if (
          destCellRef.barrier.state === true &&
          destCellRef.barrier.position === this.getOppositeDirection(direction)
        ) {
          targetFree = false;
          if (this.halfPushBackChaining === true) {
            this.startHalfPushBack("obstacle", "barrier", direction, targetCellRef);
          }
        }

        if (destCellRef.obstacle.state === true) {
          targetFree = false;

          if (this.halfPushBackChaining === true) {
            this.startHalfPushBack("obstacle", "obstacle", direction, targetCellRef);
          }
        }

        if (
          this.players.find(
            (x) =>
              x.currentPosition.cell.number.x === destCellRef.number.x &&
              x.currentPosition.cell.number.y === destCellRef.number.y
          )
        ) {
          targetFree = false;

          if (this.halfPushBackChaining === true) {
            this.startHalfPushBack("obstacle", "player", direction, targetCellRef);
          }
        }
      }
      if (targetFree === true) {
        if (targetCellRef.obstacle.moving.state !== true) {
          if (destCellRef) {
            let obstacleCrementObj = this.obstacleMoveCrementer(
              targetCellRef,
              destCellRef
            );

            targetCellRef.obstacle = {
              id: targetCellRef.obstacle.id,
              trap: targetCellRef.obstacle.trap,
              state: targetCellRef.obstacle.state,
              name: targetCellRef.obstacle.name,
              type: targetCellRef.obstacle.type,
              hp: targetCellRef.obstacle.hp,
              destructible: targetCellRef.obstacle.destructible,
              locked: targetCellRef.obstacle.locked,
              weight: targetCellRef.obstacle.weight,
              height: targetCellRef.obstacle.height,
              items: targetCellRef.obstacle.items,
              effects: targetCellRef.obstacle.effects,
              moving: {
                state: true,
                step: obstacleCrementObj.step,
                origin: {
                  number: targetCellRef.number,
                  center: targetCellRef.center,
                },
                destination: {
                  number: destCellRef.number,
                  center: destCellRef.center,
                },
                currentPosition: targetCellRef.center,
                nextPosition: obstacleCrementObj.pos,
                moveSpeed: moveSpeed,
                pushable: true,
                pushed: true,
                pusher: -1,
                falling: targetCellRef.obstacle.moving.falling,
              },
            };
          }

          if (!destCellRef) {
            let voidCenter = this.getVoidCenter(1, direction, targetCellRef.center);

            let obstacleCrementObj = this.obstacleMoveCrementer(targetCellRef, {
              center: voidCenter,
            });

            targetCellRef.obstacle = {
              id: targetCellRef.obstacle.id,
              trap: targetCellRef.obstacle.trap,
              state: targetCellRef.obstacle.state,
              name: targetCellRef.obstacle.name,
              type: targetCellRef.obstacle.type,
              hp: targetCellRef.obstacle.hp,
              destructible: targetCellRef.obstacle.destructible,
              locked: targetCellRef.obstacle.locked,
              weight: targetCellRef.obstacle.weight,
              height: targetCellRef.obstacle.height,
              items: targetCellRef.obstacle.items,
              effects: targetCellRef.obstacle.effects,
              moving: {
                state: true,
                step: obstacleCrementObj.step,
                origin: {
                  number: targetCellRef.number,
                  center: targetCellRef.center,
                },
                destination: {
                  number: {
                    x: undefined,
                    y: undefined,
                  },
                  center: voidCenter,
                },
                currentPosition: targetCellRef.center,
                nextPosition: obstacleCrementObj.pos,
                moveSpeed: moveSpeed,
                pushable: true,
                pushed: true,
                pusher: -1,
                falling: targetCellRef.obstacle.moving.falling,
              },
            };
          }
        } else {
          console.log("obstacle already being 1/2 pushed back!!");
        }
      }
    }

    if (movePlayer === true && impactee === "player") {
      let destCell = this.getCellFromDirection(1, targetCellRef.number, direction);
      let destCellRef = this.gridInfo.find(
        (x) => x.number.x === destCell.x && x.number.y === destCell.y
      );
      let destCellOccupant = "";
      let preMoveSpeed = this.rnJesus(0, 5);
      let moveSpeed = 0;
      if (preMoveSpeed <= 1) {
        moveSpeed = 0.05;
      }
      if (preMoveSpeed === 2) {
        moveSpeed = 0.1;
      }
      if (preMoveSpeed > 2 && preMoveSpeed < 4) {
        moveSpeed = 0.125;
      }
      if (preMoveSpeed >= 4) {
        moveSpeed = 0.2;
      }
      if (this.terrainMoveSpeedRef[targetCellRef.terrain.type]) {
        moveSpeed = this.terrainMoveSpeedRef[targetCellRef.terrain.type];
      }

      let targetFree = true;
      if (
        targetCellRef.barrier.state === true &&
        targetCellRef.barrier.position === direction
      ) {
        targetFree = false;
      }
      if (destCellRef) {
        if (
          destCellRef.barrier.state === true &&
          destCellRef.barrier.position === this.getOppositeDirection(direction)
        ) {
          targetFree = false;
        }

        if (destCellRef.obstacle.state === true) {
          targetFree = false;
          if (this.halfPushBackChaining === true) {
            this.startHalfPushBack("player", "obstacle", direction, impacteePlayerRef);
          }
        }

        if (
          this.players.find(
            (x) =>
              x.currentPosition.cell.number.x === destCellRef.number.x &&
              x.currentPosition.cell.number.y === destCellRef.number.y
          )
        ) {
          targetFree = false;

          if (this.halfPushBackChaining === true) {
            this.startHalfPushBack("player", "player", direction, impacteePlayerRef);
          }
        }
      }

      if (targetFree === true) {
        if (this.players[impacteePlayerRef.number - 1].moving.state !== true) {
          // this.players[targetPlayer.number-1].strafing.direction = impactDirection;
          // this.players[targetPlayer.number-1].strafing.state = true;
          // this.players[targetPlayer.number-1].action = 'strafe moving';
          this.players[impacteePlayerRef.number - 1].action = "moving";

          this.unsetDeflection(impacteePlayerRef);

          this.players[impacteePlayerRef.number - 1].pushed = {
            state: true,
            pusher: -1,
            moveSpeed: moveSpeed,
          };
          this.getTarget(impacteePlayerRef);

          if (destCellRef) {
            this.players[impacteePlayerRef.number - 1].moving = {
              state: true,
              step: 0,
              course: "",
              origin: {
                number: {
                  x: impacteePlayerRef.currentPosition.cell.number.x,
                  y: impacteePlayerRef.currentPosition.cell.number.y,
                },
                center: {
                  x: impacteePlayerRef.currentPosition.cell.center,
                  y: impacteePlayerRef.currentPosition.cell.center,
                },
              },
              destination: destCellRef.center,
            };
            let targetPlyrNextPosition = this.lineCrementer(impacteePlayerRef);
            this.players[impacteePlayerRef.number - 1].nextPosition =
              targetPlyrNextPosition;
          }

          if (!destCellRef) {
            let voidCenter = this.getVoidCenter(1, direction, targetCellRef.center);

            this.players[impacteePlayerRef.number - 1].moving = {
              state: true,
              step: 0,
              course: "",
              origin: {
                number: {
                  x: impacteePlayerRef.currentPosition.cell.number.x,
                  y: impacteePlayerRef.currentPosition.cell.number.y,
                },
                center: {
                  x: impacteePlayerRef.currentPosition.cell.center,
                  y: impacteePlayerRef.currentPosition.cell.center,
                },
              },
              destination: voidCenter,
            };
            let targetPlyrNextPosition = this.lineCrementer(impacteePlayerRef);
            this.players[impacteePlayerRef.number - 1].nextPosition =
              targetPlyrNextPosition;
          }
        } else {
          console.log("player is already being pushed back!!");
        }
      }
    }
  };
  pointChecker = (player) => {
    // console.log('point checker player',player);

    let points = player.points;
    if (points % 5 === 0) {
      this.bloodSacrificeEvent.state = true;
      this.bloodSacrificeEvent.limit = 2000;
      this.bloodSacrificeEvent.restore = true;
      this.openVoid = true;
      console.log("the gods have accepted a blood sacrifice. Standby for void tiles");
    }
  };

  placeItems = (args) => {
    if (args.init === true && this.disableInitItems === false) {
      // console.log('placing items init');

      if (this.customItemPlacement.state === true) {
        if (this.initItemList.length > this.customItemPlacement.cells.length) {
          console.log("not enough cells assigned for custom placement please add more");
        } else {
          // console.log('start:',this.initItemList.length,this.customItemPlacement.cells.length);

          for (const item2 of this.initItemList) {
            let index = this.initItemList.indexOf(item2);
            let cell3 = {
              number: this.customItemPlacement.cells[index],
              center: { x: undefined, y: undefined },
            };
            let cell3Ref = this.gridInfo.find(
              (elem) =>
                elem.number.x === cell3.number.x && elem.number.y === cell3.number.y
            );

            if (!cell3Ref) {
              // console.log('!!original item placement not found!!!',index,'/',this.initItemList.length,this.customItemPlacement.cells[index]);
              cell3 = this.getRandomFreeCell();
              // cell3Ref = this.gridInfo.find(elem => elem.number.x === cell3.number.x && elem.number.y === cell3.number.y);
              // console.log('cell doesnt exist @',this.customItemPlacement.cells[index],'pick new cell',cell3,'item',item2.name);
              if (!cell3) {
                cell3Ref = this.gridInfo.filter((x) => x.obstacle.state === true)[0];
                // console.log('no free cells for placement, replace obatcle? @ ',cell3Ref.number);
                if (cell3Ref) {
                  let oldLvlData = cell3Ref.levelData.split("_");
                  oldLvlData[1] = "*";
                  cell3Ref.levelData = oldLvlData.join("_");
                  cell3Ref.obstacle.state = false;

                  // console.log('clearing obstacle cell for placement',cell3Ref.number,'item',cell3Ref.item.name,index);

                  cell3Ref.item.name = item2.name;
                  cell3Ref.item.type = item2.type;
                  cell3Ref.item.subType = item2.subType;
                  cell3Ref.item.effect = item2.effect;
                } else {
                  // console.log('init item placement no free cells for this item. skipping');
                  continue;
                }
              } else {
                cell3Ref = this.gridInfo.find(
                  (elem) =>
                    elem.number.x === cell3.number.x && elem.number.y === cell3.number.y
                );
                // console.log('cell for placement exists',cell3Ref.number,this.customItemPlacement.cells[index],'item',item2.name);
                if (
                  this.customItemPlacement.cells.find(
                    (x) => x.x === cell3.number.x && x.y === cell3.number.y
                  )
                ) {
                  // console.log('b');
                  cell3 = this.getRandomFreeCell();
                  cell3Ref = this.gridInfo.find(
                    (elem) =>
                      elem.number.x === cell3.number.x && elem.number.y === cell3.number.y
                  );

                  if (!cell3) {
                    // console.log('here is where 1');
                    continue;
                  }
                }

                if (cell3Ref.obstacle.state === true) {
                  // console.log('obstacle in original placement cell',cell3Ref.number);
                  cell3 = this.getRandomFreeCell();

                  if (!cell3) {
                    // console.log('here is where 2');
                    continue;
                  } else {
                    cell3Ref = this.gridInfo.find(
                      (elem) =>
                        elem.number.x === cell3.number.x &&
                        elem.number.y === cell3.number.y
                    );
                    // console.log('chose another cell',cell3Ref.number);
                  }
                }

                if (cell3Ref) {
                  // console.log('cell is clear for placement2',cell3Ref.number,'item',cell3Ref.item.name,index);

                  cell3Ref.item.name = item2.name;
                  cell3Ref.item.type = item2.type;
                  cell3Ref.item.subType = item2.subType;
                  cell3Ref.item.effect = item2.effect;
                }
              }
            } else {
              cell3Ref = this.gridInfo.find(
                (elem) =>
                  elem.number.x === cell3.number.x && elem.number.y === cell3.number.y
              );
              // console.log('cell @',this.customItemPlacement.cells[index],cell3Ref.number);
              if (cell3Ref.obstacle.state === true) {
                cell3 = this.getRandomFreeCell();
                // console.log('obstacle found. choose new cell',cell3);

                if (!cell3) {
                  // console.log('here is where');
                  continue;
                } else {
                  cell3Ref = this.gridInfo.find(
                    (elem) =>
                      elem.number.x === cell3.number.x && elem.number.y === cell3.number.y
                  );
                  // console.log('cell is clear for placement3',cell3Ref.number,'item',cell3Ref.item.name,index);
                  cell3Ref.item.name = item2.name;
                  cell3Ref.item.type = item2.type;
                  cell3Ref.item.subType = item2.subType;
                  cell3Ref.item.effect = item2.effect;
                }
              } else {
                cell3Ref = this.gridInfo.find(
                  (elem) =>
                    elem.number.x === cell3.number.x && elem.number.y === cell3.number.y
                );
                // console.log('cell is clear for placement4',cell3Ref.number,'item',cell3Ref.item.name,index);

                cell3Ref.item.name = item2.name;
                cell3Ref.item.type = item2.type;
                cell3Ref.item.subType = item2.subType;
                cell3Ref.item.effect = item2.effect;
              }
            }
          }
          // this.customItemPlacement.state = false;
        }
      } else {
        for (const item of this.initItemList) {
          // if (item.amount > item.total-1) {
          // console.log('enough items for distribution');
          let cell = {
            x: 0,
            y: 0,
          };
          let checkCell = false;
          while (checkCell === false) {
            cell.x = this.rnJesus(0, this.gridWidth);
            cell.y = this.rnJesus(0, this.gridWidth);
            checkCell = this.checkCell(cell);
            // console.log(checkCell);
          }
          if (checkCell === true) {
            // console.log('cell free');
            let cellRef = this.gridInfo.find(
              (elem) => elem.number.x === cell.x && elem.number.y === cell.y
            );
            cellRef.item.name = item.name;
            cellRef.item.type = item.type;
            cellRef.item.subType = item.subType;
            cellRef.item.effect = item.effect;

            // item.amount--
            // console.log('post item', item, cell2.item,cell2.number);
          }
          // }
          // else {
          //   console.log('item stock empty');
          // }
        }
      }
    } else if (args.init !== true) {
      // console.log('placing items mid-game: ',args.item);

      let item = args.item;

      for (const item2 of this.itemList) {
        if (item2.name === item) {
          if (item2.amount > 0) {
            let cell = {
              x: 0,
              y: 0,
            };
            let checkCell = false;
            while (checkCell === false) {
              cell.x = this.rnJesus(0, this.gridWidth);
              cell.y = this.rnJesus(0, this.gridWidth);
              checkCell = this.checkCell(cell);
            }
            if (checkCell === true) {
              let cell2 = this.gridInfo.find(
                (elem) => elem.number.x === cell.x && elem.number.y === cell.y
              );
              cell2.item.name = item2.name;
              cell2.item.type = item2.type;
              cell2.item.subType = item2.subType;
              cell2.item.effect = item2.effect;

              item2.amount--;
              // console.log('placed ingame item',item2.name,"@",cell2.number.x,cell2.number.y,'remaining',item2.amount);

              // for (const cell2 of this.gridInfo) {
              //   if (
              //     cell2.number.x === cell.x &&
              //     cell2.number.y === cell.y
              //   ) {
              //     cell2.item.name = item2.name;
              //     cell2.item.type = item2.type;
              //     cell2.item.subType = item2.subType;
              //     cell2.item.effect = item2.effect;
              //
              //     item2.amount--
              //     console.log('placed ingame item',cell2.number.x,cell2.number.y,item2.amount,this.itemList);
              //   }
              // }
            }
            // item2.amount--
          } else {
            console.log("item stock empty");
          }
        }
      }
    }
  };
  deflectDrop = (player) => {
    // console.log('deflected! drop gear?',player.number);
    // console.log('preDropItems', player.items);

    let item = {
      name: "",
      type: "",
      subType: "",
      effect: "",
      initDrawn: false,
    };

    let dropWhat = this.rnJesus(1, 5);
    dropWhat = 1;
    let shouldDrop = false;
    let dropped = false;

    // let dropChance = this.rnJesus(1,1*player.crits.pushBack);

    let dropChance = this.rnJesus(1, player.crits.pushBack + 3);
    dropChance = this.rnJesus(1, 1);
    if (dropChance === 1 && player.falling.state !== true && player.dead.state !== true) {
      shouldDrop = true;

      if (dropWhat === 1) {
        if (player.currentWeapon.name !== "") {
          dropped = true;

          let index = player.items.weapons.findIndex(
            (weapon) => weapon.name === player.currentWeapon.name
          );
          // console.log("dropping weapon player ",player.number,this.players[player.number-1].items.weapons[index].name,index,);

          item.name = this.players[player.number - 1].items.weapons[index].name;
          item.subType = this.players[player.number - 1].items.weapons[index].type;
          item.type = "weapon";
          item.effect = this.players[player.number - 1].items.weapons[index].effect;

          this.players[player.number - 1].itemDrop = {
            state: true,
            count: 0,
            limit: 10,
            item: {
              name: "",
            },
            gear: {
              type: this.players[player.number - 1].items.weapons[index].type,
            },
          };

          this.players[player.number - 1].popups.push({
            state: false,
            count: 0,
            limit: 25,
            type: "",
            position: "",
            msg: "dropWeapon",
            img: "",
          });

          this.players[player.number - 1].items.weapons.splice(index, 1);
          this.players[player.number - 1].items.weaponIndex = 0;
          this.players[player.number - 1].currentWeapon = {
            name: "",
            type: "",
            effect: "",
          };

          // CURRENT WEAPON DROPPED, DROP DEFENSE
          if (
            !player.currentArmor.name ||
            !player.currentArmor ||
            player.currentArmor.name === ""
          ) {
            this.players[player.number - 1].defending = {
              state: false,
              count: 0,
              limit: this.players[player.number - 1].defending.limit,
              animRef: this.players[player.number - 1].defending.animRef,
              peak: false,
              peakCount: 0,
              decay: {
                state: false,
                count: 0,
                limit: this.players[player.number - 1].defending.decay.limit,
              },
              direction: "",
              directionType: "", //thrust or slash
            };
            this.players[player.number - 1].action = "idle";
          }

          this.players[player.number - 1].statusDisplay = {
            state: true,
            status: item.name + "dropped",
            count: 1,
            limit: this.players[player.number - 1].statusDisplay.limit,
          };
        }
      } else {
        if (player.currentArmor.name !== "") {
          dropped = true;
          let index = player.items.armor.findIndex(
            (armor) => armor.name === player.currentArmor.name
          );
          // console.log("dropping armor player ",player.number,this.players[player.number-1].items.armor[index].name);
          item.name = this.players[player.number - 1].items.armor[index].name;
          item.subType = this.players[player.number - 1].items.armor[index].type;
          item.effect = this.players[player.number - 1].items.armor[index].effect;
          item.type = "armor";

          this.players[player.number - 1].itemDrop = {
            state: true,
            count: 0,
            limit: 10,
            item: {
              name: "",
            },
            gear: {
              type: this.players[player.number - 1].items.armor[index].type,
            },
          };

          this.players[player.number - 1].popups.push({
            state: false,
            count: 0,
            limit: 25,
            type: "",
            position: "",
            msg: "dropArmor",
            img: "",
          });

          this.applyRemoveEffect(player, "remove", "deflectDrop", "armor", item);

          this.players[player.number - 1].items.armor.splice(index, 1);
          this.players[player.number - 1].items.armorIndex = 0;
          this.players[player.number - 1].currentArmor = {
            name: "",
            type: "",
            effect: "",
          };

          if (
            !player.currentWeapon.name ||
            !player.currentWeapon ||
            player.currentWeapon.name === ""
          ) {
            this.players[player.number - 1].defending = {
              state: false,
              count: 0,
              limit: this.players[player.number - 1].defending.limit,
              animRef: this.players[player.number - 1].defending.animRef,
              peak: false,
              peakCount: 0,
              decay: {
                state: false,
                count: 0,
                limit: this.players[player.number - 1].defending.decay.limit,
              },
              direction: "",
              directionType: "", //thrust or slash
            };
            this.players[player.number - 1].action = "idle";
          }

          this.players[player.number - 1].statusDisplay = {
            state: true,
            status: item.name + "dropped",
            count: 1,
            limit: this.players[player.number - 1].statusDisplay.limit,
          };
        }
      }

      if (player.currentWeapon.name === "" || player.currentArmor.name === "") {
        console.log("currently unarmed and/or unarmored. Nothing to drop");
      }

      // console.log('postDropItems', player.items, player.currentPosition.cell.number.x,player.currentPosition.cell.number.y);

      if (dropped === true) {
        let dropCellIndex = this.gridInfo.findIndex(
          (cell) =>
            cell.number.x === player.currentPosition.cell.number.x &&
            cell.number.y === player.currentPosition.cell.number.y
        );
        this.gridInfo[dropCellIndex].item = item;

        if (
          player.ai.state === true &&
          item.name !== "" &&
          player.ai.organizing.dropped.state !== true
        ) {
          if (dropWhat === 1) {
            // console.log('ai dropping weapon');
            player.ai.organizing.dropped.state = true;
            player.ai.organizing.dropped.gear = {
              name: item.name,
              type: item.type,
              subType: item.subType,
              effect: item.effect,
            };
          } else {
            // console.log('ai dropping armor');
            player.ai.organizing.dropped.state = true;
            player.ai.organizing.dropped.gear = {
              name: item.name,
              type: item.type,
              subType: item.subType,
              effect: item.effect,
            };
          }
        }
      }
    } else {
      // console.log('no gear drop',player.currentPosition.cell.number.x,player.currentPosition.cell.number.y);
    }

    //   if dropped gear remove buff/effect
    // console.log('this.players[player.number-1].itemDrop',this.players[player.number-1].itemDrop);
  };
  discardGear = (player, type) => {
    // console.log('dropping gear');

    let cellToDrop = this.gridInfo.find(
      (elem) =>
        elem.number.x === player.currentPosition.cell.number.x &&
        elem.number.y === player.currentPosition.cell.number.y
    );

    this.players[player.number - 1].action = "idle";

    if (cellToDrop.item.name === "") {
      if (type === "weapon") {
        if (player.currentWeapon.name !== "") {
          let index = player.items.weapons.findIndex(
            (weapon) => weapon.name === player.currentWeapon.name
          );

          let weapon = player.currentWeapon;

          cellToDrop.item = {
            name: weapon.name,
            type: "weapon",
            subType: weapon.type,
            effect: weapon.effect,
            initDrawn: false,
          };

          this.players[player.number - 1].itemDrop = {
            state: true,
            count: 0,
            limit: 10,
            item: {
              name: "",
            },
            gear: {
              type: this.players[player.number - 1].items.weapons[index].type,
            },
          };
          this.players[player.number - 1].statusDisplay = {
            state: true,
            status: weapon.name + " discarded!",
            count: 1,
            limit: this.players[player.number - 1].statusDisplay.limit,
          };

          this.players[player.number - 1].popups.push({
            state: false,
            count: 0,
            limit: 25,
            type: "",
            position: "",
            msg: "dropWeapon",
            img: "",
          });

          this.players[player.number - 1].items.weapons.splice(index, 1);
          this.players[player.number - 1].currentWeapon = {
            name: "",
            type: "",
            effect: "",
          };

          if (
            !player.currentArmor.name ||
            !player.currentArmor ||
            player.currentArmor.name === ""
          ) {
            this.players[player.number - 1].defending = {
              state: false,
              count: 0,
              limit: this.players[player.number - 1].defending.limit,
              animRef: this.players[player.number - 1].defending.animRef,
              peak: false,
              peakCount: 0,
              decay: {
                state: false,
                count: 0,
                limit: this.players[player.number - 1].defending.decay.limit,
              },
              direction: "",
              directionType: "", //thrust or slash
            };
            this.players[player.number - 1].action = "idle";
          }
        } else {
          console.log("no weapon equipped to discard");
        }
      }
      if (type === "armor") {
        if (player.currentArmor.name !== "") {
          let index2 = player.items.armor.findIndex(
            (armor) => armor.name === player.currentArmor.name
          );

          let armor = player.currentArmor;

          cellToDrop.item = {
            name: armor.name,
            type: "armor",
            subType: armor.type,
            effect: armor.effect,
            initDrawn: false,
          };

          this.players[player.number - 1].itemDrop = {
            state: true,
            count: 0,
            limit: 10,
            item: {
              name: "",
            },
            gear: {
              type: this.players[player.number - 1].items.armor[index2].type,
            },
          };
          this.players[player.number - 1].statusDisplay = {
            state: true,
            status: armor.name + " discarded!",
            count: 1,
            limit: this.players[player.number - 1].statusDisplay.limit,
          };

          this.players[player.number - 1].popups.push({
            state: false,
            count: 0,
            limit: 25,
            type: "",
            position: "",
            msg: "dropArmor",
            img: "",
          });
          this.applyRemoveEffect(player, "remove", "discard", "armor", cellToDrop.item);

          this.players[player.number - 1].items.armor.splice(index2, 1);
          this.players[player.number - 1].currentArmor = {
            name: "",
            type: "",
            effect: "",
          };

          if (
            !player.currentWeapon.name ||
            !player.currentWeapon ||
            player.currentWeapon.name === ""
          ) {
            this.players[player.number - 1].defending = {
              state: false,
              count: 0,
              limit: this.players[player.number - 1].defending.limit,
              animRef: this.players[player.number - 1].defending.animRef,
              peak: false,
              peakCount: 0,
              decay: {
                state: false,
                count: 0,
                limit: this.players[player.number - 1].defending.decay.limit,
              },
              direction: "",
              directionType: "", //thrust or slash
            };
            this.players[player.number - 1].action = "idle";
          }
        } else {
          console.log("no armor equipped to discard");
        }
      }
    } else {
      console.log("cell occupied. Cant drop gear");

      this.players[player.number - 1].statusDisplay = {
        state: true,
        status: "Cell occupied. Cant drop!",
        count: 1,
        limit: this.players[player.number - 1].statusDisplay.limit,
      };

      if (!this.players[player.number - 1].popups.find((x) => x.msg === "stop")) {
        this.players[player.number - 1].popups.push({
          state: false,
          count: 0,
          limit: 25,
          type: "",
          position: "",
          msg: "stop",
          img: "",
        });
      }

      this.checkDestination(player, true);
    }
  };
  attackCellContents = (
    type,
    ownerType,
    owner,
    targetCell,
    targetCell2,
    myCell,
    bolt
  ) => {
    let damage;
    let weaponCheck;
    let ownerWeaponName;
    let ownerWeaponType;
    let ownerDirection;
    const handleObstacleDamage = (calcedDamage, range) => {
      if (range === 1) {
        if (targetCell.obstacle.destructible.state === true) {
          // WEAPON CHECK
          if (ownerType === "player") {
            ownerWeaponName = owner.currentWeapon.name;
          } else {
            ownerWeaponName = owner.trap.itemNameRef;
          }
          if (type === "bolt" || type === "flyOverBolt") {
            if (targetCell.obstacle.destructible.weapons.find((x) => x === "bolt")) {
              weaponCheck = true;
            }
          }
          if (
            type === "melee" &&
            targetCell.obstacle.destructible.weapons.find((x) => x === ownerWeaponName)
          ) {
            weaponCheck = true;
          }
          if (weaponCheck === true) {
            // DAMAGE, DON'T DESTROY FWD OBSTACLE
            if (targetCell.obstacle.hp - calcedDamage > 0) {
              console.log(
                ownerType,
                owner.number,
                owner.id,
                "hit an obstacle ",
                targetCell.obstacle.id,
                "w/ a",
                ownerWeaponType,
                "@ ",
                targetCell.number,
                "and damaged it."
              );
              let hp = targetCell.obstacle.hp - calcedDamage;

              targetCell.obstacle = {
                id: targetCell.obstacle.id,
                trap: targetCell.obstacle.trap,
                state: targetCell.obstacle.state,
                name: targetCell.obstacle.name,
                type: targetCell.obstacle.type,
                hp: hp,
                destructible: targetCell.obstacle.destructible,
                locked: targetCell.obstacle.locked,
                weight: targetCell.obstacle.weight,
                height: targetCell.obstacle.height,
                items: targetCell.obstacle.items,
                effects: targetCell.obstacle.effects,
                moving: targetCell.obstacle.moving,
              };

              this.obstacleBarrierToDestroy.push({
                type: "obstacle",
                action: "damage",
                count: 0,
                limit: 30,
                complete: false,
                cell: targetCell,
              });

              // if (type === "bolt" || type === "flyOverBolt") {
              //   this.canPushObstacle(ownerType, owner, targetCell, `hitPushBolt_${bolt.direction}`);
              // }
              // if (type === "melee") {
              //   this.canPushObstacle(ownerType, owner, targetCell, `hitPush`);
              // }
            }

            // DESTROY OBSTACLE W/ OR W/O RUBBLE
            else if (targetCell.obstacle.hp - calcedDamage <= 0) {
              console.log(
                ownerType,
                owner.number,
                owner.id,
                "hit an obstacle ",
                targetCell.obstacle.id,
                "w/ a",
                ownerWeaponType,
                "@ ",
                targetCell.number,
                "and destroyed it. Drop items, leave rubble?"
              );
              let itemsToDrop = [];
              if (
                targetCell.obstacle.destructible.leaveRubble === true &&
                targetCell.terrain.type !== "void" &&
                targetCell.terrain.type !== "deep"
              ) {
                // console.log('leave rubble on ',targetCell.number,'removing obstacle');
                if (targetCell.obstacle.items[0]) {
                  itemsToDrop = targetCell.obstacle.items;
                }
                // let cellRef = this.gridInfo.find(elem => elem.number.x === targetCell.number.x && elem.number.y === targetCell.number.y);
                targetCell.rubble = true;
                // targetCell.terrain.type = 'hazard';

                targetCell.obstacle = {
                  id: targetCell.obstacle.id,
                  trap: targetCell.obstacle.trap,
                  state: false,
                  name: targetCell.obstacle.name,
                  type: targetCell.obstacle.type,
                  hp: 0,
                  destructible: targetCell.obstacle.destructible,
                  locked: targetCell.obstacle.locked,
                  weight: targetCell.obstacle.weight,
                  height: targetCell.obstacle.height,
                  items: targetCell.obstacle.items,
                  effects: targetCell.obstacle.effects,
                  moving: targetCell.obstacle.moving,
                };

                if (ownerType === "player") {
                  this.players[owner.number - 1].statusDisplay = {
                    state: true,
                    status: "Destroyed " + targetCell.obstacle.name + "!",
                    count: 1,
                    limit: this.players[owner.number - 1].statusDisplay.limit,
                  };

                  if (!owner.popups.find((x) => x.msg === "destroyedItem")) {
                    owner.popups.push({
                      state: false,
                      count: 0,
                      limit: 30,
                      type: "",
                      position: "",
                      msg: "destroyedItem",
                      img: "",
                    });
                  }
                }
              } else {
                // console.log('no rubble. Just remove obstacle');
                if (targetCell.obstacle.items[0]) {
                  itemsToDrop = targetCell.obstacle.items;
                }

                targetCell.obstacle = {
                  id: targetCell.obstacle.id,
                  trap: targetCell.obstacle.trap,
                  state: false,
                  name: targetCell.obstacle.name,
                  type: targetCell.obstacle.type,
                  hp: 0,
                  destructible: targetCell.obstacle.destructible,
                  locked: targetCell.obstacle.locked,
                  weight: targetCell.obstacle.weight,
                  height: targetCell.obstacle.height,
                  items: targetCell.obstacle.items,
                  effects: targetCell.obstacle.effects,
                  moving: targetCell.obstacle.moving,
                };

                if (ownerType === "player") {
                  this.players[owner.number - 1].statusDisplay = {
                    state: true,
                    status: "Destroyed " + targetCell.obstacle.name + "!",
                    count: 1,
                    limit: this.players[owner.number - 1].statusDisplay.limit,
                  };

                  if (!owner.popups.find((x) => x.msg === "destroyedItem")) {
                    owner.popups.push({
                      state: false,
                      count: 0,
                      limit: 30,
                      type: "",
                      position: "",
                      msg: "destroyedItem",
                      img: "",
                    });
                  }
                }
              }

              // DROP OBSTACLE ITEMS?
              if (itemsToDrop[0]) {
                // console.log('dropping obstacle items bolt',itemsToDrop);

                this.obstacleItemDrop(targetCell, owner);
              }
              this.obstacleBarrierToDestroy.push({
                type: "obstacle",
                action: "destroy",
                count: 0,
                limit: 30,
                complete: false,
                cell: targetCell,
              });
            }
          }

          // WEAPON NO GOOD. PUSH OBSTACLE?
          else {
            // console.log(
            //   "your current weapon cannot destroy this, you need ",
            //   targetCell.obstacle.destructible.weapons,
            //   ". Deflect player?"
            // );
            if (
              !this.cellPopups.find(
                (x) =>
                  x.msg === "unbreakable" &&
                  x.cell.number.x === targetCell.number.x &&
                  x.cell.number.y === targetCell.number.y
              )
            ) {
              this.cellPopups.push({
                state: false,
                count: 0,
                limit: 35,
                type: "",
                position: "",
                msg: "unbreakable",
                color: "",
                img: "",
                cell: this.gridInfo.find(
                  (x) =>
                    x.number.x === targetCell.number.x &&
                    x.number.y === targetCell.number.y
                ),
              });
            }
            console.log(
              ownerType,
              owner.number,
              owner.id,
              "hit an obstacle ",
              targetCell.obstacle.id,
              "w/ a",
              ownerWeaponType,
              "@ ",
              targetCell.number,
              " but their current weapon cannot destroy this, they need",
              targetCell.obstacle.destructible.weapons,
              ". pushback obstacle. Deflect, pushback attacker?"
            );

            if (this.rnJesus(0, 2) === 1) {
              if (type === "bolt" || type === "flyOverBolt") {
                this.canPushObstacle(
                  ownerType,
                  owner,
                  targetCell,
                  `hitPushBolt_${bolt.direction}`
                );
              }
              if (type === "melee") {
                this.canPushObstacle(ownerType, owner, targetCell, `hitPush`);
              }
            }

            // DEFLECT PLAYER
            if (type === "melee" && ownerType === "player") {
              let shouldDeflect = this.rnJesus(1, owner.crits.guardBreak);

              if (shouldDeflect === 1) {
                if (this.rnJesus(1, owner.crits.pushBack) === 1) {
                  this.setDeflection(owner, "defended", true);
                } else {
                  this.setDeflection(owner, "defended", false);
                }

                if (owner.currentWeapon.name === "") {
                  console.log("this obstacle is stronger than your fist. Take damage?");
                  let takeDamage = this.rnJesus(1, owner.crits.guardBreak);
                  if (takeDamage === 1) {
                    this.handleMiscPlayerDamage(owner, "obstacleBarrierInvulnurable");
                  }
                }
              } else {
                this.pushBack(owner, this.getOppositeDirection(owner.direction));
              }
            }
          }
        }
        // INDESTRUCTIBLE OBSTACLE. PUSH OBSTACLE?
        else {
          // console.log('attacking invurnerable obstacle w/ bolt');
          console.log(
            ownerType,
            owner.number,
            owner.id,
            "hit an obstacle ",
            targetCell.obstacle.id,
            "w/ a",
            ownerWeaponType,
            "@ ",
            targetCell.number,
            " but it is indestructible. pushback obstacle. Deflect, pushback attacker?"
          );
          if (
            !this.cellPopups.find(
              (x) =>
                x.msg === "unbreakable" &&
                x.cell.number.x === targetCell.number.x &&
                x.cell.number.y === targetCell.number.y
            )
          ) {
            this.cellPopups.push({
              state: false,
              count: 0,
              limit: 35,
              type: "",
              position: "",
              msg: "unbreakable",
              color: "",
              img: "",
              cell: this.gridInfo.find(
                (x) =>
                  x.number.x === targetCell.number.x && x.number.y === targetCell.number.y
              ),
            });
          }
          if (type === "bolt" || type === "flyOverBolt") {
            this.canPushObstacle(
              ownerType,
              owner,
              targetCell,
              `hitPushBolt_${bolt.direction}`
            );
          }
          if (type === "melee") {
            this.canPushObstacle(ownerType, owner, targetCell, `hitPush`);
          }

          if (type === "melee" && ownerType === "player") {
            let shouldDeflect = this.rnJesus(1, owner.crits.guardBreak);

            if (shouldDeflect === 1) {
              if (this.rnJesus(1, owner.crits.pushBack) === 1) {
                this.setDeflection(owner, "defended", true);
              } else {
                this.setDeflection(owner, "defended", false);
              }

              if (owner.currentWeapon.name === "") {
                console.log("this obstacle is stronger than your fist. Take damage?");
                let takeDamage = this.rnJesus(1, owner.crits.guardBreak);
                if (takeDamage === 1) {
                  this.handleMiscPlayerDamage(owner, "obstacleBarrierInvulnurable");
                }
              }
            } else {
              this.pushBack(owner, this.getOppositeDirection(owner.direction));
            }
          }
        }
      } else {
        if (targetCell2.obstacle.destructible.state === true) {
          // WEAPON CHECK
          if (ownerType === "player") {
            ownerWeaponName = owner.currentWeapon.name;
          } else {
            ownerWeaponName = owner.trap.itemNameRef;
          }
          if (type === "bolt" || type === "flyOverBolt") {
            if (targetCell2.obstacle.destructible.weapons.find((x) => x === "bolt")) {
              weaponCheck = true;
            }
          }
          if (
            type === "melee" &&
            targetCell2.obstacle.destructible.weapons.find((x) => x === ownerWeaponName)
          ) {
            weaponCheck = true;
          }
          if (weaponCheck === true) {
            // DAMAGE, DON'T DESTROY FWD OBSTACLE
            if (targetCell2.obstacle.hp - calcedDamage > 0) {
              console.log(
                ownerType,
                owner.number,
                owner.id,
                "hit an obstacle ",
                targetCell2.obstacle.id,
                "w/ a",
                ownerWeaponType,
                "@ ",
                targetCell2.number,
                "and damaged it."
              );
              let hp = targetCell2.obstacle.hp - calcedDamage;

              targetCell2.obstacle = {
                id: targetCell2.obstacle.id,
                trap: targetCell2.obstacle.trap,
                state: targetCell2.obstacle.state,
                name: targetCell2.obstacle.name,
                type: targetCell2.obstacle.type,
                hp: hp,
                destructible: targetCell2.obstacle.destructible,
                locked: targetCell2.obstacle.locked,
                weight: targetCell2.obstacle.weight,
                height: targetCell2.obstacle.height,
                items: targetCell2.obstacle.items,
                effects: targetCell2.obstacle.effects,
                moving: targetCell2.obstacle.moving,
              };

              this.obstacleBarrierToDestroy.push({
                type: "obstacle",
                action: "damage",
                count: 0,
                limit: 30,
                complete: false,
                cell: targetCell2,
              });

              if (type === "bolt" || type === "flyOverBolt") {
                this.canPushObstacle(
                  ownerType,
                  owner,
                  targetCell2,
                  `hitPushBolt_${bolt.direction}`
                );
              }
              if (type === "melee") {
                this.canPushObstacle(ownerType, owner, targetCell2, `hitPush`);
              }
            }

            // DESTROY OBSTACLE W/ OR W/O RUBBLE
            else if (targetCell2.obstacle.hp - calcedDamage <= 0) {
              console.log(
                ownerType,
                owner.number,
                owner.id,
                "hit an obstacle ",
                targetCell2.obstacle.id,
                "w/ a",
                ownerWeaponType,
                "@ ",
                targetCell2.number,
                "and destroyed it. Drop items, leave rubble?"
              );
              let itemsToDrop = [];
              if (
                targetCell2.obstacle.destructible.leaveRubble === true &&
                targetCell2.terrain.type !== "void" &&
                targetCell2.terrain.type !== "deep"
              ) {
                // console.log('leave rubble on ',targetCell2.number,'removing obstacle');
                if (targetCell2.obstacle.items[0]) {
                  itemsToDrop = targetCell2.obstacle.items;
                }
                // let cellRef = this.gridInfo.find(elem => elem.number.x === targetCell2.number.x && elem.number.y === targetCell2.number.y);
                targetCell2.rubble = true;
                // targetCell2.terrain.type = 'hazard';

                targetCell2.obstacle = {
                  id: targetCell2.obstacle.id,
                  trap: targetCell2.obstacle.trap,
                  state: false,
                  name: targetCell2.obstacle.name,
                  type: targetCell2.obstacle.type,
                  hp: 0,
                  destructible: targetCell2.obstacle.destructible,
                  locked: targetCell2.obstacle.locked,
                  weight: targetCell2.obstacle.weight,
                  height: targetCell2.obstacle.height,
                  items: targetCell2.obstacle.items,
                  effects: targetCell2.obstacle.effects,
                  moving: targetCell2.obstacle.moving,
                };

                if (ownerType === "player") {
                  this.players[owner.number - 1].statusDisplay = {
                    state: true,
                    status: "Destroyed " + targetCell2.obstacle.name + "!",
                    count: 1,
                    limit: this.players[owner.number - 1].statusDisplay.limit,
                  };

                  if (!owner.popups.find((x) => x.msg === "destroyedItem")) {
                    owner.popups.push({
                      state: false,
                      count: 0,
                      limit: 30,
                      type: "",
                      position: "",
                      msg: "destroyedItem",
                      img: "",
                    });
                  }
                }
              } else {
                // console.log('no rubble. Just remove obstacle');
                if (targetCell2.obstacle.items[0]) {
                  itemsToDrop = targetCell2.obstacle.items;
                }

                targetCell2.obstacle = {
                  id: targetCell2.obstacle.id,
                  trap: targetCell2.obstacle.trap,
                  state: false,
                  name: targetCell2.obstacle.name,
                  type: targetCell2.obstacle.type,
                  hp: 0,
                  destructible: targetCell2.obstacle.destructible,
                  locked: targetCell2.obstacle.locked,
                  weight: targetCell2.obstacle.weight,
                  height: targetCell2.obstacle.height,
                  items: targetCell2.obstacle.items,
                  effects: targetCell2.obstacle.effects,
                  moving: targetCell2.obstacle.moving,
                };

                if (ownerType === "player") {
                  this.players[owner.number - 1].statusDisplay = {
                    state: true,
                    status: "Destroyed " + targetCell2.obstacle.name + "!",
                    count: 1,
                    limit: this.players[owner.number - 1].statusDisplay.limit,
                  };

                  if (!owner.popups.find((x) => x.msg === "destroyedItem")) {
                    owner.popups.push({
                      state: false,
                      count: 0,
                      limit: 30,
                      type: "",
                      position: "",
                      msg: "destroyedItem",
                      img: "",
                    });
                  }
                }
              }

              // DROP OBSTACLE ITEMS?
              if (itemsToDrop[0]) {
                // console.log('dropping obstacle items bolt',itemsToDrop);

                this.obstacleItemDrop(targetCell2, owner);
              }
              this.obstacleBarrierToDestroy.push({
                type: "obstacle",
                action: "destroy",
                count: 0,
                limit: 30,
                complete: false,
                cell: targetCell2,
              });
            }
          }

          // WEAPON NO GOOD. PUSH OBSTACLE?
          else {
            // console.log(
            //   "your current weapon cannot destroy this, you need ",
            //   targetCell2.obstacle.destructible.weapons,
            //   ". Deflect player?"
            // );
            console.log(
              ownerType,
              owner.number,
              owner.id,
              "hit an obstacle ",
              targetCell2.obstacle.id,
              "w/ a",
              ownerWeaponType,
              "@ ",
              targetCell2.number,
              " but their current weapon cannot destroy this, they need",
              targetCell2.obstacle.destructible.weapons,
              ". pushback obstacle. Deflect attacker?"
            );
            if (
              !this.cellPopups.find(
                (x) =>
                  x.msg === "unbreakable" &&
                  x.cell.number.x === targetCell2.number.x &&
                  x.cell.number.y === targetCell2.number.y
              )
            ) {
              this.cellPopups.push({
                state: false,
                count: 0,
                limit: 35,
                type: "",
                position: "",
                msg: "unbreakable",
                color: "",
                img: "",
                cell: this.gridInfo.find(
                  (x) =>
                    x.number.x === targetCell2.number.x &&
                    x.number.y === targetCell2.number.y
                ),
              });
            }

            if (this.rnJesus(0, 2) === 1) {
              if (type === "bolt" || type === "flyOverBolt") {
                this.canPushObstacle(
                  ownerType,
                  owner,
                  targetCell2,
                  `hitPushBolt_${bolt.direction}`
                );
              }
              if (type === "melee") {
                this.canPushObstacle(ownerType, owner, targetCell2, `hitPush`);
              }
            }

            // DEFLECT PLAYER
            if (type === "melee" && ownerType === "player") {
              let shouldDeflect = this.rnJesus(1, owner.crits.guardBreak);

              if (shouldDeflect === 1) {
                if (this.rnJesus(1, owner.crits.pushBack) === 1) {
                  this.setDeflection(owner, "defended", true);
                } else {
                  this.setDeflection(owner, "defended", false);
                }

                if (owner.currentWeapon.name === "") {
                  console.log("this obstacle is stronger than your fist. Take damage?");
                  let takeDamage = this.rnJesus(1, owner.crits.guardBreak);
                  if (takeDamage === 1) {
                    this.handleMiscPlayerDamage(owner, "obstacleBarrierInvulnurable");
                  }
                }
              } else {
                this.pushBack(owner, this.getOppositeDirection(owner.direction));
              }
            }
          }
        }
        // INDESTRUCTIBLE OBSTACLE. PUSH OBSTACLE?
        else {
          // console.log('attacking invurnerable obstacle w/ bolt');
          console.log(
            ownerType,
            owner.number,
            owner.id,
            "hit an obstacle ",
            targetCell2.obstacle.id,
            "w/ a",
            ownerWeaponType,
            "@ ",
            targetCell2.number,
            " but it is indestructible. pushback obstacle. Deflect, pushback attacker?"
          );
          if (
            !this.cellPopups.find(
              (x) =>
                x.msg === "unbreakable" &&
                x.cell.number.x === targetCell2.number.x &&
                x.cell.number.y === targetCell2.number.y
            )
          ) {
            this.cellPopups.push({
              state: false,
              count: 0,
              limit: 35,
              type: "",
              position: "",
              msg: "unbreakable",
              color: "",
              img: "",
              cell: this.gridInfo.find(
                (x) =>
                  x.number.x === targetCell2.number.x &&
                  x.number.y === targetCell2.number.y
              ),
            });
          }
          if (type === "bolt" || type === "flyOverBolt") {
            this.canPushObstacle(
              ownerType,
              owner,
              targetCell2,
              `hitPushBolt_${bolt.direction}`
            );
          }
          if (type === "melee") {
            this.canPushObstacle(ownerType, owner, targetCell2, `hitPush`);
          }

          if (type === "melee" && ownerType === "player") {
            let shouldDeflect = this.rnJesus(1, owner.crits.guardBreak);

            if (shouldDeflect === 1) {
              if (this.rnJesus(1, owner.crits.pushBack) === 1) {
                this.setDeflection(owner, "defended", true);
              } else {
                this.setDeflection(owner, "defended", false);
              }

              if (owner.currentWeapon.name === "") {
                console.log("this obstacle is stronger than your fist. Take damage?");
                let takeDamage = this.rnJesus(1, owner.crits.guardBreak);
                if (takeDamage === 1) {
                  this.handleMiscPlayerDamage(owner, "obstacleBarrierInvulnurable");
                }
              }
            } else {
              this.pushBack(owner, this.getOppositeDirection(owner.direction));
            }
          }
        }
      }

      if (type === "bolt" || type === "flyOverBolt") {
        this.projectiles.find((blt) => blt.id === bolt.id).kill = true;
      }
    };
    const handleBarrierDamage = (barrierType, calcedDamage, range) => {
      if (barrierType === "myCellBarrier") {
        if (myCell.barrier.destructible.state === true) {
          // WEAPON CHECK
          if (ownerType === "player") {
            ownerWeaponName = owner.currentWeapon.name;
          } else {
            ownerWeaponName = owner.trap.itemNameRef;
          }
          if (type === "bolt" || type === "flyOverBolt") {
            if (myCell.barrier.destructible.weapons.find((x) => x === "bolt")) {
              weaponCheck = true;
            }
          }
          if (
            type === "melee" &&
            myCell.barrier.destructible.weapons.find((x) => x === ownerWeaponName)
          ) {
            weaponCheck = true;
          }
          if (weaponCheck === true) {
            // DAMAGE, DON'T DESTROY FWD BARRIER
            if (myCell.barrier.hp - calcedDamage > 0) {
              console.log(
                ownerType,
                owner.number,
                owner.id,
                "hit a barrier ",
                myCell.barrier.id,
                "w/ a",
                ownerWeaponType,
                "@ ",
                myCell.number,
                " and damaged it."
              );
              // this.gridInfo.find(elem => elem.number.x === myCell.number.x && elem.number.y === myCell.number.y ).barrier.hp -= calcedDamage;

              let hp = myCell.barrier.hp - calcedDamage;

              myCell.barrier = {
                id: myCell.barrier.id,
                trap: myCell.barrier.trap,
                state: myCell.barrier.state,
                name: myCell.barrier.name,
                type: myCell.barrier.type,
                hp: hp,
                destructible: myCell.barrier.destructible,
                locked: myCell.barrier.locked,
                position: myCell.barrier.position,
                height: myCell.barrier.height,
              };

              this.obstacleBarrierToDestroy.push({
                type: "barrier",
                action: "damage",
                count: 0,
                limit: 30,
                complete: false,
                cell: myCell,
              });
            }

            // DESTROY FWD BARRIER W/ OR W/O RUBBLE
            else if (myCell.barrier.hp - calcedDamage <= 0) {
              console.log(
                ownerType,
                owner.number,
                owner.id,
                "hit a barrier ",
                myCell.barrier.id,
                "w/ a",
                ownerWeaponType,
                "@ ",
                myCell.number,
                " and destroyed it. leave rubble?"
              );
              if (
                myCell.barrier.destructible.leaveRubble === true &&
                myCell.obstacle.state !== true &&
                myCell.item.name === "" &&
                myCell.terrain.type !== "void" &&
                myCell.terrain.type !== "deep"
              ) {
                // console.log("leave rubble on ", myCell.number, "removing barrier");
                myCell.rubble = true;
                // myCell.terrain.type = 'hazard';

                myCell.barrier = {
                  id: myCell.barrier.id,
                  trap: myCell.barrier.trap,
                  state: false,
                  name: myCell.barrier.name,
                  type: myCell.barrier.type,
                  hp: 0,
                  destructible: myCell.barrier.destructible,
                  locked: myCell.barrier.locked,
                  position: myCell.barrier.position,
                  height: myCell.barrier.height,
                };

                if (ownerType === "player") {
                  this.players[owner.number - 1].statusDisplay = {
                    state: true,
                    status: "Destroyed " + myCell.barrier.name + "!",
                    count: 1,
                    limit: this.players[owner.number - 1].statusDisplay.limit,
                  };

                  if (!owner.popups.find((x) => x.msg === "destroyedItem")) {
                    owner.popups.push({
                      state: false,
                      count: 0,
                      limit: 30,
                      type: "",
                      position: "",
                      msg: "destroyedItem",
                      img: "",
                    });
                  }
                }
              } else {
                // console.log('no rubble. Just remove barrier');
                myCell.barrier = {
                  id: myCell.barrier.id,
                  trap: myCell.barrier.trap,
                  state: false,
                  name: myCell.barrier.name,
                  type: myCell.barrier.type,
                  hp: 0,
                  destructible: myCell.barrier.destructible,
                  locked: myCell.barrier.locked,
                  position: myCell.barrier.position,
                  height: myCell.barrier.height,
                };

                if (ownerType === "player") {
                  this.players[owner.number - 1].statusDisplay = {
                    state: true,
                    status: "Destroyed " + myCell.barrier.name + "!",
                    count: 1,
                    limit: this.players[owner.number - 1].statusDisplay.limit,
                  };

                  if (!owner.popups.find((x) => x.msg === "destroyedItem")) {
                    owner.popups.push({
                      state: false,
                      count: 0,
                      limit: 30,
                      type: "",
                      position: "",
                      msg: "destroyedItem",
                      img: "",
                    });
                  }
                }
              }

              this.obstacleBarrierToDestroy.push({
                type: "barrier",
                action: "destroy",
                count: 0,
                limit: 30,
                complete: false,
                cell: myCell,
              });
            }
          }

          // WEAPON NO GOOD
          else {
            // console.log(
            //   "your current weapon cannot destroy this, you need ",
            //   myCell.obstacle.weapons,
            //   ". Deflect player?"
            // );
            console.log(
              ownerType,
              owner.number,
              owner.id,
              "hit an barrier ",
              myCell.barrier.id,
              "w/ a",
              ownerWeaponType,
              "@ ",
              myCell.number,
              " but their current weapon cannot destroy this, they need",
              myCell.barrier.destructible.weapons,
              ". Deflect, pushback attacker?"
            );
            if (
              !this.cellPopups.find(
                (x) =>
                  x.msg === "unbreakable" &&
                  x.cell.number.x === myCell.number.x &&
                  x.cell.number.y === myCell.number.y
              )
            ) {
              this.cellPopups.push({
                state: false,
                count: 0,
                limit: 35,
                type: "",
                position: "",
                msg: "unbreakable",
                color: "",
                img: "",
                cell: this.gridInfo.find(
                  (x) => x.number.x === myCell.number.x && x.number.y === myCell.number.y
                ),
              });
            }

            if (type === "melee" && ownerType === "player") {
              let shouldDeflect = this.rnJesus(1, owner.crits.guardBreak);

              if (shouldDeflect === 1) {
                if (this.rnJesus(1, owner.crits.pushBack) === 1) {
                  this.setDeflection(owner, "defended", true);
                } else {
                  this.setDeflection(owner, "defended", false);
                }

                if (owner.currentWeapon.name === "") {
                  console.log("this barrier is stronger than your fist. Take damage?");
                  let takeDamage = this.rnJesus(1, owner.crits.guardBreak);
                  if (takeDamage === 1) {
                    this.handleMiscPlayerDamage(owner, "obstacleBarrierInvulnurable");
                  }
                }
              } else {
                this.pushBack(owner, this.getOppositeDirection(owner.direction));
              }
            }
          }
        }

        // INDESTRUCTIBLE FWD BARRIER
        else {
          // console.log('attacking invurnerable barrier w/ bolt');
          console.log(
            ownerType,
            owner.number,
            owner.id,
            "hit an barrier ",
            myCell.barrier.id,
            "w/ a",
            ownerWeaponType,
            "@ ",
            myCell.number,
            " but it is indestructible. Deflect,pushback attacker?"
          );
          if (
            !this.cellPopups.find(
              (x) =>
                x.msg === "unbreakable" &&
                x.cell.number.x === myCell.number.x &&
                x.cell.number.y === myCell.number.y
            )
          ) {
            this.cellPopups.push({
              state: false,
              count: 0,
              limit: 35,
              type: "",
              position: "",
              msg: "unbreakable",
              color: "",
              img: "",
              cell: this.gridInfo.find(
                (x) => x.number.x === myCell.number.x && x.number.y === myCell.number.y
              ),
            });
          }

          if (type === "melee" && ownerType === "player") {
            let shouldDeflect = this.rnJesus(1, owner.crits.guardBreak);

            if (shouldDeflect === 1) {
              if (this.rnJesus(1, owner.crits.pushBack) === 1) {
                this.setDeflection(owner, "defended", true);
              } else {
                this.setDeflection(owner, "defended", false);
              }

              if (owner.currentWeapon.name === "") {
                console.log("this barrier is stronger than your fist. Take damage?");
                let takeDamage = this.rnJesus(1, owner.crits.guardBreak);
                if (takeDamage === 1) {
                  this.handleMiscPlayerDamage(owner, "obstacleBarrierInvulnurable");
                }
              }
            } else {
              this.pushBack(owner, this.getOppositeDirection(owner.direction));
            }
          }
        }
      } else {
        if (range === 1) {
          if (targetCell.barrier.destructible.state === true) {
            // WEAPON CHECK
            if (ownerType === "player") {
              ownerWeaponName = owner.currentWeapon.name;
            } else {
              ownerWeaponName = owner.trap.itemNameRef;
            }
            if (type === "bolt" || type === "flyOverBolt") {
              if (targetCell.barrier.destructible.weapons.find((x) => x === "bolt")) {
                weaponCheck = true;
              }
            }
            if (
              type === "melee" &&
              targetCell.barrier.destructible.weapons.find((x) => x === ownerWeaponName)
            ) {
              weaponCheck = true;
            }
            if (weaponCheck === true) {
              // DAMAGE, DON'T DESTROY FWD BARRIER
              if (targetCell.barrier.hp - calcedDamage > 0) {
                console.log(
                  ownerType,
                  owner.number,
                  owner.id,
                  "hit an barrier ",
                  targetCell.barrier.id,
                  "w/ a",
                  ownerWeaponType,
                  "@ ",
                  targetCell.number,
                  " and damaged it"
                );
                // this.gridInfo.find(elem => elem.number.x === targetCell.number.x && elem.number.y === targetCell.number.y ).barrier.hp -= calcedDamage;

                let hp = targetCell.barrier.hp - calcedDamage;

                targetCell.barrier = {
                  id: targetCell.barrier.id,
                  trap: targetCell.barrier.trap,
                  state: targetCell.barrier.state,
                  name: targetCell.barrier.name,
                  type: targetCell.barrier.type,
                  hp: hp,
                  destructible: targetCell.barrier.destructible,
                  locked: targetCell.barrier.locked,
                  position: targetCell.barrier.position,
                  height: targetCell.barrier.height,
                };

                this.obstacleBarrierToDestroy.push({
                  type: "barrier",
                  action: "damage",
                  count: 0,
                  limit: 30,
                  complete: false,
                  cell: targetCell,
                });
              }

              // DESTROY FWD BARRIER W/ OR W/O RUBBLE
              else if (targetCell.barrier.hp - calcedDamage <= 0) {
                console.log(
                  ownerType,
                  owner.number,
                  owner.id,
                  "hit an barrier ",
                  targetCell.barrier.id,
                  "w/ a",
                  ownerWeaponType,
                  "@ ",
                  targetCell.number,
                  " and destroyed it"
                );
                if (
                  targetCell.barrier.destructible.leaveRubble === true &&
                  targetCell.obstacle.state !== true &&
                  targetCell.item.name === "" &&
                  targetCell.terrain.type !== "void" &&
                  targetCell.terrain.type !== "deep"
                ) {
                  // console.log("leave rubble on ", targetCell.number, "removing barrier");
                  targetCell.rubble = true;
                  // targetCell.terrain.type = 'hazard';

                  targetCell.barrier = {
                    id: targetCell.barrier.id,
                    trap: targetCell.barrier.trap,
                    state: false,
                    name: targetCell.barrier.name,
                    type: targetCell.barrier.type,
                    hp: 0,
                    destructible: targetCell.barrier.destructible,
                    locked: targetCell.barrier.locked,
                    position: targetCell.barrier.position,
                    height: targetCell.barrier.height,
                  };

                  if (ownerType === "player") {
                    this.players[owner.number - 1].statusDisplay = {
                      state: true,
                      status: "Destroyed " + targetCell.barrier.name + "!",
                      count: 1,
                      limit: this.players[owner.number - 1].statusDisplay.limit,
                    };

                    if (!owner.popups.find((x) => x.msg === "destroyedItem")) {
                      owner.popups.push({
                        state: false,
                        count: 0,
                        limit: 30,
                        type: "",
                        position: "",
                        msg: "destroyedItem",
                        img: "",
                      });
                    }
                  }
                } else {
                  // console.log('no rubble. Just remove barrier');
                  targetCell.barrier = {
                    id: targetCell.barrier.id,
                    trap: targetCell.barrier.trap,
                    state: false,
                    name: targetCell.barrier.name,
                    type: targetCell.barrier.type,
                    hp: 0,
                    destructible: targetCell.barrier.destructible,
                    locked: targetCell.barrier.locked,
                    position: targetCell.barrier.position,
                    height: targetCell.barrier.height,
                  };

                  if (ownerType === "player") {
                    this.players[owner.number - 1].statusDisplay = {
                      state: true,
                      status: "Destroyed " + targetCell.barrier.name + "!",
                      count: 1,
                      limit: this.players[owner.number - 1].statusDisplay.limit,
                    };

                    if (!owner.popups.find((x) => x.msg === "destroyedItem")) {
                      owner.popups.push({
                        state: false,
                        count: 0,
                        limit: 30,
                        type: "",
                        position: "",
                        msg: "destroyedItem",
                        img: "",
                      });
                    }
                  }
                }

                this.obstacleBarrierToDestroy.push({
                  type: "barrier",
                  action: "destroy",
                  count: 0,
                  limit: 30,
                  complete: false,
                  cell: targetCell,
                });
              }
            }

            // WEAPON NO GOOD
            else {
              // console.log(
              //   "your current weapon cannot destroy this, you need ",
              //   targetCell.obstacle.weapons,
              //   ". Deflect player?"
              // );
              console.log(
                ownerType,
                owner.number,
                owner.id,
                "hit an barrier ",
                targetCell.barrier.id,
                "w/ a",
                ownerWeaponType,
                "@ ",
                targetCell.number,
                " but their current weapon cannot destroy this, they need",
                targetCell.barrier.destructible.weapons,
                ". Deflect,pushback attacker?"
              );
              if (
                !this.cellPopups.find(
                  (x) =>
                    x.msg === "unbreakable" &&
                    x.cell.number.x === targetCell.number.x &&
                    x.cell.number.y === targetCell.number.y
                )
              ) {
                this.cellPopups.push({
                  state: false,
                  count: 0,
                  limit: 35,
                  type: "",
                  position: "",
                  msg: "unbreakable",
                  color: "",
                  img: "",
                  cell: this.gridInfo.find(
                    (x) =>
                      x.number.x === targetCell.number.x &&
                      x.number.y === targetCell.number.y
                  ),
                });
              }

              if (type === "melee" && ownerType === "player") {
                let shouldDeflect = this.rnJesus(1, owner.crits.guardBreak);

                if (shouldDeflect === 1) {
                  if (this.rnJesus(1, owner.crits.pushBack) === 1) {
                    this.setDeflection(owner, "defended", true);
                  } else {
                    this.setDeflection(owner, "defended", false);
                  }

                  if (owner.currentWeapon.name === "") {
                    console.log("this barrier is stronger than your fist. Take damage?");
                    let takeDamage = this.rnJesus(1, owner.crits.guardBreak);
                    if (takeDamage === 1) {
                      this.handleMiscPlayerDamage(owner, "obstacleBarrierInvulnurable");
                    }
                  }
                } else {
                  this.pushBack(owner, this.getOppositeDirection(owner.direction));
                }
              }
            }
          }

          // INDESTRUCTIBLE FWD BARRIER
          else {
            console.log(
              ownerType,
              owner.number,
              owner.id,
              "hit an barrier ",
              targetCell.barrier.id,
              "w/ a",
              ownerWeaponType,
              "@ ",
              targetCell.number,
              " but it is indestructible. Deflect,pushback attacker?"
            );
            // console.log('attacking invurnerable barrier w/ bolt');
            if (
              !this.cellPopups.find(
                (x) =>
                  x.msg === "unbreakable" &&
                  x.cell.number.x === targetCell.number.x &&
                  x.cell.number.y === targetCell.number.y
              )
            ) {
              this.cellPopups.push({
                state: false,
                count: 0,
                limit: 35,
                type: "",
                position: "",
                msg: "unbreakable",
                color: "",
                img: "",
                cell: this.gridInfo.find(
                  (x) =>
                    x.number.x === targetCell.number.x &&
                    x.number.y === targetCell.number.y
                ),
              });
            }

            if (type === "melee" && ownerType === "player") {
              let shouldDeflect = this.rnJesus(1, owner.crits.guardBreak);

              if (shouldDeflect === 1) {
                if (this.rnJesus(1, owner.crits.pushBack) === 1) {
                  this.setDeflection(owner, "defended", true);
                } else {
                  this.setDeflection(owner, "defended", false);
                }

                if (owner.currentWeapon.name === "") {
                  console.log("this barrier is stronger than your fist. Take damage?");
                  let takeDamage = this.rnJesus(1, owner.crits.guardBreak);
                  if (takeDamage === 1) {
                    this.handleMiscPlayerDamage(owner, "obstacleBarrierInvulnurable");
                  }
                }
              } else {
                this.pushBack(owner, this.getOppositeDirection(owner.direction));
              }
            }
          }
        } else {
          if (targetCell2.barrier.destructible.state === true) {
            // WEAPON CHECK
            if (ownerType === "player") {
              ownerWeaponName = owner.currentWeapon.name;
            } else {
              ownerWeaponName = owner.trap.itemNameRef;
            }
            if (type === "bolt" || type === "flyOverBolt") {
              if (targetCell2.barrier.destructible.weapons.find((x) => x === "bolt")) {
                weaponCheck = true;
              }
            }
            if (
              type === "melee" &&
              targetCell2.barrier.destructible.weapons.find((x) => x === ownerWeaponName)
            ) {
              weaponCheck = true;
            }
            if (weaponCheck === true) {
              // DAMAGE, DON'T DESTROY FWD BARRIER
              if (targetCell2.barrier.hp - calcedDamage > 0) {
                console.log(
                  ownerType,
                  owner.number,
                  owner.id,
                  "hit an barrier ",
                  targetCell2.barrier.id,
                  "w/ a",
                  ownerWeaponType,
                  "@ ",
                  targetCell2.number,
                  " and damaged it"
                );
                // this.gridInfo.find(elem => elem.number.x === targetCell2.number.x && elem.number.y === targetCell2.number.y ).barrier.hp -= calcedDamage;

                let hp = targetCell2.barrier.hp - calcedDamage;

                targetCell2.barrier = {
                  id: targetCell2.barrier.id,
                  trap: targetCell2.barrier.trap,
                  state: targetCell2.barrier.state,
                  name: targetCell2.barrier.name,
                  type: targetCell2.barrier.type,
                  hp: hp,
                  destructible: targetCell2.barrier.destructible,
                  locked: targetCell2.barrier.locked,
                  position: targetCell2.barrier.position,
                  height: targetCell2.barrier.height,
                };

                this.obstacleBarrierToDestroy.push({
                  type: "barrier",
                  action: "damage",
                  count: 0,
                  limit: 30,
                  complete: false,
                  cell: targetCell2,
                });
              }

              // DESTROY FWD BARRIER W/ OR W/O RUBBLE
              else if (targetCell2.barrier.hp - calcedDamage <= 0) {
                console.log(
                  ownerType,
                  owner.number,
                  owner.id,
                  "hit an barrier ",
                  targetCell2.barrier.id,
                  "w/ a",
                  ownerWeaponType,
                  "@ ",
                  targetCell2.number,
                  " and destroyed it"
                );
                if (
                  targetCell2.barrier.destructible.leaveRubble === true &&
                  targetCell2.obstacle.state !== true &&
                  targetCell2.item.name === "" &&
                  targetCell2.terrain.type !== "void" &&
                  targetCell2.terrain.type !== "deep"
                ) {
                  // console.log("leave rubble on ", targetCell2.number, "removing barrier");
                  targetCell2.rubble = true;
                  // targetCell2.terrain.type = 'hazard';

                  targetCell2.barrier = {
                    id: targetCell2.barrier.id,
                    trap: targetCell2.barrier.trap,
                    state: false,
                    name: targetCell2.barrier.name,
                    type: targetCell2.barrier.type,
                    hp: 0,
                    destructible: targetCell2.barrier.destructible,
                    locked: targetCell2.barrier.locked,
                    position: targetCell2.barrier.position,
                    height: targetCell2.barrier.height,
                  };

                  if (ownerType === "player") {
                    this.players[owner.number - 1].statusDisplay = {
                      state: true,
                      status: "Destroyed " + targetCell2.barrier.name + "!",
                      count: 1,
                      limit: this.players[owner.number - 1].statusDisplay.limit,
                    };

                    if (!owner.popups.find((x) => x.msg === "destroyedItem")) {
                      owner.popups.push({
                        state: false,
                        count: 0,
                        limit: 30,
                        type: "",
                        position: "",
                        msg: "destroyedItem",
                        img: "",
                      });
                    }
                  }
                } else {
                  // console.log('no rubble. Just remove barrier');
                  targetCell2.barrier = {
                    id: targetCell2.barrier.id,
                    trap: targetCell2.barrier.trap,
                    state: false,
                    name: targetCell2.barrier.name,
                    type: targetCell2.barrier.type,
                    hp: 0,
                    destructible: targetCell2.barrier.destructible,
                    locked: targetCell2.barrier.locked,
                    position: targetCell2.barrier.position,
                    height: targetCell2.barrier.height,
                  };

                  if (ownerType === "player") {
                    this.players[owner.number - 1].statusDisplay = {
                      state: true,
                      status: "Destroyed " + targetCell2.barrier.name + "!",
                      count: 1,
                      limit: this.players[owner.number - 1].statusDisplay.limit,
                    };

                    if (!owner.popups.find((x) => x.msg === "destroyedItem")) {
                      owner.popups.push({
                        state: false,
                        count: 0,
                        limit: 30,
                        type: "",
                        position: "",
                        msg: "destroyedItem",
                        img: "",
                      });
                    }
                  }
                }

                this.obstacleBarrierToDestroy.push({
                  type: "barrier",
                  action: "destroy",
                  count: 0,
                  limit: 30,
                  complete: false,
                  cell: targetCell2,
                });
              }
            }

            // WEAPON NO GOOD
            else {
              // console.log(
              //   "your current weapon cannot destroy this, you need ",
              //   targetCell2.obstacle.weapons,
              //   ". Deflect player?"
              // );
              onsole.log(
                ownerType,
                owner.number,
                owner.id,
                "hit an barrier ",
                targetCell2.barrier.id,
                "w/ a",
                ownerWeaponType,
                "@ ",
                targetCell2.number,
                " but their current weapon cannot destroy this, they need",
                targetCell2.barrier.destructible.weapons,
                ". Deflect,pushback attacker?"
              );
              if (
                !this.cellPopups.find(
                  (x) =>
                    x.msg === "unbreakable" &&
                    x.cell.number.x === targetCell2.number.x &&
                    x.cell.number.y === targetCell2.number.y
                )
              ) {
                this.cellPopups.push({
                  state: false,
                  count: 0,
                  limit: 35,
                  type: "",
                  position: "",
                  msg: "unbreakable",
                  color: "",
                  img: "",
                  cell: this.gridInfo.find(
                    (x) =>
                      x.number.x === targetCell2.number.x &&
                      x.number.y === targetCell2.number.y
                  ),
                });
              }

              if (type === "melee" && ownerType === "player") {
                let shouldDeflect = this.rnJesus(1, owner.crits.guardBreak);

                if (shouldDeflect === 1) {
                  if (this.rnJesus(1, owner.crits.pushBack) === 1) {
                    this.setDeflection(owner, "defended", true);
                  } else {
                    this.setDeflection(owner, "defended", false);
                  }

                  if (owner.currentWeapon.name === "") {
                    console.log("this barrier is stronger than your fist. Take damage?");
                    let takeDamage = this.rnJesus(1, owner.crits.guardBreak);
                    if (takeDamage === 1) {
                      this.handleMiscPlayerDamage(owner, "obstacleBarrierInvulnurable");
                    }
                  }
                } else {
                  this.pushBack(owner, this.getOppositeDirection(owner.direction));
                }
              }
            }
          }

          // INDESTRUCTIBLE FWD BARRIER
          else {
            console.log(
              ownerType,
              owner.number,
              owner.id,
              "hit an barrier ",
              targetCell2.barrier.id,
              "w/ a",
              ownerWeaponType,
              "@ ",
              targetCell2.number,
              " but it is indestructible. deflected, pushback attack?"
            );
            // console.log('attacking invurnerable barrier w/ bolt');
            if (
              !this.cellPopups.find(
                (x) =>
                  x.msg === "unbreakable" &&
                  x.cell.number.x === targetCell2.number.x &&
                  x.cell.number.y === targetCell2.number.y
              )
            ) {
              this.cellPopups.push({
                state: false,
                count: 0,
                limit: 35,
                type: "",
                position: "",
                msg: "unbreakable",
                color: "",
                img: "",
                cell: this.gridInfo.find(
                  (x) =>
                    x.number.x === targetCell2.number.x &&
                    x.number.y === targetCell2.number.y
                ),
              });
            }

            if (type === "melee" && ownerType === "player") {
              let shouldDeflect = this.rnJesus(1, owner.crits.guardBreak);

              if (shouldDeflect === 1) {
                if (this.rnJesus(1, owner.crits.pushBack) === 1) {
                  this.setDeflection(owner, "defended", true);
                } else {
                  this.setDeflection(owner, "defended", false);
                }

                if (owner.currentWeapon.name === "") {
                  console.log("this barrier is stronger than your fist. Take damage?");
                  let takeDamage = this.rnJesus(1, owner.crits.guardBreak);
                  if (takeDamage === 1) {
                    this.handleMiscPlayerDamage(owner, "obstacleBarrierInvulnurable");
                  }
                }
              } else {
                this.pushBack(owner, this.getOppositeDirection(owner.direction));
              }
            }
          }
        }
      }

      // bolt.kill = true;
      if (type === "bolt" || type === "flyOverBolt") {
        this.projectiles.find((blt) => blt.id === bolt.id).kill = true;
      }
    };
    // DESTROY ITEMS AND RUBBLE
    const handleNonObstacleBarrierDamage = (calcedDamage, range) => {
      if (ownerType === "player") {
        ownerWeaponName = owner.currentWeapon.name;
      } else {
        ownerWeaponName = owner.trap.itemNameRef;
      }
      if (range === 1) {
        if (
          targetCell &&
          targetCell.item.name !== "" &&
          calcedDamage > 0 &&
          ownerWeaponName !== ""
        ) {
          console.log(
            ownerType,
            owner.number,
            owner.id,
            "hit an item ",
            targetCell.item.name,
            "w/ a",
            ownerWeaponType,
            "@ ",
            targetCell.number,
            " and destroyed it."
          );

          if (ownerType === "player") {
            this.players[owner.number - 1].statusDisplay = {
              state: true,
              status: "Destroyed " + targetCell.item.name + "!",
              count: 1,
              limit: this.players[owner.number - 1].statusDisplay.limit,
            };

            if (!owner.popups.find((x) => x.msg === "destroyedItem")) {
              owner.popups.push({
                state: false,
                count: 0,
                limit: 30,
                type: "",
                position: "",
                msg: "destroyedItem",
                img: "",
              });
            }
          }

          this.gridInfo.find(
            (elem) =>
              elem.number.x === targetCell.number.x &&
              elem.number.y === targetCell.number.y
          ).item = {
            name: "",
            type: "",
            subType: "",
            effect: "",
            initDrawn: false,
          };
        }

        if ((targetCell.rubble === true) & (calcedDamage > 0)) {
          console.log(
            ownerType,
            owner.number,
            owner.id,
            "hit rubble w/ a",
            ownerWeaponType,
            "@ ",
            targetCell.number,
            " and destroyed it."
          );
          this.gridInfo.find(
            (elem) =>
              elem.number.x === targetCell.number.x &&
              elem.number.y === targetCell.number.y
          ).rubble = false;
        }
      } else {
        if (
          targetCell2 &&
          targetCell2.item.name !== "" &&
          calcedDamage > 0 &&
          ownerWeaponName !== ""
        ) {
          console.log(
            ownerType,
            owner.number,
            owner.id,
            "hit an item ",
            targetCell2.item.name,
            "w/ a",
            ownerWeaponType,
            "@ ",
            targetCell2.number,
            " and destroyed it."
          );
          if (ownerType === "player") {
            this.players[owner.number - 1].statusDisplay = {
              state: true,
              status: "Destroyed " + targetCell2.item.name + "!",
              count: 1,
              limit: this.players[owner.number - 1].statusDisplay.limit,
            };

            if (!owner.popups.find((x) => x.msg === "destroyedItem")) {
              owner.popups.push({
                state: false,
                count: 0,
                limit: 30,
                type: "",
                position: "",
                msg: "destroyedItem",
                img: "",
              });
            }
          }

          this.gridInfo.find(
            (elem) =>
              elem.number.x === targetCell2.number.x &&
              elem.number.y === targetCell2.number.y
          ).item = {
            name: "",
            type: "",
            subType: "",
            effect: "",
            initDrawn: false,
          };
        }

        if ((targetCell2.rubble === true) & (calcedDamage > 0)) {
          console.log(
            ownerType,
            owner.number,
            owner.id,
            "hit rubble w/ a",
            ownerWeaponType,
            "@ ",
            targetCell2.number,
            " and destroyed it."
          );
          // console.log('damage/clear rubble @ ',targetCell2.number);
          this.gridInfo.find(
            (elem) =>
              elem.number.x === targetCell2.number.x &&
              elem.number.y === targetCell2.number.y
          ).rubble = false;
        }
      }
    };
    if (type === "melee") {
      let doubleHitChance;
      let singleHitChance;
      if (ownerType === "player") {
        ownerWeaponType = owner.currentWeapon.type;
        doubleHitChance = owner.crits.doubleHit;
        singleHitChance = owner.crits.singleHit;
        ownerDirection = owner.direction;
      } else {
        ownerWeaponType = owner.trap.item.subType;
        doubleHitChance = 2;
        singleHitChance = 1;
        ownerDirection = this.getDirectionFromCells(myCell.number, owner.trap.target);
      }

      let doubleHit = this.rnJesus(1, doubleHitChance);
      let singleHit = this.rnJesus(1, singleHitChance);

      if (doubleHit === 1) {
        damage = 2;
      } else {
        damage = 1;
      }
      let shouldDamage = 0;
      if (ownerType === "player") {
        if (owner.attacking.blunt === true) {
          shouldDamage = this.rnJesus(1, owner.crits.guardBreak);
          if ((shouldDamage = 1)) {
            damage = 1;
          } else {
            damage = 0;
          }
        }
        if (owner.currentWeapon.name === "") {
          shouldDamage = this.rnJesus(1, owner.crits.guardBreak + 3);
          if ((shouldDamage = 1)) {
            damage = 1;
          } else {
            damage = 0;
          }
        }
      }

      // AT ELEVATION
      if (targetCell) {
        if (targetCell.elevation.number < myCell.elevation.number + 1) {
          let checkSpearTarget = false;
          // set this false if first target obstacles or barrier industructible or not destroyed

          // SWORD/ RANGE === 1 ATTACK
          if (ownerWeaponType !== "spear") {
            // MY CELL BARRIER?
            let myCellBarrier = false;
            if (myCell.barrier.state === true) {
              if (myCell.barrier.position === ownerDirection) {
                myCellBarrier = true;

                handleBarrierDamage("myCellBarrier", damage, 0);
              }
            }

            // FWD BARRIER?
            let fwdBarrier = false;
            if (targetCell.barrier.state === true) {
              fwdBarrier = this.checkForwardBarrier(ownerDirection, targetCell);
            }

            if (fwdBarrier === true) {
              handleBarrierDamage("fwdBarrier", damage, 1);
            }

            // NO FWD BARRIER. OBSTACLE, REAR  BARRIER (SPEAR)?
            else if (fwdBarrier !== true && myCellBarrier !== true) {
              if (targetCell.obstacle.state === true) {
                handleObstacleDamage(damage, 1);
              } else {
                // NO OBSTACLE. ITEM ON GROUND? DESTROY

                handleNonObstacleBarrierDamage(damage, 1);

                // NO OBSTACLE. ITEM OR RUBBLE. DESTROY REAR BARRIER

                // else {
                //   // do nothing
                // }
              }
            }
          }

          // CHECK 1ST CELL, SPEAR TARGET 1
          if (ownerWeaponType === "spear") {
            let myCellBarrier = false;
            if (myCell.barrier.state === true) {
              if (myCell.barrier.position === ownerDirection) {
                myCellBarrier = true;
                handleBarrierDamage("myCellBarrier", damage, 0);
              }
            }

            // FWD BARRIER?
            let fwdBarrier = false;
            if (targetCell.barrier.state === true) {
              fwdBarrier = this.checkForwardBarrier(ownerDirection, targetCell);
            }

            if (myCellBarrier !== true && fwdBarrier === true) {
              handleBarrierDamage("fwdBarrier", damage, 1);
            }

            // NO FWD BARRIER. OBSTACLE, REAR  BARRIER (SPEAR)?
            else if (myCellBarrier !== true && fwdBarrier !== true) {
              if (targetCell.obstacle.state === true) {
                handleObstacleDamage(damage, 1);
              } else {
                // NO OBSTACLE. ITEM ON GROUND? DESTROY

                handleNonObstacleBarrierDamage(damage, 1);

                // NO OBSTACLE. ITEM OR RUBBLE. DESTROY REAR BARRIER

                if (
                  ownerWeaponType === "spear" &&
                  targetCell.item.name === "" &&
                  targetCell.rubble !== true
                ) {
                  let rearBarrier = false;
                  if (targetCell.barrier.state === true) {
                    if (ownerDirection === targetCell.barrier.position) {
                      rearBarrier = true;
                    }
                  }
                  if (rearBarrier === true) {
                    handleBarrierDamage("rearBarrier", damage, 1);
                  } else {
                    // console.log('spear target one no obstructions, atk spear target 2');
                    checkSpearTarget = true;
                  }
                }
                // else {
                //   // do nothing
                // }
              }
            }
          }

          // CHECK 2ND CELL SPEAR TARGET 2
          if (ownerWeaponType === "spear" && checkSpearTarget === true) {
            let targetCell2;
            if (ownerType === "player") {
              targetCell2 = this.gridInfo.find(
                (elem) =>
                  elem.number.x === owner.target.cell2.number.x &&
                  elem.number.y === owner.target.cell2.number.y
              );
            } else {
              targetCell2 = this.gridInfo.find(
                (elem) =>
                  elem.number.x === owner.trap.target.x &&
                  elem.number.y === owner.trap.target.y
              );
            }

            let myCellBarrier = false;
            if (myCell.barrier.state === true) {
              if (myCell.barrier.position === ownerDirection) {
                myCellBarrier = true;
                handleBarrierDamage("myCellBarrier", damage, 0);
              }
            }

            if (targetCell2) {
              let fwdBarrier = false;
              if (targetCell2.barrier.state === true) {
                fwdBarrier = this.checkForwardBarrier(ownerDirection, targetCell2);
              }

              if (fwdBarrier === true) {
                handleBarrierDamage("fwdBarrier", damage, 2);
              }

              // NO FWD BARRIER. OBSTACLE?
              else if (myCellBarrier !== true && fwdBarrier !== true) {
                if (targetCell2.obstacle.state === true) {
                  handleObstacleDamage(damage, 2);
                } else {
                  // NO OBSTACLE. ITEM ON GROUND? DESTROY
                  handleNonObstacleBarrierDamage(damage, 2);

                  // NO OBSTACLE. DESTROY REAR BARRIER
                  if (ownerType === "player") {
                    if (!owner.popups.find((x) => x.msg === "missedAttack2")) {
                      owner.popups.push({
                        state: false,
                        count: 0,
                        limit:
                          owner.attacking.animRef.limit[player.currentWeapon.type] -
                          owner.attacking.animRef.peak[player.currentWeapon.type],
                        type: "",
                        position: "",
                        msg: "missedAttack2",
                        img: "",
                      });
                    }
                  }
                }
              }
            }
          }
        }
        if (targetCell.elevation.number > myCell.elevation.number) {
          console.log("target is above your elevation");
        }
      }

      if (!targetCell) {
        if (myCell.barrier.state === true && myCell.barrier.position === ownerDirection) {
          handleBarrierDamage("myCellBarrier", damage, 0);
        }
      }
    }

    if (type === "bolt") {
      let doubleHitChance;
      let singleHitChance;
      if (ownerType === "player") {
        doubleHitChance = owner.crits.doubleHit;
        singleHitChance = owner.crits.singleHit;
      } else {
        doubleHitChance = 2;
        singleHitChance = 1;
      }
      let doubleHit = this.rnJesus(1, doubleHitChance);
      let singleHit = this.rnJesus(1, singleHitChance);

      if (doubleHit === 1) {
        damage = 2;
      } else {
        damage = 1;
      }

      let myCellBarrier = false;
      if (myCell) {
        if (myCell.barrier.state === true) {
          if (myCell.barrier.position === bolt.direction) {
            myCellBarrier = true;
            handleBarrierDamage("myCellBarrier", damage, 0);
          }
        }
      }

      // FWD BARRIER CHECK
      let fwdBarrier = false;
      if (targetCell.barrier.state === true) {
        fwdBarrier = this.checkForwardBarrier(bolt.direction, targetCell);
      }

      // IF TARGET CELL IS ORIGIN CELL
      if (
        targetCell.number.x === bolt.origin.number.x &&
        targetCell.number.y === bolt.origin.number.y
      ) {
        fwdBarrier = false;
      }

      // FWD BARRIER
      if (
        myCellBarrier !== true &&
        fwdBarrier === true &&
        targetCell.barrier.height >= 1
      ) {
        // console.log('owner ',owner.number,'hit fwd barrier ',targetCell.barrier.name,'@ ',targetCell.number,type);
        handleBarrierDamage("fwdBarrier", damage, 1);
      }

      // NO FWD BARRIER. OBSTACLE?
      if (myCellBarrier !== true && fwdBarrier !== true) {
        if (targetCell.obstacle.state === true && targetCell.obstacle.height >= 1) {
          console.log(
            "player ",
            owner.number,
            "hit obstacle ",
            targetCell.obstacle.name,
            " @ ",
            targetCell.number,
            type,
            " for ",
            damage,
            " damage"
          );
          handleObstacleDamage(damage, 1);
        }
        // NO OBSTACLE. REAR BARRIER CHECK
        else {
          // NO OBSTACLE. ITEM ON GROUND? DESTROY
          // console.log('bolt cant destroy item on ground');

          let rearBarrier = false;
          if (targetCell.barrier.state === true) {
            if (bolt.direction === targetCell.barrier.position) {
              rearBarrier = true;
            }
          }
          if (rearBarrier === true && targetCell.barrier.height >= 1) {
            // console.log('player ',owner.number,'hit rear barrier ',targetCell.barrier.name,' @ ',targetCell.number,type);
            handleBarrierDamage("rearBarrier", damage, 1);
          }
        }
      }
    }

    if (type === "flyOverBolt") {
      myCell = undefined;
      if (bolt.direction === "north") {
        myCell = this.gridInfo.find(
          (elem) =>
            elem.number.x === targetCell.number.x + 1 &&
            elem.number.y === targetCell.number.y
        );
      }
      if (bolt.direction === "south") {
        myCell = this.gridInfo.find(
          (elem) =>
            elem.number.x === targetCell.number.x - 1 &&
            elem.number.y === targetCell.number.y
        );
      }
      if (bolt.direction === "east") {
        myCell = this.gridInfo.find(
          (elem) =>
            elem.number.x === targetCell.number.x &&
            elem.number.y === targetCell.number.y - 1
        );
      }
      if (bolt.direction === "east") {
        myCell = this.gridInfo.find(
          (elem) =>
            elem.number.x === targetCell.number.x &&
            elem.number.y === targetCell.number.y + 1
        );
      }

      let doubleHitChance;
      let singleHitChance;
      if (ownerType === "player") {
        doubleHitChance = owner.crits.doubleHit;
        singleHitChance = owner.crits.singleHit;
      } else {
        doubleHitChance = 2;
        singleHitChance = 1;
      }
      let doubleHit = this.rnJesus(1, doubleHitChance);
      let singleHit = this.rnJesus(1, singleHitChance);
      if (doubleHit === 1) {
        damage = 2;
      } else {
        damage = 1;
      }

      // (targetCell.obstacle.height + targetCell.elevation.number) < bolt.elevation;
      let obstacleHeightCheck =
        targetCell.obstacle.height + targetCell.elevation.number >= bolt.elevation + 1;
      let barrierHeightCheck =
        targetCell.barrier.height + targetCell.elevation.number >= bolt.elevation + 1;

      let myCellBarrier = false;
      if (myCell.barrier.state === true) {
        if (myCell.barrier.position === bolt.direction) {
          myCellBarrier = true;
          handleBarrierDamage("myCellBarrier", damage, 0);
        }
      }

      // FWD BARRIER?
      let fwdBarrier = false;
      if (targetCell.barrier.state === true) {
        fwdBarrier = this.checkForwardBarrier(bolt.direction, targetCell);
      }

      if (myCellBarrier !== true && fwdBarrier === true && barrierHeightCheck === true) {
        handleBarrierDamage("fwdBarrier", damage, 1);
      }

      // NO FWD BARRIER. OBSTACLE?
      if (myCellBarrier !== true && fwdBarrier !== true) {
        if (targetCell.obstacle.state === true && obstacleHeightCheck === true) {
          // console.log('targetCell.obstacle.hp',targetCell.obstacle.hp);
          handleObstacleDamage(damage, 1);
        } else {
          // NO OBSTACLE. ITEM ON GROUND? DESTROY
          // console.log('bolt cant destroy item on ground');

          // NO OBSTACLE. DESTROY REAR BARRIER
          let rearBarrier = false;
          if (targetCell.barrier.state === true) {
            if (bolt.direction === targetCell.barrier.position) {
              rearBarrier = true;
            }
          }
          if (rearBarrier === true && barrierHeightCheck === true) {
            handleBarrierDamage("rearBarrier", damage);
          }
        }
      }
    }

    if (type === "arc") {
    }
  };
  obstacleItemDrop = (targetCell, player) => {
    // console.log("obstacleItemDrop");

    let itemCount = targetCell.obstacle.items.length;
    let itemCount2 = itemCount;
    let availibleCells = [];
    let baseDirs = ["south", "west", "north", "east"];
    let multiple = 1;
    let baseDirIndx = 0;
    let refPos = {
      x: targetCell.number.x,
      y: targetCell.number.y,
    };
    let cellToCheck = {
      x: undefined,
      y: undefined,
    };
    let instructions = [];
    let instructionRef = {
      north: {
        x: 0,
        y: -1,
      },
      south: {
        x: 0,
        y: 1,
      },
      east: {
        x: 1,
        y: 0,
      },
      west: {
        x: -1,
        y: 0,
      },
    };
    let stepsA = 0;
    let stepsB = 0;

    while (availibleCells.length < itemCount) {
      for (let i = 0; i < multiple; i++) {
        instructions.push(baseDirs[baseDirIndx]);
        // console.log('set instructions baseDirIndx',baseDirIndx,'multiple',multiple,'baseDir',baseDirs[baseDirIndx]);
      }
      // console.log('item drop instructions',instructions);

      for (const instruct of instructions) {
        cellToCheck = {
          x: refPos.x + instructionRef[instruct].x,
          y: refPos.y + instructionRef[instruct].y,
        };
        // console.log('ctc instruct ',instruct,instructionRef[instruct],'cell to check',cellToCheck,'steps',stepsA,stepsB);

        let ctcRef = this.gridInfo.find(
          (x) => x.number.x === cellToCheck.x && x.number.y === cellToCheck.y
        );

        let cellFree = true;

        // if (
        //   ctcRef.number.x < 0 ||
        //   ctcRef.number.x > this.gridWidth-1 ||
        //   ctcRef.number.y < 0 ||
        //   ctcRef.number.y > this.gridWidth-1
        // ) {
        //   cellFree = false;
        // }
        if (ctcRef) {
          if (
            ctcRef.obstacle.state === true ||
            ctcRef.void.state === true ||
            ctcRef.terrain.type === "deep" ||
            ctcRef.terrain.name === "lava" ||
            ctcRef.item.name !== "" ||
            ctcRef.rubble === true
          ) {
            cellFree = false;
          }

          for (const plyr of this.players) {
            if (
              plyr.currentPosition.cell.number.x === ctcRef.number.x &&
              plyr.currentPosition.cell.number.y === ctcRef.number.y
            ) {
              cellFree = false;
            }
          }
        } else {
          cellFree = false;
        }

        if (cellFree === true) {
          itemCount2--;
          availibleCells.push(cellToCheck);
          // console.log('cell free',cellToCheck,'item count1',itemCount,'item count2',itemCount2,'availibleCells',availibleCells.length,'steps',stepsA,stepsB);
          // console.log('availibleCells',availibleCells.length,availibleCells);
        } else {
          // console.log('cell not free',cellToCheck,'availibleCells',availibleCells.length,'steps',stepsA,stepsB);
          // console.log('availibleCells',availibleCells.length,availibleCells);
        }
        refPos = {
          x: cellToCheck.x,
          y: cellToCheck.y,
        };
        stepsA++;
        stepsB++;

        if (availibleCells.length === itemCount) {
          break;
        }
      }

      instructions = [];

      // if (steps%2 === 0) {
      //   stepsA = 0;
      //   multiple++;
      // }
      if (stepsB === multiple * 2) {
        multiple++;
        stepsB = 0;
      }
      if (baseDirIndx >= 3) {
        // console.log('a');
        baseDirIndx = 0;
      } else {
        baseDirIndx++;
      }
    }

    if (availibleCells.length === itemCount) {
      // console.log('break loop. have free cell for each item');
      for (const cell of availibleCells) {
        let indx = availibleCells.indexOf(cell);
        let item = targetCell.obstacle.items[indx];
        this.gridInfo.find((x) => x.number.x === cell.x && x.number.y === cell.y).item =
          item;

        this.cellsToHighlight2.push({
          number: {
            x: cell.x,
            y: cell.y,
          },
          count: 0,
          limit: 50,
        });

        this.obstacleItemsToDrop.push({
          origin: targetCell.number,
          target: cell,
          item: item,
          state: true,
          count: 0,
          limit: 30,
          position: {
            x: undefined,
            y: undefined,
          },
        });
      }
    }
  };
  applyRemoveEffect = (player, action, subAction, type, item) => {
    // console.log('applyRemoveEffect',action,subAction,type,item);
    // call from: pickup, discard, deflect drop, use
    //
    // action: apply, remove
    //
    // actiontype: pickup, discard, deflect drop, use
    //
    // type: armor, weapon, item

    let pickUp = false;

    if (action === "remove") {
      if (type === "armor") {
        switch (item.effect) {
          case "hpUp":
            if (player.hp > 1) {
              player.hp = player.hp - 1;
              // console.log(`armor ${subAction} debuff hp`,player.hp);
            }
            break;
          case "speedUp":
            let currentSpd1 = player.speed.range.indexOf(player.speed.move);
            if (player.speed.move > 0.05) {
              player.speed.move = player.speed.range[currentSpd1 - 1];
              // console.log(`armor ${subAction} debuff speed`,player.speed.move);
            }
            break;
        }
      }
    }

    if (action === "apply") {
      if (type === "armor") {
        switch (item.effect) {
          case "hpUp":
            // console.log('armor pickup buff');
            if (this.players[player.number - 1].hp < 3) {
              player.hp = player.hp + 1;

              player.statusDisplay = {
                state: true,
                status: "hpUp",
                count: 1,
                limit: player.statusDisplay.limit,
              };

              if (!player.popups.find((x) => x.msg === "pickupBuff")) {
                player.popups.push({
                  state: false,
                  count: 0,
                  limit: 25,
                  type: "",
                  position: "",
                  msg: "pickupBuff",
                  img: "",
                });
              }

              if (!player.popups.find((x) => x.msg.split("_")[0] === "hpUp")) {
                player.popups.push({
                  state: false,
                  count: 0,
                  limit: 30,
                  type: "",
                  position: "",
                  msg: "hpUp_" + "+" + 1 + "",
                  img: "",
                });
              }
            }
            break;
          case "speedUp":
            // console.log('armor pickup buff');
            let currentSpd1 = player.speed.range.indexOf(player.speed.move);
            if (player.speed.move < 0.2) {
              player.speed.move = player.speed.range[currentSpd1 + 1];

              player.statusDisplay = {
                state: true,
                status: "speedUp",
                count: 1,
                limit: player.statusDisplay.limit,
              };

              if (!player.popups.find((x) => x.msg === "pickupBuff")) {
                player.popups.push({
                  state: false,
                  count: 0,
                  limit: 25,
                  type: "",
                  position: "",
                  msg: "pickupBuff",
                  img: "",
                });
              }
            }
            break;
        }
      }

      if (type === "item") {
        let ammo;
        switch (item.name) {
          case "moveSpeedUp":
            // console.log('moveSpeedUp');
            let currentSpd1 = player.speed.range.indexOf(player.speed.move);

            if (player.speed.move < 0.2) {
              // console.log('added buff');
              player.speed.move = player.speed.range[currentSpd1 + 1];

              player.statusDisplay = {
                state: true,
                status: item.name,
                count: 1,
                limit: player.statusDisplay.limit,
              };

              if (!player.popups.find((x) => x.msg === "pickupBuff")) {
                player.popups.push({
                  state: false,
                  count: 0,
                  limit: 25,
                  type: "",
                  position: "",
                  msg: "pickupBuff",
                  img: "",
                });
              }

              pickUp = true;
            } else {
              console.log(
                "player " + player.number + " you already have max movement speed"
              );

              player.statusDisplay = {
                state: true,
                status: "Already Max Speed!!",
                count: 1,
                limit: this.players[player.number - 1].statusDisplay.limit,
              };

              if (!player.popups.find((x) => x.msg === "stop")) {
                player.popups.push({
                  state: false,
                  count: 0,
                  limit: 25,
                  type: "",
                  position: "",
                  msg: "stop",
                  img: "",
                });
              }
            }
            break;
          case "moveSpeedDown":
            // console.log('moveSpeedDown');
            let currentSpd2 = player.speed.range.indexOf(player.speed.move);
            // console.log('ff',currentSpd2,this.players[player.number-1].speed.range[currentSpd2]);
            // console.log('ff2',currentSpd2,this.players[player.number-1].speed.range[currentSpd2-1]);
            if (player.speed.move > 0.05) {
              // console.log('added debuff');
              player.speed.move = player.speed.range[currentSpd2 - 1];

              player.statusDisplay = {
                state: true,
                status: item.name,
                count: 1,
                limit: player.statusDisplay.limit,
              };

              if (!player.popups.find((x) => x.msg === "pickupDebuff")) {
                player.popups.push({
                  state: false,
                  count: 0,
                  limit: 25,
                  type: "",
                  position: "",
                  msg: "pickupDebuff",
                  img: "",
                });
              }

              pickUp = true;
            }
            break;
          case "hpUp":
            // console.log('hpUp');
            if (player.hp === 1 && player.speed.move < 0.1) {
              player.speed.move = 0.1;
            }
            if (player.hp < 3) {
              player.hp++;

              player.statusDisplay = {
                state: true,
                status: item.name,
                count: 1,
                limit: player.statusDisplay.limit,
              };

              if (!player.popups.find((x) => x.msg === "pickupBuff")) {
                player.popups.push({
                  state: false,
                  count: 0,
                  limit: 25,
                  type: "",
                  position: "",
                  msg: "pickupBuff",
                  img: "",
                });
              }

              if (!player.popups.find((x) => x.msg.split("_")[0] === "hpUp")) {
                player.popups.push({
                  state: false,
                  count: 0,
                  limit: 30,
                  type: "",
                  position: "",
                  msg: "hpUp_" + "+" + 1 + "",
                  img: "",
                });
              }

              pickUp = true;
            } else {
              console.log("player " + player.number + " you already have max hp");

              player.statusDisplay = {
                state: true,
                status: "Already Max HP!!",
                count: 1,
                limit: player.statusDisplay.limit,
              };

              if (!player.popups.find((x) => x.msg === "stop")) {
                player.popups.push({
                  state: false,
                  count: 0,
                  limit: 25,
                  type: "",
                  position: "",
                  msg: "stop",
                  img: "",
                });
              }
            }
            break;
          case "hpDown":
            // console.log('hpDown');
            if (player.hp > 1) {
              player.hp--;

              player.statusDisplay = {
                state: true,
                status: item.name,
                count: 1,
                limit: player.statusDisplay.limit,
              };

              if (!player.popups.find((x) => x.msg === "pickupDebuff")) {
                player.popups.push({
                  state: false,
                  count: 0,
                  limit: 25,
                  type: "",
                  position: "",
                  msg: "pickupDebuff",
                  img: "",
                });
              }
              if (!player.popups.find((x) => x.msg === "alarmed")) {
                player.popups.push({
                  state: false,
                  count: 0,
                  limit: 25,
                  type: "",
                  position: "",
                  msg: "alarmed",
                  img: "",
                });
              }
              pickUp = true;
            }
            break;
          case "focusUp":
            if (player.crits.doubleHit - 2 !== 0) {
              player.crits.doubleHit = player.crits.doubleHit - 2;

              player.statusDisplay = {
                state: true,
                status: item.name,
                count: 1,
                limit: player.statusDisplay.limit,
              };

              if (!player.popups.find((x) => x.msg === "pickupBuff")) {
                player.popups.push({
                  state: false,
                  count: 0,
                  limit: 25,
                  type: "",
                  position: "",
                  msg: "pickupBuff",
                  img: "",
                });
              }
            }
            player.crits.guardBreak = player.crits.guardBreak + 1;

            pickUp = true;
            break;
          case "focusDown":
            player.crits.doubleHit = player.crits.doubleHit + 2;
            if (player.crits.guardBreak - 1 !== 0) {
              player.crits.guardBreak = player.crits.guardBreak - 1;
            }

            player.statusDisplay = {
              state: true,
              status: item.name,
              count: 1,
              limit: player.statusDisplay.limit,
            };

            if (!player.popups.find((x) => x.msg === "pickupDebuff")) {
              player.popups.push({
                state: false,
                count: 0,
                limit: 25,
                type: "",
                position: "",
                msg: "pickupDebuff",
                img: "",
              });
            }

            pickUp = true;
            break;
          case "strengthUp":
            player.crits.pushBack = player.crits.pushBack + 1;

            player.crits.guardBreak = player.crits.guardBreak + 1;

            player.statusDisplay = {
              state: true,
              status: item.name,
              count: 1,
              limit: player.statusDisplay.limit,
            };

            if (!player.popups.find((x) => x.msg === "pickupBuff")) {
              player.popups.push({
                state: false,
                count: 0,
                limit: 25,
                type: "",
                position: "",
                msg: "pickupBuff",
                img: "",
              });
            }

            pickUp = true;
            break;
          case "strengthDown":
            if (player.crits.pushBack - 1 !== 0) {
              player.crits.pushBack = player.crits.pushBack - 1;

              player.statusDisplay = {
                state: true,
                status: item.name,
                count: 1,
                limit: player.statusDisplay.limit,
              };

              if (!player.popups.find((x) => x.msg === "pickupDebuff")) {
                player.popups.push({
                  state: false,
                  count: 0,
                  limit: 25,
                  type: "",
                  position: "",
                  msg: "pickupDebuff",
                  img: "",
                });
              }

              pickUp = true;
            }
            if (player.crits.guardBreak - 1 !== 0) {
              player.crits.guardBreak = player.crits.guardBreak - 1;

              player.statusDisplay = {
                state: true,
                status: item.name,
                count: 1,
                limit: player.statusDisplay.limit,
              };

              pickUp = true;
            }
            break;
          case "ammo5":
            ammo = parseInt(item.name.split("o")[1]);
            player.items.ammo = player.items.ammo + ammo;

            player.statusDisplay = {
              state: true,
              status: item.name,
              count: 1,
              limit: player.statusDisplay.limit,
            };

            if (!player.popups.find((x) => x.msg === "pickupAmmo")) {
              player.popups.push({
                state: false,
                count: 0,
                limit: 25,
                type: "",
                position: "",
                msg: "pickupAmmo",
                img: "",
              });
            }

            pickUp = true;
            break;
          case "ammo10":
            ammo = parseInt(item.name.split("o")[1]);
            player.items.ammo = player.items.ammo + ammo;

            player.statusDisplay = {
              state: true,
              status: item.name,
              count: 1,
              limit: player.statusDisplay.limit,
            };

            if (!player.popups.find((x) => x.msg === "pickupAmmo")) {
              player.popups.push({
                state: false,
                count: 0,
                limit: 25,
                type: "",
                position: "",
                msg: "pickupAmmo",
                img: "",
              });
            }

            pickUp = true;
            break;
        }
      }
    }

    this.players[player.number - 1] = player;
    return pickUp;
  };

  preObstaclePushCheck = (player, target) => {
    // console.log('pre push check');

    let resetPush = false;
    let refCell = this.gridInfo.find(
      (x) => x.number.x === target.cell1.number.x && x.number.y === target.cell1.number.y
    );
    let plyrRefCell = this.gridInfo.find(
      (x) =>
        x.number.x === player.currentPosition.cell.number.x &&
        x.number.y === player.currentPosition.cell.number.y
    );

    let myCellCheck = true;
    if (
      plyrRefCell.barrier.state === true &&
      plyrRefCell.barrier.position === player.direction
    ) {
      myCellCheck = false;
    }
    if (myCellCheck !== true) {
      console.log("a barrier in player cell is blocking a push");
      resetPush = true;
    }

    if (refCell.obstacle.state !== true) {
      console.log("barrier not obstacle. Cant be pushed");
      resetPush = true;
    } else if (
      refCell.obstacle.moving.pushable === true &&
      myCellCheck === true &&
      player.newPushPullDelay.state !== true
    ) {
      if (player.prePush.state !== true && player.prePush.count === 0) {
        // console.log('start pre push');
        player.prePush = {
          state: true,
          count: player.prePush.count++,
          limit: player.prePush.limit,
          targetCell: refCell,
          direction: player.direction,
          pusher: player.number,
        };
      }

      if (player.prePush.state === true) {
        if (player.prePush.count >= player.prePush.limit) {
          // console.log('pre push limit. check can push');
          this.players[player.number - 1].prePush = player.prePush;
          this.players[player.number - 1].pushing = player.pushing;

          if (player.popups.find((x) => x.msg === "prePush")) {
            player.popups.splice(
              player.popups.findIndex((x) => x.msg === "prePush"),
              1
            );
          }
          this.canPushObstacle("player", player, refCell, "");
        } else {
          if (
            player.prePush.targetCell.number.x === refCell.number.x &&
            player.prePush.targetCell.number.y === refCell.number.y &&
            player.prePush.direction === player.direction &&
            player.prePush.pusher === player.number
          ) {
            player.prePush.count++;
            if (!player.popups.find((x) => x.msg === "prePush")) {
              player.popups.push({
                state: false,
                count: 0,
                limit: player.prePush.limit,
                type: "",
                position: "",
                msg: "prePush",
                img: "",
              });
            }
            // console.log('pre pushing the same obstacle. Continue',player.prePush.count);
          } else {
            // console.log('pre push player, target or direction has changed. Reset prepush');
            player.prePush = {
              state: false,
              count: 0,
              limit: player.prePush.limit,
              targetCell: undefined,
              direction: "",
              pusher: undefined,
            };

            resetPush = true;
          }
        }
      }
    }

    if (player.newPushPullDelay.state === true) {
      resetPush = true;
    }

    if (refCell.obstacle.moving.pushable !== true) {
      console.log("obstacle is instrinsically unpushable");
      resetPush = true;
    }

    if (resetPush === true) {
      player.prePush = {
        state: false,
        count: 0,
        limit: player.prePush.limit,
        targetCell: undefined,
        direction: "",
        pusher: undefined,
      };

      if (player.newPushPullDelay.state !== true) {
        player.newPushPullDelay.state = true;
      }
    }

    this.players[player.number - 1].prePush = player.prePush;
    this.players[player.number - 1].pushing = player.pushing;
  };
  canPushObstacle = (ownerType, owner, obstacleCell, type) => {
    // console.log("canPushObstacle");
    // let pusherCellRef = this.gridInfo.find(x=> x.number.x === player.currentPosition.cell.number.x && x.number.y === player.currentPosition.cell.number.y);
    let resetPush = false;
    let thresholdMultiplier = this.rnJesus(1, 3);
    let canPushStrength = false;
    let canPushTargetFree = true;
    let pushStrengthThreshold =
      (obstacleCell.obstacle.height + obstacleCell.obstacle.weight) * thresholdMultiplier;
    let pushStrengthPlayer = 0;
    let movePlayer = true;
    let impactDirection = "";
    let preMoveSpeed;
    let moveSpeed;
    let staminaCheck;
    let ownerId;
    pushStrengthPlayer += 15;

    const setSpeed = () => {
      preMoveSpeed = Math.ceil(pushStrengthPlayer / pushStrengthThreshold);

      moveSpeed = 0;
      if (preMoveSpeed <= 1) {
        moveSpeed = 0.05;
      }
      if (preMoveSpeed === 2) {
        moveSpeed = 0.1;
      }
      if (preMoveSpeed > 2 && preMoveSpeed < 4) {
        moveSpeed = 0.125;
      }
      if (preMoveSpeed >= 4) {
        moveSpeed = 0.2;
      }

      if (this.terrainMoveSpeedRef[obstacleCell.terrain.type]) {
        moveSpeed = this.terrainMoveSpeedRef[obstacleCell.terrain.type];
      }
    };
    const setPushStrength = () => {
      if (ownerType === "player") {
        if (owner.hp > 1) {
          pushStrengthPlayer += owner.hp - 1;
        }
        pushStrengthPlayer += owner.crits.pushBack - 3;
        pushStrengthPlayer += owner.crits.guardBreak - 2;
      } else {
        pushStrengthPlayer = 5;
        pushStrengthPlayer += this.rnJesus(1, pushStrengthThreshold);
      }
      setSpeed();
    };

    if (type === "hitPush" || type.split("_")[0] === "hitPushBolt") {
      movePlayer = false;
      pushStrengthPlayer += 1;
      // console.log('obstacle hit push');
    }

    if (type.split("_")[0] === "hitPushBolt") {
      impactDirection = type.split("_")[1];
      // console.log('impactDirection',type.split('_')[1]);
    }
    if (type === "hitPush") {
      if (ownerType === "player") {
        impactDirection = owner.direction;
      } else {
        let myCell = this.gridInfo.find(
          (x) => x[ownerType].state === true && x[ownerType].id === owner.id
        );
        impactDirection = this.getDirectionFromCells(myCell.number, owner.trap.target);
      }
    }
    if (type === "") {
      impactDirection = owner.prePush.direction;
    }

    if (type === "jumpCollision") {
      impactDirection = owner.direction;
      movePlayer = false;
      pushStrengthPlayer += 30;
    }

    if (type.split("_")[0] === "overlap") {
      impactDirection = type.split("_")[1];
      movePlayer = false;
      pushStrengthPlayer += 30;
    }

    let destCell = this.getCellFromDirection(1, obstacleCell.number, impactDirection);
    let destCellRef = this.gridInfo.find(
      (x) => x.number.x === destCell.x && x.number.y === destCell.y
    );
    let destCellOccupant = "";

    if (ownerType === "player") {
      ownerId = owner.number;
      if (owner.stamina.current - this.staminaCostRef.push >= 0) {
        staminaCheck = true;
      }
      owner.stamina.current = owner.stamina.current - this.staminaCostRef.push;
    } else {
      ownerId = owner.id;
      staminaCheck = true;
    }

    if (staminaCheck === true) {
      setPushStrength();
      // setSpeed();

      if (destCellRef) {
        if (destCellRef.obstacle.state === true) {
          canPushTargetFree = false;
          destCellOccupant = "obstacle";
          resetPush = true;
        }

        if (destCellRef.barrier.state === true) {
          let barrier = false;
          if (
            destCellRef.barrier.position === this.getOppositeDirection(impactDirection)
          ) {
            barrier = true;
          }

          if (barrier === true) {
            canPushTargetFree = false;
            destCellOccupant = "barrier";
            resetPush = true;
          }
        }

        if (destCellRef.elevation.number > obstacleCell.elevation.number) {
          canPushTargetFree = false;
          destCellOccupant = "higherElevation";
          resetPush = true;
        }

        if (obstacleCell.barrier.state === true) {
          // --------------
          let barrier = false;
          if (
            obstacleCell.barrier.position === this.getOppositeDirection(impactDirection)
          ) {
            barrier = true;
          }

          if (barrier === true) {
            console.log("barrier in obstacle cell in front of obstacle");
            canPushTargetFree = false;
            destCellOccupant = "barrier";
            resetPush = true;
          }
          // --------------

          if (obstacleCell.barrier.position === impactDirection) {
            console.log("barrier in obstacle cell behind obstacle");
            canPushTargetFree = false;
            destCellOccupant = "barrier";
            resetPush = true;
          }
        }

        for (const plyr of this.players) {
          if (
            plyr.currentPosition.cell.number.x === destCell.x &&
            plyr.currentPosition.cell.number.y === destCell.y
          ) {
            canPushTargetFree = false;
            resetPush = true;
            destCellOccupant = `player_${plyr.number}`;
          }
        }
      } else {
        if (obstacleCell.barrier.state === true) {
          // --------------
          let barrier = false;
          if (
            obstacleCell.barrier.position === this.getOppositeDirection(impactDirection)
          ) {
            barrier = true;
          }

          if (barrier === true) {
            console.log("barrier in obstacle cell in front of obstacle2");
            canPushTargetFree = false;
            destCellOccupant = "barrier";
            resetPush = true;
          }
          // --------------

          if (obstacleCell.barrier.position === impactDirection) {
            console.log("barrier in obstacle cell behind obstacle2");
            canPushTargetFree = false;
            destCellOccupant = "barrier";
            resetPush = true;
          }
        }
      }

      let extraPush = 0;
      if (
        pushStrengthPlayer >= pushStrengthThreshold &&
        obstacleCell.obstacle.moving.pushable === true
      ) {
        canPushStrength = true;
        extraPush = pushStrengthPlayer - pushStrengthThreshold;
        if (ownerType === "player") {
          // console.log(
          //   "you are strongh enough to push this obstacle",
          //   pushStrengthPlayer,
          //   pushStrengthThreshold,
          //   owner.crits.guardBreak - 2,
          //   owner.crits.pushBack - 2,
          //   "extra",
          //   extraPush
          // );
        }
      } else {
        if (ownerType === "player") {
          console.log(
            "you are NOT strong enough to push this obstacle",
            pushStrengthPlayer,
            pushStrengthThreshold,
            owner.crits.guardBreak - 2,
            owner.crits.pushBack - 2
          );
        }

        resetPush = true;
      }
      if (extraPush > 5) {
        // console.log("extra push force. Push obstacle w/o plyr move");
        movePlayer = false;
      }

      // if(!destCellRef && pushStrengthPlayer >= pushStrengthThreshold ) {
      if (canPushStrength === true && canPushTargetFree === true && !destCellRef) {
        if (ownerType === "player") {
          if (!this.players[owner.number - 1].popups.find((x) => x.msg === "canPush")) {
            this.players[owner.number - 1].popups.push({
              state: false,
              count: 0,
              limit: 25,
              type: "",
              position: "",
              msg: "canPush",
              img: "",
            });
          }

          if (this.players[owner.number - 1].popups.find((x) => x.msg === "prePush")) {
            this.players[owner.number - 1].popups.splice(
              this.players[owner.number - 1].popups.findIndex((x) => x.msg === "prePush"),
              1
            );
          }
          if (this.players[owner.number - 1].popups.find((x) => x.msg === "noPush")) {
            this.players[owner.number - 1].popups.splice(
              this.players[owner.number - 1].popups.findIndex((x) => x.msg === "noPush"),
              1
            );
          }
        }

        let voidCenter = this.getVoidCenter(1, impactDirection, obstacleCell.center);

        let obstacleCrementObj = this.obstacleMoveCrementer(obstacleCell, {
          center: voidCenter,
        });

        obstacleCell.obstacle = {
          id: obstacleCell.obstacle.id,
          trap: obstacleCell.obstacle.trap,
          state: obstacleCell.obstacle.state,
          name: obstacleCell.obstacle.name,
          type: obstacleCell.obstacle.type,
          hp: obstacleCell.obstacle.hp,
          destructible: obstacleCell.obstacle.destructible,
          locked: obstacleCell.obstacle.locked,
          weight: obstacleCell.obstacle.weight,
          height: obstacleCell.obstacle.height,
          items: obstacleCell.obstacle.items,
          effects: obstacleCell.obstacle.effects,
          moving: {
            state: true,
            step: obstacleCrementObj.step,
            origin: {
              number: obstacleCell.number,
              center: obstacleCell.center,
            },
            destination: {
              number: {
                x: undefined,
                y: undefined,
              },
              center: voidCenter,
            },
            currentPosition: obstacleCell.center,
            nextPosition: obstacleCrementObj.pos,
            moveSpeed: moveSpeed,
            pushable: true,
            pushed: true,
            pusher: ownerId,
            falling: obstacleCell.obstacle.moving.falling,
          },
        };

        if (ownerType === "player") {
          this.players[owner.number - 1].prePush = {
            state: false,
            count: 0,
            limit: owner.prePush.limit,
            targetCell: undefined,
            direction: "",
            pusher: undefined,
          };

          if (movePlayer === true) {
            this.players[owner.number - 1].pushing = {
              state: true,
              targetCell: obstacleCell,
              moveSpeed: moveSpeed,
            };

            if (owner.turning.delayCount === 0) {
              this.players[owner.number - 1].action = "moving";
              this.players[owner.number - 1].moving = {
                state: true,
                step: 0,
                course: "",
                origin: {
                  number: {
                    x: owner.currentPosition.cell.number.x,
                    y: owner.currentPosition.cell.number.y,
                  },
                  center: {
                    x: owner.currentPosition.cell.center,
                    y: owner.currentPosition.cell.center,
                  },
                },
                destination: obstacleCell.center,
              };
              let nextPosition = this.lineCrementer(owner);
              owner.nextPosition = nextPosition;
            }
          }
        }
      }

      if (ownerType === "player") {
        // console.log('pushStrengthThreshold/Player',pushStrengthThreshold,pushStrengthPlayer);
        if (!this.players[owner.number - 1].popups.find((x) => x.msg === "canPush")) {
          this.players[owner.number - 1].popups.push({
            state: false,
            count: 0,
            limit: 25,
            type: "",
            position: "",
            msg: "canPush",
            img: "",
          });
        }

        if (this.players[owner.number - 1].popups.find((x) => x.msg === "prePush")) {
          this.players[owner.number - 1].popups.splice(
            this.players[owner.number - 1].popups.findIndex((x) => x.msg === "prePush"),
            1
          );
        }
        if (this.players[owner.number - 1].popups.find((x) => x.msg === "noPush")) {
          this.players[owner.number - 1].popups.splice(
            this.players[owner.number - 1].popups.findIndex((x) => x.msg === "noPush"),
            1
          );
        }
      }

      if (canPushTargetFree !== true) {
        // console.log('something is in the way of the obstacle to be pushed');
        resetPush = true;
      }

      if (canPushStrength === true && canPushTargetFree === true && destCellRef) {
        // console.log("ready to push");
        if (ownerType === "player") {
          if (!this.players[owner.number - 1].popups.find((x) => x.msg === "canPush")) {
            this.players[owner.number - 1].popups.push({
              state: false,
              count: 0,
              limit: 25,
              type: "",
              position: "",
              msg: "canPush",
              img: "",
            });
          }

          if (this.players[owner.number - 1].popups.find((x) => x.msg === "prePush")) {
            this.players[owner.number - 1].popups.splice(
              this.players[owner.number - 1].popups.findIndex((x) => x.msg === "prePush"),
              1
            );
          }
          if (this.players[owner.number - 1].popups.find((x) => x.msg === "noPush")) {
            this.players[owner.number - 1].popups.splice(
              this.players[owner.number - 1].popups.findIndex((x) => x.msg === "noPush"),
              1
            );
          }
        }

        let obstacleCrementObj = this.obstacleMoveCrementer(obstacleCell, destCellRef);

        obstacleCell.obstacle = {
          id: obstacleCell.obstacle.id,
          trap: obstacleCell.obstacle.trap,
          state: obstacleCell.obstacle.state,
          name: obstacleCell.obstacle.name,
          type: obstacleCell.obstacle.type,
          hp: obstacleCell.obstacle.hp,
          destructible: obstacleCell.obstacle.destructible,
          locked: obstacleCell.obstacle.locked,
          weight: obstacleCell.obstacle.weight,
          height: obstacleCell.obstacle.height,
          items: obstacleCell.obstacle.items,
          effects: obstacleCell.obstacle.effects,
          moving: {
            state: true,
            step: obstacleCrementObj.step,
            origin: {
              number: obstacleCell.number,
              center: obstacleCell.center,
            },
            destination: {
              number: destCellRef.number,
              center: destCellRef.center,
            },
            currentPosition: obstacleCell.center,
            nextPosition: obstacleCrementObj.pos,
            moveSpeed: moveSpeed,
            pushable: true,
            pushed: true,
            pusher: ownerId,
            falling: obstacleCell.obstacle.moving.falling,
          },
        };

        if (ownerType === "player") {
          this.players[owner.number - 1].prePush = {
            state: false,
            count: 0,
            limit: owner.prePush.limit,
            targetCell: undefined,
            direction: "",
            pusher: undefined,
          };

          if (movePlayer === true) {
            this.players[owner.number - 1].pushing = {
              state: true,
              targetCell: obstacleCell,
              moveSpeed: moveSpeed,
            };

            if (owner.turning.delayCount === 0) {
              this.players[owner.number - 1].action = "moving";
              this.players[owner.number - 1].moving = {
                state: true,
                step: 0,
                course: "",
                origin: {
                  number: {
                    x: owner.currentPosition.cell.number.x,
                    y: owner.currentPosition.cell.number.y,
                  },
                  center: {
                    x: owner.currentPosition.cell.center,
                    y: owner.currentPosition.cell.center,
                  },
                },
                destination: obstacleCell.center,
              };
              let nextPosition = this.lineCrementer(owner);
              owner.nextPosition = nextPosition;
            }
          } else {
            owner.action = "idle";
          }
        }
      }
    } else {
      owner.stamina.current = 0;
      resetPush = true;
      owner.statusDisplay = {
        state: true,
        status: "Out of Stamina",
        count: 1,
        limit: owner.statusDisplay.limit,
      };

      if (!owner.popups.find((x) => x.msg === "outOfStamina")) {
        owner.popups.push({
          state: false,
          count: 0,
          limit: 20,
          type: "",
          position: "",
          msg: "outOfStamina",
          img: "",
        });
      }
    }

    if (resetPush === true) {
      if (ownerType === "player") {
        this.players[owner.number - 1].prePush = {
          state: false,
          count: 0,
          limit: owner.prePush.limit,
          targetCell: undefined,
          direction: "",
          pusher: undefined,
        };
        this.players[owner.number - 1].pushing = {
          state: false,
          targetCell: undefined,
          moveSpeed: 0,
        };

        if (this.players[owner.number - 1].newPushPullDelay.state !== true) {
          this.players[owner.number - 1].newPushPullDelay.state = true;
        }

        if (!this.players[owner.number - 1].popups.find((x) => x.msg === "noPush")) {
          this.players[owner.number - 1].popups.push({
            state: false,
            count: 0,
            limit: 25,
            type: "",
            position: "",
            msg: "noPush",
            img: "",
          });
        }

        if (this.players[owner.number - 1].popups.find((x) => x.msg === "prePush")) {
          this.players[owner.number - 1].popups.splice(
            this.players[owner.number - 1].popups.findIndex((x) => x.msg === "prePush"),
            1
          );
        }
        if (this.players[owner.number - 1].popups.find((x) => x.msg === "noPush")) {
          this.players[owner.number - 1].popups.splice(
            this.players[owner.number - 1].popups.findIndex((x) => x.msg === "canPush"),
            1
          );
        }
      }

      if (canPushTargetFree !== true && destCellOccupant !== "") {
        let type = destCellOccupant;
        if (type.split("_")[1]) {
          type = "player";
        }
        this.startHalfPushBack("obstacle", type, impactDirection, obstacleCell);
      }
    }

    if (type === "jumpCollision") {
      if (canPushTargetFree === true) {
        return true;
      } else {
        return false;
      }
    }
  };
  prePlayerPushCheck = (pusher, target) => {
    // console.log('prePlayerPushCheck');

    let resetPush = false;
    let targetCell = this.gridInfo.find(
      (x) => x.number.x === target.cell1.number.x && x.number.y === target.cell1.number.y
    );
    let plyrRefCell = this.gridInfo.find(
      (x) =>
        x.number.x === pusher.currentPosition.cell.number.x &&
        x.number.y === pusher.currentPosition.cell.number.y
    );

    let myCellCheck = true;
    if (
      plyrRefCell.barrier.state === true &&
      plyrRefCell.barrier.position === pusher.direction
    ) {
      myCellCheck = false;
    }
    if (myCellCheck !== true) {
      console.log("a barrier in player cell is blocking a player push");
      resetPush = true;
    }

    let targetOpen = false;
    let targetPlayer = this.players[target.cell1.occupant.player - 1];
    if (targetPlayer.success.deflected.state === true || targetPlayer.action === "idle") {
      targetOpen = true;
    } else {
      // console.log('target player is no longer deflected or idle');
      resetPush = true;
    }

    if (
      targetOpen === true &&
      myCellCheck === true &&
      pusher.newPushPullDelay.state !== true
    ) {
      if (pusher.prePush.state !== true && pusher.prePush.count === 0) {
        // console.log('start player pre push');
        pusher.prePush = {
          state: true,
          count: pusher.prePush.count++,
          limit: pusher.prePush.limit,
          targetCell: targetCell,
          direction: pusher.direction,
          pusher: pusher.number,
        };
      }

      if (pusher.prePush.state === true) {
        // if (pusher.prePush.count >= 25) {
        if (pusher.prePush.count >= pusher.prePush.limit) {
          // console.log('pre push limit. check can push player');
          this.players[pusher.number - 1].prePush = pusher.prePush;
          this.players[pusher.number - 1].pushing = pusher.pushing;
          if (pusher.popups.find((x) => x.msg === "prePush")) {
            pusher.popups.splice(
              pusher.popups.findIndex((x) => x.msg === "prePush"),
              1
            );
          }
          this.canPushPlayer(pusher, targetCell, targetPlayer);
        } else {
          if (
            pusher.prePush.targetCell.number.x === targetCell.number.x &&
            pusher.prePush.targetCell.number.y === targetCell.number.y &&
            pusher.prePush.direction === pusher.direction &&
            pusher.prePush.pusher === pusher.number
          ) {
            pusher.prePush.count++;
            if (!pusher.popups.find((x) => x.msg === "prePush")) {
              pusher.popups.push({
                state: false,
                count: 0,
                limit: pusher.prePush.limit,
                type: "",
                position: "",
                msg: "prePush",
                img: "",
              });
            }
            // console.log('pre pushing the same player. Continue',pusher.prePush.count);
          } else {
            // console.log('pre push player, target or direction has changed. Reset prepush');
            pusher.prePush = {
              state: false,
              count: 0,
              limit: pusher.prePush.limit,
              targetCell: undefined,
              direction: "",
              pusher: undefined,
            };

            resetPush = true;
          }
        }
      }
    }

    if (pusher.newPushPullDelay.state === true) {
      resetPush = true;
    }

    if (targetOpen !== true) {
      // console.log('player is unpushable');
      resetPush = true;
    }

    if (resetPush === true) {
      pusher.prePush = {
        state: false,
        count: 0,
        limit: pusher.prePush.limit,
        targetCell: undefined,
        direction: "",
        pusher: undefined,
      };

      if (pusher.newPushPullDelay.state !== true) {
        pusher.newPushPullDelay.state = true;
      }
    }

    this.players[pusher.number - 1].prePush = pusher.prePush;
    this.players[pusher.number - 1].pushing = pusher.pushing;
  };
  canPushPlayer = (pusher, targetCell, targetPlayer) => {
    let resetPush = false;
    let thresholdMultiplier = this.rnJesus(1, 3);
    let canPushStrength = false;
    let canPushTargetFree = true;
    let pushStrengthThreshold =
      (targetPlayer.hp +
        (targetPlayer.crits.pushBack - 3) +
        (targetPlayer.crits.guardBreak - 2)) *
      thresholdMultiplier;
    let pushStrengthPlayer = 0;
    let movePlayer = true;
    let impactDirection = pusher.prePush.direction;

    let destCell = this.getCellFromDirection(1, targetCell.number, impactDirection);

    let destCellRef = this.gridInfo.find(
      (x) => x.number.x === destCell.x && x.number.y === destCell.y
    );
    let destCellOccupant = "";

    if (pusher.stamina.current - this.staminaCostRef.push >= 0) {
      pusher.stamina.current = pusher.stamina.current - this.staminaCostRef.push;

      if (pusher.hp > 1) {
        pushStrengthPlayer += pusher.hp - 1;
      }
      pushStrengthPlayer += pusher.crits.pushBack - 3;
      pushStrengthPlayer += pusher.crits.guardBreak - 2;
      // pushStrengthPlayer += 15;

      let preMoveSpeed = Math.ceil(pushStrengthPlayer / pushStrengthThreshold);
      let moveSpeed = 0;
      if (preMoveSpeed <= 1) {
        moveSpeed = 0.05;
      }
      if (preMoveSpeed === 2) {
        moveSpeed = 0.1;
      }
      if (preMoveSpeed > 2 && preMoveSpeed < 4) {
        moveSpeed = 0.125;
      }
      if (preMoveSpeed >= 4) {
        moveSpeed = 0.2;
      }

      if (destCellRef) {
        if (destCellRef.obstacle.state === true) {
          canPushTargetFree = false;
          destCellOccupant = "obstacle";
          resetPush = true;
        }

        if (destCellRef.barrier.state === true) {
          let barrier = this.checkForwardBarrier(impactDirection, destCellRef);
          let destCell = this.getCellFromDirection(1, targetCell.number, impactDirection);

          if (barrier === true) {
            canPushTargetFree = false;
            destCellOccupant = "barrier";
            resetPush = true;
          }
        }

        if (targetCell.barrier.state === true) {
          // --------------
          let barrier = this.checkForwardBarrier(impactDirection, targetCell);

          if (barrier === true) {
            console.log("barrier in obstacle cell in front of target player");
            canPushTargetFree = false;
            destCellOccupant = "barrier";
            resetPush = true;
          }
          // --------------

          if (targetCell.barrier.position === impactDirection) {
            console.log("barrier in obstacle cell behind target player");
            canPushTargetFree = false;
            destCellOccupant = "barrier";
            resetPush = true;
          }
        }

        if (destCellRef.elevation.number > targetCell.elevation.number) {
          canPushTargetFree = false;
          destCellOccupant = "higherElevation";
          resetPush = true;
        }

        for (const plyr of this.players) {
          if (
            plyr.currentPosition.cell.number.x === destCell.x &&
            plyr.currentPosition.cell.number.y === destCell.y
          ) {
            // change when implementing push player
            canPushTargetFree = false;
            resetPush = true;
            destCellOccupant = `player_${plyr.number}`;
          }
        }
      } else {
        if (targetCell.barrier.state === true) {
          // --------------
          let barrier = this.checkForwardBarrier(impactDirection, targetCell);

          if (barrier === true) {
            console.log("barrier in obstacle cell in front of target player");
            canPushTargetFree = false;
            destCellOccupant = "barrier";
            resetPush = true;
          }
          // --------------

          if (targetCell.barrier.position === impactDirection) {
            console.log("barrier in obstacle cell behind target player");
            canPushTargetFree = false;
            destCellOccupant = "barrier";
            resetPush = true;
          }
        }
      }

      let extraPush = 0;
      if (pushStrengthPlayer >= pushStrengthThreshold) {
        canPushStrength = true;
        extraPush = pushStrengthPlayer - pushStrengthThreshold;
        // console.log(
        //   "you are strongh enough to push this player",
        //   pushStrengthPlayer,
        //   pushStrengthThreshold,
        //   pusher.crits.guardBreak - 2,
        //   pusher.crits.pushBack - 2,
        //   "extra",
        //   extraPush
        // );
      } else {
        console.log(
          "you are NOT strong enough to push this player",
          pushStrengthPlayer,
          pushStrengthThreshold,
          pusher.crits.guardBreak - 2,
          pusher.crits.pushBack - 2
        );
        resetPush = true;
      }
      if (extraPush > 3) {
        console.log("extra push force. Push player w/o plyr move");
        movePlayer = false;
      }

      if (canPushStrength === true && canPushTargetFree === true && !destCellRef) {
        if (!this.players[pusher.number - 1].popups.find((x) => x.msg === "canPush")) {
          this.players[pusher.number - 1].popups.push({
            state: false,
            count: 0,
            limit: 25,
            type: "",
            position: "",
            msg: "canPush",
            img: "",
          });
        }

        if (this.players[pusher.number - 1].popups.find((x) => x.msg === "prePush")) {
          this.players[pusher.number - 1].popups.splice(
            this.players[pusher.number - 1].popups.findIndex((x) => x.msg === "prePush"),
            1
          );
        }
        if (this.players[pusher.number - 1].popups.find((x) => x.msg === "noPush")) {
          this.players[pusher.number - 1].popups.splice(
            this.players[pusher.number - 1].popups.findIndex((x) => x.msg === "noPush"),
            1
          );
        }

        // MOVE TARGET PLAYER
        this.players[targetPlayer.number - 1].strafing.direction = impactDirection;
        this.players[targetPlayer.number - 1].strafing.state = true;
        this.players[targetPlayer.number - 1].action = "strafe moving";

        this.unsetDeflection(targetPlayer);

        this.players[targetPlayer.number - 1].pushed = {
          state: true,
          pusher: pusher.number,
          moveSpeed: moveSpeed,
        };
        this.getTarget(targetPlayer);

        if (
          !this.players[targetPlayer.number - 1].popups.find(
            (x) => x.msg === "pushedPulled"
          )
        ) {
          this.players[targetPlayer.number - 1].popups.push({
            state: false,
            count: 0,
            limit: this.players[targetPlayer.number - 1].prePull.limit,
            type: "",
            position: "",
            msg: "pushedPulled",
            img: "",
          });
        }
        this.players[targetPlayer.number - 1].moving = {
          state: true,
          step: 0,
          course: "",
          origin: {
            number: {
              x: targetPlayer.currentPosition.cell.number.x,
              y: targetPlayer.currentPosition.cell.number.y,
            },
            center: {
              x: targetPlayer.currentPosition.cell.center,
              y: targetPlayer.currentPosition.cell.center,
            },
          },
          destination: targetPlayer.target.cell1.center,
        };
        let targetPlyrNextPosition = this.lineCrementer(targetPlayer);
        this.players[targetPlayer.number - 1].nextPosition = targetPlyrNextPosition;

        // MOVE PUSHER
        this.players[pusher.number - 1].prePush = {
          state: false,
          count: 0,
          limit: pusher.prePush.limit,
          targetCell: undefined,
          direction: "",
          pusher: undefined,
        };

        if (movePlayer === true) {
          this.players[pusher.number - 1].pushing = {
            state: true,
            targetCell: targetCell,
            moveSpeed: moveSpeed,
          };

          if (pusher.turning.delayCount === 0) {
            this.players[pusher.number - 1].action = "moving";
            this.players[pusher.number - 1].moving = {
              state: true,
              step: 0,
              course: "",
              origin: {
                number: {
                  x: pusher.currentPosition.cell.number.x,
                  y: pusher.currentPosition.cell.number.y,
                },
                center: {
                  x: pusher.currentPosition.cell.center,
                  y: pusher.currentPosition.cell.center,
                },
              },
              destination: targetCell.center,
            };
            let nextPosition = this.lineCrementer(pusher);
            pusher.nextPosition = nextPosition;
          }
        }
      }

      // console.log('pushStrengthThreshold/Player',pushStrengthThreshold,pushStrengthPlayer);

      if (canPushTargetFree !== true) {
        console.log("something is in the way of the player to be pushed");
        resetPush = true;
      }

      if (canPushStrength === true && canPushTargetFree === true && destCellRef) {
        // console.log('ready to push');
        if (!this.players[pusher.number - 1].popups.find((x) => x.msg === "canPush")) {
          this.players[pusher.number - 1].popups.push({
            state: false,
            count: 0,
            limit: 25,
            type: "",
            position: "",
            msg: "canPush",
            img: "",
          });
        }

        if (this.players[pusher.number - 1].popups.find((x) => x.msg === "prePush")) {
          this.players[pusher.number - 1].popups.splice(
            this.players[pusher.number - 1].popups.findIndex((x) => x.msg === "prePush"),
            1
          );
        }
        if (this.players[pusher.number - 1].popups.find((x) => x.msg === "noPush")) {
          this.players[pusher.number - 1].popups.splice(
            this.players[pusher.number - 1].popups.findIndex((x) => x.msg === "noPush"),
            1
          );
        }

        // MOVE TARGET PLAYER
        this.players[targetPlayer.number - 1].strafing.direction = impactDirection;
        this.players[targetPlayer.number - 1].strafing.state = true;
        this.players[targetPlayer.number - 1].action = "strafe moving";

        this.unsetDeflection(targetPlayer);

        this.players[targetPlayer.number - 1].pushed = {
          state: true,
          pusher: pusher.number,
          moveSpeed: moveSpeed,
        };
        this.getTarget(targetPlayer);

        if (
          !this.players[targetPlayer.number - 1].popups.find(
            (x) => x.msg === "pushedPulled"
          )
        ) {
          this.players[targetPlayer.number - 1].popups.push({
            state: false,
            count: 0,
            limit: this.players[targetPlayer.number - 1].prePull.limit,
            type: "",
            position: "",
            msg: "pushedPulled",
            img: "",
          });
        }

        this.players[targetPlayer.number - 1].moving = {
          state: true,
          step: 0,
          course: "",
          origin: {
            number: {
              x: targetPlayer.currentPosition.cell.number.x,
              y: targetPlayer.currentPosition.cell.number.y,
            },
            center: {
              x: targetPlayer.currentPosition.cell.center,
              y: targetPlayer.currentPosition.cell.center,
            },
          },
          destination: destCellRef.center,
        };
        let targetPlyrNextPosition = this.lineCrementer(targetPlayer);
        this.players[targetPlayer.number - 1].nextPosition = targetPlyrNextPosition;

        // MOVE PUSHER
        this.players[pusher.number - 1].prePush = {
          state: false,
          count: 0,
          limit: pusher.prePush.limit,
          targetCell: undefined,
          direction: "",
          pusher: undefined,
        };
        if (movePlayer === true) {
          this.players[pusher.number - 1].pushing = {
            state: true,
            targetCell: targetCell,
            moveSpeed: moveSpeed,
          };

          if (pusher.turning.delayCount === 0) {
            this.players[pusher.number - 1].action = "moving";
            this.players[pusher.number - 1].moving = {
              state: true,
              step: 0,
              course: "",
              origin: {
                number: {
                  x: pusher.currentPosition.cell.number.x,
                  y: pusher.currentPosition.cell.number.y,
                },
                center: {
                  x: pusher.currentPosition.cell.center,
                  y: pusher.currentPosition.cell.center,
                },
              },
              destination: targetCell.center,
            };
            let nextPosition = this.lineCrementer(pusher);
            pusher.nextPosition = nextPosition;
          }
        } else {
          pusher.action = "idle";
        }
      }
    } else {
      pusher.stamina.current = 0;
      resetPush = true;
      pusher.statusDisplay = {
        state: true,
        status: "Out of Stamina",
        count: 1,
        limit: pusher.statusDisplay.limit,
      };

      if (!pusher.popups.find((x) => x.msg === "outOfStamina")) {
        pusher.popups.push({
          state: false,
          count: 0,
          limit: 20,
          type: "",
          position: "",
          msg: "outOfStamina",
          img: "",
        });
      }
    }

    if (resetPush === true) {
      this.players[pusher.number - 1].prePush = {
        state: false,
        count: 0,
        limit: pusher.prePush.limit,
        targetCell: undefined,
        direction: "",
        pusher: undefined,
      };
      this.players[pusher.number - 1].pushing = {
        state: false,
        targetCell: undefined,
        moveSpeed: 0,
      };
      if (this.players[pusher.number - 1].newPushPullDelay.state !== true) {
        this.players[pusher.number - 1].newPushPullDelay.state = true;
      }

      if (!this.players[pusher.number - 1].popups.find((x) => x.msg === "noPush")) {
        this.players[pusher.number - 1].popups.push({
          state: false,
          count: 0,
          limit: 25,
          type: "",
          position: "",
          msg: "noPush",
          img: "",
        });
      }

      if (this.players[pusher.number - 1].popups.find((x) => x.msg === "prePush")) {
        this.players[pusher.number - 1].popups.splice(
          this.players[pusher.number - 1].popups.findIndex((x) => x.msg === "prePush"),
          1
        );
      }
      if (this.players[pusher.number - 1].popups.find((x) => x.msg === "canaPush")) {
        this.players[pusher.number - 1].popups.splice(
          this.players[pusher.number - 1].popups.findIndex((x) => x.msg === "canPush"),
          1
        );
      }

      if (canPushTargetFree !== true && destCellOccupant !== "") {
        let type = destCellOccupant;
        if (type.split("_")[1]) {
          type = "player";
        }
        this.startHalfPushBack("player", type, impactDirection, targetPlayer);
      }
    }
  };
  preObstaclePullCheck = (player, target, pullDirection) => {
    // console.log('pre obstacle pull check');

    let resetPull = false;
    let refCell = this.gridInfo.find(
      (x) => x.number.x === target.cell1.number.x && x.number.y === target.cell1.number.y
    );
    let plyrRefCell = this.gridInfo.find(
      (x) =>
        x.number.x === player.currentPosition.cell.number.x &&
        x.number.y === player.currentPosition.cell.number.y
    );
    let limit = player.defending.limit - 1;
    let myCellCheck = true;
    if (
      plyrRefCell.barrier.state === true &&
      plyrRefCell.barrier.position === player.direction
    ) {
      myCellCheck = false;
    }
    if (myCellCheck !== true) {
      console.log("a barrier in player cell is blocking a pull");
      resetPull = true;
    }

    if (refCell.obstacle.state !== true) {
      console.log("barrier not obstacle. Cant be pulled");
      resetPull = true;
    } else if (
      refCell.obstacle.moving.pushable === true &&
      myCellCheck === true &&
      player.newPushPullDelay.state !== true
    ) {
      if (player.prePull.state !== true && player.prePull.count === 0) {
        // console.log('start pre pull');
        player.prePull = {
          state: true,
          count: player.prePull.count++,
          limit: player.prePull.limit,
          targetCell: refCell,
          direction: pullDirection,
          puller: player.number,
        };
      }

      if (player.prePull.state === true) {
        if (player.prePull.count >= player.prePull.limit) {
          // if (player.prePull.count >= 25) {
          // if (player.prePull.count >= limit) {

          // console.log("pre pull limit. check can pull");
          this.players[player.number - 1].prePull = player.prePull;
          this.players[player.number - 1].pulling = player.pulling;
          if (player.popups.find((x) => x.msg === "prePull")) {
            player.popups.splice(
              player.popups.findIndex((x) => x.msg === "prePull"),
              1
            );
          }
          this.canPullObstacle(player, refCell);
        } else {
          if (
            player.prePull.targetCell.number.x === refCell.number.x &&
            player.prePull.targetCell.number.y === refCell.number.y &&
            player.prePull.direction === pullDirection &&
            player.prePull.puller === player.number
          ) {
            player.prePull.count++;
            if (!player.popups.find((x) => x.msg === "prePull")) {
              player.popups.push({
                state: false,
                count: 0,
                limit: player.prePull.limit,
                type: "",
                position: "",
                msg: "prePull",
                img: "",
              });
            }
            // console.log('pre pulling the same obstacle. Continue',player.prePull.count,limit);
          } else {
            // console.log('pre pull player, target or direction has changed. Reset prepull');
            player.action = "idle";
            player.prePull = {
              state: false,
              count: 0,
              limit: player.prePull.limit,
              targetCell: undefined,
              direction: "",
              puller: undefined,
            };

            resetPull = true;
          }
        }
      }
    }

    if (player.newPushPullDelay.state === true) {
      resetPull = true;
    }

    if (refCell.obstacle.moving.pushable !== true) {
      console.log("obstacle is instrinsically unpullable");
      resetPull = true;
    }

    if (resetPull === true) {
      player.action = "idle";
      player.prePull = {
        state: false,
        count: 0,
        limit: player.prePull.limit,
        targetCell: undefined,
        direction: "",
        puller: undefined,
      };
      player.postPull = {
        state: true,
        count: 0,
        limit: player.postPull.limit,
      };

      this.keyPressed[player.number - 1].pull = false;

      if (this.players[player.number - 1].newPushPullDelay.state !== true) {
        this.players[player.number - 1].newPushPullDelay.state = true;
      }

      if (!player.popups.find((x) => x.msg === "noPull")) {
        player.popups.push({
          state: false,
          count: 0,
          limit: player.prePull.limit,
          type: "",
          position: "",
          msg: "noPull",
          img: "",
        });
      }

      if (player.popups.find((x) => x.msg === "prePull")) {
        player.popups.splice(
          player.popups.findIndex((x) => x.msg === "prePull"),
          1
        );
      }
      if (player.popups.find((x) => x.msg === "canPull")) {
        player.popups.splice(
          player.popups.findIndex((x) => x.msg === "canPull"),
          1
        );
      }
    }

    this.players[player.number - 1].prePull = player.prePull;
    this.players[player.number - 1].pulling = player.pulling;
  };
  canPullObstacle = (player, obstacleCell) => {
    let resetPull = false;
    let thresholdMultiplier = this.rnJesus(1, 3);
    let canPullStrength = false;
    let canPullTargetFree = true;
    let pullStrengthThreshold =
      (obstacleCell.obstacle.height + obstacleCell.obstacle.weight) * thresholdMultiplier;
    let pullStrengthPlayer = 0;
    let impactDirection = player.prePull.direction;

    if (player.stamina.current - this.staminaCostRef.pull >= 0) {
      player.stamina.current = player.stamina.current - this.staminaCostRef.pull;

      if (player.hp > 1) {
        pullStrengthPlayer += player.hp - 1;
      }
      pullStrengthPlayer += player.crits.pushBack - 3;
      pullStrengthPlayer += player.crits.guardBreak - 2;
      let playerCellRef = this.gridInfo.find(
        (x) =>
          x.number.x === player.currentPosition.cell.number.x &&
          x.number.y === player.currentPosition.cell.number.y
      );

      let destCell = this.getCellFromDirection(
        1,
        player.currentPosition.cell.number,
        impactDirection
      );

      let destCellRef = this.gridInfo.find(
        (x) => x.number.x === destCell.x && x.number.y === destCell.y
      );
      let destCellOccupant = "";

      let preMoveSpeed = Math.ceil(pullStrengthPlayer / pullStrengthThreshold);
      let moveSpeed = 0;
      if (preMoveSpeed <= 1) {
        moveSpeed = 0.05;
      }
      if (preMoveSpeed === 2) {
        moveSpeed = 0.1;
      }
      if (preMoveSpeed > 2 && preMoveSpeed < 4) {
        moveSpeed = 0.125;
      }
      if (preMoveSpeed >= 4) {
        moveSpeed = 0.2;
      }
      // pullStrengthThreshold = 100
      if (this.terrainMoveSpeedRef[obstacleCell.terrain.type]) {
        moveSpeed = this.terrainMoveSpeedRef[obstacleCell.terrain.type];
      }

      if (destCellRef) {
        if (destCellRef.obstacle.state === true) {
          canPullTargetFree = false;
          destCellOccupant = "obstacle";
          resetPull = true;
        }

        if (destCellRef.barrier.state === true) {
          let barrier = this.checkForwardBarrier(impactDirection, destCellRef);

          if (barrier === true) {
            canPullTargetFree = false;
            destCellOccupant = "barrier";
            resetPull = true;
          }
        }

        if (obstacleCell.barrier.state === true) {
          if (obstacleCell.barrier.position === impactDirection) {
            console.log("barrier in obstacle cell behind obstacle");
            canPullTargetFree = false;
            destCellOccupant = "barrier";
            resetPull = true;
          }
        }

        for (const plyr of this.players) {
          if (
            plyr.currentPosition.cell.number.x === destCell.x &&
            plyr.currentPosition.cell.number.y === destCell.y
          ) {
            canPullTargetFree = false;
            resetPull = true;
            destCellOccupant = `player_${plyr.number}`;
          }
        }
      }

      if (!destCellRef && pullStrengthPlayer >= pullStrengthThreshold) {
        // console.log('ready to pull',moveSpeed);
        if (!this.players[player.number - 1].popups.find((x) => x.msg === "canPull")) {
          this.players[player.number - 1].popups.push({
            state: false,
            count: 0,
            limit: 25,
            type: "",
            position: "",
            msg: "canPull",
            img: "",
          });
        }

        if (this.players[player.number - 1].popups.find((x) => x.msg === "prePull")) {
          this.players[player.number - 1].popups.splice(
            this.players[player.number - 1].popups.findIndex((x) => x.msg === "prePull"),
            1
          );
        }
        if (this.players[player.number - 1].popups.find((x) => x.msg === "noPull")) {
          this.players[player.number - 1].popups.splice(
            this.players[player.number - 1].popups.findIndex((x) => x.msg === "noPull"),
            1
          );
        }

        let voidCenter = this.getVoidCenter(1, impactDirection, playerCellRef.center);

        let obstacleCrementObj = this.obstacleMoveCrementer(obstacleCell, {
          center: playerCellRef.center,
        });

        obstacleCell.obstacle = {
          id: obstacleCell.obstacle.id,
          trap: obstacleCell.obstacle.trap,
          state: obstacleCell.obstacle.state,
          name: obstacleCell.obstacle.name,
          type: obstacleCell.obstacle.type,
          hp: obstacleCell.obstacle.hp,
          destructible: obstacleCell.obstacle.destructible,
          locked: obstacleCell.obstacle.locked,
          weight: obstacleCell.obstacle.weight,
          height: obstacleCell.obstacle.height,
          items: obstacleCell.obstacle.items,
          effects: obstacleCell.obstacle.effects,
          moving: {
            state: true,
            step: obstacleCrementObj.step,
            origin: {
              number: obstacleCell.number,
              center: obstacleCell.center,
            },
            destination: {
              number: playerCellRef.number,
              center: playerCellRef.center,
            },
            currentPosition: obstacleCell.center,
            nextPosition: obstacleCrementObj.pos,
            moveSpeed: moveSpeed,
            pushable: true,
            pushed: true,
            pusher: player.number,
            falling: obstacleCell.obstacle.moving.falling,
          },
        };

        this.players[player.number - 1].prePull = {
          state: false,
          count: 0,
          limit: player.prePull.limit,
          targetCell: undefined,
          direction: impactDirection,
          puller: undefined,
        };
        this.players[player.number - 1].pulling = {
          state: true,
          targetCell: obstacleCell,
          moveSpeed: moveSpeed,
        };

        // this.players[player.number-1].postPull = {
        //   state: true,
        //   count: 0,
        //   limit: player.postPull.limit
        // }
        this.getTarget(player);
        console.log("here", voidCenter);

        this.players[player.number - 1].prePull.direction = "";

        if (player.turning.delayCount === 0) {
          player.target.cell1.void = true;
          this.players[player.number - 1].strafing.direction = impactDirection;
          this.players[player.number - 1].strafing.state = true;
          this.players[player.number - 1].action = "strafe moving";
          this.players[player.number - 1].moving = {
            state: true,
            step: 0,
            course: "",
            origin: {
              number: {
                x: player.currentPosition.cell.number.x,
                y: player.currentPosition.cell.number.y,
              },
              center: {
                x: player.currentPosition.cell.center,
                y: player.currentPosition.cell.center,
              },
            },
            destination: voidCenter,
          };
          let nextPosition = this.lineCrementer(player);
          player.nextPosition = nextPosition;
        }
      }

      // console.log('pushStrengthThreshold/Player',pushStrengthThreshold,pushStrengthPlayer);
      pullStrengthPlayer += 15;
      if (
        pullStrengthPlayer >= pullStrengthThreshold &&
        obstacleCell.obstacle.moving.pushable === true
      ) {
        canPullStrength = true;
        // console.log(
        //   "you are strongh enough to pull this obstacle",
        //   pullStrengthPlayer,
        //   pullStrengthThreshold,
        //   player.crits.guardBreak - 2,
        //   player.crits.pushBack - 2
        // );
      } else {
        console.log(
          "you are NOT strong enough to pull this obstacle",
          pullStrengthPlayer,
          pullStrengthThreshold,
          player.crits.guardBreak - 2,
          player.crits.pushBack - 2
        );
        resetPull = true;
      }

      if (canPullTargetFree !== true) {
        console.log("something is in the way of the obstacle to be pulled");
        resetPull = true;
      }

      if (canPullStrength === true && canPullTargetFree === true && destCellRef) {
        // console.log('ready to pull',moveSpeed);
        if (!this.players[player.number - 1].popups.find((x) => x.msg === "canPull")) {
          this.players[player.number - 1].popups.push({
            state: false,
            count: 0,
            limit: 25,
            type: "",
            position: "",
            msg: "canPull",
            img: "",
          });
        }

        if (this.players[player.number - 1].popups.find((x) => x.msg === "prePull")) {
          this.players[player.number - 1].popups.splice(
            this.players[player.number - 1].popups.findIndex((x) => x.msg === "prePull"),
            1
          );
        }
        if (this.players[player.number - 1].popups.find((x) => x.msg === "noPull")) {
          this.players[player.number - 1].popups.splice(
            this.players[player.number - 1].popups.findIndex((x) => x.msg === "noPull"),
            1
          );
        }

        let obstacleCrementObj = this.obstacleMoveCrementer(obstacleCell, playerCellRef);

        obstacleCell.obstacle = {
          id: obstacleCell.obstacle.id,
          trap: obstacleCell.obstacle.trap,
          state: obstacleCell.obstacle.state,
          name: obstacleCell.obstacle.name,
          type: obstacleCell.obstacle.type,
          hp: obstacleCell.obstacle.hp,
          destructible: obstacleCell.obstacle.destructible,
          locked: obstacleCell.obstacle.locked,
          weight: obstacleCell.obstacle.weight,
          height: obstacleCell.obstacle.height,
          items: obstacleCell.obstacle.items,
          effects: obstacleCell.obstacle.effects,
          moving: {
            state: true,
            step: obstacleCrementObj.step,
            origin: {
              number: obstacleCell.number,
              center: obstacleCell.center,
            },
            destination: {
              number: playerCellRef.number,
              center: playerCellRef.center,
            },
            currentPosition: obstacleCell.center,
            nextPosition: obstacleCrementObj.pos,
            moveSpeed: moveSpeed,
            pushable: true,
            pushed: true,
            pusher: player.number,
            falling: obstacleCell.obstacle.moving.falling,
          },
        };

        this.players[player.number - 1].prePull = {
          state: false,
          count: 0,
          limit: player.prePull.limit,
          targetCell: undefined,
          direction: impactDirection,
          puller: undefined,
        };
        this.players[player.number - 1].pulling = {
          state: true,
          targetCell: obstacleCell,
          moveSpeed: moveSpeed,
        };
        this.players[player.number - 1].defending = {
          state: false,
          count: 0,
          limit: player.defending.limit,
          animRef: player.defending.animRef,
          peak: false,
          peakCount: 0,
          decay: {
            state: false,
            count: 0,
            limit: player.defending.decay.limit,
          },
          direction: "",
          directionType: "", //thrust or slash
        };

        this.getTarget(player);

        this.players[player.number - 1].prePull.direction = "";

        if (player.turning.delayCount === 0) {
          this.players[player.number - 1].strafing.direction = impactDirection;
          this.players[player.number - 1].strafing.state = true;
          this.players[player.number - 1].action = "strafe moving";
          this.players[player.number - 1].moving = {
            state: true,
            step: 0,
            course: "",
            origin: {
              number: {
                x: player.currentPosition.cell.number.x,
                y: player.currentPosition.cell.number.y,
              },
              center: {
                x: player.currentPosition.cell.center,
                y: player.currentPosition.cell.center,
              },
            },
            destination: destCellRef.center,
          };
          let nextPosition = this.lineCrementer(player);
          player.nextPosition = nextPosition;
        }
      }
    } else {
      player.stamina.current = 0;
      resetPull = true;
      player.statusDisplay = {
        state: true,
        status: "Out of Stamina",
        count: 1,
        limit: player.statusDisplay.limit,
      };

      if (!player.popups.find((x) => x.msg === "outOfStamina")) {
        player.popups.push({
          state: false,
          count: 0,
          limit: 20,
          type: "",
          position: "",
          msg: "outOfStamina",
          img: "",
        });
      }
    }

    if (resetPull === true) {
      this.players[player.number - 1].action = "idle";
      this.players[player.number - 1].prePull = {
        state: false,
        count: 0,
        limit: player.prePull.limit,
        targetCell: undefined,
        direction: "",
        puller: undefined,
      };
      this.players[player.number - 1].pulling = {
        state: false,
        targetCell: undefined,
        moveSpeed: 0,
      };

      this.players[player.number - 1].postPull = {
        state: true,
        count: 0,
        limit: player.postPull.limit,
      };

      this.keyPressed[player.number - 1].pull = false;

      if (this.players[player.number - 1].newPushPullDelay.state !== true) {
        this.players[player.number - 1].newPushPullDelay.state = true;
      }

      if (!this.players[player.number - 1].popups.find((x) => x.msg === "noPull")) {
        this.players[player.number - 1].popups.push({
          state: false,
          count: 0,
          limit: 25,
          type: "",
          position: "",
          msg: "noPull",
          img: "",
        });
      }

      if (this.players[player.number - 1].popups.find((x) => x.msg === "prePull")) {
        this.players[player.number - 1].popups.splice(
          this.players[player.number - 1].popups.findIndex((x) => x.msg === "prePull"),
          1
        );
      }
      if (this.players[player.number - 1].popups.find((x) => x.msg === "canPull")) {
        this.players[player.number - 1].popups.splice(
          this.players[player.number - 1].popups.findIndex((x) => x.msg === "canPull"),
          1
        );
      }
    }
  };
  prePlayerPullCheck = (puller, target, pullDirection) => {
    // console.log('pre player pull check');

    let resetPull = false;
    let targetCell = this.gridInfo.find(
      (x) => x.number.x === target.cell1.number.x && x.number.y === target.cell1.number.y
    );
    let plyrRefCell = this.gridInfo.find(
      (x) =>
        x.number.x === puller.currentPosition.cell.number.x &&
        x.number.y === puller.currentPosition.cell.number.y
    );
    let limit = puller.defending.limit - 1;
    let myCellCheck = true;
    if (
      plyrRefCell.barrier.state === true &&
      plyrRefCell.barrier.position === puller.direction
    ) {
      myCellCheck = false;
    }
    if (myCellCheck !== true) {
      console.log("a barrier in player cell is blocking a player push");
      resetPull = true;
    }

    let targetOpen = false;
    let targetPlayer = this.players[target.cell1.occupant.player - 1];
    if (targetPlayer.success.deflected.state === true || targetPlayer.action === "idle") {
      targetOpen = true;
    } else {
      console.log("target player is no longer deflected or idle");
      resetPull = true;
    }

    if (
      targetOpen === true &&
      myCellCheck === true &&
      puller.newPushPullDelay.state !== true
    ) {
      if (puller.prePull.state !== true && puller.prePull.count === 0) {
        // console.log('start player pre pull');
        puller.prePull = {
          state: true,
          count: puller.prePull.count++,
          limit: puller.prePull.limit,
          targetCell: targetCell,
          direction: pullDirection,
          puller: puller.number,
        };
      }

      if (puller.prePull.state === true) {
        if (puller.prePull.count >= puller.prePull.limit) {
          // if (puller.prePllh.count >= 25) {
          // if (puller.prePull.count >= limit) {

          // console.log('pre pull limit. check can pull player');
          this.players[puller.number - 1].prePull = puller.prePull;
          this.players[puller.number - 1].pulling = puller.pulling;
          if (puller.popups.find((x) => x.msg === "prePull")) {
            puller.popups.splice(
              puller.popups.findIndex((x) => x.msg === "prePull"),
              1
            );
          }
          this.canPullPlayer(puller, targetCell, targetPlayer);
        } else {
          if (
            puller.prePull.targetCell.number.x === targetCell.number.x &&
            puller.prePull.targetCell.number.y === targetCell.number.y &&
            puller.prePull.direction === pullDirection &&
            puller.prePull.puller === puller.number
          ) {
            puller.prePull.count++;
            if (!puller.popups.find((x) => x.msg === "prePull")) {
              puller.popups.push({
                state: false,
                count: 0,
                limit: puller.prePull.limit,
                type: "",
                position: "",
                msg: "prePull",
                img: "",
              });
            }
            // console.log('pre pulling the same player. Continue',puller.prePull.count);
          } else {
            // console.log('pre pull player, target or direction has changed. Reset prepull');
            puller.prePull = {
              state: false,
              count: 0,
              limit: puller.prePull.limit,
              targetCell: undefined,
              direction: "",
              puller: undefined,
            };

            resetPull = true;
          }
        }
      }
    }

    if (puller.newPushPullDelay.state === true) {
      resetPull = true;
    }

    if (targetOpen !== true) {
      // console.log('player is unpullable');
      resetPull = true;
    }

    if (resetPull === true) {
      puller.action = "idle";
      puller.prePull = {
        state: false,
        count: 0,
        limit: puller.prePull.limit,
        targetCell: undefined,
        direction: "",
        puller: undefined,
      };

      this.keyPressed[puller.number - 1].pull = false;

      if (this.players[puller.number - 1].newPushPullDelay.state !== true) {
        this.players[puller.number - 1].newPushPullDelay.state = true;
      }

      if (!this.players[puller.number - 1].popups.find((x) => x.msg === "noPull")) {
        this.players[puller.number - 1].popups.push({
          state: false,
          count: 0,
          limit: this.players[puller.number - 1].prePull.limit,
          type: "",
          position: "",
          msg: "noPull",
          img: "",
        });
      }

      if (this.players[puller.number - 1].popups.find((x) => x.msg === "prePull")) {
        this.players[puller.number - 1].popups.splice(
          this.players[puller.number - 1].popups.findIndex((x) => x.msg === "prePull"),
          1
        );
      }
      if (this.players[puller.number - 1].popups.find((x) => x.msg === "canPull")) {
        this.players[puller.number - 1].popups.splice(
          this.players[puller.number - 1].popups.findIndex((x) => x.msg === "canPull"),
          1
        );
      }
    }

    this.players[puller.number - 1].prePull = puller.prePull;
    this.players[puller.number - 1].pulling = puller.pulling;
  };
  canPullPlayer = (puller, targetCell, targetPlayer) => {
    let resetPull = false;
    let thresholdMultiplier = this.rnJesus(1, 3);
    let canPullStrength = false;
    let canPullTargetFree = true;
    let pullStrengthThreshold =
      (targetPlayer.hp +
        (targetPlayer.crits.pushBack - 3) +
        (targetPlayer.crits.guardBreak - 2)) *
      thresholdMultiplier;
    let pullStrengthPlayer = 0;
    let movePlayer = true;
    let impactDirection = puller.prePull.direction;
    let pullerCellRef = this.gridInfo.find(
      (x) =>
        x.number.x === puller.currentPosition.cell.number.x &&
        x.number.y === puller.currentPosition.cell.number.y
    );

    if (puller.stamina.current - this.staminaCostRef.pull >= 0) {
      puller.stamina.current = puller.stamina.current - this.staminaCostRef.pull;

      if (puller.hp > 1) {
        pullStrengthPlayer += puller.hp - 1;
      }
      pullStrengthPlayer += puller.crits.pushBack - 3;
      pullStrengthPlayer += puller.crits.guardBreak - 2;
      pullStrengthPlayer += 15;

      let destCell = this.getCellFromDirection(
        1,
        puller.currentPosition.cell.number,
        impactDirection
      );

      // console.log('destCell',destCell,'pull pos',puller.currentPosition.cell.number,'impact dir',impactDirection);
      let destCellRef = this.gridInfo.find(
        (x) => x.number.x === destCell.x && x.number.y === destCell.y
      );
      let destCellOccupant = "";

      let preMoveSpeed = Math.ceil(pullStrengthPlayer / pullStrengthThreshold);
      let moveSpeed = 0;
      if (preMoveSpeed <= 1) {
        moveSpeed = 0.05;
      }
      if (preMoveSpeed === 2) {
        moveSpeed = 0.1;
      }
      if (preMoveSpeed > 2 && preMoveSpeed < 4) {
        moveSpeed = 0.125;
      }
      if (preMoveSpeed >= 4) {
        moveSpeed = 0.2;
      }

      if (destCellRef) {
        if (destCellRef.obstacle.state === true) {
          canPullTargetFree = false;
          destCellOccupant = "obstacle";
          resetPull = true;
        }

        if (destCellRef.barrier.state === true) {
          let barrier = this.checkForwardBarrier(impactDirection, destCellRef);

          if (barrier === true) {
            canPullTargetFree = false;
            destCellOccupant = "barrier";
            resetPull = true;
          }
        }

        if (targetCell.barrier.state === true) {
          // --------------
          let barrier = this.checkForwardBarrier(impactDirection, targetCell);

          if (barrier === true) {
            console.log("barrier in obstacle cell in front of target player");
            canPullTargetFree = false;
            destCellOccupant = "barrier";
            resetPull = true;
          }
          // --------------

          if (targetCell.barrier.position === impactDirection) {
            console.log("barrier in target player cell behind target player");
            canPullTargetFree = false;
            destCellOccupant = "barrier";
            resetPull = true;
          }
        }

        for (const plyr of this.players) {
          if (
            plyr.currentPosition.cell.number.x === destCell.x &&
            plyr.currentPosition.cell.number.y === destCell.y
          ) {
            // change when implementing push player
            canPullTargetFree = false;
            resetPull = true;
            destCellOccupant = `player_${plyr.number}`;
          }
        }
      }

      if (pullStrengthPlayer >= pullStrengthThreshold) {
        canPullStrength = true;
        // console.log(
        //   "you are strongh enough to pull this player",
        //   pullStrengthPlayer,
        //   pullStrengthThreshold,
        //   puller.crits.guardBreak - 2,
        //   puller.crits.pushBack - 2
        // );
      } else {
        console.log(
          "you are NOT strong enough to pull this player",
          pullStrengthPlayer,
          pullStrengthThreshold,
          puller.crits.guardBreak - 2,
          puller.crits.pushBack - 2
        );
        resetPull = true;
      }

      // movePlayer = true;

      if (!destCellRef && pullStrengthPlayer >= pullStrengthThreshold) {
        // console.log('ready to pull',moveSpeed);
        if (!this.players[puller.number - 1].popups.find((x) => x.msg === "canPull")) {
          this.players[puller.number - 1].popups.push({
            state: false,
            count: 0,
            limit: 25,
            type: "",
            position: "",
            msg: "canPull",
            img: "",
          });
        }

        if (this.players[puller.number - 1].popups.find((x) => x.msg === "prePull")) {
          this.players[puller.number - 1].popups.splice(
            this.players[puller.number - 1].popups.findIndex((x) => x.msg === "prePull"),
            1
          );
        }
        if (this.players[puller.number - 1].popups.find((x) => x.msg === "noPull")) {
          this.players[puller.number - 1].popups.splice(
            this.players[puller.number - 1].popups.findIndex((x) => x.msg === "noPull"),
            1
          );
        }

        let voidCenter = this.getVoidCenter(1, impactDirection, pullerCellRef.center);

        // MOVE TARGET PLAYER

        if (puller.prePull.direction !== targetPlayer.direction) {
          this.players[targetPlayer.number - 1].strafing.direction = impactDirection;
          this.players[targetPlayer.number - 1].strafing.state = true;
          this.players[targetPlayer.number - 1].action = "strafe moving";
        } else {
          this.players[targetPlayer.number - 1].action = "moving";
        }

        this.unsetDeflection(targetPlayer);

        this.players[targetPlayer.number - 1].pulled = {
          state: true,
          puller: puller.number,
          moveSpeed: moveSpeed,
        };
        this.getTarget(targetPlayer);

        if (
          !this.players[targetPlayer.number - 1].popups.find(
            (x) => x.msg === "pushedPulled"
          )
        ) {
          this.players[targetPlayer.number - 1].popups.push({
            state: false,
            count: 0,
            limit: this.players[targetPlayer.number - 1].prePull.limit,
            type: "",
            position: "",
            msg: "pushedPulled",
            img: "",
          });
        }

        this.players[targetPlayer.number - 1].moving = {
          state: true,
          step: 0,
          course: "",
          origin: {
            number: {
              x: targetPlayer.currentPosition.cell.number.x,
              y: targetPlayer.currentPosition.cell.number.y,
            },
            center: {
              x: targetPlayer.currentPosition.cell.center,
              y: targetPlayer.currentPosition.cell.center,
            },
          },
          destination: pullerCellRef.center,
        };
        let targetPlyrNextPosition = this.lineCrementer(targetPlayer);
        this.players[targetPlayer.number - 1].nextPosition = targetPlyrNextPosition;

        // MOVE PUllER
        this.players[puller.number - 1].prePull = {
          state: false,
          count: 0,
          limit: puller.prePull.limit,
          targetCell: undefined,
          direction: impactDirection,
          puller: undefined,
        };

        if (movePlayer === true) {
          this.players[puller.number - 1].pulling = {
            state: true,
            targetCell: targetCell,
            moveSpeed: moveSpeed,
          };

          this.getTarget(puller);

          if (puller.turning.delayCount === 0) {
            this.players[puller.number - 1].strafing.direction = impactDirection;
            this.players[puller.number - 1].strafing.state = true;
            this.players[puller.number - 1].action = "strafe moving";
            this.players[puller.number - 1].moving = {
              state: true,
              step: 0,
              course: "",
              origin: {
                number: {
                  x: puller.currentPosition.cell.number.x,
                  y: puller.currentPosition.cell.number.y,
                },
                center: {
                  x: puller.currentPosition.cell.center,
                  y: puller.currentPosition.cell.center,
                },
              },
              destination: voidCenter,
            };
            let nextPosition = this.lineCrementer(puller);
            puller.nextPosition = nextPosition;
          }
        }

        this.players[puller.number - 1].prePull.direction = "";
      }

      // console.log('pullStrengthThreshold/Player',pullStrengthThreshold,pullStrengthPlayer);

      if (canPullTargetFree !== true) {
        console.log("something is in the way of the player to be pulled");
        resetPull = true;
      }

      if (canPullStrength === true && canPullTargetFree === true && destCellRef) {
        // console.log('ready to pull',moveSpeed);
        if (!this.players[puller.number - 1].popups.find((x) => x.msg === "canPull")) {
          this.players[puller.number - 1].popups.push({
            state: false,
            count: 0,
            limit: 25,
            type: "",
            position: "",
            msg: "canPull",
            img: "",
          });
        }

        if (this.players[puller.number - 1].popups.find((x) => x.msg === "prePull")) {
          this.players[puller.number - 1].popups.splice(
            this.players[puller.number - 1].popups.findIndex((x) => x.msg === "prePull"),
            1
          );
        }
        if (this.players[puller.number - 1].popups.find((x) => x.msg === "noPull")) {
          this.players[puller.number - 1].popups.splice(
            this.players[puller.number - 1].popups.findIndex((x) => x.msg === "noPull"),
            1
          );
        }

        // MOVE TARGET PLAYER
        if (impactDirection !== targetPlayer.direction) {
          this.players[targetPlayer.number - 1].strafing.direction = impactDirection;
          this.players[targetPlayer.number - 1].strafing.state = true;
          this.players[targetPlayer.number - 1].action = "strafe moving";
        } else {
          this.players[targetPlayer.number - 1].action = "moving";
        }

        this.unsetDeflection(targetPlayer);

        this.players[targetPlayer.number - 1].pulled = {
          state: true,
          puller: puller.number,
          moveSpeed: moveSpeed,
        };

        this.getTarget(targetPlayer);

        if (
          !this.players[targetPlayer.number - 1].popups.find(
            (x) => x.msg === "pushedPulled"
          )
        ) {
          this.players[targetPlayer.number - 1].popups.push({
            state: false,
            count: 0,
            limit: this.players[targetPlayer.number - 1].prePull.limit,
            type: "",
            position: "",
            msg: "pushedPulled",
            img: "",
          });
        }

        this.players[targetPlayer.number - 1].moving = {
          state: true,
          step: 0,
          course: "",
          origin: {
            number: {
              x: targetPlayer.currentPosition.cell.number.x,
              y: targetPlayer.currentPosition.cell.number.y,
            },
            center: {
              x: targetPlayer.currentPosition.cell.center,
              y: targetPlayer.currentPosition.cell.center,
            },
          },
          destination: pullerCellRef.center,
        };
        let targetPlyrNextPosition = this.lineCrementer(targetPlayer);
        this.players[targetPlayer.number - 1].nextPosition = targetPlyrNextPosition;

        // MOVE PULLER
        this.players[puller.number - 1].prePull = {
          state: false,
          count: 0,
          limit: puller.prePull.limit,
          targetCell: undefined,
          direction: impactDirection,
          puller: undefined,
        };
        this.players[puller.number - 1].defending = {
          state: false,
          count: 0,
          limit: puller.defending.limit,
          animRef: puller.defending.animRef,
          peak: false,
          peakCount: 0,
          decay: {
            state: false,
            count: 0,
            limit: puller.defending.decay.limit,
          },
          direction: "",
          directionType: "", //thrust or slash
        };

        if (movePlayer === true) {
          this.players[puller.number - 1].pulling = {
            state: true,
            targetCell: targetCell,
            moveSpeed: moveSpeed,
          };

          this.getTarget(puller);

          this.players[puller.number - 1].prePull.direction = "";

          if (puller.turning.delayCount === 0) {
            this.players[puller.number - 1].strafing.direction = impactDirection;
            this.players[puller.number - 1].strafing.state = true;
            this.players[puller.number - 1].action = "strafe moving";
            this.players[puller.number - 1].moving = {
              state: true,
              step: 0,
              course: "",
              origin: {
                number: {
                  x: puller.currentPosition.cell.number.x,
                  y: puller.currentPosition.cell.number.y,
                },
                center: {
                  x: puller.currentPosition.cell.center,
                  y: puller.currentPosition.cell.center,
                },
              },
              destination: destCellRef.center,
            };
            let nextPosition = this.lineCrementer(puller);
            puller.nextPosition = nextPosition;
          }
        } else {
          puller.action = "idle";
        }
      }

      // if target isn't free, 1/2 pushback
    } else {
      puller.stamina.current = 0;
      resetPull = true;
      puller.statusDisplay = {
        state: true,
        status: "Out of Stamina",
        count: 1,
        limit: puller.statusDisplay.limit,
      };

      if (!puller.popups.find((x) => x.msg === "outOfStamina")) {
        puller.popups.push({
          state: false,
          count: 0,
          limit: 20,
          type: "",
          position: "",
          msg: "outOfStamina",
          img: "",
        });
      }
    }

    if (resetPull === true) {
      this.players[puller.number - 1].action = "idle";
      this.players[puller.number - 1].prePull = {
        state: false,
        count: 0,
        limit: puller.prePull.limit,
        targetCell: undefined,
        direction: "",
        puller: undefined,
      };
      this.players[puller.number - 1].pulling = {
        state: false,
        targetCell: undefined,
        moveSpeed: 0,
      };

      this.players[puller.number - 1].postPull = {
        state: true,
        count: 0,
        limit: puller.postPull.limit,
      };

      this.keyPressed[puller.number - 1].pull = false;

      if (this.players[puller.number - 1].newPushPullDelay.state !== true) {
        this.players[puller.number - 1].newPushPullDelay.state = true;
      }

      if (!this.players[puller.number - 1].popups.find((x) => x.msg === "noPull")) {
        this.players[puller.number - 1].popups.push({
          state: false,
          count: 0,
          limit: 25,
          type: "",
          position: "",
          msg: "noPull",
          img: "",
        });
      }

      if (this.players[puller.number - 1].popups.find((x) => x.msg === "prePull")) {
        this.players[puller.number - 1].popups.splice(
          this.players[puller.number - 1].popups.findIndex((x) => x.msg === "prePull"),
          1
        );
      }
      if (this.players[puller.number - 1].popups.find((x) => x.msg === "canPull")) {
        this.players[puller.number - 1].popups.splice(
          this.players[puller.number - 1].popups.findIndex((x) => x.msg === "canPull"),
          1
        );
      }
    }
  };

  respawn = (player) => {
    // console.log('respawning',player.number,player);

    if (this.camera.state !== true) {
      this.resetTarget(player);
      this.unsetDeflection(player);
      player.respawn = true;
      player.action = "idle";
      player.hp = 2;
      player.speed.move = 0.1;
      // player.dead = {
      //   state: false,
      //   count: 0,
      //   limit: player.dead.limit
      // }
      player.ghost.state = false;
      player.drowning = false;
      player.dodging = {
        countState: false,
        state: false,
        count: 0,
        limit: this.baseDodgeCountRef.limit,
        peak: {
          start: this.baseDodgeCountRef.peak.start,
          end: this.baseDodgeCountRef.peak.end,
        },
        direction: "",
      };
      player.crits = {
        singleHit: 1,
        doubleHit: 6,
        pushBack: 3,
        guardBreak: 3,
        dodge: 0,
      };
      player.items = {
        weaponIndex: 0,
        armorIndex: 0,
        weapons: [
          {
            name: "sword1",
            type: "sword",
            effect: "",
          },
        ],
        armor: [],
        ammo: 0,
      };
      player.currentWeapon = {
        name: "sword1",
        type: "sword",
        effect: "",
      };
      player.currentArmor = {};
      player.pushBack = {
        state: false,
        prePushBackMoveSpeed: 0,
      };
      player.flanking = {
        checking: false,
        direction: "",
        preFlankDirection: "",
        state: false,
        step: 0,
        target1: { x: 0, y: 0 },
        target2: { x: 0, y: 0 },
      };
      player.itemDrop = {
        state: false,
        count: 0,
        limit: 10,
        item: {
          name: "",
        },
        gear: {
          type: "",
        },
      };
      player.itemPickup = {
        state: false,
        count: 0,
        limit: 10,
        item: {
          name: "",
        },
        gear: {
          type: "",
        },
      };
      player.jumping = {
        checking: false,
        state: false,
      };
      player.stamina = {
        current: 20,
        max: 20,
      };
      player.popups = [];
      player.prePush = {
        state: false,
        count: 0,
        limit: 15,
        targetCell: undefined,
        direction: "",
        pusher: undefined,
      };
      player.pushing = {
        state: false,
        targetCell: undefined,
        moveSpeed: 0,
      };
      player.prePull = {
        state: false,
        count: 0,
        limit: 15,
        targetCell: undefined,
        direction: "",
        puller: undefined,
      };
      player.pulling = {
        state: false,
        targetCell: undefined,
        moveSpeed: 0,
      };
      player.postPull = {
        state: false,
        count: 0,
        limit: player.postPull.limit,
      };
      player.pushed = {
        state: false,
        pusher: 0,
        moveSpeed: 0,
      };
      player.pulled = {
        state: false,
        puller: 0,
        moveSpeed: 0,
      };
      player.popups = [
        {
          state: true,
          count: 0,
          limit: 0,
          type: "",
          position: "northWest",
          msg: "",
          img: "",
        },
      ];
      player.turning = {
        state: false,
        toDirection: "",
        delayCount: 0,
        limit: 5.1,
      };
      player.turnCheckerDirection = "";
      player.moving = {
        state: false,
        step: 0,
        course: "",
        origin: {
          number: {
            x: 0,
            y: 0,
          },
          center: {
            x: 0,
            y: 0,
          },
        },
        destination: {
          x: 0,
          y: 0,
        },
      };
      player.newMoveDelay = {
        state: false,
        count: 0,
        limit: 15,
      };
      player.strafeReleaseHook = false;
      player.moveCancel = {
        state: false,
        oldDirection: "",
        newDirection: "",
        returningTo: {},
        returningFrom: {},
      };
      player.attacking = {
        state: false,
        count: 0,
        limit: this.attackAnimRef.limit.sword.slash.normal,
        strength: 0,
        direction: "",
        directionType: "", //thrust or slash
        animRef: this.attackAnimRef,
        peak: false,
        peakCount: 0,
        charge: 0,
        chargePeak: false,
        blunt: false,
        clashing: {
          state: false,
          count: 0,
          limit: 10,
        },
      };
      player.defending = {
        state: false,
        count: 0,
        limit: this.defendAnimRef.limit.sword.slash,
        animRef: this.defendAnimRef,
        peak: false,
        peakCount: 0,
        decay: {
          state: false,
          count: 0,
          limit:
            this.defendAnimRef.limit.sword.slash - this.defendAnimRef.peak.sword.slash,
        },
        direction: "",
        directionType: "", //thrust or slash
      };
      player.success = {
        attackSuccess: {
          state: false,
          count: 0,
          limit: 10,
        },
        defendSuccess: {
          state: false,
          count: 0,
          limit: 10,
        },
        deflected: {
          state: false,
          count: 0,
          limit: 20,
          predeflect: false,
          type: "",
        },
      };
      player.halfPushBack = {
        state: false,
        direction: "",
        type: "",
        countUp: {
          state: true,
          count: 0,
          limit: 0,
        },
        countDown: {
          state: false,
          count: 0,
          limit: 0,
        },
        coords: {
          x: undefined,
          y: undefined,
        },
      };
      player.falling = {
        state: false,
        count: 0,
        limit: 10,
      };
      player.dead = {
        state: false,
        count: 0,
        limit: 10,
      };
      player.speed = {
        move: 0.1,
        range: [0.05, 0.1, 0.125, 0.2],
      };
      player.terrainMoveSpeed = {
        state: false,
        speed: 0,
      };
      player.inventorySize = 4;
      player.cycleWeapon = {
        state: false,
        count: 0,
        limit: 3,
      };
      player.cycleArmor = {
        state: false,
        count: 0,
        limit: 3,
      };
      player.statusDisplay = {
        state: false,
        status: "",
        count: 0,
        limit: 15,
      };
      player.discardGear = {
        state: false,
        count: 0,
        limit: 8,
      };
      player.ai = {
        state: false,
        imgType: "",
        primaryMission: "",
        mission: "",
        prevMission: "",
        currentObjective: "",
        targetSet: false,
        targetAcquired: false,
        safeRange: true,
        pathArray: [],
        targetPlayer: {
          number: 1,
          currentPosition: {
            x: undefined,
            y: undefined,
          },
          target: {
            number1: {
              x: undefined,
              y: undefined,
            },
            number2: {
              x: undefined,
              y: undefined,
            },
          },
          action: "",
        },
        instructions: [],
        currentInstruction: 0,
        resetInstructions: false,
        patrolling: {
          checkin: undefined,
          state: false,
          area: [],
          loopControl: false,
        },
        defending: {
          checkin: undefined,
          state: false,
          area: [],
        },
        persuing: {
          state: false,
        },
        engaging: {
          state: true,
          targetAction: "",
        },
        retrieving: {
          checkin: undefined,
          state: false,
          point: { x: undefined, y: undefined },
          targetItem: {
            name: "",
            type: "",
            subType: "",
            effect: "",
          },
          safe: true,
        },
        retreating: {
          checkin: undefined,
          state: false,
          point: { x: undefined, y: undefined },
          level: 0,
          safe: true,
        },
        organizing: {
          weaponPriorityIndex: 0,
          armorPriorityIndex: 0,
          dropped: {
            state: false,
            gear: {
              name: "",
              type: "",
              subType: "",
              effect: "",
            },
          },
        },
        mode: "",
        upgradeWeapon: false,
        upgradeArmor: false,
        pathfindingRanges: {
          spear: 3,
          crossbow: 5,
        },
      };
      player.newPushPullDelay = {
        state: false,
        count: 0,
        limit: 10,
      };
      player.elasticCounter = {
        preState: false,
        state: false,
        direction: "",
        type: "",
        subType: "",
        countUp: {
          state: false,
          count: 0,
          limit: 6,
        },
        countDown: {
          state: false,
          count: 0,
          limit: 6,
        },
        coords: {
          x: undefined,
          y: undefined,
        },
        pause: {
          preState: false,
          state: false,
          type: "",
          count: 0,
          limit: 6,
        },
      };

      this.players[player.number - 1] = player;
    } else {
      console.log("can't respawn in manual camera mode");
    }
  };
  killPlayer = (player) => {
    // console.log("killing player", player);

    player.ghost.state = true;
    player.ghost.position.cell = {
      number: {
        x: player.currentPosition.cell.number.x,
        y: player.currentPosition.cell.number.y,
      },
      center: {
        x: player.currentPosition.cell.center.x,
        y: player.currentPosition.cell.center.y,
      },
    };
    player.currentPosition.cell.number = { x: undefined, y: undefined };
    player.action = "idle";
    player.direction = "north";
    this.resetTarget(player);
    this.unsetDeflection(player);
    player.turning = {
      state: false,
      toDirection: "",
      delayCount: 0,
      limit: 5.1,
    };
    player.turnCheckerDirection = "";
    player.moving = {
      state: false,
      step: 0,
      course: "",
      origin: {
        number: {
          x: 0,
          y: 0,
        },
        center: {
          x: 0,
          y: 0,
        },
      },
      destination: {
        x: 0,
        y: 0,
      },
    };
    player.newMoveDelay = {
      state: false,
      count: 0,
      limit: 15,
    };
    player.strafing = {
      state: false,
      direction: "",
    };
    player.strafeReleaseHook = false;
    player.moveCancel = {
      state: false,
      oldDirection: "",
      newDirection: "",
      returningTo: {},
      returningFrom: {},
    };
    player.flanking = {
      checking: false,
      preFlankDirection: "",
      direction: "",
      state: false,
      step: 0,
      target1: { x: 0, y: 0 },
      target2: { x: 0, y: 0 },
    };
    player.attacking = {
      state: false,
      count: 0,
      limit: 20,
      strength: 0,
      direction: "",
      directionType: "", //thrust or slash
      animRef: this.attackAnimRef,
      peak: false,
      peakCount: 0,
      charge: 0,
      chargePeak: false,
      blunt: false,
      clashing: {
        state: false,
        count: 0,
        limit: 10,
      },
    };
    player.defending = {
      state: false,
      count: 0,
      limit: 4,
      animRef: this.defendAnimRef,
      peak: false,
      peakCount: 0,
      decay: {
        state: false,
        count: 0,
        limit: 25,
      },
      direction: "",
      directionType: "", //thrust or slash
    };
    player.drowning = false;
    player.dodging = {
      countState: false,
      state: false,
      count: 0,
      limit: this.baseDodgeCountRef.limit,
      peak: {
        start: this.baseDodgeCountRef.peak.start,
        end: this.baseDodgeCountRef.peak.end,
      },
      direction: "",
    };
    player.jumping = {
      checking: false,
      state: false,
    };
    player.success = {
      attackSuccess: {
        state: false,
        count: 0,
        limit: 10,
      },
      defendSuccess: {
        state: false,
        count: 0,
        limit: 10,
      },
      deflected: {
        state: false,
        count: 0,
        limit: 20,
        predeflect: false,
        type: "",
      },
    };
    player.pushBack = {
      state: false,
      prePushBackMoveSpeed: 0,
    };
    player.halfPushBack = {
      state: false,
      direction: "",
      type: "",
      countUp: {
        state: true,
        count: 0,
        limit: 0,
      },
      countDown: {
        state: false,
        count: 0,
        limit: 0,
      },
      coords: {
        x: undefined,
        y: undefined,
      },
    };
    player.falling = {
      state: false,
      count: 0,
      limit: 10,
    };
    player.dead = {
      state: true,
      count: 1,
      limit: player.dead.limit,
    };
    // player.ghost = {
    //   state: false,
    //   position: {
    //     cell: {
    //       number: {
    //         x: 0,
    //         y: 0,
    //       },
    //       center: {
    //         x: 0,
    //         y: 0,
    //       },
    //     },
    //   },
    // };
    player.respawn = false;
    player.speed = {
      move: 0.1,
      range: [0.05, 0.1, 0.125, 0.2],
    };
    player.terrainMoveSpeed = {
      state: false,
      speed: 0,
    };
    player.hp = 2;
    player.inventorySize = 4;
    player.cycleWeapon = {
      state: false,
      count: 0,
      limit: 3,
    };
    player.cycleArmor = {
      state: false,
      count: 0,
      limit: 3,
    };
    player.crits = {
      singleHit: 1,
      doubleHit: 6,
      pushBack: 4,
      guardBreak: 3,
      dodge: 0,
    };
    player.statusDisplay = {
      state: false,
      status: "",
      count: 0,
      limit: 15,
    };
    player.popups = [
      {
        state: true,
        count: 0,
        limit: 0,
        type: "",
        position: "northWest",
        msg: "",
        img: "",
      },
    ];
    player.itemDrop = {
      state: false,
      count: 0,
      limit: 10,
      item: {
        name: "",
      },
      gear: {
        type: "",
      },
    };
    player.itemPickup = {
      state: false,
      count: 0,
      limit: 10,
      item: {
        name: "",
      },
      gear: {
        type: "",
      },
    };
    player.discardGear = {
      state: false,
      count: 0,
      limit: 8,
    };
    player.ai = {
      state: false,
      imgType: "",
      primaryMission: "",
      mission: "",
      prevMission: "",
      currentObjective: "",
      targetSet: false,
      targetAcquired: false,
      safeRange: true,
      pathArray: [],
      targetPlayer: {
        number: 1,
        currentPosition: {
          x: undefined,
          y: undefined,
        },
        target: {
          number1: {
            x: undefined,
            y: undefined,
          },
          number2: {
            x: undefined,
            y: undefined,
          },
        },
        action: "",
      },
      instructions: [],
      currentInstruction: 0,
      resetInstructions: false,
      patrolling: {
        checkin: undefined,
        state: false,
        area: [],
        loopControl: false,
      },
      defending: {
        checkin: undefined,
        state: false,
        area: [],
      },
      persuing: {
        state: false,
      },
      engaging: {
        state: true,
        targetAction: "",
      },
      retrieving: {
        checkin: undefined,
        state: false,
        point: { x: undefined, y: undefined },
        targetItem: {
          name: "",
          type: "",
          subType: "",
          effect: "",
        },
        safe: true,
      },
      retreating: {
        checkin: undefined,
        state: false,
        point: { x: undefined, y: undefined },
        level: 0,
        safe: true,
      },
      organizing: {
        weaponPriorityIndex: 0,
        armorPriorityIndex: 0,
        dropped: {
          state: false,
          gear: {
            name: "",
            type: "",
            subType: "",
            effect: "",
          },
        },
      },
      mode: "",
      upgradeWeapon: false,
      upgradeArmor: false,
      pathfindingRanges: {
        spear: 3,
        crossbow: 5,
      },
    };
    player.stamina = {
      current: 20,
      max: 20,
    };
    player.newPushPullDelay = {
      state: false,
      count: 0,
      limit: 10,
    };
    player.prePush = {
      state: false,
      count: 0,
      limit: 15,
      targetCell: undefined,
      direction: "",
      pusher: undefined,
    };
    player.pushing = {
      state: false,
      targetCell: undefined,
      moveSpeed: 0,
    };
    player.prePull = {
      state: false,
      count: 0,
      limit: 15,
      targetCell: undefined,
      direction: "",
      puller: undefined,
    };
    player.pulling = {
      state: false,
      targetCell: undefined,
      moveSpeed: 0,
    };
    player.postPull = {
      state: false,
      count: 0,
      limit: 10,
    };
    player.pushed = {
      state: false,
      pusher: 0,
      moveSpeed: 0,
    };
    player.pulled = {
      state: false,
      puller: 0,
      moveSpeed: 0,
    };
    player.elasticCounter = {
      preState: false,
      state: false,
      direction: "",
      type: "",
      subType: "",
      countUp: {
        state: false,
        count: 0,
        limit: 6,
      },
      countDown: {
        state: false,
        count: 0,
        limit: 6,
      },
      coords: {
        x: undefined,
        y: undefined,
      },
      pause: {
        preState: false,
        state: false,
        type: "",
        count: 0,
        limit: 6,
      },
    };
    player.points--;
    player.drowning = false;
    this.pointChecker(player);

    // RESET TARGETTING FOR AI TARGETTING ME!!

    if (player.ai.state !== true) {
      this.resetAiTarget.state = true;
      this.resetAiTarget.player = player.number;
    }

    this.players[player.number - 1] = player;

    if (player.ai.state === true) {
      // console.log('ai player eliminated');
      this.removeAiPlayer(player.number);

      let newArr = this.aiDeflectedCheck.filter((x) => x !== player.number);
      this.aiDeflectedCheck = newArr;
    }

    for (const player2 of this.players) {
      if (player2.ai.state === true) {
        console.log("player death/item drop. Search for weapon upgrades");
        player2.ai.upgradeWeapon = true;
      }
    }
  };
  gameReset = (type) => {
    // console.log('resetting');

    this.setState({
      loading: true,
    });

    this.time = 0;
    this.projectiles = [];
    this.mouseOverCell = {
      state: false,
      cell: undefined,
      count: 0,
      threshold: 40,
    };
    this.mouseOverCellSwitchOff = {
      state: false,
      count: 0,
      limit: 100,
    };
    this.cellInfoMouseOver = false;
    this.cellsUnderAttack = [];
    this.cellsUnderPreAttack = [];
    this.cellsToHighlight = [];
    this.cellsToHighlight2 = [];
    this.gamepadPollCounter = {
      count1: 0,
      count2: 0,
      store1: [],
      store2: [],
    };
    this.movingObstacles = [];
    this.halfPushBackObstacles = [];
    this.obstacleBarrierToDestroy = [];
    this.obstacleItemsToDrop = [];
    this.obstaclesOutOfBoundsFall = [];
    this.cellPopups = [];
    this.aiDeflectedCheck = [];
    this.bloodSacrificeEvent = {
      state: false,
      count: 0,
      limit: 100,
      restore: false,
    };
    this.openVoid = false;
    this.cellToVoid = {
      state: false,
      x: 0,
      y: 0,
      count: 0,
      limit: 35,
    };

    this.camera = {
      state: true,
      startCount: 0,
      startLimit: 4,
      mode: "pan",
      fixed: false,
      target: {
        type: "player",
        plyrNo: 1,
        cell: {
          x: undefined,
          y: undefined,
        },
      },
      focus: {
        x: undefined,
        y: undefined,
      },
      focusCell: {
        x: this.camera.focusCell.x,
        y: this.camera.focusCell.y,
      },
      cellToPanOrigin: {
        x: undefined,
        y: undefined,
      },
      zoom: {
        x: 1,
        y: 1,
      },
      zoomDirection: "in",
      pan: {
        x: 1,
        y: 1,
      },
      panDirection: "east",
      zoomFocusPan: {
        x: -1,
        y: -1,
      },
      adjustedPan: {
        x: 1,
        y: 1,
      },
      limits: {
        zoom: {
          min: 0.5,
          max: 2.5,
        },
        pan: {
          x: {
            min: -400,
            max: 400,
          },
          y: {
            min: -200,
            max: 200,
          },
        },
        state: {
          count: 0,
          limit: 10,
          zoom: false,
          pan: false,
        },
      },
      instructionType: "default",
      currentPreInstruction: 0,
      preInstructions: [],
      currentInstruction: 0,
      instructions: [],
      customView: {
        state: false,
        zoom: 0,
        pan: {
          x: 0,
          y: 0,
        },
        keyPressCount: {
          start: 0,
          limit: 4,
        },
      },
    };
    this.camera.preInstructions = [];
    this.camera.instructions = [];
    this.camera.currentInstruction = 0;
    this.settingAutoCamera = false;
    this.camera.state = false;

    for (const player of this.players) {
      if (player.ai.state !== true) {
        this.resetTarget(player);

        let currentWeapon = {
          name: "sword1",
          type: "sword",
          effect: "",
        };
        let currentArmor = {
          name: "",
          type: "",
          effect: "",
        };
        let items = {
          weaponIndex: 0,
          armorIndex: 0,
          weapons: [],
          armor: [],
          ammo: 0,
        };

        for (const weapon of this.settingsFormPlayerData.weapon) {
          if (weapon.plyrNo === player.number) {
            for (const weapon2 of weapon.weapons) {
              let indx = weapon.weapons.indexOf(weapon2);
              let itemRef = this.itemList.find((x) => x.subType === weapon2);
              if (indx === 0) {
                currentWeapon = {
                  name: itemRef.name,
                  type: itemRef.subType,
                  effect: itemRef.effect,
                };
                items.weapons.push(currentWeapon);
                if (itemRef.effect.split("+")[0] === "ammo") {
                  items.ammo = parseInt(itemRef.effect.split("+")[1]);
                }
              } else {
                let weapon3 = {
                  name: itemRef.name,
                  type: itemRef.subType,
                  effect: itemRef.effect,
                };
                items.weapons.push(weapon3);
                if (itemRef.effect.split("+")[0] === "ammo") {
                  items.ammo = parseInt(itemRef.effect.split("+")[1]);
                }
              }
            }
          }
        }

        for (const armor of this.settingsFormPlayerData.armor) {
          if (armor.plyrNo === player.number) {
            for (const armor2 of armor.armor) {
              let indx = armor.armor.indexOf(armor2);
              let itemRef = this.itemList.find((x) => x.subType === armor2);
              if (indx === 0) {
                currentArmor = {
                  name: itemRef.name,
                  type: itemRef.subType,
                  effect: itemRef.effect,
                };
                items.armor.push(currentArmor);
              } else {
                let armor3 = {
                  name: itemRef.name,
                  type: itemRef.subType,
                  effect: itemRef.effect,
                };
                items.armor.push(armor3);
              }
            }
          }
        }

        for (const team of this.settingsFormPlayerData.team) {
          if (team.plyrNo === player.number) {
            player.team = team.team;
          }
        }

        player.currentWeapon = currentWeapon;
        player.currentArmor = currentArmor;
        player.items = items;

        player.currentPosition.cell = player.startPosition.cell;

        player.turning = {
          state: false,
          toDirection: "",
          delayCount: 0,
          limit: 5.1,
        };
        player.turnCheckerDirection = "";
        player.action = "idle";
        player.moving = {
          state: false,
          step: 0,
          course: "",
          origin: {
            number: {
              x: 0,
              y: 0,
            },
            center: {
              x: 0,
              y: 0,
            },
          },
          destination: {
            x: 0,
            y: 0,
          },
        };
        player.newMoveDelay = {
          state: false,
          count: 0,
          limit: 15,
        };
        player.strafing = {
          state: false,
          direction: "",
        };
        player.strafeReleaseHook = false;
        player.moveCancel = {
          state: false,
          oldDirection: "",
          newDirection: "",
          returningTo: {},
          returningFrom: {},
        };
        player.flanking = {
          checking: false,
          preFlankDirection: "",
          direction: "",
          state: false,
          step: 0,
          target1: { x: 0, y: 0 },
          target2: { x: 0, y: 0 },
        };
        player.attacking = {
          state: false,
          count: 0,
          limit: this.attackAnimRef.limit[currentWeapon.type].slash.normal,
          strength: 0,
          direction: "",
          directionType: "", //thrust or slash
          animRef: this.attackAnimRef,
          peak: false,
          peakCount: 0,
          charge: 0,
          chargePeak: false,
          blunt: false,
          clashing: {
            state: false,
            count: 0,
            limit: 10,
          },
        };
        player.defending = {
          state: false,
          count: 0,
          limit: this.defendAnimRef.limit[currentWeapon.type].slash,
          animRef: this.defendAnimRef,
          peak: false,
          peakCount: 0,
          decay: {
            state: false,
            count: 0,
            limit:
              this.defendAnimRef.limit[currentWeapon.type].slash -
              this.defendAnimRef.peak[currentWeapon.type].slash,
          },
          direction: "",
          directionType: "", //thrust or slash
        };
        player.drowning = false;
        player.dodging = {
          countState: false,
          state: false,
          count: 0,
          limit: this.baseDodgeCountRef.limit,
          peak: {
            start: this.baseDodgeCountRef.peak.start,
            end: this.baseDodgeCountRef.peak.end,
          },
          direction: "",
        };
        player.jumping = {
          checking: false,
          state: false,
        };
        player.success = {
          attackSuccess: {
            state: false,
            count: 0,
            limit: 10,
          },
          defendSuccess: {
            state: false,
            count: 0,
            limit: 10,
          },
          deflected: {
            state: false,
            count: 0,
            limit: 20,
            predeflect: false,
            type: "",
          },
        };
        player.pushBack = {
          state: false,
          prePushBackMoveSpeed: 0,
        };
        player.halfPushBack = {
          state: false,
          direction: "",
          type: "",
          countUp: {
            state: true,
            count: 0,
            limit: 0,
          },
          countDown: {
            state: false,
            count: 0,
            limit: 0,
          },
          coords: {
            x: undefined,
            y: undefined,
          },
        };
        player.falling = {
          state: false,
          count: 0,
          limit: 10,
        };
        player.dead = {
          state: false,
          count: 0,
          limit: 10,
        };
        player.ghost = {
          state: false,
          position: {
            cell: {
              number: {
                x: 0,
                y: 0,
              },
              center: {
                x: 0,
                y: 0,
              },
            },
          },
        };
        player.respawn = false;
        player.points = 0;
        player.speed = {
          move: 0.1,
          range: [0.05, 0.1, 0.125, 0.2],
        };
        player.terrainMoveSpeed = {
          state: false,
          speed: 0,
        };
        player.hp = 2;
        player.inventorySize = 4;
        player.cycleWeapon = {
          state: false,
          count: 0,
          limit: 3,
        };
        player.cycleArmor = {
          state: false,
          count: 0,
          limit: 3,
        };
        player.crits = {
          singleHit: 1,
          doubleHit: 6,
          pushBack: 4,
          guardBreak: 3,
          dodge: 0,
        };
        player.statusDisplay = {
          state: false,
          status: "",
          count: 0,
          limit: 15,
        };
        player.popups = [
          {
            state: true,
            count: 0,
            limit: 0,
            type: "",
            position: "northWest",
            msg: "",
            img: "",
          },
        ];
        player.itemDrop = {
          state: false,
          count: 0,
          limit: 10,
          item: {
            name: "",
          },
          gear: {
            type: "",
          },
        };
        player.itemPickup = {
          state: false,
          count: 0,
          limit: 10,
          item: {
            name: "",
          },
          gear: {
            type: "",
          },
        };
        player.discardGear = {
          state: false,
          count: 0,
          limit: 8,
        };
        player.ai = {
          state: false,
          imgType: "",
          primaryMission: "",
          mission: "",
          prevMission: "",
          currentObjective: "",
          targetSet: false,
          targetAcquired: false,
          safeRange: true,
          pathArray: [],
          targetPlayer: {
            number: 1,
            currentPosition: {
              x: undefined,
              y: undefined,
            },
            target: {
              number1: {
                x: undefined,
                y: undefined,
              },
              number2: {
                x: undefined,
                y: undefined,
              },
            },
            action: "",
          },
          instructions: [],
          currentInstruction: 0,
          resetInstructions: false,
          patrolling: {
            checkin: undefined,
            state: false,
            area: [],
            loopControl: false,
          },
          defending: {
            checkin: undefined,
            state: false,
            area: [],
          },
          persuing: {
            state: false,
          },
          engaging: {
            state: true,
            targetAction: "",
          },
          retrieving: {
            checkin: undefined,
            state: false,
            point: { x: undefined, y: undefined },
            targetItem: {
              name: "",
              type: "",
              subType: "",
              effect: "",
            },
            safe: true,
          },
          retreating: {
            checkin: undefined,
            state: false,
            point: { x: undefined, y: undefined },
            level: 0,
            safe: true,
          },
          organizing: {
            weaponPriorityIndex: 0,
            armorPriorityIndex: 0,
            dropped: {
              state: false,
              gear: {
                name: "",
                type: "",
                subType: "",
                effect: "",
              },
            },
          },
          mode: "",
          upgradeWeapon: false,
          upgradeArmor: false,
          pathfindingRanges: {
            spear: 3,
            crossbow: 5,
          },
        };
        player.stamina = {
          current: 20,
          max: 20,
        };
        player.newPushPullDelay = {
          state: false,
          count: 0,
          limit: 10,
        };
        player.prePush = {
          state: false,
          count: 0,
          limit: 15,
          targetCell: undefined,
          direction: "",
          pusher: undefined,
        };
        player.pushing = {
          state: false,
          targetCell: undefined,
          moveSpeed: 0,
        };
        player.prePull = {
          state: false,
          count: 0,
          limit: 15,
          targetCell: undefined,
          direction: "",
          puller: undefined,
        };
        player.pulling = {
          state: false,
          targetCell: undefined,
          moveSpeed: 0,
        };
        player.postPull = {
          state: false,
          count: 0,
          limit: 10,
        };
        player.pushed = {
          state: false,
          pusher: 0,
          moveSpeed: 0,
        };
        player.pulled = {
          state: false,
          puller: 0,
          moveSpeed: 0,
        };
        player.elasticCounter = {
          preState: false,
          state: false,
          direction: "",
          type: "",
          subType: "",
          countUp: {
            state: false,
            count: 0,
            limit: 6,
          },
          countDown: {
            state: false,
            count: 0,
            limit: 6,
          },
          coords: {
            x: undefined,
            y: undefined,
          },
          pause: {
            preState: false,
            state: false,
            type: "",
            count: 0,
            limit: 6,
          },
        };

        this.applyRemoveEffect(player, "apply", "pickup", "weapon", player.currentWeapon);
        this.applyRemoveEffect(player, "apply", "pickup", "armor", player.currentArmor);
      }
    }
    this.aiTarget = 1;

    // this.resetCameraSwitch = true;

    let plyrz = this.players;
    for (const plyr of plyrz) {
      if (plyr.ai.state === true) {
        let indx = plyrz.indexOf(plyr);
        let toRemove1 = this.players[indx];
        this.players = this.players.filter((x) => x !== toRemove1);
      }
    }

    this.drawGridInit(
      this.state.canvas,
      this.state.context,
      this.state.canvas2,
      this.state.context2,
      this.state.canvas3,
      this.state.context3
    );

    if (type === "soft") {
      if (Object.keys(this.updateSettingsFormAiDataData).length !== 0) {
        if (this.addAiCount.state !== true) {
          this.loadAiSettings();
        }
      }
    }
  };

  addAiPlayer = () => {
    let newPlayerNumber = this.players.length + 1;

    let imgTypeRoll = this.rnJesus(1, 2);
    let imgType;
    if (imgTypeRoll === 1) {
      imgType = "A";
    } else {
      imgType = "B";
    }

    if (this.addAiCount.state !== true) {
      if (this.aiInitSettings.randomStart === true) {
        // console.log('random ai mission is',this.aiInitSettings.primaryMission);
      }

      this.addAiCount.state = true;

      let cell = { x: 0, y: 0 };
      let cell1 = { x: 0, y: 0 };
      let cell3 = { x: 0, y: 0 };

      let checkCell = false;
      if (
        this.aiInitSettings.randomStart === true &&
        this.aiInitSettings.primaryMission === "pursue"
      ) {
        while (checkCell === false) {
          cell.x = this.rnJesus(0, this.gridWidth);
          cell.y = this.rnJesus(0, this.gridWidth);
          checkCell = this.checkCell(cell);
        }
      }
      if (
        this.aiInitSettings.randomStart === true &&
        this.aiInitSettings.primaryMission === "patrol"
      ) {
        let checkPatrolCell1 = false;
        let checkPatrolCell2 = false;
        let inBounds = false;

        while (checkPatrolCell1 === false) {
          cell1.x = this.rnJesus(0, this.gridWidth);
          cell1.y = this.rnJesus(0, this.gridWidth);
          checkPatrolCell1 = this.checkCell(cell1);
        }

        while (checkPatrolCell2 === false && checkPatrolCell1 === true) {
          // console.log('cell1 chosen',cell1);
          let range = 4;
          let directions = ["north", "east", "south", "west"];
          let whatDir1 = this.rnJesus(1, 4);
          let chooseDirection = directions[whatDir1 - 1];

          switch (chooseDirection) {
            case "north":
              cell3 = {
                x: cell1.x,
                y: cell1.y - range,
              };
              break;
            case "south":
              cell3 = cell1.y + range;
              cell3 = {
                x: cell1.x,
                y: cell1.y + range,
              };
              break;
            case "west":
              cell3 = {
                x: cell1.x - range,
                y: cell1.y,
              };
              break;
            case "east":
              cell3 = {
                x: cell1.x + range,
                y: cell1.y,
              };
              break;
          }
          // console.log('proposed cell 2',cell3);
          if (
            cell3.x < 0 ||
            cell3.x > this.gridWidth ||
            cell3.y < 0 ||
            cell3.y > this.gridWidth
          ) {
            // console.log('2nd cell is out of bounds');
          } else {
            cell3.x = this.rnJesus(0, this.gridWidth);
            cell3.y = this.rnJesus(0, this.gridWidth);
            checkPatrolCell2 = this.checkCell(cell3);
          }
        }

        if (checkPatrolCell1 === true && checkPatrolCell2 === true) {
          // console.log('patrol cells 1 & 2 chosen',cell1,cell3);
          this.aiInitSettings.partolArea[0] = cell1;
          this.aiInitSettings.partolArea[1] = cell3;
          inBounds = true;
        }
        if (inBounds === true) {
          while (checkCell === false) {
            cell.x = this.rnJesus(0, this.gridWidth);
            cell.y = this.rnJesus(0, this.gridWidth);
            checkCell = this.checkCell(cell);
            if (cell === cell1 || cell === cell3) {
              checkCell = false;
            }
          }
        }
        if (checkCell === true) {
          console.log(
            "random patrol points chosen: start",
            cell,
            "patrol points",
            cell1,
            cell3
          );
        }
      }
      if (
        this.aiInitSettings.randomStart === true &&
        this.aiInitSettings.primaryMission === "defend"
      ) {
        let checkCell2 = false;
        let cell4 = { x: 0, y: 0 };
        while (checkCell2 === false) {
          cell4.x = this.rnJesus(0, this.gridWidth);
          cell4.y = this.rnJesus(0, this.gridWidth);
          checkCell2 = this.checkCell(cell4);
        }
        if (checkCell2 === true) {
          this.aiInitSettings.partolArea[0] = cell4;
        }

        while (checkCell === false && checkCell2 === true) {
          cell.x = this.rnJesus(0, this.gridWidth);
          cell.y = this.rnJesus(0, this.gridWidth);
          checkCell = this.checkCell(cell);
        }
        if (checkCell === true) {
          console.log("random defend points chosen: start", cell, "defend point", cell4);
        }
      }

      if (this.aiInitSettings.randomStart !== true) {
        checkCell = true;
        cell.x = this.aiInitSettings.startPosition.number.x;
        cell.y = this.aiInitSettings.startPosition.number.y;
      }

      if (checkCell === true) {
        let currentWeapon = {
          name: "sword1",
          type: "sword",
          effect: "",
        };
        let currentArmor = {
          name: "",
          type: "",
          effect: "",
        };
        let items = {
          weaponIndex: 0,
          armorIndex: 0,
          weapons: [],
          armor: [],
          ammo: 0,
        };

        for (const weapon of this.aiInitSettings.weapons) {
          let indx = this.aiInitSettings.weapons.indexOf(weapon);
          let itemRef = this.itemList.find((x) => x.subType === weapon);
          if (indx === 0) {
            currentWeapon = {
              name: itemRef.name,
              type: itemRef.subType,
              effect: itemRef.effect,
            };
            items.weapons.push(currentWeapon);
            if (itemRef.effect.split("+")[0] === "ammo") {
              items.ammo = parseInt(itemRef.effect.split("+")[1]);
            }
          } else {
            let weapon = {
              name: itemRef.name,
              type: itemRef.subType,
              effect: itemRef.effect,
            };
            items.weapons.push(weapon);
            if (itemRef.effect.split("+")[0] === "ammo") {
              items.ammo = parseInt(itemRef.effect.split("+")[1]);
            }
          }
        }
        for (const armor of this.aiInitSettings.armor) {
          let indx = this.aiInitSettings.armor.indexOf(armor);
          let itemRef = this.itemList.find((x) => x.subType === armor);
          if (indx === 0) {
            currentArmor = {
              name: itemRef.name,
              type: itemRef.subType,
              effect: itemRef.effect,
            };
            items.armor.push(currentArmor);
          } else {
            let armor = {
              name: itemRef.name,
              type: itemRef.subType,
              effect: itemRef.effect,
            };
            items.armor.push(armor);
          }
        }

        let cell2 = this.gridInfo.find(
          (elem) => elem.number.x === cell.x && elem.number.y === cell.y
        );
        let newPlayer = {
          number: newPlayerNumber,
          startPosition: {
            cell: {
              number: {
                x: cell.x,
                y: cell.y,
              },
              center: {
                x: cell2.center.x,
                y: cell2.center.y,
              },
            },
          },
          currentPosition: {
            cell: {
              number: {
                x: cell.x,
                y: cell.y,
              },
              center: {
                x: cell2.center.x,
                y: cell2.center.y,
              },
            },
          },
          nextPosition: {
            x: cell2.center.x,
            y: cell2.center.y,
          },
          target: {
            cell1: {
              number: {
                x: 0,
                y: 0,
              },
              center: {
                x: 0,
                y: 0,
              },
              free: true,
              occupant: {
                type: "",
                player: "",
              },
              void: false,
            },
            cell2: {
              number: {
                x: 0,
                y: 0,
              },
              center: {
                x: 0,
                y: 0,
              },
              free: true,
              occupant: {
                type: "",
                player: "",
              },
              void: false,
            },
            myCellBlock: false,
          },
          direction: "north",
          turning: {
            state: false,
            toDirection: "",
            delayCount: 0,
            limit: 5.1,
          },
          turnCheckerDirection: "",
          action: "idle",
          moving: {
            state: false,
            step: 0,
            course: "",
            origin: {
              number: {
                x: cell.x,
                y: cell.y,
              },
              center: {
                x: cell2.center.x,
                y: cell2.center.y,
              },
            },
            destination: {
              x: 0,
              y: 0,
            },
          },
          newMoveDelay: {
            state: false,
            count: 0,
            limit: 15,
          },
          strafing: {
            state: false,
            direction: "",
          },
          strafeReleaseHook: false,
          moveCancel: {
            state: false,
            oldDirection: "",
            newDirection: "",
            returningTo: {},
            returningFrom: {},
          },
          flanking: {
            checking: false,
            preFlankDirection: "",
            direction: "",
            state: false,
            step: 0,
            target1: { x: 0, y: 0 },
            target2: { x: 0, y: 0 },
          },
          attacking: {
            state: false,
            count: 0,
            limit: this.attackAnimRef.limit[currentWeapon.type].slash.normal,
            strength: 0,
            direction: "",
            directionType: "", //thrust or slash
            animRef: this.attackAnimRef,
            peak: false,
            peakCount: 0,
            charge: 0,
            chargePeak: false,
            blunt: false,
            clashing: {
              state: false,
              count: 0,
              limit: 10,
            },
          },
          defending: {
            state: false,
            count: 0,
            limit: this.defendAnimRef.limit[currentWeapon.type].slash,
            animRef: this.defendAnimRef,
            peak: false,
            peakCount: 0,
            decay: {
              state: false,
              count: 0,
              limit:
                this.defendAnimRef.limit[currentWeapon.type].slash -
                this.defendAnimRef.peak[currentWeapon.type].slash,
            },
            direction: "",
            directionType: "", //thrust or slash
          },
          drowning: false,
          dodging: {
            countState: false,
            state: false,
            count: 0,
            limit: this.baseDodgeCountRef.limit,
            peak: {
              start: this.baseDodgeCountRef.peak.start,
              end: this.baseDodgeCountRef.peak.end,
            },
            direction: "",
          },
          jumping: {
            checking: false,
            state: false,
          },
          success: {
            attackSuccess: {
              state: false,
              count: 0,
              limit: 10,
            },
            defendSuccess: {
              state: false,
              count: 0,
              limit: 10,
            },
            deflected: {
              state: false,
              count: 0,
              limit: 20,
              predeflect: false,
              type: "",
            },
          },
          pushBack: {
            state: false,
            prePushBackMoveSpeed: 0,
          },
          halfPushBack: {
            state: false,
            direction: "",
            type: "",
            countUp: {
              state: true,
              count: 0,
              limit: 0,
            },
            countDown: {
              state: false,
              count: 0,
              limit: 0,
            },
            coords: {
              x: undefined,
              y: undefined,
            },
          },
          falling: {
            state: false,
            count: 0,
            limit: 10,
          },
          dead: {
            state: false,
            count: 0,
            limit: 10,
          },
          ghost: {
            state: false,
            position: {
              cell: {
                number: {
                  x: 0,
                  y: 0,
                },
                center: {
                  x: 0,
                  y: 0,
                },
              },
            },
          },
          respawn: false,
          points: 0,
          speed: {
            move: 0.1,
            range: [0.05, 0.1, 0.125, 0.2],
          },
          terrainMoveSpeed: {
            state: false,
            speed: 0,
          },
          hp: 2,
          currentWeapon: currentWeapon,
          currentArmor: currentArmor,
          items: items,
          inventorySize: 4,
          cycleWeapon: {
            state: false,
            count: 0,
            limit: 3,
          },
          cycleArmor: {
            state: false,
            count: 0,
            limit: 3,
          },
          crits: {
            singleHit: 1,
            doubleHit: 6,
            pushBack: 4,
            guardBreak: 3,
            dodge: 0,
          },
          statusDisplay: {
            state: false,
            status: "",
            count: 0,
            limit: 15,
          },
          popups: [
            {
              state: true,
              count: 0,
              limit: 0,
              type: "",
              position: "northWest",
              msg: "",
              img: "",
            },
          ],
          itemDrop: {
            state: false,
            count: 0,
            limit: 10,
            item: {
              name: "",
            },
            gear: {
              type: "",
            },
          },
          itemPickup: {
            state: false,
            count: 0,
            limit: 10,
            item: {
              name: "",
            },
            gear: {
              type: "",
            },
          },
          discardGear: {
            state: false,
            count: 0,
            limit: 8,
          },
          idleAnim: {
            state: false,
            count: 0,
            limit: 5,
          },
          ai: {
            state: true,
            imgType: imgType,
            mission: "",
            primaryMission: "",
            prevMission: "",
            currentObjective: "",
            currentInstruction: 0,
            resetInstructions: false,
            targetSet: false,
            targetAcquired: false,
            safeRange: true,
            pathArray: [],
            targetPlayer: {
              number: 1,
              currentPosition: {
                x: undefined,
                y: undefined,
              },
              target: {
                number1: {
                  x: undefined,
                  y: undefined,
                },
                number2: {
                  x: undefined,
                  y: undefined,
                },
              },
              action: "",
            },
            instructions: [],
            engaging: {
              state: false,
              targetAction: "",
            },
            patrolling: {
              checkin: undefined,
              state: false,
              area: [],
              loopControl: false,
            },
            defending: {
              checkin: undefined,
              state: false,
              area: [],
            },
            persuing: {
              state: false,
            },
            retrieving: {
              checkin: undefined,
              state: false,
              point: { x: undefined, y: undefined },
              targetItem: {
                name: "",
                type: "",
                subType: "",
                effect: "",
              },
              safe: false,
            },
            retreating: {
              checkin: undefined,
              state: false,
              point: { x: undefined, y: undefined },
              level: 0,
              safe: false,
            },
            organizing: {
              weaponPriorityIndex: 0,
              armorPriorityIndex: 0,
              dropped: {
                state: false,
                gear: {
                  name: "",
                  type: "",
                  subType: "",
                  effect: "",
                },
              },
            },
            mode: this.aiInitSettings.mode,
            upgradeWeapon: false,
            upgradeArmor: false,
            pathfindingRanges: {
              spear: 3,
              crossbow: 5,
            },
          },
          stamina: {
            current: 20,
            max: 20,
          },
          newPushPullDelay: {
            state: false,
            count: 0,
            limit: 10,
          },
          prePush: {
            state: false,
            count: 0,
            limit: 15,
            targetCell: undefined,
            direction: "",
            pusher: undefined,
          },
          pushing: {
            state: false,
            targetCell: undefined,
            moveSpeed: 0,
          },
          prePull: {
            state: false,
            count: 0,
            limit: 15,
            targetCell: undefined,
            direction: "",
            puller: undefined,
          },
          pulling: {
            state: false,
            targetCell: undefined,
            moveSpeed: 0,
          },
          postPull: {
            state: false,
            count: 0,
            limit: 10,
          },
          pushed: {
            state: false,
            pusher: 0,
            moveSpeed: 0,
          },
          pulled: {
            state: false,
            puller: 0,
            moveSpeed: 0,
          },
          elasticCounter: {
            preState: false,
            state: false,
            direction: "",
            type: "",
            subType: "",
            countUp: {
              state: false,
              count: 0,
              limit: 6,
            },
            countDown: {
              state: false,
              count: 0,
              limit: 6,
            },
            coords: {
              x: undefined,
              y: undefined,
            },
            pause: {
              preState: false,
              state: false,
              type: "",
              count: 0,
              limit: 6,
            },
          },
          team: this.aiInitSettings.team,
          input: "Keyboard",
        };

        this.players.push(newPlayer);
        this.keyPressed.push({
          north: false,
          south: false,
          east: false,
          west: false,
          attack: false,
          defend: false,
          strafe: false,
          dodge: false,
          pull: false,
          kick: false,
          cycleArmor: false,
          discardWeapon: false,
          discardArmor: false,
          uiMenu: false,
          playerMenu: false,
          rotateRight: false,
          rotateLeft: false,
        });
        this.aiPlayers.push(newPlayerNumber);
        this.getTarget(this.players[newPlayerNumber - 1]);
        this.updatePathArray();
        this.players[newPlayerNumber - 1].ai.primaryMission =
          this.aiInitSettings.primaryMission;
        if (!this.aiInitSettings.mission) {
          this.players[newPlayerNumber - 1].ai.mission =
            this.aiInitSettings.primaryMission;
        } else if (this.aiInitSettings.mission) {
          this.players[newPlayerNumber - 1].ai.mission = this.aiInitSettings.mission;
        }

        if (this.aiInitSettings.primaryMission === "patrol") {
          this.players[newPlayerNumber - 1].ai.patrolling = {
            checkin: undefined,
            state: true,
            area: [
              {
                x: this.aiInitSettings.partolArea[0].x,
                y: this.aiInitSettings.partolArea[0].y,
              },
              {
                x: this.aiInitSettings.partolArea[1].x,
                y: this.aiInitSettings.partolArea[1].y,
              },
            ],
            loopControl: false,
          };
        }
        if (this.aiInitSettings.primaryMission === "defend") {
          this.players[newPlayerNumber - 1].ai.defending = {
            checkin: undefined,
            state: true,
            area: [
              {
                x: this.aiInitSettings.partolArea[0].x,
                y: this.aiInitSettings.partolArea[0].y,
              },
            ],
          };
        }

        if (
          this.camera.customView.state !== true &&
          this.settingAutoCamera === false &&
          this.camera.preInstructions.length === 0 &&
          this.camera.instructions.length === 0
        ) {
          // this.setAutoCamera('aiSpawnFocus',newPlayer)
        } else {
          console.log("no setting auto cam: aiSpawnFocus");
        }
      }
    } else if (this.addAiCount.state === true) {
      // console.log('already adding an ai player');
    }
    // console.log('new ai player: settings',this.aiInitSettings);
  };
  addAiRandomPlayer = (mission) => {
    let newMisson = mission;
    let weapon = {
      name: "sword1",
      type: "sword",
    };

    if (mission === "random") {
      let whatMission = this.rnJesus(1, 10);
      if (whatMission % 2 === 0 || whatMission % 7 === 0) {
        newMisson = "pursue";
      }
      if (whatMission % 3 === 0) {
        newMisson = "patrol";
      }
      if (whatMission % 5 === 0) {
        newMisson = "defend";
      }
    }

    let whatWeapon = this.rnJesus(1, 10);
    if (whatWeapon % 2 === 0 || whatWeapon % 3 === 0) {
      weapon = {
        name: "sword1",
        type: "sword",
      };
    }
    if (whatWeapon % 5 === 0) {
      weapon = {
        name: "spear1",
        type: "spear",
      };
    }
    if (whatWeapon % 7 === 0) {
      weapon = {
        name: "crossbow1",
        type: "crossbow",
      };
    }

    this.aiInitSettings = {
      randomStart: true,
      startPosition: {
        number: { x: undefined, y: undefined },
      },
      primaryMission: newMisson,
      mission: undefined,
      mode: "careful",
      partolArea: [
        { x: undefined, y: undefined },
        { x: undefined, y: undefined },
      ],
      weapons: [
        {
          name: weapon.name,
          type: weapon.type,
          effect: "",
        },
      ],
      armor: [],
    };
    this.addAiPlayer();
  };
  removeAiPlayer = (playerNumber) => {
    console.log("removing ai player", playerNumber);

    let index1 = this.players.indexOf(this.players[playerNumber - 1]);
    let index2 = this.aiPlayers.indexOf(playerNumber);

    // SHIFT AI PLAYER NUMBERS!
    for (let elem of this.players) {
      let indx = this.players.indexOf(elem);
      if (indx > index1) {
        elem.number = elem.number - 1;
      }
    }
    for (let elem2 of this.aiPlayers) {
      let indx2 = this.aiPlayers.indexOf(elem2);
      if (indx2 > index2) {
        elem2 = elem2 - 1;
      }
    }

    this.aiPlayers.splice(index2, 1);

    let keyPressedToRemove = this.keyPressed[playerNumber - 1];
    this.keyPressed = this.keyPressed.filter((y) => y !== keyPressedToRemove);

    this.removeAi = playerNumber;

    this.addAiCount.state = true;

    // REMOVE DEAD AI FINAL POSITION
    // let indx3;
    // for (const item of this.additionalAvoidArray) {
    //   if (item.player === playerNumber) {
    //     indx3 = this.additionalAvoidArray.indexOf(item)
    //   }
    // }
    // this.additionalAvoidArray.splice(indx3,1)
  };
  toggleAiDisplay = () => {
    let newState = !this.state.showAiStatus;
    this.setState({
      showAiStatus: newState,
    });
  };
  scanTargetAreaThreat = (args) => {
    // console.log('scanning area for threats');

    let point = args.point;
    let range = args.range;
    let playerPositions = [];
    let isSafe = true;
    let threats = [];
    for (const player of this.players) {
      if (player.ai.state !== true && player.number !== args.player) {
        playerPositions.push({
          player: player.number,
          position: player.currentPosition.cell.number,
        });
      }
    }
    for (const playerPos of playerPositions) {
      let xDiff;
      let yDiff;
      let largerx = Math.max(point.x, playerPos.position.x);
      // console.log('playerPos.position.x',playerPos.position.x,'point.x',point.x,'largerx',largerx);
      if (largerx === point.x) {
        xDiff = point.x - playerPos.position.x;
      } else {
        xDiff = playerPos.position.x - point.x;
      }
      let largery = Math.max(point.y, playerPos.position.y);
      // console.log('playerPos.position.y',playerPos.position.y,'point.y',point.y,'largery',largery);
      if (largery === point.y) {
        yDiff = point.y - playerPos.position.y;
      } else {
        yDiff = playerPos.position.y - point.y;
      }
      let diffSum = xDiff + yDiff;
      // console.log('vv',playerPos.player,diffSum);

      if (diffSum <= range) {
        threats.push({
          player: playerPos.player,
          position: playerPos.position,
          distValue: diffSum,
          distIndex: undefined,
        });
      }
    }

    if (threats.length > 0) {
      isSafe = false;
    }

    threats.sort((a, b) => (a.distValue > b.distValue ? 1 : -1));
    for (const threat of threats) {
      let threatIndex = threats.findIndex((x) => x.player === threat.player);
      threat.distIndex = threatIndex;
    }
    // console.log('threats',threats);

    return {
      isSafe: isSafe,
      threats: threats,
    };
  };
  safeDistanceRetreat = (plyr, cell) => {
    let isSafeDistance = false;
    let safeRetreatDistance = 2;
    if (
      cell.x <= plyr.currentPosition.cell.number.x + safeRetreatDistance ||
      cell.x >= plyr.currentPosition.cell.number.x - safeRetreatDistance ||
      cell.y <= plyr.currentPosition.cell.number.y + safeRetreatDistance ||
      cell.y >= plyr.currentPosition.cell.number.y - safeRetreatDistance
    ) {
      isSafeDistance = false;
    } else {
      isSafeDistance = true;
    }
    return isSafeDistance;
  };
  aiResetRanges = (plyr) => {
    this.players[plyr.number - 1].ai.pathfindingRanges = {
      spear: 3,
      crossbow: 5,
    };
    this.players[plyr.number - 1].ai.safeRange = true;
  };
  aiEvaluate = (plyr) => {
    // console.log('aiEvaluate',plyr.ai.upgradeWeapon);
    // console.log('aiEvaluate',plyr.ai.organizing.dropped.state);

    // SOMEONE DIED, RESET AI TARGETS
    if (this.resetAiTarget.state === true) {
      console.log("someone died. reset ai targets");
      if (!plyr.popups.find((x) => x.msg === "thinking")) {
        plyr.popups.push({
          state: false,
          count: 0,
          limit: 30,
          type: "",
          position: "",
          msg: "thinking",
          img: "",
        });
      }
      for (const plyr of this.players) {
        if (
          plyr.ai.state === true &&
          plyr.ai.targetSet === true &&
          plyr.ai.targetPlayer.number === this.resetAiTarget.player
        ) {
          this.aiResetRanges(plyr);

          if (plyr.attacking.state === true) {
            plyr.attacking.state = false;
            plyr.action = "idle";
            // this.attackedCancel(plyr)
            plyr.ai.targetSet = false;
            plyr.ai.targetAcquired = false;
            plyr.ai.mission = plyr.ai.primaryMission;
            plyr.ai.currentInstruction = 0;
            plyr.ai.pathArray = [];
            plyr.ai.instructions = [];

            // if (!plyr.popups.find(x=>x.msg === 'mission'+plyr.ai.mission 1st char upper+'')) {
            //   plyr.popups.push(
            //     {
            //       state: false,
            //       count: 0,
            //       limit: 25,
            //       type: '',
            //       position: '',
            //       msg: 'mission'+plyr.ai.mission 1st char upper+'',
            //       img: '',
            //
            //     }
            //   )
            // }
          }

          plyr.ai.targetSet = false;
          plyr.ai.targetPlayer = {
            number: undefined,
            currentPosition: {
              x: undefined,
              y: undefined,
            },
            target: {
              number1: {
                x: undefined,
                y: undefined,
              },
              number2: {
                x: undefined,
                y: undefined,
              },
            },
            action: "",
          };

          if (plyr.ai.mission === "pursue") {
            plyr.ai.targetSet = false;
            plyr.ai.targetAcquired = false;
            plyr.ai.mission = plyr.ai.primaryMission;
            plyr.ai.currentInstruction = 0;
            plyr.ai.pathArray = [];
            plyr.ai.instructions = [];

            // if (!plyr.popups.find(x=>x.msg === 'mission'+plyr.ai.mission 1st char upper+'')) {
            //   plyr.popups.push(
            //     {
            //       state: false,
            //       count: 0,
            //       limit: 25,
            //       type: '',
            //       position: '',
            //       msg: 'mission'+plyr.ai.mission 1st char upper+'',
            //       img: '',
            //
            //     }
            //   )
            // }
          }
        }
      }

      if (this.playerNumber > 1) {
        if (this.resetAiTarget.player === 1) {
          if (
            this.players[1].dead.state !== true &&
            this.players[1].falling.state !== true &&
            this.players[1].respawn !== true
          ) {
            console.log("1");
            this.aiTarget = 2;
            this.resetAiTarget.player = 0;
          } else {
            this.allPlayersDead = true;
          }
        }

        if (this.resetAiTarget.player === 2) {
          if (
            this.players[0].dead.state !== true &&
            this.players[0].falling.state !== true &&
            this.players[0].respawn !== true
          ) {
            console.log("2");
            this.aiTarget = 1;
            this.resetAiTarget.player = 0;
          } else {
            this.allPlayersDead = true;
          }
        }
      } else {
        this.allPlayersDead = true;
      }

      // this.resetAiTarget.state2 = true;
      this.resetAiTarget.state = false;
    }

    if (this.allPlayersDead === true) {
      for (const plyr2 of this.players) {
        if (
          plyr2.dead.state !== true &&
          plyr2.respawn !== true &&
          plyr2.ai.state !== true
        ) {
          this.aiTarget = plyr2.number;
          this.allPlayersDead = false;
          this.resetAiTarget.player = 0;

          if (!plyr2.popups.find((x) => x.msg === "thinking")) {
            plyr2.popups.push({
              state: false,
              count: 0,
              limit: 25,
              type: "",
              position: "",
              msg: "thinking",
              img: "",
            });
          }
        }
      }
    }

    if (this.allPlayersDead === true) {
      // console.log('still no targets availible for ai!!');
    }

    if (
      plyr.ai.mission !== "engage" &&
      this.aiDeflectedCheck.includes(plyr.number === true)
    ) {
      // console.log('!! AI DEFLECTED BUT NOT ENGAGED, CHECK CIRCUMSTANCES AND BEHAVIOR !!');
    }

    // ITEM LOGIC
    let fieldItemScan = [];
    for (const cell of this.gridInfo) {
      if (cell.item.name !== "") {
        fieldItemScan.push({
          name: cell.item.name,
          type: cell.item.type,
          subType: cell.item.subType,
          effect: cell.item.effect,
          location: { x: cell.number.x, y: cell.number.y },
        });
      }
    }

    let nerfItemPositions = [];
    for (const item of fieldItemScan) {
      switch (item.name) {
        case "moveSpeedDown":
          nerfItemPositions.push(item);
          break;
        case "hpDown":
          nerfItemPositions.push(item);
          break;
        case "focusDown":
          nerfItemPositions.push(item);
          break;
        case "strengthDown":
          nerfItemPositions.push(item);
          break;
      }
    }

    // console.log('fieldItemScan',fieldItemScan);
    // console.log('nerfItemPositions',nerfItemPositions);

    let weaponUpgradePriority = [];
    let armorUpgradePriority = [];

    if (
      plyr.ai.upgradeWeapon === true &&
      plyr.ai.mission !== "retreat" &&
      plyr.ai.mission !== "retrieve"
    ) {
      console.log("upgrade weapon");

      let weaponPriorityIndex = plyr.ai.organizing.weaponPriorityIndex;
      let havePriorityWeapon = true;
      weaponUpgradePriority = ["crossbow", "spear", "sword"];
      let inMyInventory = plyr.items.weapons.find(
        (elem) => elem.type === weaponUpgradePriority[weaponPriorityIndex]
      );

      console.log(
        "priority weapon",
        weaponUpgradePriority[weaponPriorityIndex],
        "index",
        weaponPriorityIndex
      );

      if (plyr.currentWeapon.type === weaponUpgradePriority[weaponPriorityIndex]) {
        console.log("priority weapon is my current");

        if (
          plyr.currentWeapon.type === "crossbow" &&
          plyr.items.ammo === 0 &&
          plyr.items.weapons.length < 2
        ) {
          console.log("priority weapon is crossbow but out of ammo!");
          if (
            plyr.ai.organizing.weaponPriorityIndex ===
            weaponUpgradePriority.length - 1
          ) {
            plyr.ai.upgradeWeapon = false;
            console.log("priority index max w/ nothing to retrieve");
          } else {
            console.log("check next priority weapon");
            plyr.ai.organizing.weaponPriorityIndex++;
          }
        } else {
          havePriorityWeapon = true;
          plyr.ai.upgradeWeapon = false;
        }
      } else {
        havePriorityWeapon = false;
      }

      if (
        inMyInventory &&
        plyr.currentWeapon.type !== weaponUpgradePriority[weaponPriorityIndex]
      ) {
        console.log(
          "priority weapon is in my inventory. Switching to it",
          plyr.currentWeapon,
          plyr.items.ammo,
          plyr.items.weapons
        );

        if (
          plyr.currentWeapon.type === "crossbow" &&
          plyr.items.ammo === 0 &&
          plyr.items.weapons.length === 1
        ) {
          console.log("priority weapon is crossbow but out of ammo!");
          if (
            plyr.ai.organizing.weaponPriorityIndex ===
            weaponUpgradePriority.length - 1
          ) {
            plyr.ai.upgradeWeapon = false;
            console.log("priority index max w/ nothing to retrieve");
          } else {
            console.log("check next priority weapon");
            plyr.ai.organizing.weaponPriorityIndex++;
          }
        } else {
          havePriorityWeapon = true;
          plyr.ai.upgradeWeapon = false;

          plyr.currentWeapon.name = inMyInventory.name;
          plyr.currentWeapon.type = inMyInventory.type;
          plyr.currentWeapon.effect = inMyInventory.effect;
        }
        // plyr.currentWeapon.name = inMyInventory.name;
        // plyr.currentWeapon.type = inMyInventory.type;
        // plyr.currentWeapon.effect = inMyInventory.effect;

        // havePriorityWeapon = true;
        // plyr.ai.upgradeWeapon = false
      } else if (plyr.currentWeapon.type !== weaponUpgradePriority[weaponPriorityIndex]) {
        havePriorityWeapon = false;
      }

      if (havePriorityWeapon === false) {
        console.log("dont have priority weapon");

        let inTheField = fieldItemScan.find(
          (elem) => elem.subType === weaponUpgradePriority[weaponPriorityIndex]
        );
        // console.log('inTheField',inTheField);
        if (inTheField) {
          console.log("priority weapon is in the field");

          if (inTheField.subType === "crossbow") {
            console.log("priority is a crossbow", inTheField.effect.split("+")[1]);

            if (
              inTheField.effect.split("+")[1] !== 0 &&
              inTheField.effect.split("+")[1] !== "0"
            ) {
              let targetSafeData = this.scanTargetAreaThreat({
                player: plyr.number,
                point: {
                  x: inTheField.location.x,
                  y: inTheField.location.y,
                },
                range: 3,
              });

              if (targetSafeData.isSafe === true) {
                console.log("priority weapon target is safe. Retrieve");

                plyr.ai.mission = "retrieve";
                plyr.ai.retrieving.point = {
                  x: inTheField.location.x,
                  y: inTheField.location.y,
                };
                plyr.ai.retrieving.targetItem = {
                  name: inTheField.name,
                  type: inTheField.type,
                  subType: inTheField.subType,
                  effect: inTheField.effect,
                };
                plyr.ai.retrieving.safe = true;
                plyr.ai.upgradeWeapon = false;

                if (!plyr.popups.find((x) => x.msg === "missionRetrieve")) {
                  plyr.popups.push({
                    state: false,
                    count: 0,
                    limit: 30,
                    type: "",
                    position: "",
                    msg: "missionRetrieve",
                    img: "",
                  });
                }
              } else {
                console.log("priority weapon target is unsafe.");

                if (
                  plyr.ai.organizing.weaponPriorityIndex ===
                  weaponUpgradePriority.length - 1
                ) {
                  // plyr.ai.upgradeWeapon = false;
                  console.log("priority index max w/ nothing to retrieve");
                } else {
                  console.log("check next priority weapon");
                  plyr.ai.organizing.weaponPriorityIndex++;
                }
              }
            } else if (
              inTheField.effect.split("+")[1] === 0 ||
              inTheField.effect.split("+")[1] === "0"
            ) {
              console.log("bow in the field but has no ammo");
              if (
                plyr.ai.organizing.weaponPriorityIndex ===
                weaponUpgradePriority.length - 1
              ) {
                // plyr.ai.upgradeWeapon = false;
                console.log("priority index max w/ nothing to retrieve");
              } else {
                console.log("check next priority weapon");
                plyr.ai.organizing.weaponPriorityIndex++;
              }
            }
          } else {
            console.log("priority is not a crossbow");

            let targetSafeData2 = this.scanTargetAreaThreat({
              player: plyr.number,
              point: {
                x: inTheField.location.x,
                y: inTheField.location.y,
              },
              range: 3,
            });

            if (targetSafeData2.isSafe === true) {
              plyr.ai.mission = "retrieve";
              plyr.ai.retrieving.point = {
                x: inTheField.location.x,
                y: inTheField.location.y,
              };
              plyr.ai.retrieving.targetItem = {
                name: inTheField.name,
                type: inTheField.type,
                subType: inTheField.subType,
                effect: inTheField.effect,
              };
              plyr.ai.retrieving.safe = true;
              plyr.ai.upgradeWeapon = false;

              if (!plyr.popups.find((x) => x.msg === "missionRetrieve")) {
                plyr.popups.push({
                  state: false,
                  count: 0,
                  limit: 30,
                  type: "",
                  position: "",
                  msg: "missionRetrieve",
                  img: "",
                });
              }
            } else {
              console.log("priority weapon is not in the field");

              if (
                plyr.ai.organizing.weaponPriorityIndex ===
                weaponUpgradePriority.length - 1
              ) {
                // plyr.ai.upgradeWeapon = false;
                console.log("priority index max w/ nothing to retrieve");
              } else {
                console.log("choose next priority weapon");
                plyr.ai.organizing.weaponPriorityIndex++;
              }
            }
          }
        } else {
          console.log("priority weapon is not in the field, nor current nor inventory");
          if (
            plyr.ai.organizing.weaponPriorityIndex ===
            weaponUpgradePriority.length - 1
          ) {
            // plyr.ai.upgradeWeapon = false;
            console.log("priority index max w/ nothing to retrieve");
          } else {
            console.log("check next priority weapon");
            plyr.ai.organizing.weaponPriorityIndex++;
          }
        }
      }
    }
    if (
      plyr.ai.upgradeArmor === true &&
      plyr.ai.upgradeWeapon !== true &&
      plyr.ai.mission !== "retreat" &&
      plyr.ai.mission !== "retrieve"
    ) {
      console.log("upgrade armor");

      let armorInTheField;
      if (plyr.hp === 1) {
        armorInTheField = fieldItemScan.find((gear) => gear.effect === "hpUp")[0];
        if (armorInTheField) {
          let targetSafeData2 = this.scanTargetAreaThreat({
            player: plyr.number,
            point: {
              x: armorInTheField.location.x,
              y: armorInTheField.location.y,
            },
            range: 3,
          });

          if (targetSafeData2.isSafe === true) {
            plyr.ai.mission = "retrieve";
            plyr.ai.retrieving.point = {
              x: armorInTheField.location.x,
              y: armorInTheField.location.y,
            };
            plyr.ai.retrieving.targetItem = {
              name: armorInTheField.name,
              type: armorInTheField.type,
              subType: armorInTheField.subType,
              effect: armorInTheField.effect,
            };
            plyr.ai.retrieving.safe = true;
            plyr.ai.upgradeArmor = false;

            if (!plyr.popups.find((x) => x.msg === "missionRetrieve")) {
              plyr.popups.push({
                state: false,
                count: 0,
                limit: 30,
                type: "",
                position: "",
                msg: "missionRetrieve",
                img: "",
              });
            }
          }

          console.log(
            "found hpup gear in the field. retrieve! @",
            plyr.ai.retrieving.point
          );
        } else {
          console.log(
            "no hp up gear found in the field",
            fieldItemScan.find((gear) => gear.effect === "hpUp")
          );
        }
      }

      if (plyr.speed.move < 0.1) {
        armorInTheField = fieldItemScan.find((gear) => gear.effect === "speedUp")[0];

        if (armorInTheField) {
          let targetSafeData2 = this.scanTargetAreaThreat({
            player: plyr.number,
            point: {
              x: armorInTheField.location.x,
              y: armorInTheField.location.y,
            },
            range: 3,
          });

          if (targetSafeData2.isSafe === true) {
            plyr.ai.mission = "retrieve";
            plyr.ai.retrieving.point = {
              x: armorInTheField.location.x,
              y: armorInTheField.location.y,
            };
            plyr.ai.retrieving.targetItem = {
              name: armorInTheField.name,
              type: armorInTheField.type,
              subType: armorInTheField.subType,
              effect: armorInTheField.effect,
            };
            plyr.ai.retrieving.safe = true;
            plyr.ai.upgradeArmor = false;

            if (!plyr.popups.find((x) => x.msg === "missionRetrieve")) {
              plyr.popups.push({
                state: false,
                count: 0,
                limit: 30,
                type: "",
                position: "",
                msg: "missionRetrieve",
                img: "",
              });
            }
          }

          console.log(
            "found speedUp gear in the field. retrieve! @",
            plyr.ai.retrieving.point
          );
        } else {
          console.log(
            "no spped up gear found in the field",
            fieldItemScan.find((gear) => gear.effect === "speedUp")
          );
        }
      }
    }

    // RELOAD BOW AMMO
    if (
      plyr.currentWeapon.type === "crossbow" &&
      plyr.ai.mission !== "retrieve" &&
      plyr.ai.mission !== "retreat"
    ) {
      if (plyr.items.ammo === 0) {
        console.log("my crossbow out of ammo");
        let inTheField = fieldItemScan.find(
          (elem) => elem.type === "crossbow" || elem.name.substr(0, 4) === "ammo"
        );
        if (inTheField) {
          if (
            inTheField.effect.split("+")[1] !== 0 &&
            inTheField.effect.split("+")[1] !== "0"
          ) {
            let targetSafeData2 = this.scanTargetAreaThreat({
              player: plyr.number,
              point: {
                x: inTheField.location.x,
                y: inTheField.location.y,
              },
              range: 3,
            });

            if (targetSafeData2.isSafe === true) {
              plyr.ai.mission = "retrieve";
              plyr.ai.retrieving.point = {
                x: inTheField.location.x,
                y: inTheField.location.y,
              };
              plyr.ai.retrieving.targetItem = {
                name: inTheField.name,
                type: inTheField.type,
                subType: inTheField.subType,
                effect: inTheField.effect,
              };
              plyr.ai.retrieving.safe = true;
              plyr.ai.upgradeWeapon = false;

              if (!plyr.popups.find((x) => x.msg === "missionRetrieve")) {
                plyr.popups.push({
                  state: false,
                  count: 0,
                  limit: 30,
                  type: "",
                  position: "",
                  msg: "missionRetrieve",
                  img: "",
                });
              }
            } else {
              console.log("unsafe to retrieve. Choose from inventory");

              if (plyr.items.weapons.length > 1) {
                console.log("fallback to other weapon1", plyr.items.weapons);
                plyr.currentWeapon = {
                  name: plyr.items.weapons[1].name,
                  type: plyr.items.weapons[1].type,
                  effect: plyr.items.weapons[1].effect,
                };

                plyr.ai.targetAcquired = false;
              } else {
                console.log("nothing else in inventory. find other in the field1");
                plyr.ai.upgradeWeapon = true;
              }
            }
          } else {
            console.log("bow in the field but no ammo");

            if (plyr.items.weapons.length > 1) {
              console.log("fallback to other weapon2", plyr.items.weapons);
              plyr.currentWeapon = {
                name: plyr.items.weapons[1].name,
                type: plyr.items.weapons[1].type,
                effect: plyr.items.weapons[1].effect,
              };

              plyr.ai.targetAcquired = false;
            } else {
              console.log("nothing else in inventory. find other in the field2");
              plyr.ai.upgradeWeapon = true;
            }
          }
        } else {
          console.log("no bow or ammo in the field");

          if (plyr.items.weapons.length > 1) {
            console.log("fallback to other weapon3", plyr.items.weapons);
            plyr.currentWeapon = {
              name: plyr.items.weapons[0].name,
              type: plyr.items.weapons[0].type,
              effect: plyr.items.weapons[0].effect,
            };

            plyr.ai.targetAcquired = false;
          } else {
            console.log("nothing else in inventory. find other in the field3");
            plyr.ai.upgradeWeapon = true;

            if (
              plyr.ai.organizing.weaponPriorityIndex ===
              weaponUpgradePriority.length - 1
            ) {
              console.log(
                "no ammo for bow or alternative weapons to upgrade to. Switch to unarmed"
              );
              plyr.currentWeapon = {
                name: "",
                type: "",
                effect: "",
              };
            }
          }
        }
      }
    }

    // INJURED OR SLOW!
    if (
      plyr.hp === 1 &&
      plyr.ai.mission !== "retrieve" &&
      plyr.ai.mission !== "retrieve"
    ) {
      console.log("injured. check for heal item");

      let itemToRetrieve = undefined;
      for (const item2 of fieldItemScan) {
        if (item2.effect === "hpUp") {
          itemToRetrieve = item2;
        }
      }

      if (itemToRetrieve) {
        let targetSafeData2 = this.scanTargetAreaThreat({
          player: plyr.number,
          point: {
            x: itemToRetrieve.location.x,
            y: itemToRetrieve.location.y,
          },
          range: 3,
        });

        if (targetSafeData2.isSafe === true) {
          plyr.ai.mission = "retrieve";
          plyr.ai.retrieving.point = {
            x: itemToRetrieve.location.x,
            y: itemToRetrieve.location.y,
          };
          plyr.ai.retrieving.targetItem = {
            name: itemToRetrieve.name,
            type: itemToRetrieve.type,
            subType: itemToRetrieve.subType,
            effect: itemToRetrieve.effect,
          };
          plyr.ai.retrieving.safe = true;

          if (!plyr.popups.find((x) => x.msg === "missionRetrieve")) {
            plyr.popups.push({
              state: false,
              count: 0,
              limit: 30,
              type: "",
              position: "",
              msg: "missionRetrieve",
              img: "",
            });
          }

          console.log(
            "found hpup item in the field. retrieve @ ",
            itemToRetrieve.location
          );
        } else {
          console.log("no heal item/gear found.");
        }
      }
    }

    if (
      plyr.speed.move < 0.1 &&
      plyr.ai.mission !== "retrieve" &&
      plyr.ai.mission !== "retrieve"
    ) {
      console.log("slow. check for speed up item");

      let itemToRetrieve = undefined;
      for (const item3 of fieldItemScan) {
        if (item3.effect === "speedUp") {
          itemToRetrieve = item3;
        }
      }

      if (itemToRetrieve) {
        console.log("found speed up item in the field. retrieve");

        let targetSafeData2 = this.scanTargetAreaThreat({
          player: plyr.number,
          point: {
            x: itemToRetrieve.location.x,
            y: itemToRetrieve.location.y,
          },
          range: 3,
        });

        if (targetSafeData2.isSafe === true) {
          plyr.ai.mission = "retrieve";
          plyr.ai.retrieving.point = {
            x: itemToRetrieve.location.x,
            y: itemToRetrieve.location.y,
          };
          plyr.ai.retrieving.targetItem = {
            name: itemToRetrieve.name,
            type: itemToRetrieve.type,
            subType: itemToRetrieve.subType,
            effect: itemToRetrieve.effect,
          };
          plyr.ai.retrieving.safe = true;
          plyr.ai.upgradeWeapon = false;

          if (!plyr.popups.find((x) => x.msg === "missionRetrieve")) {
            plyr.popups.push({
              state: false,
              count: 0,
              limit: 30,
              type: "",
              position: "",
              msg: "missionRetrieve",
              img: "",
            });
          }
        } else {
          console.log("no speedup item/gear found. Check for armor");
          plyr.ai.upgradeArmor = true;
        }
      }
    }

    // RETRIEVE DROPPED GEAR!
    if (plyr.ai.organizing.dropped.state === true) {
      console.log("ai retrieve dropped gear flow");

      for (const cell of this.gridInfo) {
        if (cell.item.name !== "") {
          fieldItemScan.push({
            name: cell.item.name,
            type: cell.item.type,
            subType: cell.item.subType,
            effect: cell.item.effect,
            location: { x: cell.number.x, y: cell.number.y },
          });
        }
      }

      let droppedGear = fieldItemScan.find(
        (elem) => elem.name === plyr.ai.organizing.dropped.gear.name
      );
      // console.log('droppedGear',droppedGear);

      if (plyr.ai.mission !== "engage") {
        console.log("gear dropped out of battle");

        if (
          droppedGear.location.x === plyr.currentPosition.cell.number.x &&
          droppedGear.location.y === plyr.currentPosition.cell.number.y
        ) {
          plyr.ai.instructions.push({
            keyword: "pickup",
            count: 0,
            limit: 1,
          });

          this.players[plyr.number - 1].ai.organizing.dropped.state = false;

          console.log("standing over dropped gear", plyr.ai.organizing.dropped.state);
        } else {
          console.log("retrieve dropped gear");

          plyr.ai.mission = "retrieve";
          plyr.ai.retrieving.point = {
            x: droppedGear.location.x,
            y: droppedGear.location.y,
          };
          plyr.ai.retrieving.targetItem = {
            name: droppedGear.name,
            type: droppedGear.type,
            subType: droppedGear.subType,
            effect: droppedGear.effect,
          };
          plyr.ai.retrieving.safe = true;

          // let targetSafeData2 = this.scanTargetAreaThreat({
          //   player: plyr.number,
          //   point: {
          //     x: droppedGear.location.x,
          //     y: droppedGear.location.y,
          //   },
          //   range: 3,
          // })
          //
          // if (targetSafeData2.isSafe === true) {
          //
          //   plyr.ai.mission = 'retrieve';
          //   plyr.ai.retrieving.point = {
          //     x: droppedGear.location.x,
          //     y: droppedGear.location.y,
          //   }
          //   plyr.ai.retrieving.targetItem = {
          //     name: droppedGear.name,
          //     type: droppedGear.type,
          //     subType: droppedGear.subType,
          //     effect: droppedGear.effect,
          //   };
          //   plyr.ai.retrieving.safe = true;
          //
          // }
          // else {
          //   console.log('unsafe to retrieve. check inventory');
          //
          //   if (plyr.items.weapons.length > 1) {
          //     console.log('fallback to other weapon');
          //     plyr.currentWeapon = {
          //       name: plyr.items.weapons[1].name,
          //       type: plyr.items.weapons[1].type,
          //       effect: plyr.items.weapons[1].effect,
          //     }
          //
          //     plyr.ai.organizing.dropped.state = false;
          //   } else {
          //     console.log('nothing else in inventory. find other in the field');
          //     plyr.ai.upgradeWeapon = true;
          //   }
          // }

          if (!plyr.popups.find((x) => x.msg === "missionRetrieve")) {
            plyr.popups.push({
              state: false,
              count: 0,
              limit: 30,
              type: "",
              position: "",
              msg: "missionRetrieve",
              img: "",
            });
          }
        }
      } else {
        console.log("dropped gear in battle");

        if (
          droppedGear.location.x === plyr.currentPosition.cell.number.x &&
          droppedGear.location.y === plyr.currentPosition.cell.number.y
        ) {
          plyr.ai.instructions.push({
            keyword: "pickup",
            count: 0,
            limit: 1,
          });

          this.players[plyr.number - 1].ai.organizing.dropped.state = false;

          console.log("standing over dropped gear", plyr.ai.organizing.dropped.state);
        } else {
          if (plyr.items.weapons.length > 1) {
            console.log("switch to something else from inventory");
            plyr.currentWeapon = {
              name: plyr.items.weapons[0].name,
              type: plyr.items.weapons[0].type,
              effect: plyr.items.weapons[0].effect,
            };
          } else {
            console.log("retrieve dropped gear");

            plyr.ai.mission = "retrieve";
            plyr.ai.retrieving.point = {
              x: droppedGear.location.x,
              y: droppedGear.location.y,
            };
            plyr.ai.retrieving.targetItem = {
              name: droppedGear.name,
              type: droppedGear.type,
              subType: droppedGear.subType,
              effect: droppedGear.effect,
            };
            plyr.ai.retrieving.safe = true;

            // let targetSafeData2 = this.scanTargetAreaThreat({
            //   player: plyr.number,
            //   point: {
            //     x: droppedGear.location.x,
            //     y: droppedGear.location.y,
            //   },
            //   range: 3,
            // })
            //
            // if (targetSafeData2.isSafe === true) {
            //
            //   plyr.ai.mission = 'retrieve';
            //   plyr.ai.retrieving.point = {
            //     x: droppedGear.location.x,
            //     y: droppedGear.location.y,
            //   }
            //   plyr.ai.retrieving.targetItem = {
            //     name: droppedGear.name,
            //     type: droppedGear.type,
            //     subType: droppedGear.subType,
            //     effect: droppedGear.effect,
            //   };
            //   plyr.ai.retrieving.safe = true;
            //
            // }
            // else {
            //   console.log('unsafe to retrieve. check inventory');
            //
            //   if (plyr.items.weapons.length > 1) {
            //     console.log('fallback to other weapon');
            //     plyr.currentWeapon = {
            //       name: plyr.items.weapons[1].name,
            //       type: plyr.items.weapons[1].type,
            //       effect: plyr.items.weapons[1].effect,
            //     }
            //
            //     plyr.ai.organizing.dropped.state = false;
            //   } else {
            //     console.log('nothing else in inventory. find other in the field');
            //     plyr.ai.upgradeWeapon = true
            //   }
            //
            // }

            if (!plyr.popups.find((x) => x.msg === "missionRetrieve")) {
              plyr.popups.push({
                state: false,
                count: 0,
                limit: 30,
                type: "",
                position: "",
                msg: "missionRetrieve",
                img: "",
              });
            }
          }
        }
      }

      // plyr.ai.organizing.dropped.state = true
    }

    // PATHFIND ERROR/ PREVENT SUICIDE!
    if (plyr.ai.resetInstructions === true) {
      console.log("pathfinding reset");
      if (!plyr.popups.find((x) => x.msg === "thinking")) {
        plyr.popups.push({
          state: false,
          count: 0,
          limit: 30,
          type: "",
          position: "",
          msg: "thinking",
          img: "",
        });
      }
      if (!plyr.popups.find((x) => x.msg === "pathSwitch")) {
        plyr.popups.push({
          state: false,
          count: 0,
          limit: 30,
          type: "",
          position: "",
          msg: "pathSwitch",
          img: "",
        });
      }
      // console.log('reset instructions','set',plyr.ai.targetSet,'acquired',plyr.ai.targetAcquired,'mission',plyr.ai.mission);
      plyr.ai.currentInstruction = 0;
      plyr.ai.instructions = [];
      plyr.ai.targetAcquired = false;
      plyr.ai.resetInstructions = false;

      if (plyr.ai.mission === "retreat") {
        console.log("retreat pathfinding reset");
        plyr.ai.retreating.checkin = undefined;
        plyr.ai.retreating.state = false;
      }
      if (plyr.ai.mission === "retrieve") {
        console.log("retrieve pathfinding reset");
        plyr.ai.retrieving.checkin = undefined;
        plyr.ai.retrieving.state = false;
      }
      if (plyr.ai.mission === "patrol") {
        console.log("patrol pathfinding reset");
        plyr.ai.patrolling.checkin = undefined;
        plyr.ai.patrolling.state = false;
      }
    }

    // SET TARGET!!
    // determine who is closer to me
    if (plyr.ai.targetSet !== true) {
      let targetAlive = false;
      let targetPlayer;

      targetPlayer = this.players[this.aiTarget - 1];
      if (
        targetPlayer.dead.state !== true &&
        targetPlayer.falling.state !== true &&
        targetPlayer.respawn !== true
      ) {
        targetAlive = true;
      } else {
        targetAlive = false;
      }

      if (targetAlive === true) {
        console.log("setting ai target... ", "this.aiTarget", this.aiTarget);

        plyr.ai.targetPlayer = {
          number: targetPlayer.number,
          currentPosition: {
            x: targetPlayer.currentPosition.cell.number.x,
            y: targetPlayer.currentPosition.cell.number.y,
          },
          target: {
            number1: {
              x: targetPlayer.target.cell1.number.x,
              y: targetPlayer.target.cell1.number.y,
            },
            number2: {
              x: targetPlayer.target.cell2.number.x,
              y: targetPlayer.target.cell2.number.y,
            },
          },
          action: targetPlayer.action,
        };
        plyr.ai.targetSet = true;
        // console.log('player',plyr.number,'setting target...player',targetPlayer.number,'my mission',plyr.ai.mission);
        // this.getTarget(plyr)
      } else {
        // console.log('no targets availible for ai');
      }
    }

    // TARGET AQUISITION & RANGE FINDING!!
    let targetInRange = false;

    if (plyr.ai.targetSet === true) {
      for (const plyr2 of this.players) {
        if (plyr2.ai.state !== true) {
          // CHECK FOR IN WEAPON RANGE!!
          if (plyr.currentWeapon.type === "crossbow") {
            let range = plyr.ai.pathfindingRanges.crossbow + 2;

            if (
              plyr.currentPosition.cell.number.x === plyr2.currentPosition.cell.number.x
            ) {
              if (
                (plyr2.currentPosition.cell.number.y <
                  plyr.currentPosition.cell.number.y + range &&
                  plyr2.currentPosition.cell.number.y >
                    plyr.currentPosition.cell.number.y) ||
                (plyr2.currentPosition.cell.number.y >
                  plyr.currentPosition.cell.number.y - range &&
                  plyr2.currentPosition.cell.number.y <
                    plyr.currentPosition.cell.number.y)
              ) {
                let clearToShoot = this.aiBoltPathCheck(plyr);
                if (
                  clearToShoot === true &&
                  plyr.ai.targetPlayer.number === plyr2.number &&
                  plyr.ai.mission !== "retrieve" &&
                  plyr.ai.mission !== "retreat"
                ) {
                  targetInRange = true;
                  // console.log('target in bow range for player',plyr.number,'@',plyr.currentPosition.cell.number);
                  plyr.ai.currentInstruction = 0;
                }
                if (clearToShoot !== true) {
                  console.log("in-range detection: crossbow target obstructed");
                } else if (
                  plyr.ai.mission !== "pursue" &&
                  plyr.ai.mission !== "engage" &&
                  plyr.ai.mission !== "retrieve" &&
                  plyr.ai.mission !== "retreat"
                ) {
                  plyr.ai.currentInstruction = 0;
                  // console.log('alternative target in range. Switching');

                  if (!plyr.popups.find((x) => x.msg === "alarmed")) {
                    plyr.popups.push({
                      state: false,
                      count: 0,
                      limit: 30,
                      type: "",
                      position: "",
                      msg: "alarmed",
                      img: "",
                    });
                  }

                  plyr.ai.targetPlayer = {
                    number: plyr2.number,
                    currentPosition: {
                      x: plyr2.currentPosition.cell.number.x,
                      y: plyr2.currentPosition.cell.number.y,
                    },
                    target: {
                      number1: {
                        x: plyr2.target.cell1.number.x,
                        y: plyr2.target.cell1.number.y,
                      },
                      number2: {
                        x: plyr2.target.cell2.number.x,
                        y: plyr2.target.cell2.number.y,
                      },
                    },
                    action: plyr2.action,
                  };
                }
              }
            }

            if (
              plyr.currentPosition.cell.number.y === plyr2.currentPosition.cell.number.y
            ) {
              if (
                (plyr2.currentPosition.cell.number.x <
                  plyr.currentPosition.cell.number.x + range &&
                  plyr2.currentPosition.cell.number.x >
                    plyr.currentPosition.cell.number.x) ||
                (plyr2.currentPosition.cell.number.x >
                  plyr.currentPosition.cell.number.x - range &&
                  plyr2.currentPosition.cell.number.x <
                    plyr.currentPosition.cell.number.x)
              ) {
                let clearToShoot = this.aiBoltPathCheck(plyr);
                if (
                  clearToShoot === true &&
                  plyr.ai.targetPlayer.number === plyr2.number &&
                  plyr.ai.mission !== "retrieve" &&
                  plyr.ai.mission !== "retreat"
                ) {
                  targetInRange = true;
                  // console.log('target in bow range for player',plyr.number,'@',plyr.currentPosition.cell.number);
                  plyr.ai.currentInstruction = 0;
                }
                if (clearToShoot !== true) {
                  console.log("in-range detection: crossbow target obstructed");
                } else if (
                  plyr.ai.mission !== "pursue" &&
                  plyr.ai.mission !== "engage" &&
                  plyr.ai.mission !== "retrieve" &&
                  plyr.ai.mission !== "retreat"
                ) {
                  plyr.ai.currentInstruction = 0;
                  // console.log('alternative target in range. Switching');

                  if (!plyr.popups.find((x) => x.msg === "alarmed")) {
                    plyr.popups.push({
                      state: false,
                      count: 0,
                      limit: 30,
                      type: "",
                      position: "",
                      msg: "alarmed",
                      img: "",
                    });
                  }

                  plyr.ai.targetPlayer = {
                    number: plyr2.number,
                    currentPosition: {
                      x: plyr2.currentPosition.cell.number.x,
                      y: plyr2.currentPosition.cell.number.y,
                    },
                    target: {
                      number1: {
                        x: plyr2.target.cell1.number.x,
                        y: plyr2.target.cell1.number.y,
                      },
                      number2: {
                        x: plyr2.target.cell2.number.x,
                        y: plyr2.target.cell2.number.y,
                      },
                    },
                    action: plyr2.action,
                  };
                }
              }
            }
          }

          if (plyr.currentWeapon.type === "spear") {
            let range = plyr.ai.pathfindingRanges.spear;
            // if (this.aiCarefulRange === true) {
            //   // console.log('careful range finding');
            //   range = 3;
            // }

            if (
              plyr.currentPosition.cell.number.x === plyr2.currentPosition.cell.number.x
            ) {
              if (plyr.ai.safeRange === true) {
                if (
                  plyr.currentPosition.cell.number.y ===
                    plyr2.currentPosition.cell.number.y + range ||
                  plyr.currentPosition.cell.number.y ===
                    plyr2.currentPosition.cell.number.y - range ||
                  plyr.currentPosition.cell.number.y ===
                    plyr2.currentPosition.cell.number.y + (range - 1) ||
                  plyr.currentPosition.cell.number.y ===
                    plyr2.currentPosition.cell.number.y - (range - 1) ||
                  plyr.currentPosition.cell.number.y ===
                    plyr2.currentPosition.cell.number.y + (range - 2) ||
                  plyr.currentPosition.cell.number.y ===
                    plyr2.currentPosition.cell.number.y - (range - 2)
                ) {
                  let clearToShoot = this.aiBoltPathCheck(plyr);
                  if (
                    clearToShoot === true &&
                    plyr.ai.targetPlayer.number === plyr2.number &&
                    plyr.ai.mission !== "retrieve" &&
                    plyr.ai.mission !== "retreat"
                  ) {
                    // if (plyr.ai.targetPlayer.number === plyr2.number && plyr.ai.mission !== 'retrieve' && plyr.ai.mission !== 'retreat') {
                    targetInRange = true;
                    // console.log('target in spear range for player',plyr.number,'@',plyr.currentPosition.cell.number);
                  }
                  if (clearToShoot !== true) {
                    console.log("in-range detection: spear target obstructed");
                  } else if (
                    plyr.ai.mission !== "pursue" &&
                    plyr.ai.mission !== "engage" &&
                    plyr.ai.mission !== "retrieve" &&
                    plyr.ai.mission !== "retreat"
                  ) {
                    // console.log('alternative target in range. Switching');

                    if (!plyr.popups.find((x) => x.msg === "alarmed")) {
                      plyr.popups.push({
                        state: false,
                        count: 0,
                        limit: 30,
                        type: "",
                        position: "",
                        msg: "alarmed",
                        img: "",
                      });
                    }

                    plyr.ai.targetPlayer = {
                      number: plyr2.number,
                      currentPosition: {
                        x: plyr2.currentPosition.cell.number.x,
                        y: plyr2.currentPosition.cell.number.y,
                      },
                      target: {
                        number1: {
                          x: plyr2.target.cell1.number.x,
                          y: plyr2.target.cell1.number.y,
                        },
                        number2: {
                          x: plyr2.target.cell2.number.x,
                          y: plyr2.target.cell2.number.y,
                        },
                      },
                      action: plyr2.action,
                    };
                  }
                }
              } else {
                if (
                  plyr.currentPosition.cell.number.y ===
                    plyr2.currentPosition.cell.number.y + range ||
                  plyr.currentPosition.cell.number.y ===
                    plyr2.currentPosition.cell.number.y - range
                ) {
                  let clearToShoot = this.aiBoltPathCheck(plyr);
                  if (
                    clearToShoot === true &&
                    plyr.ai.targetPlayer.number === plyr2.number &&
                    plyr.ai.mission !== "retrieve" &&
                    plyr.ai.mission !== "retreat"
                  ) {
                    // if (plyr.ai.targetPlayer.number === plyr2.number && plyr.ai.mission !== 'retrieve' && plyr.ai.mission !== 'retreat') {
                    targetInRange = true;
                    // console.log('target in spear range for player',plyr.number,'@',plyr.currentPosition.cell.number);
                  }
                  if (clearToShoot !== true) {
                    console.log("in-range detection: spear target obstructed");
                  } else if (
                    plyr.ai.mission !== "pursue" &&
                    plyr.ai.mission !== "engage" &&
                    plyr.ai.mission !== "retrieve" &&
                    plyr.ai.mission !== "retreat"
                  ) {
                    // console.log('alternative target in range. Switching');

                    if (!plyr.popups.find((x) => x.msg === "alarmed")) {
                      plyr.popups.push({
                        state: false,
                        count: 0,
                        limit: 30,
                        type: "",
                        position: "",
                        msg: "alarmed",
                        img: "",
                      });
                    }

                    plyr.ai.targetPlayer = {
                      number: plyr2.number,
                      currentPosition: {
                        x: plyr2.currentPosition.cell.number.x,
                        y: plyr2.currentPosition.cell.number.y,
                      },
                      target: {
                        number1: {
                          x: plyr2.target.cell1.number.x,
                          y: plyr2.target.cell1.number.y,
                        },
                        number2: {
                          x: plyr2.target.cell2.number.x,
                          y: plyr2.target.cell2.number.y,
                        },
                      },
                      action: plyr2.action,
                    };
                  }
                }
              }
            }

            if (
              plyr.currentPosition.cell.number.y === plyr2.currentPosition.cell.number.y
            ) {
              if (plyr.ai.safeRange === true) {
                if (
                  plyr.currentPosition.cell.number.x ===
                    plyr2.currentPosition.cell.number.x + range ||
                  plyr.currentPosition.cell.number.x ===
                    plyr2.currentPosition.cell.number.x - range ||
                  plyr.currentPosition.cell.number.x ===
                    plyr2.currentPosition.cell.number.x + (range - 1) ||
                  plyr.currentPosition.cell.number.x ===
                    plyr2.currentPosition.cell.number.x + (range - 1) ||
                  plyr.currentPosition.cell.number.x ===
                    plyr2.currentPosition.cell.number.x - (range - 2) ||
                  plyr.currentPosition.cell.number.x ===
                    plyr2.currentPosition.cell.number.x - (range - 2)
                ) {
                  let clearToShoot = this.aiBoltPathCheck(plyr);
                  if (
                    clearToShoot === true &&
                    plyr.ai.targetPlayer.number === plyr2.number &&
                    plyr.ai.mission !== "retrieve" &&
                    plyr.ai.mission !== "retreat"
                  ) {
                    // if (plyr.ai.targetPlayer.number === plyr2.number && plyr.ai.mission !== 'retrieve' && plyr.ai.mission !== 'retreat') {
                    targetInRange = true;
                    // console.log('target in spear range for player',plyr.number,'@',plyr.currentPosition.cell.number);
                  }
                  if (clearToShoot !== true) {
                    console.log("in-range detection: spear target obstructed");
                  } else if (
                    plyr.ai.mission !== "pursue" &&
                    plyr.ai.mission !== "engage" &&
                    plyr.ai.mission !== "retrieve" &&
                    plyr.ai.mission !== "retreat"
                  ) {
                    // console.log('alternative target in range. Switching');

                    if (!plyr.popups.find((x) => x.msg === "alarmed")) {
                      plyr.popups.push({
                        state: false,
                        count: 0,
                        limit: 30,
                        type: "",
                        position: "",
                        msg: "alarmed",
                        img: "",
                      });
                    }

                    plyr.ai.targetPlayer = {
                      number: plyr2.number,
                      currentPosition: {
                        x: plyr2.currentPosition.cell.number.x,
                        y: plyr2.currentPosition.cell.number.y,
                      },
                      target: {
                        number1: {
                          x: plyr2.target.cell1.number.x,
                          y: plyr2.target.cell1.number.y,
                        },
                        number2: {
                          x: plyr2.target.cell2.number.x,
                          y: plyr2.target.cell2.number.y,
                        },
                      },
                      action: plyr2.action,
                    };
                  }
                }
              } else {
                if (
                  plyr.currentPosition.cell.number.x ===
                    plyr2.currentPosition.cell.number.x + 1 ||
                  plyr.currentPosition.cell.number.x ===
                    plyr2.currentPosition.cell.number.x - 1 ||
                  plyr.currentPosition.cell.number.x ===
                    plyr2.currentPosition.cell.number.x + 2 ||
                  plyr.currentPosition.cell.number.x ===
                    plyr2.currentPosition.cell.number.x - 2
                  // plyr.currentPosition.cell.number.x === plyr2.currentPosition.cell.number.x + range ||
                  // plyr.currentPosition.cell.number.x === plyr2.currentPosition.cell.number.x - range
                ) {
                  let clearToShoot = this.aiBoltPathCheck(plyr);
                  if (
                    clearToShoot === true &&
                    plyr.ai.targetPlayer.number === plyr2.number &&
                    plyr.ai.mission !== "retrieve" &&
                    plyr.ai.mission !== "retreat"
                  ) {
                    // if (plyr.ai.targetPlayer.number === plyr2.number && plyr.ai.mission !== 'retrieve' && plyr.ai.mission !== 'retreat') {
                    targetInRange = true;
                    // console.log('target in spear range for player',plyr.number,'@',plyr.currentPosition.cell.number);
                  }
                  if (clearToShoot !== true) {
                    console.log("in-range detection: spear target obstructed");
                  } else if (
                    plyr.ai.mission !== "pursue" &&
                    plyr.ai.mission !== "engage" &&
                    plyr.ai.mission !== "retrieve" &&
                    plyr.ai.mission !== "retreat"
                  ) {
                    // console.log('alternative target in range. Switching');

                    if (!plyr.popups.find((x) => x.msg === "alarmed")) {
                      plyr.popups.push({
                        state: false,
                        count: 0,
                        limit: 30,
                        type: "",
                        position: "",
                        msg: "alarmed",
                        img: "",
                      });
                    }

                    plyr.ai.targetPlayer = {
                      number: plyr2.number,
                      currentPosition: {
                        x: plyr2.currentPosition.cell.number.x,
                        y: plyr2.currentPosition.cell.number.y,
                      },
                      target: {
                        number1: {
                          x: plyr2.target.cell1.number.x,
                          y: plyr2.target.cell1.number.y,
                        },
                        number2: {
                          x: plyr2.target.cell2.number.x,
                          y: plyr2.target.cell2.number.y,
                        },
                      },
                      action: plyr2.action,
                    };
                  }
                }
              }
            }
          }

          if (plyr.currentWeapon.type === "sword" || plyr.currentWeapon.type === "") {
            let range2 = 1;
            if (plyr.ai.safeRange === true) {
              // console.log('careful range finding');
              range2 = 2;
            }

            if (
              plyr.currentPosition.cell.number.x === plyr2.currentPosition.cell.number.x
            ) {
              if (plyr.ai.safeRange === true) {
                if (
                  plyr.currentPosition.cell.number.y ===
                    plyr2.currentPosition.cell.number.y + range2 ||
                  plyr.currentPosition.cell.number.y ===
                    plyr2.currentPosition.cell.number.y - range2 ||
                  plyr.currentPosition.cell.number.y ===
                    plyr2.currentPosition.cell.number.y + (range2 - 1) ||
                  plyr.currentPosition.cell.number.y ===
                    plyr2.currentPosition.cell.number.y - (range2 - 1)
                ) {
                  if (
                    plyr.ai.targetPlayer.number === plyr2.number &&
                    plyr.ai.mission !== "retrieve" &&
                    plyr.ai.mission !== "retreat"
                  ) {
                    targetInRange = true;
                    // console.log('target in sword range for player',plyr.number,'@',plyr.currentPosition.cell.number);
                  } else if (
                    plyr.ai.mission !== "pursue" &&
                    plyr.ai.mission !== "engage" &&
                    plyr.ai.mission !== "retrieve" &&
                    plyr.ai.mission !== "retreat"
                  ) {
                    // console.log('alternative target in range. Switching');

                    if (!plyr.popups.find((x) => x.msg === "alarmed")) {
                      plyr.popups.push({
                        state: false,
                        count: 0,
                        limit: 30,
                        type: "",
                        position: "",
                        msg: "alarmed",
                        img: "",
                      });
                    }

                    plyr.ai.targetPlayer = {
                      number: plyr2.number,
                      currentPosition: {
                        x: plyr2.currentPosition.cell.number.x,
                        y: plyr2.currentPosition.cell.number.y,
                      },
                      target: {
                        number1: {
                          x: plyr2.target.cell1.number.x,
                          y: plyr2.target.cell1.number.y,
                        },
                        number2: {
                          x: plyr2.target.cell2.number.x,
                          y: plyr2.target.cell2.number.y,
                        },
                      },
                      action: plyr2.action,
                    };
                  }
                }
              } else {
                if (
                  plyr.currentPosition.cell.number.y ===
                    plyr2.currentPosition.cell.number.y + range2 ||
                  plyr.currentPosition.cell.number.y ===
                    plyr2.currentPosition.cell.number.y - range2
                ) {
                  if (
                    plyr.ai.targetPlayer.number === plyr2.number &&
                    plyr.ai.mission !== "retrieve" &&
                    plyr.ai.mission !== "retreat"
                  ) {
                    targetInRange = true;
                    // console.log('target in sword range for player',plyr.number,'@',plyr.currentPosition.cell.number);
                  } else if (
                    plyr.ai.mission !== "pursue" &&
                    plyr.ai.mission !== "engage" &&
                    plyr.ai.mission !== "retrieve" &&
                    plyr.ai.mission !== "retreat"
                  ) {
                    // console.log('alternative target in range. Switching');

                    if (!plyr.popups.find((x) => x.msg === "alarmed")) {
                      plyr.popups.push({
                        state: false,
                        count: 0,
                        limit: 30,
                        type: "",
                        position: "",
                        msg: "alarmed",
                        img: "",
                      });
                    }

                    plyr.ai.targetPlayer = {
                      number: plyr2.number,
                      currentPosition: {
                        x: plyr2.currentPosition.cell.number.x,
                        y: plyr2.currentPosition.cell.number.y,
                      },
                      target: {
                        number1: {
                          x: plyr2.target.cell1.number.x,
                          y: plyr2.target.cell1.number.y,
                        },
                        number2: {
                          x: plyr2.target.cell2.number.x,
                          y: plyr2.target.cell2.number.y,
                        },
                      },
                      action: plyr2.action,
                    };
                  }
                }
              }
            }

            if (
              plyr.currentPosition.cell.number.y === plyr2.currentPosition.cell.number.y
            ) {
              if (plyr.ai.safeRange === true) {
                if (
                  plyr.currentPosition.cell.number.x ===
                    plyr2.currentPosition.cell.number.x + range2 ||
                  plyr.currentPosition.cell.number.x ===
                    plyr2.currentPosition.cell.number.x - range2 ||
                  plyr.currentPosition.cell.number.x ===
                    plyr2.currentPosition.cell.number.x + (range2 - 1) ||
                  plyr.currentPosition.cell.number.x ===
                    plyr2.currentPosition.cell.number.x - (range2 - 1)
                ) {
                  if (
                    plyr.ai.targetPlayer.number === plyr2.number &&
                    plyr.ai.mission !== "retrieve" &&
                    plyr.ai.mission !== "retreat"
                  ) {
                    targetInRange = true;
                    // console.log('target in sword range for player',plyr.number,'@',plyr.currentPosition.cell.number);
                  } else if (
                    plyr.ai.mission !== "pursue" &&
                    plyr.ai.mission !== "engage" &&
                    plyr.ai.mission !== "retrieve" &&
                    plyr.ai.mission !== "retreat"
                  ) {
                    // console.log('alternative target in range. Switching');

                    if (!plyr.popups.find((x) => x.msg === "alarmed")) {
                      plyr.popups.push({
                        state: false,
                        count: 0,
                        limit: 30,
                        type: "",
                        position: "",
                        msg: "alarmed",
                        img: "",
                      });
                    }

                    plyr.ai.targetPlayer = {
                      number: plyr2.number,
                      currentPosition: {
                        x: plyr2.currentPosition.cell.number.x,
                        y: plyr2.currentPosition.cell.number.y,
                      },
                      target: {
                        number1: {
                          x: plyr2.target.cell1.number.x,
                          y: plyr2.target.cell1.number.y,
                        },
                        number2: {
                          x: plyr2.target.cell2.number.x,
                          y: plyr2.target.cell2.number.y,
                        },
                      },
                      action: plyr2.action,
                    };
                  }
                }
              } else {
                if (
                  plyr.currentPosition.cell.number.x ===
                    plyr2.currentPosition.cell.number.x + range2 ||
                  plyr.currentPosition.cell.number.x ===
                    plyr2.currentPosition.cell.number.x - range2
                ) {
                  if (
                    plyr.ai.targetPlayer.number === plyr2.number &&
                    plyr.ai.mission !== "retrieve" &&
                    plyr.ai.mission !== "retreat"
                  ) {
                    targetInRange = true;
                    // console.log('target in sword range for player',plyr.number,'@',plyr.currentPosition.cell.number);
                  } else if (
                    plyr.ai.mission !== "pursue" &&
                    plyr.ai.mission !== "engage" &&
                    plyr.ai.mission !== "retrieve" &&
                    plyr.ai.mission !== "retreat"
                  ) {
                    // console.log('alternative target in range. Switching');

                    if (!plyr.popups.find((x) => x.msg === "alarmed")) {
                      plyr.popups.push({
                        state: false,
                        count: 0,
                        limit: 30,
                        type: "",
                        position: "",
                        msg: "alarmed",
                        img: "",
                      });
                    }

                    plyr.ai.targetPlayer = {
                      number: plyr2.number,
                      currentPosition: {
                        x: plyr2.currentPosition.cell.number.x,
                        y: plyr2.currentPosition.cell.number.y,
                      },
                      target: {
                        number1: {
                          x: plyr2.target.cell1.number.x,
                          y: plyr2.target.cell1.number.y,
                        },
                        number2: {
                          x: plyr2.target.cell2.number.x,
                          y: plyr2.target.cell2.number.y,
                        },
                      },
                      action: plyr2.action,
                    };
                  }
                }
              }
            }
          }
        }
      }
    }

    // TARGET IN RANGE, SWITCH TO MISSION ENGAGE
    if (targetInRange === true) {
      // console.log('target in range. switch to engage',plyr.ai.targetSet);
      if (plyr.ai.mission === "patrol") {
        plyr.ai.patrolling.checkin = undefined;
      }

      if (plyr.ai.mission === "defend") {
        plyr.ai.defending.checkin = undefined;
      }

      plyr.ai.prevMission = plyr.ai.mission;
      if (plyr.ai.mission !== "retrieve" && plyr.ai.mission !== "retreat") {
        // console.log('player',plyr.number,'target in range. Engage!');

        plyr.ai.mission = "engage";

        if (!plyr.popups.find((x) => x.msg === "missionEngage")) {
          plyr.popups.push({
            state: false,
            count: 0,
            limit: 30,
            type: "",
            position: "",
            msg: "missionEngage",
            img: "",
          });
        }
      }

      if (plyr.ai.mission === "retrieve" || plyr.ai.mission === "retreat") {
        // console.log('...');
      }

      // plyr.ai.engaging.state = true;
    }

    // TARGET OUT OF RANGE, REVERT TO PRIMARY MISSION
    if (plyr.ai.mission === "engage" && targetInRange !== true) {
      // console.log('target out of range. reverting to primary mission',plyr.ai.primaryMission);

      plyr.ai.mission = plyr.ai.primaryMission;

      if (!plyr.popups.find((x) => x.msg === "thinking")) {
        plyr.popups.push({
          state: false,
          count: 0,
          limit: 30,
          type: "",
          position: "",
          msg: "thinking",
          img: "",
        });
      }

      // if (!plyr.popups.find(x=>x.msg === 'mission'+plyr.ai.mission 1st char upper+'')) {
      //   plyr.popups.push(
      //     {
      //       state: false,
      //       count: 0,
      //       limit: 30,
      //       type: '',
      //       position: '',
      //       msg: 'mission'+plyr.ai.mission 1st char upper+'',
      //       img: '',
      //
      //     }
      //   )
      // }

      this.aiResetRanges(plyr);
      if (plyr.ai.primaryMission === "defend") {
        console.log("defend", plyr.ai.defending.checkin);
        plyr.ai.patrolling.checkin = undefined;
        plyr.ai.defending.state = true;
      }

      if (plyr.ai.primaryMission === "patrol") {
        // console.log('patrol',plyr.ai.patrolling.checkin);
        plyr.ai.defending.checkin = undefined;
        plyr.ai.patrolling.state = true;
      }
      // plyr.ai.engaging.state = false;
    }

    if (plyr.ai.targetAqcuiredReset === true) {
      plyr.ai.targetAcquired = false;
      plyr.ai.targetAqcuiredReset = false;
    }

    // if (plyr.ai.mission === 'retrieve' && plyr.ai.retrieving.state !== true) {
    if (plyr.ai.mission === "retrieve") {
      // console.log('retrieve @  ai evaluate', plyr.ai.retrieving);

      let targetSafeData = this.scanTargetAreaThreat({
        player: plyr.number,
        point: {
          x: plyr.ai.retrieving.point.x,
          y: plyr.ai.retrieving.point.y,
        },
        range: 3,
      });

      plyr.ai.retrieving.safe = targetSafeData.isSafe;

      if (targetSafeData.isSafe !== true) {
        // console.log('target area is under threat');
        if (plyr.ai.mode === "aggressive") {
          // console.log('threats',targetSafeData.threats);
          plyr.ai.mission = "pursue";

          if (!plyr.popups.find((x) => x.msg === "missionPursue")) {
            plyr.popups.push({
              state: false,
              count: 0,
              limit: 30,
              type: "",
              position: "",
              msg: "missionPursue",
              img: "",
            });
          }
          if (!plyr.popups.find((x) => x.msg === "aggressiveMode")) {
            plyr.popups.push({
              state: false,
              count: 0,
              limit: 30,
              type: "",
              position: "",
              msg: "aggressiveMode",
              img: "",
            });
          }

          for (const threat of targetSafeData.threats) {
            console.log("threat", threat);
            if (threat.distVal === 0) {
              console.log("threats", targetSafeData.threats);

              plyr.ai.targetSet = true;
              plyr.ai.targetAquired = false;
              let threat2 = this.players[threat.player - 1];
              plyr.ai.targetPlayer = {
                number: 1,
                currentPosition: {
                  x: threat2.currentPosition.cell.number.x,
                  y: threat2.currentPosition.cell.number.y,
                },
                target: {
                  number1: {
                    x: threat2.target.cell1.x,
                    y: threat2.target.cell1.y,
                  },
                  number2: {
                    x: threat2.target.cell2.x,
                    y: threat2.target.cell2.y,
                  },
                },
                action: threat.action,
              };
            }
          }
        }
        if (plyr.ai.mode === "careful" && plyr.ai.retrieving.checkin === "enroute") {
          console.log("was enroute, now retreating");

          if (!plyr.popups.find((x) => x.msg === "passiveMode")) {
            plyr.popups.push({
              state: false,
              count: 0,
              limit: 30,
              type: "",
              position: "",
              msg: "passiveMode",
              img: "",
            });
          }

          plyr.ai.mission = "retreat";

          if (!plyr.popups.find((x) => x.msg === "missionRetreat")) {
            plyr.popups.push({
              state: false,
              count: 0,
              limit: 30,
              type: "",
              position: "",
              msg: "missionRetreat",
              img: "",
            });
          }
        }
      } else {
        // console.log('target area clear. proceed w/ retrieval');
        plyr.ai.retrieving.safe = true;
      }

      if (plyr.ai.retrieving.checkin === "complete") {
        plyr.ai.mission = plyr.ai.primaryMission;
        this.aiResetRanges(plyr);

        if (!plyr.popups.find((x) => x.msg === "missionComplete")) {
          plyr.popups.push({
            state: false,
            count: 0,
            limit: 30,
            type: "",
            position: "",
            msg: "missionComplete",
            img: "",
          });
        }

        // if (!plyr.popups.find(x=>x.msg === 'mission'+plyr.ai.mission 1st char upper+'')) {
        //   plyr.popups.push(
        //     {
        //       state: false,
        //       count: 0,
        //       limit: 30,
        //       type: '',
        //       position: '',
        //       msg: 'mission'+plyr.ai.mission 1st char upper+'',
        //       img: '',
        //
        //     }
        //   )
        // }

        plyr.ai.retrieving.checkin = undefined;
        plyr.ai.retrieving.safe = false;
        plyr.ai.targetAcquired = false;
        // console.log('retrieval complete. revert mission',plyr.ai.mission,plyr.ai.targetSet,plyr.ai.targetPlayer.currentPosition,plyr.ai.targetAcquired,plyr.ai.targetPlayer);

        let itemRetrieved;

        if (plyr.ai.retrieving.targetItem.type !== "item") {
          if (plyr.ai.retrieving.targetItem.type === "weapon") {
            if (plyr.currentWeapon.name === plyr.ai.retrieving.targetItem.name) {
              itemRetrieved = true;
            }
            for (const item of plyr.items.weapons) {
              if (item.name === plyr.ai.retrieving.targetItem.name) {
                itemRetrieved = true;
                plyr.currentWeapon = {
                  name: plyr.ai.retrieving.targetItem.name,
                  type: plyr.ai.retrieving.targetItem.subType,
                  effect: plyr.ai.retrieving.targetItem.effect,
                };
              }
            }
          }
          if (plyr.ai.retrieving.targetItem.type === "armor") {
            if (plyr.currentArmor.name === plyr.ai.retrieving.targetItem.name) {
              itemRetrieved = true;
            }
            for (const item of plyr.items.armor) {
              if (item.name === plyr.ai.retrieving.targetItem.name) {
                itemRetrieved = true;
                plyr.currentArmor = {
                  name: plyr.ai.retrieving.targetItem.name,
                  type: plyr.ai.retrieving.targetItem.subType,
                  effect: plyr.ai.retrieving.targetItem.effect,
                };
              }
            }
          }
        }

        if (itemRetrieved === true) {
          plyr.ai.retrieving = {
            checkin: undefined,
            state: false,
            point: { x: undefined, y: undefined },
            targetItem: {
              name: "",
              type: "",
              subType: "",
              effect: "",
            },
            safe: false,
          };
        }

        if (plyr.ai.organizing.dropped.state === true) {
          plyr.ai.organizing.dropped.state = false;
        }
      }

      if (plyr.ai.retrieving.checkin === "abort") {
        plyr.ai.retrieving = {
          checkin: undefined,
          state: false,
          point: { x: undefined, y: undefined },
          targetItem: {
            name: "",
            type: "",
            subType: "",
            effect: "",
          },
          safe: false,
        };
      }
    }

    if (plyr.ai.mission === "retreat") {
      // console.log('retreating @ ai evaluate');

      if (!plyr.ai.retreating.checkin) {
        let isSafeDistance = false;

        let cell = { x: 0, y: 0 };
        let checkCell = false;
        let safeTarget = false;
        while (checkCell === false && safeTarget !== true && isSafeDistance !== true) {
          cell.x = this.rnJesus(0, this.gridWidth);
          cell.y = this.rnJesus(0, this.gridWidth);
          checkCell = this.checkCell(cell);
          safeTarget = this.scanTargetAreaThreat({
            player: plyr.number,
            point: {
              x: cell.x,
              y: cell.y,
            },
            range: 3,
          }).isSafe;
          isSafeDistance = this.safeDistanceRetreat(plyr, cell);
        }

        if (checkCell === true && safeTarget === true && isSafeDistance !== true) {
          plyr.ai.retreating.point = cell;
          plyr.ai.retreating.safe = safeTarget;
          console.log("found a free, safe retreat location", cell);
        }
      }

      if (plyr.ai.retreating.checkin && plyr.ai.retreating.state !== true) {
        let targetSafeData = this.scanTargetAreaThreat({
          player: plyr.number,
          point: {
            x: plyr.ai.retreating.point.x,
            y: plyr.ai.retreating.point.y,
          },
          range: 3,
        });

        plyr.ai.retrieving.safe = targetSafeData.isSafe;

        if (targetSafeData.isSafe !== true) {
          console.log("retreat target area is under threat. Find another target");
          plyr.ai.retreating.checkin = undefined;
          plyr.ai.retreating.safe = false;
        }

        if (plyr.ai.retreating.checkin === "complete") {
          plyr.ai.retreating.checkin = undefined;
          plyr.ai.retreating.safe = false;
          plyr.ai.mission = plyr.ai.primaryMission;
          this.aiResetRanges(plyr);

          switch (plyr.ai.primaryMission) {
            case "defend":
              plyr.ai.defending.checkin = undefined;
              break;
            case "patrol":
              plyr.ai.patrolling.checkin = undefined;
              break;
            default:
          }

          // console.log('gg',plyr.ai.targetPlayer);

          if (!plyr.popups.find((x) => x.msg === "missionComplete")) {
            plyr.popups.push({
              state: false,
              count: 0,
              limit: 30,
              type: "",
              position: "",
              msg: "missionComplete",
              img: "",
            });
          }

          // if (!plyr.popups.find(x=>x.msg === 'mission'+plyr.ai.mission 1st char upper+'')) {
          //   plyr.popups.push(
          //     {
          //       state: false,
          //       count: 0,
          //       limit: 30,
          //       type: '',
          //       position: '',
          //       msg: 'mission'+plyr.ai.mission 1st char upper+'',
          //       img: '',
          //
          //     }
          //   )
          // }

          // plyr.ai.targetSet = false
          plyr.ai.targetAcquired = false;
        }
      }

      // plyr.ai.retreating.level pick a spot further away depending on levelData
    }

    // AI CAN'T ACT IF FLANKING OR MOVING!

    if (
      plyr.flanking.state !== true &&
      plyr.flanking.step !== 1 &&
      plyr.flanking.step !== 2 &&
      plyr.moving.state !== true &&
      // plyr.attacking.state !== true &&
      plyr.defending.state !== true &&
      plyr.success.deflected.state !== true &&
      plyr.action !== "deflected" &&
      plyr.pushBack.state !== true &&
      plyr.dead.state !== true &&
      plyr.falling.state !== true
    ) {
      this.aiDecide(plyr);
    }
  };
  aiDecide = (aiPlayer) => {
    // console.log('aiDecide',aiPlayer.number);

    let getPath = false;

    let targetPlayer = this.players[aiPlayer.ai.targetPlayer.number - 1];
    let prevTargetPos = aiPlayer.ai.targetPlayer.currentPosition;
    let currentTargetPos;
    if (aiPlayer.ai.targetSet === true) {
      currentTargetPos = targetPlayer.currentPosition.cell.number;
    }

    // CHECK FOR PURSUIT TARGET POSITION CHANGE!!
    if (aiPlayer.ai.mission === "pursue" && aiPlayer.ai.targetSet === true) {
      // console.log('pursuing');

      if (
        prevTargetPos.x !== currentTargetPos.x ||
        (prevTargetPos.y !== currentTargetPos.y &&
          targetPlayer.dead.state !== true &&
          targetPlayer.falling.state !== true)
      ) {
        // console.log('pursuit target location changed! Updating path for player',aiPlayer.number);

        aiPlayer.ai.targetPlayer.currentPosition = {
          x: targetPlayer.currentPosition.cell.number.x,
          y: targetPlayer.currentPosition.cell.number.y,
        };
        getPath = true;
        aiPlayer.ai.targetAcquired = true;
        aiPlayer.ai.currentInstruction = 0;
      }
      if (aiPlayer.ai.targetSet === true && aiPlayer.ai.targetAcquired !== true) {
        getPath = true;
        aiPlayer.ai.targetAcquired = true;
      } else if (getPath !== true) {
        // console.log('target position unchanged! Skipping path update!');
        getPath = false;
      }
    }

    let patrolDest;
    if (aiPlayer.ai.mission === "patrol") {
      // console.log('patrolling',aiPlayer.ai.patrolling.checkin);
      if (targetPlayer) {
        if (
          prevTargetPos.x !== currentTargetPos.x ||
          (prevTargetPos.y !== currentTargetPos.y &&
            targetPlayer.dead.state !== true &&
            targetPlayer.falling.state !== true)
        ) {
          // console.log('patrolling but target location changed! Dont update path. Just track target',aiPlayer.number);

          aiPlayer.ai.targetPlayer.currentPosition = {
            x: targetPlayer.currentPosition.cell.number.x,
            y: targetPlayer.currentPosition.cell.number.y,
          };
        }
      }

      if (!aiPlayer.ai.patrolling.checkin) {
        // if (aiPlayer.ai.instructions.length > 0) {
        //   console.log('bloody hell');
        //   aiPlayer.ai.instructions = []
        // }
        // console.log('start out to patrol location @',aiPlayer.ai.patrolling.area[0],aiPlayer.ai.instructions,aiPlayer.ai.currentInstruction,aiPlayer.ai.patrolling.area[0]);

        aiPlayer.ai.patrolling.checkin = "enroute";

        if (!aiPlayer.popups.find((x) => x.msg === "missionEnroute")) {
          aiPlayer.popups.push({
            state: false,
            count: 0,
            limit: 30,
            type: "",
            position: "",
            msg: "missionEnroute",
            img: "",
          });
        }

        patrolDest = aiPlayer.ai.patrolling.area[0];
        getPath = true;
      }
      if (aiPlayer.ai.patrolling.checkin === "enroute") {
        if (aiPlayer.attacking.state === true) {
          aiPlayer.attacking.state = false;
        }

        if (
          aiPlayer.ai.patrolling.area[0].x === aiPlayer.currentPosition.cell.number.x &&
          aiPlayer.ai.patrolling.area[0].y === aiPlayer.currentPosition.cell.number.y
        ) {
          aiPlayer.ai.patrolling.checkin = "arrived";
          // console.log('arrived @ patrol point');
        } else {
          // console.log('en route to patrol. do nothing',aiPlayer.ai.patrolling.area[0]);
        }
      }
      if (aiPlayer.ai.patrolling.checkin === "arrived") {
        aiPlayer.ai.patrolling.checkin = "checkedIn";
        aiPlayer.ai.currentInstruction = 0;
        aiPlayer.ai.instructions = [];
        patrolDest = aiPlayer.ai.patrolling.area[1];
        getPath = true;
        // console.log('checked in to patrol point. moving to 2nd point @ ',patrolDest);
      }

      if (
        aiPlayer.ai.patrolling.checkin === "checkedIn" &&
        aiPlayer.ai.patrolling.loopControl === false
      ) {
        // console.log('currently patrolling');
        let currentPatrolPoint = aiPlayer.ai.patrolling.area.findIndex(
          (elem) =>
            elem.x === aiPlayer.currentPosition.cell.number.x &&
            elem.y === aiPlayer.currentPosition.cell.number.y
        );
        // console.log('currentPatrolPoint 1',currentPatrolPoint, aiPlayer.currentPosition.cell.number);
        if (currentPatrolPoint === 0) {
          patrolDest = aiPlayer.ai.patrolling.area[1];
          getPath = true;
          aiPlayer.ai.patrolling.loopControl = true;
        }
        if (currentPatrolPoint === 1) {
          patrolDest = aiPlayer.ai.patrolling.area[0];
          getPath = true;
          aiPlayer.ai.patrolling.loopControl = true;
        }
      }
    }

    if (aiPlayer.ai.mission === "engage" && aiPlayer.attacking.state !== true) {
      // console.log('engaging');

      // CHECK FOR TARGET LOCATION CHNAGE!
      if (
        prevTargetPos.x !== currentTargetPos.x ||
        (prevTargetPos.y !== currentTargetPos.y &&
          targetPlayer.dead.state !== true &&
          targetPlayer.falling.state !== true)
      ) {
        // console.log('engage target location changed! Updating path for player',aiPlayer.number,targetPlayer.dead.state);

        aiPlayer.ai.targetPlayer.currentPosition = {
          x: targetPlayer.currentPosition.cell.number.x,
          y: targetPlayer.currentPosition.cell.number.y,
        };
        if (aiPlayer.ai.primaryMission === "pursue") {
          aiPlayer.ai.mission = "pursue";
          this.aiResetRanges(aiPlayer);

          if (!aiPlayer.popups.find((x) => x.msg === "missionPursue")) {
            aiPlayer.popups.push({
              state: false,
              count: 0,
              limit: 30,
              type: "",
              position: "",
              msg: "missionPursue",
              img: "",
            });
          }
        }

        aiPlayer.ai.targetAcquired = false;
      }

      let oppositeDir;
      let engageTargetAction;
      // FACE TARGET!
      if (
        targetPlayer.currentPosition.cell.number.x ===
          aiPlayer.currentPosition.cell.number.x &&
        targetPlayer.currentPosition.cell.number.y >
          aiPlayer.currentPosition.cell.number.y
      ) {
        if (aiPlayer.direction !== "south") {
          aiPlayer.direction = "south";
          // oppositeDir = 'north';
        }
        oppositeDir = "north";
      }
      if (
        targetPlayer.currentPosition.cell.number.x ===
          aiPlayer.currentPosition.cell.number.x &&
        targetPlayer.currentPosition.cell.number.y <
          aiPlayer.currentPosition.cell.number.y
      ) {
        if (aiPlayer.direction !== "north") {
          aiPlayer.direction = "north";
          // oppositeDir = 'south';
        }
        oppositeDir = "south";
      }
      if (
        targetPlayer.currentPosition.cell.number.x <
          aiPlayer.currentPosition.cell.number.x &&
        targetPlayer.currentPosition.cell.number.y ===
          aiPlayer.currentPosition.cell.number.y
      ) {
        if (aiPlayer.direction !== "west") {
          aiPlayer.direction = "west";
          // oppositeDir = 'east';
        }
        oppositeDir = "east";
      }
      if (
        targetPlayer.currentPosition.cell.number.x >
          aiPlayer.currentPosition.cell.number.x &&
        targetPlayer.currentPosition.cell.number.y ===
          aiPlayer.currentPosition.cell.number.y
      ) {
        if (aiPlayer.direction !== "east") {
          aiPlayer.direction = "east";
          // oppositeDir = 'west';
        }
        oppositeDir = "west";
      }

      this.getTarget(aiPlayer);
      // if (aiPlayer.ai.engaging.state === true) {
      // if (aiPlayer.ai.engaging.state !== true) {

      if (
        aiPlayer.currentWeapon.type === "crossbow" &&
        aiPlayer.action === "idle" &&
        aiPlayer.success.deflected.state !== true
      ) {
        let instructions3 = [];
        // ENGAGED TARGET IS OPEN TO ATTACK!
        if (
          targetPlayer.defending.state !== true &&
          targetPlayer.attacking.state !== true &&
          targetPlayer.defending.decay.state !== true &&
          targetPlayer.dodging.state !== true
        ) {
          // console.log('ai #',aiPlayer.number,'target  ',targetPlayer.number,'is neither attacking nor defending');

          if (
            aiPlayer.currentPosition.cell.number.x ===
              targetPlayer.currentPosition.cell.number.x - 3 ||
            aiPlayer.currentPosition.cell.number.x ===
              targetPlayer.currentPosition.cell.number.x + 3 ||
            aiPlayer.currentPosition.cell.number.y ===
              targetPlayer.currentPosition.cell.number.y - 3 ||
            aiPlayer.currentPosition.cell.number.y ===
              targetPlayer.currentPosition.cell.number.y + 3 ||
            aiPlayer.currentPosition.cell.number.x ===
              targetPlayer.currentPosition.cell.number.x - 2 ||
            aiPlayer.currentPosition.cell.number.x ===
              targetPlayer.currentPosition.cell.number.x + 2 ||
            aiPlayer.currentPosition.cell.number.y ===
              targetPlayer.currentPosition.cell.number.y - 2 ||
            aiPlayer.currentPosition.cell.number.y ===
              targetPlayer.currentPosition.cell.number.y + 2 ||
            aiPlayer.currentPosition.cell.number.x ===
              targetPlayer.currentPosition.cell.number.x - 1 ||
            aiPlayer.currentPosition.cell.number.x ===
              targetPlayer.currentPosition.cell.number.x + 1 ||
            aiPlayer.currentPosition.cell.number.y ===
              targetPlayer.currentPosition.cell.number.y - 1 ||
            aiPlayer.currentPosition.cell.number.y ===
              targetPlayer.currentPosition.cell.number.y + 1
          ) {
            console.log(
              "plyr",
              aiPlayer.number,
              " engaging w/ crossbow but too close for comfort"
            );
            aiPlayer.ai.retreating.state = false;
            aiPlayer.ai.retreating.checkin = undefined;
            aiPlayer.ai.mission = "retreat";
            aiPlayer.ai.retreating.safe = false;

            if (!aiPlayer.popups.find((x) => x.msg === "missionRetreat")) {
              aiPlayer.popups.push({
                state: false,
                count: 0,
                limit: 30,
                type: "",
                position: "",
                msg: "missionRetreat",
                img: "",
              });
            }
            // aiPlayer.ai.currentInstruction = 0;
          } else if (aiPlayer.items.ammo > 0) {
            instructions3.push({
              keyword: "attack",
              count: 0,
              limit: 1,
            });
          }
          if (aiPlayer.items.ammo === 0) {
            console.log("no ammo!!!");
          }

          engageTargetAction = "open";
        }
        if (
          targetPlayer.defending.state === true ||
          targetPlayer.defending.decay.count > targetPlayer.defending.decay.limit - 10
        ) {
        }

        let deflecting = false;
        if (this.aiDeflectedCheck.includes(aiPlayer.number) === true) {
          deflecting = true;
        }
        if (deflecting === true) {
          aiPlayer.ai.instructions = [];
          aiPlayer.ai.currentInstruction = 0;
          aiPlayer.ai.engaging.targetAction = "";
        }

        if (
          aiPlayer.ai.engaging.targetAction !== engageTargetAction &&
          deflecting !== true
        ) {
          // console.log('target status has changed. switch up the approach');

          aiPlayer.ai.instructions = instructions3;
          aiPlayer.ai.currentInstruction = 0;
          aiPlayer.ai.engaging.state = true;
          aiPlayer.ai.engaging.targetAction = engageTargetAction;
        }
      }
      if (
        aiPlayer.currentWeapon.type === "spear" &&
        aiPlayer.action === "idle" &&
        aiPlayer.success.deflected.state !== true
      ) {
        let instructions2 = [];

        // ENGAGED TARGET IS OPEN TO ATTAVK!
        if (
          targetPlayer.defending.state !== true &&
          targetPlayer.attacking.state !== true &&
          targetPlayer.defending.decay.state !== true
        ) {
          // console.log('ai #',aiPlayer.number,'target  ',targetPlayer.number,'is neither attacking nor defending')
          if (aiPlayer.ai.safeRange === true) {
            if (oppositeDir) {
              if (aiPlayer.target.cell2.occupant.type === "player") {
                // console.log('target is too close! back it up');
                instructions2.push(
                  {
                    keyword: "strafe_" + oppositeDir,
                    count: 0,
                    limit: 1,
                  },
                  {
                    keyword: "strafe_" + oppositeDir,
                    count: 0,
                    limit: 1,
                  }
                );
              }
              if (
                aiPlayer.currentPosition.cell.number.x ===
                  targetPlayer.currentPosition.cell.number.x - 3 ||
                aiPlayer.currentPosition.cell.number.x ===
                  targetPlayer.currentPosition.cell.number.x + 3 ||
                aiPlayer.currentPosition.cell.number.y ===
                  targetPlayer.currentPosition.cell.number.y - 3 ||
                aiPlayer.currentPosition.cell.number.y ===
                  targetPlayer.currentPosition.cell.number.y + 3
              ) {
                instructions2.push({
                  keyword: "move_" + aiPlayer.direction,
                  count: 0,
                  limit: 1,
                });
              }
              instructions2.push(
                {
                  keyword: "attack",
                  count: 0,
                  limit: 1,
                },
                {
                  keyword: "strafe_" + oppositeDir,
                  count: 0,
                  limit: 1,
                },
                {
                  keyword: "short_wait",
                  count: 0,
                  limit: 15,
                }
              );
            }
          } else {
            instructions2.push(
              {
                keyword: "attack",
                count: 0,
                limit: 1,
              },
              {
                keyword: "short_wait",
                count: 0,
                limit: 1,
              }
            );
          }
          engageTargetAction = "open";
        }

        // ENGAGED TARGET IS DEFENDING!
        if (
          targetPlayer.defending.decay.count >
          targetPlayer.defending.decay.limit - 10
        ) {
          console.log(
            "ai #",
            aiPlayer.number,
            "target  ",
            targetPlayer.number,
            " is defending",
            targetPlayer.defending.decay.count
          );
          if (aiPlayer.ai.safeRange === true) {
            if (oppositeDir) {
              if (aiPlayer.target.cell2.occupant.type === "player") {
                // console.log('target is too close! back it up');
                instructions2.push(
                  {
                    keyword: "strafe_" + oppositeDir,
                    count: 0,
                    limit: 1,
                  },
                  {
                    keyword: "strafe_" + oppositeDir,
                    count: 0,
                    limit: 1,
                  }
                );
              }
              if (
                aiPlayer.currentPosition.cell.number.x ===
                  targetPlayer.currentPosition.cell.number.x - 3 ||
                aiPlayer.currentPosition.cell.number.x ===
                  targetPlayer.currentPosition.cell.number.x + 3 ||
                aiPlayer.currentPosition.cell.number.y ===
                  targetPlayer.currentPosition.cell.number.y - 3 ||
                aiPlayer.currentPosition.cell.number.y ===
                  targetPlayer.currentPosition.cell.number.y + 3
              ) {
                instructions2.push({
                  keyword: "move_" + aiPlayer.direction,
                  count: 0,
                  limit: 1,
                });
              }
              instructions2.push(
                {
                  keyword: "attack",
                  count: 0,
                  limit: 1,
                },
                {
                  keyword: "strafe_" + oppositeDir,
                  count: 0,
                  limit: 1,
                },
                {
                  keyword: "short_wait",
                  count: 0,
                  limit: 15,
                }
              );
            }
          } else {
            instructions2.push(
              {
                keyword: "attack",
                count: 0,
                limit: 1,
              },
              {
                keyword: "short_wait",
                count: 0,
                limit: 1,
              }
            );
          }
          engageTargetAction = "defend";
        }

        // ENGAGED TARGET IS ATTACKING!
        if (targetPlayer.attacking.count > 0) {
          // console.log('ai #',aiPlayer.number,'target  ',targetPlayer.number,' is attacking',targetPlayer.attacking.count);

          // ATTACK IS PEAKING!
          if (
            targetPlayer.attacking.count < targetPlayer.attacking.animRef.peak.spear &&
            targetPlayer.attacking.count >= targetPlayer.attacking.animRef.peak.spear - 4
          ) {
            console.log("almost peak attack");
            let whatDo3 = this.rnJesus(1, 2);

            // DEFEND!
            if (whatDo3 === 1) {
              console.log("ai defend");
              instructions2.push({
                keyword: "long_defend",
                count: 0,
                limit: 1,
              });
            }

            // DODGE!
            else {
              console.log("ai dodge");
              instructions2.push({
                keyword: "dodge",
                count: 0,
                limit: 1,
              });
            }
          }

          // ATTACK IS EARLY!
          if (targetPlayer.attacking.count <= 8) {
            console.log("early attack");
            let whatDo4 = this.rnJesus(1, 4);
            // whatDo2 = 4

            // DEFEND!
            if (whatDo4 === 1) {
              console.log(" ai defend");
              instructions2.push({
                keyword: "long_defend",
                count: 0,
                limit: 1,
              });
            }

            // FLANK!
            if (whatDo4 === 2) {
              let flankDir3;
              let aiPosCell3 = this.gridInfo.find(
                (elem) =>
                  elem.number.x === aiPlayer.currentPosition.cell.number.x &&
                  elem.number.y === aiPlayer.currentPosition.cell.number.y
              );

              switch (aiPlayer.direction) {
                case "north":
                  if (aiPosCell3.edge.state === true && aiPosCell3.edge.side === "east") {
                    flankDir3 = "west";
                  }
                  if (aiPosCell3.edge.state === true && aiPosCell3.edge.side === "west") {
                    flankDir3 = "east";
                  } else {
                    flankDir3 = "west";
                  }
                  break;
                case "south":
                  if (aiPosCell3.edge.state === true && aiPosCell3.edge.side === "east") {
                    flankDir3 = "west";
                  }
                  if (aiPosCell3.edge.state === true && aiPosCell3.edge.side === "west") {
                    flankDir3 = "east";
                  } else {
                    flankDir3 = "west";
                  }
                  break;
                case "east":
                  if (
                    aiPosCell3.edge.state === true &&
                    aiPosCell3.edge.side === "north"
                  ) {
                    flankDir3 = "south";
                  }
                  if (
                    aiPosCell3.edge.state === true &&
                    aiPosCell3.edge.side === "south"
                  ) {
                    flankDir3 = "north";
                  } else {
                    flankDir3 = "south";
                  }
                  break;
                case "west":
                  if (
                    aiPosCell3.edge.state === true &&
                    aiPosCell3.edge.side === "north"
                  ) {
                    flankDir3 = "south";
                  }
                  if (
                    aiPosCell3.edge.state === true &&
                    aiPosCell3.edge.side === "south"
                  ) {
                    flankDir3 = "north";
                  } else {
                    flankDir3 = "south";
                  }
                  break;
              }
              console.log("ai flank", flankDir3);

              instructions2.push({
                keyword: "flank_" + flankDir3,
                count: 0,
                limit: 5,
              });
            }

            // DODGE!
            if (whatDo4 === 3) {
              console.log("ai dodge");
              instructions2.push({
                keyword: "dodge",
                count: 0,
                limit: 1,
              });
            }

            // STRAFE EVADE!
            if (whatDo4 === 4) {
              console.log("ai strafe evade");
              let evadeDirection2;
              let cellsToConsider2 = [
                {
                  x: aiPlayer.currentPosition.cell.number.x + 1,
                  y: aiPlayer.currentPosition.cell.number.y,
                },
                {
                  x: aiPlayer.currentPosition.cell.number.x - 1,
                  y: aiPlayer.currentPosition.cell.number.y,
                },
                {
                  x: aiPlayer.currentPosition.cell.number.x,
                  y: aiPlayer.currentPosition.cell.number.y + 1,
                },
                {
                  x: aiPlayer.currentPosition.cell.number.x,
                  y: aiPlayer.currentPosition.cell.number.y - 1,
                },
              ];
              for (const cell2 of cellsToConsider2) {
                let freeCell2 = true;
                let cellRef2 = this.gridInfo.find(
                  (elem) => elem.number.x === cell2.x && elem.number.y === cell2.y
                );
                if (cellRef2) {
                  let terrainInfo4 = cellRef2.levelData.length - 1;
                  if (
                    cellRef2.levelData.charAt(terrainInfo4) === "j" ||
                    cellRef2.levelData.charAt(terrainInfo4) === "h" ||
                    cellRef2.levelData.charAt(terrainInfo4) === "i" ||
                    cellRef2.levelData.charAt(0) !== "x" ||
                    cellRef2.void.state === true
                  ) {
                    freeCell2 = false;
                  }
                  for (const plyr6 of this.players) {
                    if (
                      plyr6.currentPosition.cell.number.x === cellRef2.number.x &&
                      plyr6.currentPosition.cell.number.y === cellRef2.number.y
                    ) {
                      freeCell2 = false;
                    }
                  }
                } else {
                  freeCell2 = false;
                }
                if (freeCell2 === true) {
                  if (
                    cell2.x === aiPlayer.currentPosition.cell.number.x + 1 &&
                    cell2.y === aiPlayer.currentPosition.cell.number.y
                  ) {
                    evadeDirection2 = "east";
                  }
                  if (
                    cell2.x === aiPlayer.currentPosition.cell.number.x - 1 &&
                    cell2.y === aiPlayer.currentPosition.cell.number.y
                  ) {
                    evadeDirection2 = "west";
                  }
                  if (
                    cell2.x === aiPlayer.currentPosition.cell.number.x &&
                    cell2.y === aiPlayer.currentPosition.cell.number.y + 1
                  ) {
                    evadeDirection2 = "south";
                  }
                  if (
                    cell2.x === aiPlayer.currentPosition.cell.number.x &&
                    cell2.y === aiPlayer.currentPosition.cell.number.y - 1
                  ) {
                    evadeDirection2 = "north";
                  }
                }
              }

              instructions2.push({
                keyword: "strafe_" + evadeDirection2,
                count: 0,
                limit: 1,
              });
              aiPlayer.ai.targetAcquired = false;
            }
          }

          engageTargetAction = "attack";
        }

        for (const inst of aiPlayer.ai.instructions) {
          if (inst.keyword === "attack") {
            // console.log('ai '+aiPlayer.number+' decides to attack w/ spear');
          }
        }

        let deflecting = false;
        if (this.aiDeflectedCheck.includes(aiPlayer.number) === true) {
          deflecting = true;
        }
        if (deflecting === true) {
          aiPlayer.ai.instructions = [];
          aiPlayer.ai.currentInstruction = 0;
          aiPlayer.ai.engaging.targetAction = "";
        }

        if (
          aiPlayer.ai.engaging.targetAction !== engageTargetAction &&
          deflecting !== true
        ) {
          // console.log('target status has changed. switch up the approach');

          aiPlayer.ai.instructions = instructions2;
          aiPlayer.ai.currentInstruction = 0;
          aiPlayer.ai.engaging.state = true;
          aiPlayer.ai.engaging.targetAction = engageTargetAction;
        }

        // console.log('aiPlayer.instructions',aiPlayer.ai.instructions);
      }
      if (
        aiPlayer.currentWeapon.type === "sword" &&
        aiPlayer.action === "idle" &&
        aiPlayer.success.deflected.state !== true
      ) {
        // console.log('ai decide sword engagement');

        let instructions1 = [];

        // ENGAGED TARGET IS OPEN TO ATTACK!
        if (
          targetPlayer.defending.state !== true &&
          targetPlayer.attacking.state !== true &&
          targetPlayer.defending.decay.state !== true &&
          targetPlayer.dodging.state !== true
        ) {
          // console.log('ai #',aiPlayer.number,'target  ',targetPlayer.number,'is neither attacking nor defending');
          if (aiPlayer.ai.safeRange === true) {
            if (oppositeDir) {
              // console.log('safe sword range attack flow');

              if (aiPlayer.target.cell1.occupant.type === "player") {
                // console.log('target is too close! back it up');
                instructions1.push({
                  keyword: "strafe_" + oppositeDir,
                  count: 0,
                  limit: 1,
                });
              }
              instructions1.push(
                {
                  keyword: "move_" + aiPlayer.direction,
                  count: 0,
                  limit: 1,
                },
                {
                  keyword: "attack",
                  count: 0,
                  limit: 1,
                },
                {
                  keyword: "strafe_" + oppositeDir,
                  count: 0,
                  limit: 1,
                },
                {
                  keyword: "short_wait",
                  count: 0,
                  limit: 15,
                }
              );
            }
          } else {
            instructions1.push(
              {
                keyword: "attack",
                count: 0,
                limit: 1,
              },
              {
                keyword: "short_wait",
                count: 0,
                limit: 1,
              }
            );
          }
          engageTargetAction = "open";
        }

        // ENGAGED TARGET DEFENDING!
        if (
          targetPlayer.defending.state === true ||
          targetPlayer.defending.decay.count > targetPlayer.defending.decay.limit - 10
        ) {
          // console.log('ai #',aiPlayer.number,'target  ',targetPlayer.number,' is defending',targetPlayer.defending.decay.count);

          if (aiPlayer.ai.safeRange === true) {
            if (oppositeDir) {
              // console.log('safe range attack flow');

              if (aiPlayer.target.cell1.occupant.type === "player") {
                // console.log('target is too close! back it up');
                instructions1.push({
                  keyword: "strafe_" + oppositeDir,
                  count: 0,
                  limit: 1,
                });
              }
              instructions1.push(
                {
                  keyword: "move_" + aiPlayer.direction,
                  count: 0,
                  limit: 1,
                },
                {
                  keyword: "attack",
                  count: 0,
                  limit: 1,
                },
                {
                  keyword: "strafe_" + oppositeDir,
                  count: 0,
                  limit: 1,
                },
                {
                  keyword: "short_wait",
                  count: 0,
                  limit: 15,
                }
              );
            }
          } else {
            instructions1.push(
              {
                keyword: "attack",
                count: 0,
                limit: 1,
              },
              {
                keyword: "short_wait",
                count: 0,
                limit: 1,
              }
            );
          }
          engageTargetAction = "defend";
        }

        // ENGAGED TARGET ATTACKING!
        if (targetPlayer.attacking.count > 0) {
          // console.log('ai #',aiPlayer.number,'target  ',targetPlayer.number,' is attacking',targetPlayer.attacking.count);

          // ATTACK IS PEAKING!
          if (
            targetPlayer.attacking.count < targetPlayer.attacking.animRef.peak.sword &&
            targetPlayer.attacking.count >= targetPlayer.attacking.animRef.peak.sword - 4
          ) {
            console.log("almost peak attack");
            let whatDo = this.rnJesus(1, 2);
            whatDo = 1;

            // DEFEND!
            if (whatDo === 1) {
              console.log("ai defend");
              instructions1.push({
                keyword: "long_defend",
                count: 0,
                limit: 1,
              });
            }

            // DODGE!
            else {
              console.log("ai dodge");
              instructions1.push({
                keyword: "dodge",
                count: 0,
                limit: 1,
              });
            }
          }

          // ATTACK IS EARLY!
          if (targetPlayer.attacking.count <= 6) {
            console.log("early attack");
            let whatDo2 = this.rnJesus(1, 4);
            whatDo2 = 1;

            // DEFEND!
            if (whatDo2 === 1) {
              console.log(" ai defend");
              instructions1.push({
                keyword: "long_defend",
                count: 0,
                limit: 1,
              });
            }

            // FLANK!
            if (whatDo2 === 2) {
              let flankDir2;
              let aiPosCell2 = this.gridInfo.find(
                (elem) =>
                  elem.number.x === aiPlayer.currentPosition.cell.number.x &&
                  elem.number.y === aiPlayer.currentPosition.cell.number.y
              );

              switch (aiPlayer.direction) {
                case "north":
                  if (aiPosCell2.edge.state === true && aiPosCell2.edge.side === "east") {
                    flankDir2 = "west";
                  }
                  if (aiPosCell2.edge.state === true && aiPosCell2.edge.side === "west") {
                    flankDir2 = "east";
                  } else {
                    flankDir2 = "west";
                  }
                  break;
                case "south":
                  if (aiPosCell2.edge.state === true && aiPosCell2.edge.side === "east") {
                    flankDir2 = "west";
                  }
                  if (aiPosCell2.edge.state === true && aiPosCell2.edge.side === "west") {
                    flankDir2 = "east";
                  } else {
                    flankDir2 = "west";
                  }
                  break;
                case "east":
                  if (
                    aiPosCell2.edge.state === true &&
                    aiPosCell2.edge.side === "north"
                  ) {
                    flankDir2 = "south";
                  }
                  if (
                    aiPosCell2.edge.state === true &&
                    aiPosCell2.edge.side === "south"
                  ) {
                    flankDir2 = "north";
                  } else {
                    flankDir2 = "south";
                  }
                  break;
                case "west":
                  if (
                    aiPosCell2.edge.state === true &&
                    aiPosCell2.edge.side === "north"
                  ) {
                    flankDir2 = "south";
                  }
                  if (
                    aiPosCell2.edge.state === true &&
                    aiPosCell2.edge.side === "south"
                  ) {
                    flankDir2 = "north";
                  } else {
                    flankDir2 = "south";
                  }
                  break;
              }
              console.log("ai flank", flankDir2);

              instructions1.push({
                keyword: "flank_" + flankDir2,
                count: 0,
                limit: 5,
              });
            }

            // DODGE!
            if (whatDo2 === 3) {
              console.log("ai dodge");
              instructions1.push({
                keyword: "dodge",
                count: 0,
                limit: 1,
              });
            }

            // STRAFE EVADE!
            if (whatDo2 === 4) {
              console.log("ai strafe evade");
              let evadeDirection;
              let cellsToConsider = [
                {
                  x: aiPlayer.currentPosition.cell.number.x + 1,
                  y: aiPlayer.currentPosition.cell.number.y,
                },
                {
                  x: aiPlayer.currentPosition.cell.number.x - 1,
                  y: aiPlayer.currentPosition.cell.number.y,
                },
                {
                  x: aiPlayer.currentPosition.cell.number.x,
                  y: aiPlayer.currentPosition.cell.number.y + 1,
                },
                {
                  x: aiPlayer.currentPosition.cell.number.x,
                  y: aiPlayer.currentPosition.cell.number.y - 1,
                },
              ];
              for (const cell of cellsToConsider) {
                let freeCell = true;
                let cellRef = this.gridInfo.find(
                  (elem) => elem.number.x === cell.x && elem.number.y === cell.y
                );
                if (cellRef) {
                  let terrainInfo3 = cellRef.levelData.length - 1;
                  if (
                    cellRef.levelData.charAt(terrainInfo3) === "j" ||
                    cellRef.levelData.charAt(terrainInfo3) === "h" ||
                    cellRef.levelData.charAt(terrainInfo3) === "i" ||
                    cellRef.levelData.charAt(0) !== "x" ||
                    cellRef.void.state === true
                  ) {
                    freeCell = false;
                  }
                  for (const plyr5 of this.players) {
                    if (
                      plyr5.currentPosition.cell.number.x === cellRef.number.x &&
                      plyr5.currentPosition.cell.number.y === cellRef.number.y
                    ) {
                      freeCell = false;
                    }
                  }
                } else {
                  freeCell = false;
                }
                if (freeCell === true) {
                  if (
                    cell.x === aiPlayer.currentPosition.cell.number.x + 1 &&
                    cell.y === aiPlayer.currentPosition.cell.number.y
                  ) {
                    evadeDirection = "east";
                  }
                  if (
                    cell.x === aiPlayer.currentPosition.cell.number.x - 1 &&
                    cell.y === aiPlayer.currentPosition.cell.number.y
                  ) {
                    evadeDirection = "west";
                  }
                  if (
                    cell.x === aiPlayer.currentPosition.cell.number.x &&
                    cell.y === aiPlayer.currentPosition.cell.number.y + 1
                  ) {
                    evadeDirection = "south";
                  }
                  if (
                    cell.x === aiPlayer.currentPosition.cell.number.x &&
                    cell.y === aiPlayer.currentPosition.cell.number.y - 1
                  ) {
                    evadeDirection = "north";
                  }
                }
              }

              instructions1.push({
                keyword: "strafe_" + evadeDirection,
                count: 0,
                limit: 1,
              });
              aiPlayer.ai.targetAcquired = false;
            }
          }

          engageTargetAction = "attack";
        }

        let deflecting = false;
        if (this.aiDeflectedCheck.includes(aiPlayer.number) === true) {
          deflecting = true;
        }
        if (deflecting === true) {
          aiPlayer.ai.instructions = [];
          aiPlayer.ai.currentInstruction = 0;
          aiPlayer.ai.engaging.targetAction = "";
        }

        // target status has changed. switch up the approach
        if (
          aiPlayer.ai.engaging.targetAction !== engageTargetAction &&
          deflecting !== true
        ) {
          // if (aiPlayer.ai.engaging.targetAction !== engageTargetAction ) {

          // console.log('target status has changed. switch up the approach');

          aiPlayer.ai.instructions = instructions1;
          aiPlayer.ai.currentInstruction = 0;
          aiPlayer.ai.engaging.state = true;
          aiPlayer.ai.engaging.targetAction = engageTargetAction;
        }

        // console.log('aiPlayer.instructions',aiPlayer.ai.instructions);
      }
      if (
        aiPlayer.currentWeapon.type === "" &&
        aiPlayer.action === "idle" &&
        aiPlayer.success.deflected.state !== true &&
        aiPlayer.ai.organizing.dropped.state !== true
      ) {
        // console.log('unarmed engagement');

        let instructions4 = [];

        // ENGAGED TARGET IS OPEN TO ATTACK!
        if (
          targetPlayer.defending.state !== true &&
          targetPlayer.attacking.state !== true &&
          targetPlayer.defending.decay.state !== true &&
          targetPlayer.dodging.state !== true
        ) {
          // console.log('ai #',aiPlayer.number,'target  ',targetPlayer.number,'is neither attacking nor defending');
          if (aiPlayer.ai.safeRange === true) {
            if (oppositeDir) {
              // console.log('safe sword range attack flow');

              if (aiPlayer.target.cell1.occupant.type === "player") {
                // console.log('target is too close! back it up');
                instructions4.push({
                  keyword: "strafe_" + oppositeDir,
                  count: 0,
                  limit: 1,
                });
              }
              instructions4.push(
                {
                  keyword: "move_" + aiPlayer.direction,
                  count: 0,
                  limit: 1,
                },
                {
                  keyword: "attack",
                  count: 0,
                  limit: 1,
                },
                {
                  keyword: "strafe_" + oppositeDir,
                  count: 0,
                  limit: 1,
                },
                {
                  keyword: "short_wait",
                  count: 0,
                  limit: 15,
                }
              );
            }
          } else {
            instructions4.push(
              {
                keyword: "attack",
                count: 0,
                limit: 1,
              },
              {
                keyword: "short_wait",
                count: 0,
                limit: 1,
              }
            );
          }

          engageTargetAction = "open";
        }

        // ENGAGED TARGET DEFENDING!
        if (
          targetPlayer.defending.state === true ||
          targetPlayer.defending.decay.count > targetPlayer.defending.decay.limit - 10
        ) {
          console.log(
            "ai #",
            aiPlayer.number,
            "target  ",
            targetPlayer.number,
            " is defending",
            targetPlayer.defending.decay.count
          );

          if (aiPlayer.ai.safeRange === true) {
            if (oppositeDir) {
              // console.log('safe range attack flow');

              if (aiPlayer.target.cell1.occupant.type === "player") {
                // console.log('target is too close! back it up');
                instructions4.push({
                  keyword: "strafe_" + oppositeDir,
                  count: 0,
                  limit: 1,
                });
              }
              instructions4.push(
                {
                  keyword: "move_" + aiPlayer.direction,
                  count: 0,
                  limit: 1,
                },
                {
                  keyword: "attack",
                  count: 0,
                  limit: 1,
                },
                {
                  keyword: "strafe_" + oppositeDir,
                  count: 0,
                  limit: 1,
                },
                {
                  keyword: "short_wait",
                  count: 0,
                  limit: 15,
                }
              );
            }
          } else {
            instructions4.push(
              {
                keyword: "attack",
                count: 0,
                limit: 1,
              },
              {
                keyword: "short_wait",
                count: 0,
                limit: 1,
              }
            );
          }

          engageTargetAction = "defend";
        }

        // ENGAGED TARGET ATTACKING!
        if (targetPlayer.attacking.count > 0) {
          // console.log('ai #',aiPlayer.number,'target  ',targetPlayer.number,' is attacking',targetPlayer.attacking.count);

          // ATTACK IS PEAKING!
          if (
            targetPlayer.attacking.count < targetPlayer.attacking.animRef.peak.sword &&
            targetPlayer.attacking.count >= targetPlayer.attacking.animRef.peak.sword - 4
          ) {
            console.log("almost peak attack");
            let whatDo5 = this.rnJesus(1, 2);

            // DEFEND!
            if (whatDo5 === 1) {
              console.log("ai defend");
              instructions4.push({
                keyword: "long_defend",
                count: 0,
                limit: 1,
              });
            }

            // DODGE!
            else {
              console.log("ai dodge");
              instructions4.push({
                keyword: "dodge",
                count: 0,
                limit: 1,
              });
            }
          }

          // ATTACK IS EARLY!
          if (targetPlayer.attacking.count <= 6) {
            console.log("early attack");
            let whatDo6 = this.rnJesus(1, 4);
            // whatDo2 = 4

            // DEFEND!
            if (whatDo6 === 1) {
              console.log(" ai defend");
              instructions4.push({
                keyword: "long_defend",
                count: 0,
                limit: 1,
              });
            }

            // FLANK!
            if (whatDo6 === 2) {
              let flankDir3;
              let aiPosCell3 = this.gridInfo.find(
                (elem) =>
                  elem.number.x === aiPlayer.currentPosition.cell.number.x &&
                  elem.number.y === aiPlayer.currentPosition.cell.number.y
              );

              switch (aiPlayer.direction) {
                case "north":
                  if (aiPosCell3.edge.state === true && aiPosCell3.edge.side === "east") {
                    flankDir3 = "west";
                  }
                  if (aiPosCell3.edge.state === true && aiPosCell3.edge.side === "west") {
                    flankDir3 = "east";
                  } else {
                    flankDir3 = "west";
                  }
                  break;
                case "south":
                  if (aiPosCell3.edge.state === true && aiPosCell3.edge.side === "east") {
                    flankDir3 = "west";
                  }
                  if (aiPosCell3.edge.state === true && aiPosCell3.edge.side === "west") {
                    flankDir3 = "east";
                  } else {
                    flankDir3 = "west";
                  }
                  break;
                case "east":
                  if (
                    aiPosCell3.edge.state === true &&
                    aiPosCell3.edge.side === "north"
                  ) {
                    flankDir3 = "south";
                  }
                  if (
                    aiPosCell3.edge.state === true &&
                    aiPosCell3.edge.side === "south"
                  ) {
                    flankDir3 = "north";
                  } else {
                    flankDir3 = "south";
                  }
                  break;
                case "west":
                  if (
                    aiPosCell3.edge.state === true &&
                    aiPosCell3.edge.side === "north"
                  ) {
                    flankDir3 = "south";
                  }
                  if (
                    aiPosCell3.edge.state === true &&
                    aiPosCell3.edge.side === "south"
                  ) {
                    flankDir3 = "north";
                  } else {
                    flankDir3 = "south";
                  }
                  break;
              }
              console.log("ai flank", flankDir3);

              instructions4.push({
                keyword: "flank_" + flankDir3,
                count: 0,
                limit: 5,
              });
            }

            // DODGE!
            if (whatDo6 === 3) {
              console.log("ai dodge");
              instructions4.push({
                keyword: "dodge",
                count: 0,
                limit: 1,
              });
            }

            // STRAFE EVADE!
            if (whatDo6 === 4) {
              console.log("ai strafe evade");
              let evadeDirection3;
              let cellsToConsider3 = [
                {
                  x: aiPlayer.currentPosition.cell.number.x + 1,
                  y: aiPlayer.currentPosition.cell.number.y,
                },
                {
                  x: aiPlayer.currentPosition.cell.number.x - 1,
                  y: aiPlayer.currentPosition.cell.number.y,
                },
                {
                  x: aiPlayer.currentPosition.cell.number.x,
                  y: aiPlayer.currentPosition.cell.number.y + 1,
                },
                {
                  x: aiPlayer.currentPosition.cell.number.x,
                  y: aiPlayer.currentPosition.cell.number.y - 1,
                },
              ];
              for (const cell3 of cellsToConsider3) {
                let freeCell3 = true;
                let cellRef3 = this.gridInfo.find(
                  (elem) => elem.number.x === cell3.x && elem.number.y === cell3.y
                );
                if (cellRef3) {
                  let terrainInfo5 = cellRef3.levelData.length - 1;
                  if (
                    cellRef3.levelData.charAt(terrainInfo5) === "j" ||
                    cellRef3.levelData.charAt(terrainInfo5) === "h" ||
                    cellRef3.levelData.charAt(terrainInfo5) === "i" ||
                    cellRef3.levelData.charAt(0) !== "x" ||
                    cellRef3.void.state === true
                  ) {
                    freeCell3 = false;
                  }
                  for (const plyr7 of this.players) {
                    if (
                      plyr7.currentPosition.cell.number.x === cellRef3.number.x &&
                      plyr7.currentPosition.cell.number.y === cellRef3.number.y
                    ) {
                      freeCell3 = false;
                    }
                  }
                } else {
                  freeCell3 = false;
                }
                if (freeCell3 === true) {
                  if (
                    cell3.x === aiPlayer.currentPosition.cell.number.x + 1 &&
                    cell3.y === aiPlayer.currentPosition.cell.number.y
                  ) {
                    evadeDirection3 = "east";
                  }
                  if (
                    cell3.x === aiPlayer.currentPosition.cell.number.x - 1 &&
                    cell3.y === aiPlayer.currentPosition.cell.number.y
                  ) {
                    evadeDirection3 = "west";
                  }
                  if (
                    cell3.x === aiPlayer.currentPosition.cell.number.x &&
                    cell3.y === aiPlayer.currentPosition.cell.number.y + 1
                  ) {
                    evadeDirection3 = "south";
                  }
                  if (
                    cell3.x === aiPlayer.currentPosition.cell.number.x &&
                    cell3.y === aiPlayer.currentPosition.cell.number.y - 1
                  ) {
                    evadeDirection3 = "north";
                  }
                }
              }

              instructions4.push({
                keyword: "strafe_" + evadeDirection3,
                count: 0,
                limit: 1,
              });
              aiPlayer.ai.targetAcquired = false;
            }
          }

          engageTargetAction = "attack";
        }

        let deflecting = false;
        if (this.aiDeflectedCheck.includes(aiPlayer.number) === true) {
          deflecting = true;
        }
        if (deflecting === true) {
          aiPlayer.ai.instructions = [];
          aiPlayer.ai.currentInstruction = 0;
          aiPlayer.ai.engaging.targetAction = "";
        }

        if (
          aiPlayer.ai.engaging.targetAction !== engageTargetAction &&
          deflecting !== true
        ) {
          // console.log('target status has changed. switch up the approach');

          aiPlayer.ai.instructions = instructions4;
          aiPlayer.ai.currentInstruction = 0;
          aiPlayer.ai.engaging.state = true;
          aiPlayer.ai.engaging.targetAction = engageTargetAction;
        }

        // console.log('aiPlayer.instructions',aiPlayer.ai.instructions);
      }

      // }
    }

    let defendDest;
    if (aiPlayer.ai.mission === "defend") {
      // console.log('defending',aiPlayer.ai.defending);
      // console.log('aiDecide mission: defend - prevTargetPos',prevTargetPos,'currentTargetPos',currentTargetPos);

      // TARGET LOCATION CHANGED!!
      if (prevTargetPos.x && currentTargetPos.x) {
        if (
          prevTargetPos.x !== currentTargetPos.x ||
          (prevTargetPos.y !== currentTargetPos.y &&
            targetPlayer.dead.state !== true &&
            targetPlayer.falling.state !== true)
        ) {
          // console.log('defending but target location changed! Dont update path. Just track target',aiPlayer.number);

          aiPlayer.ai.targetPlayer.currentPosition = {
            x: targetPlayer.currentPosition.cell.number.x,
            y: targetPlayer.currentPosition.cell.number.y,
          };
        }
      }

      // SET OUT TO DEFEND POINT
      if (!aiPlayer.ai.defending.checkin) {
        console.log("start out to defend location", aiPlayer.ai.defending.area[0]);
        aiPlayer.ai.defending.checkin = "enroute";

        if (!aiPlayer.popups.find((x) => x.msg === "missionEnroute")) {
          aiPlayer.popups.push({
            state: false,
            count: 0,
            limit: 30,
            type: "",
            position: "",
            msg: "missionEnroute",
            img: "",
          });
        }

        let cellsToConsider2 = [
          {
            x: aiPlayer.ai.defending.area[0].x + 1,
            y: aiPlayer.ai.defending.area[0].y,
          },
          {
            x: aiPlayer.ai.defending.area[0].x - 1,
            y: aiPlayer.ai.defending.area[0].y,
          },
          {
            x: aiPlayer.ai.defending.area[0].x,
            y: aiPlayer.ai.defending.area[0].y + 1,
          },
          {
            x: aiPlayer.ai.defending.area[0].x,
            y: aiPlayer.ai.defending.area[0].y - 1,
          },
        ];
        let freeCell2 = true;
        let freeCellNo;
        let freeCells = [];
        for (const cell2 of cellsToConsider2) {
          // console.log('cell2a',cell2);
          freeCell2 = true;
          let cellRef2 = this.gridInfo.find(
            (elem) => elem.number.x === cell2.x && elem.number.y === cell2.y
          );
          if (cellRef2) {
            if (
              cellRef2.levelData.split("_")[1] !== "*" ||
              cellRef2.terrain.type === "deep" ||
              cellRef2.terrain.type === "hazard" ||
              // cellRef2.barrier.state === true ||
              cellRef2.void.state === true
            ) {
              freeCell2 = false;
            }
            for (const plyr6 of this.players) {
              if (
                plyr6.currentPosition.cell.number.x === cellRef2.number.x &&
                plyr6.currentPosition.cell.number.y === cellRef2.number.y
              ) {
                freeCell2 = false;
              }
            }
          } else {
            freeCell2 = false;
          }
          if (freeCell2 === true) {
            freeCells.push(cell2);
            // console.log('freeCellNo',cell2);
          }
        }
        let whatCell = this.rnJesus(1, freeCells.length);

        defendDest = freeCells[whatCell - 1];
        console.log("defendDest", defendDest);
        if (aiPlayer.ai.defending.area.length > 1) {
          aiPlayer.ai.defending.area[1] = defendDest;
        }
        if (aiPlayer.ai.defending.area.length === 1) {
          aiPlayer.ai.defending.area.push(defendDest);
        }

        getPath = true;
      }

      // EN ROUTE TO DEFEND POINT
      if (aiPlayer.ai.defending.checkin === "enroute") {
        // console.log('en route to defend point');

        if (aiPlayer.attacking.state === true) {
          aiPlayer.attacking.state = false;
        }

        if (
          aiPlayer.ai.defending.area[1].x === aiPlayer.currentPosition.cell.number.x &&
          aiPlayer.ai.defending.area[1].y === aiPlayer.currentPosition.cell.number.y
        ) {
          aiPlayer.ai.defending.checkin = "checkedIn";
          aiPlayer.ai.instructions = [];
          aiPlayer.ai.currentInstruction = 0;
          // console.log('arrived @ defend point',aiPlayer.ai.instructions);
        } else {
          // console.log('en route to defend post. do nothing',aiPlayer.ai.defending.area[0]);
        }
      }

      // ARRIVED AT DEFEND POINT
      if (
        aiPlayer.ai.defending.checkin === "checkedIn" &&
        aiPlayer.ai.instructions.length === 0
      ) {
        // console.log('defend post checkedIn');
        let instructions = [];
        switch (aiPlayer.direction) {
          case "north":
            instructions = [
              { keyword: "long_wait", count: 0, limit: 25 },
              { keyword: "move_east", count: 0, limit: 1 },
              { keyword: "long_wait", count: 0, limit: 25 },
              { keyword: "long_wait", count: 0, limit: 25 },
              { keyword: "move_south", count: 0, limit: 1 },
              { keyword: "long_wait", count: 0, limit: 25 },
              { keyword: "long_wait", count: 0, limit: 25 },
              { keyword: "move_west", count: 0, limit: 1 },
              { keyword: "long_wait", count: 0, limit: 25 },
              { keyword: "long_wait", count: 0, limit: 25 },
              { keyword: "move_north", count: 0, limit: 1 },
              { keyword: "long_wait", count: 0, limit: 25 },
            ];
            break;
          case "east":
            instructions = [
              { keyword: "long_wait", count: 0, limit: 25 },
              { keyword: "move_south", count: 0, limit: 1 },
              { keyword: "long_wait", count: 0, limit: 25 },
              { keyword: "long_wait", count: 0, limit: 25 },
              { keyword: "move_west", count: 0, limit: 1 },
              { keyword: "long_wait", count: 0, limit: 25 },
              { keyword: "long_wait", count: 0, limit: 25 },
              { keyword: "move_north", count: 0, limit: 1 },
              { keyword: "long_wait", count: 0, limit: 25 },
              { keyword: "long_wait", count: 0, limit: 25 },
              { keyword: "move_east", count: 0, limit: 1 },
              { keyword: "long_wait", count: 0, limit: 25 },
            ];
            break;
          case "south":
            instructions = [
              { keyword: "long_wait", count: 0, limit: 25 },
              { keyword: "move_west", count: 0, limit: 1 },
              { keyword: "long_wait", count: 0, limit: 25 },
              { keyword: "long_wait", count: 0, limit: 25 },
              { keyword: "move_north", count: 0, limit: 1 },
              { keyword: "long_wait", count: 0, limit: 25 },
              { keyword: "long_wait", count: 0, limit: 25 },
              { keyword: "move_east", count: 0, limit: 1 },
              { keyword: "long_wait", count: 0, limit: 25 },
              { keyword: "long_wait", count: 0, limit: 25 },
              { keyword: "move_south", count: 0, limit: 1 },
              { keyword: "long_wait", count: 0, limit: 25 },
            ];
            break;
          case "west":
            instructions = [
              { keyword: "long_wait", count: 0, limit: 25 },
              { keyword: "move_north", count: 0, limit: 1 },
              { keyword: "long_wait", count: 0, limit: 25 },
              { keyword: "long_wait", count: 0, limit: 25 },
              { keyword: "move_east", count: 0, limit: 1 },
              { keyword: "long_wait", count: 0, limit: 25 },
              { keyword: "long_wait", count: 0, limit: 25 },
              { keyword: "move_south", count: 0, limit: 1 },
              { keyword: "long_wait", count: 0, limit: 25 },
              { keyword: "long_wait", count: 0, limit: 25 },
              { keyword: "move_west", count: 0, limit: 1 },
              { keyword: "long_wait", count: 0, limit: 25 },
            ];
            break;
        }
        aiPlayer.ai.instructions = instructions;
        aiPlayer.ai.currentInstruction = 0;
        // console.log('aiPlayer.ai.instructions',aiPlayer.ai.instructions);
      }
    }

    if (aiPlayer.ai.mission === "retrieve") {
      // SET OUT
      if (aiPlayer.ai.retrieving.state !== true && aiPlayer.ai.retrieving.safe === true) {
        // console.log('retrive mission start: target item ',aiPlayer.ai.retrieving.targetItem.name,targetPlayer,aiPlayer.ai.retrieving);
        aiPlayer.ai.retrieving.state = true;
        aiPlayer.ai.retrieving.checkin = "enroute";
        getPath = true;

        if (!aiPlayer.popups.find((x) => x.msg === "missionEnroute")) {
          aiPlayer.popups.push({
            state: false,
            count: 0,
            limit: 30,
            type: "",
            position: "",
            msg: "missionEnroute",
            img: "",
          });
        }
      }

      // EN ROUTE
      if (aiPlayer.ai.retrieving.state === true) {
        if (aiPlayer.ai.retrieving.checkin === "enroute") {
          // console.log('en route to retrieve point',aiPlayer.ai.retrieving.point);

          let targetCell = this.gridInfo.find(
            (elem) =>
              elem.number.x === aiPlayer.ai.retrieving.point.x &&
              elem.number.y === aiPlayer.ai.retrieving.point.y
          );
          if (
            targetCell.item.name === "" ||
            aiPlayer.ai.retrieving.targetItem.name !== targetCell.item.name
          ) {
            console.log("item to retrieve is no longer there. abort");
            aiPlayer.ai.retrieving.checkin = "abort";
          }

          if (
            aiPlayer.currentPosition.cell.number.x === aiPlayer.ai.retrieving.point.x &&
            aiPlayer.currentPosition.cell.number.y === aiPlayer.ai.retrieving.point.y
          ) {
            console.log("arrived at retrieval location");
            aiPlayer.ai.retrieving.checkin = "complete";
            aiPlayer.ai.retrieving.state = false;
          }
        }
      }
    }

    if (aiPlayer.ai.mission === "retreat") {
      // SET OUT
      if (aiPlayer.ai.retreating.state !== true && aiPlayer.ai.retreating.safe === true) {
        // console.log('start retreating to',aiPlayer.ai.retreating.point);
        aiPlayer.ai.retreating.state = true;
        aiPlayer.ai.retreating.checkin = "enroute";
        getPath = true;

        if (!aiPlayer.popups.find((x) => x.msg === "missionEnroute")) {
          aiPlayer.popups.push({
            state: false,
            count: 0,
            limit: 30,
            type: "",
            position: "",
            msg: "missionEnroute",
            img: "",
          });
        }
      }

      // EN ROUTE
      if (aiPlayer.ai.retreating.state === true) {
        if (aiPlayer.ai.retreating.checkin === "enroute") {
          // console.log('enroute to retreat point @',aiPlayer.ai.retreating.point,'instructions',aiPlayer.ai.instructions,aiPlayer.ai.currentInstruction);
          if (
            aiPlayer.currentPosition.cell.number.x === aiPlayer.ai.retreating.point.x &&
            aiPlayer.currentPosition.cell.number.y === aiPlayer.ai.retreating.point.y
          ) {
            // console.log('arrived at retreat location');
            aiPlayer.ai.instructions.push({
              keyword: "long_wait",
              count: 0,
              limit: 25,
            });
            aiPlayer.ai.retreating.checkin = "resting";
          }
        }

        if (aiPlayer.ai.retreating.checkin === "resting") {
          if (aiPlayer.stamina.current >= aiPlayer.stamina.max) {
            console.log("plyr is well rested. retreat complete");
            aiPlayer.ai.retreating.checkin = "complete";
            aiPlayer.ai.retreating.state = false;
          }
        }
      }
    }

    // if player cycling and path set not true add cycle gear to plyr instructions

    let cancelPath = false;

    // SET PATH !!
    let pathSet = [];

    if (
      getPath === true &&
      !targetPlayer &&
      aiPlayer.ai.mission === "retrieve" &&
      aiPlayer.ai.retrieving.state === true
    ) {
      console.log("pathfinding...retrieve");
      this.updatePathArray();
      this.easyStar = new Easystar.js();

      let aiPos;
      let targetPos;

      // console.log('get retrive path',aiPlayer.ai.retrieving.point);
      aiPos = aiPlayer.currentPosition.cell.number;
      targetPos = {
        x: aiPlayer.ai.retrieving.point.x,
        y: aiPlayer.ai.retrieving.point.y,
      };

      this.easyStar.setGrid(this.pathArray);
      this.easyStar.setAcceptableTiles([0]);

      // PLAYER CELLS TO AVOID
      for (const plyr of this.players) {
        // console.log('building pathfind obstacles checking plyr',plyr.number);
        if (
          plyr.dead.state !== true &&
          plyr.falling.state !== true &&
          plyr.respawn !== true &&
          plyr.number !== aiPlayer.number &&
          plyr.number !== targetPlayer.number
        ) {
          // console.log('avoid plyr',plyr.number,'@',plyr.currentPosition.cell.number.x, plyr.currentPosition.cell.number.y);
          this.easyStar.avoidAdditionalPoint(
            plyr.currentPosition.cell.number.x,
            plyr.currentPosition.cell.number.y
          );
        }
      }

      // AVOID PATHS THAT GO CLOSE TO ENEMY PLAYERS IF ALIVE
      for (const plyr of this.players) {
        if (
          plyr.ai.state !== true &&
          plyr.dead.state !== true &&
          plyr.falling.state !== true
        ) {
          console.log(
            aiPlayer.ai.mission,
            " careful pathfinding. enemy is plyr #",
            plyr.number
          );
          let rng;
          let span;

          if (plyr.currentWeapon.type === "sword" || plyr.currentWeapon.name === "") {
            rng = 1;
          } else {
            rng = 2;
          }
          span = rng * 2 + 1;
          let cornerCell = undefined;
          let whichCorner;

          while (!cornerCell) {
            let whichCorner2 = this.rnJesus(1, 4);

            switch (whichCorner2) {
              case 1:
                cornerCell = this.gridInfo.find(
                  (elem) =>
                    elem.number.x === plyr.currentPosition.cell.number.x + rng &&
                    elem.number.y === plyr.currentPosition.cell.number.y + rng
                );
                whichCorner = "southEast";
                break;
              case 2:
                cornerCell = this.gridInfo.find(
                  (elem) =>
                    elem.number.x === plyr.currentPosition.cell.number.x - rng &&
                    elem.number.y === plyr.currentPosition.cell.number.y - rng
                );
                whichCorner = "northWest";
                break;
              case 3:
                cornerCell = this.gridInfo.find(
                  (elem) =>
                    elem.number.x === plyr.currentPosition.cell.number.x - rng &&
                    elem.number.y === plyr.currentPosition.cell.number.y + rng
                );
                whichCorner = "southWest";
                break;
              case 4:
                cornerCell = this.gridInfo.find(
                  (elem) =>
                    elem.number.x === plyr.currentPosition.cell.number.x + rng &&
                    elem.number.y === plyr.currentPosition.cell.number.y - rng
                );
                whichCorner = "northEast";
                break;
            }
          }

          if (cornerCell) {
            // console.log('cornerCell',cornerCell.number);

            for (var i = 0; i < span; i++) {
              let startCell;
              switch (whichCorner) {
                case "southEast":
                  startCell = {
                    x: cornerCell.number.x - i,
                    y: cornerCell.number.y,
                  };
                  break;
                case "northEast":
                  startCell = {
                    x: cornerCell.number.x - i,
                    y: cornerCell.number.y,
                  };
                  break;
                case "southWest":
                  startCell = {
                    x: cornerCell.number.x + i,
                    y: cornerCell.number.y,
                  };
                  break;
                case "northWest":
                  startCell = {
                    x: cornerCell.number.x + i,
                    y: cornerCell.number.y,
                  };
                  break;
              }
              // console.log('startCell',startCell,i);

              for (var j = 0; j < span; j++) {
                let cell;

                switch (whichCorner) {
                  case "southEast":
                    cell = {
                      x: startCell.x,
                      y: startCell.y - j,
                    };
                    break;
                  case "northEast":
                    cell = {
                      x: startCell.x,
                      y: startCell.y + j,
                    };
                    break;
                  case "southWest":
                    cell = {
                      x: startCell.x,
                      y: startCell.y - j,
                    };
                    break;
                  case "northWest":
                    cell = {
                      x: startCell.x,
                      y: startCell.y + j,
                    };
                    break;
                }
                // console.log('cell',cell,j);

                if (
                  cell.x <= this.gridWidth &&
                  cell.x >= 0 &&
                  cell.y <= this.gridWidth &&
                  cell.y >= 0
                ) {
                  // console.log(aiPlayer.ai.mission,'avoid cell ',cell);
                  this.easyStar.avoidAdditionalPoint(cell.x, cell.y);
                }
              }
            }
          }
        }
      }

      // AVOID DEBUFFS!!
      if (aiPlayer.ai.mission === "retrieve") {
        let fieldItemScan = [];
        for (const cell of this.gridInfo) {
          if (cell.item.name !== "") {
            fieldItemScan.push({
              name: cell.item.name,
              type: cell.item.type,
              subType: cell.item.subType,
              effect: cell.item.effect,
              location: { x: cell.number.x, y: cell.number.y },
            });
          }
        }

        let nerfItemPositions = [];
        for (const item of fieldItemScan) {
          switch (item.name) {
            case "moveSpeedDown":
              nerfItemPositions.push(item);
              break;
            case "hpDown":
              nerfItemPositions.push(item);
              break;
            case "focusDown":
              nerfItemPositions.push(item);
              break;
            case "strengthDown":
              nerfItemPositions.push(item);
              break;
          }
        }

        for (const nerf of nerfItemPositions) {
          this.easyStar.avoidAdditionalPoint(nerf.location.x, nerf.location.y);
        }
      }

      // TERRAIN & OBSTACLE CELLS TO AVOID
      for (const cell2 of this.gridInfo) {
        let terrainInfo3 = cell2.levelData.length - 1;
        if (
          cell2.levelData.split("_")[1] !== "*" ||
          cell2.terrain.type === "deep" ||
          cell2.terrain.type === "hazard" ||
          // cell2.barrier.state === true ||
          cell2.void.state === true
        ) {
          this.easyStar.avoidAdditionalPoint(cell2.number.x, cell2.number.y);
        }
      }

      // FIND PATH!
      this.players[aiPlayer.number - 1].ai.easyStarPath = this.easyStar.findPath(
        aiPos.x,
        aiPos.y,
        targetPos.x,
        targetPos.y,
        function (path) {
          if (path === null) {
            cancelPath = true;
            console.log("Path was not found...for player", aiPlayer.number);
          } else {
            pathSet = path;
          }
        }
      );

      this.easyStar.setIterationsPerCalculation(4000);
      this.easyStar.calculate();
      setTimeout(() => {
        // console.log('plyr',aiPlayer.number,'pathSet',pathSet,this.players[aiPlayer.number-1].ai.easyStarPath);

        if (cancelPath === true) {
          console.log("cancel path");
          this.easyStar = new Easystar.js();
          this.players[aiPlayer.number - 1].ai.targetAcquired = false;
        }
        this.aiParsePath(pathSet, aiPlayer.number);
      }, 50);
    }

    if (targetPlayer) {
      if (
        getPath === true &&
        targetPlayer.dead.state !== true &&
        targetPlayer.falling.state !== true
      ) {
        console.log("pathfinding...");
        this.updatePathArray();
        this.easyStar = new Easystar.js();

        let aiPos;
        let targetPos;

        if (aiPlayer.ai.mission === "pursue") {
          aiPos = aiPlayer.currentPosition.cell.number;
          targetPos =
            this.players[aiPlayer.ai.targetPlayer.number - 1].currentPosition.cell.number;
          console.log("pursuit target ", targetPos);

          if (aiPlayer.ai.safeRange === true) {
            let candidateTargets = [
              { x: 0, y: 0 },
              { x: 0, y: 0 },
              { x: 0, y: 0 },
              { x: 0, y: 0 },
            ];

            if (aiPlayer.currentWeapon.type === "crossbow") {
              // candidateTargets = [
              //   {x: targetPos.x-6, y: targetPos.y},
              //   {x: targetPos.x+6, y: targetPos.y},
              //   {x: targetPos.x, y: targetPos.y+6},
              //   {x: targetPos.x, y: targetPos.y-6},
              // ]
              let range = aiPlayer.ai.pathfindingRanges.crossbow;
              candidateTargets = [
                { x: targetPos.x - range, y: targetPos.y },
                { x: targetPos.x + range, y: targetPos.y },
                { x: targetPos.x, y: targetPos.y + range },
                { x: targetPos.x, y: targetPos.y - range },
              ];

              // console.log('candidateTargets',candidateTargets);

              let freeSpaces = [];

              for (const rangeElem of candidateTargets) {
                let indx = candidateTargets.findIndex(
                  (rng) => rng.x === rangeElem.x && rng.y === rangeElem.y
                );

                let pursuitTargetRef = this.gridInfo.find(
                  (elem) => elem.number.x === rangeElem.x && elem.number.y === rangeElem.y
                );

                if (!pursuitTargetRef) {
                  // console.log('range element is  out of bounds',rangeElem,'indx',indx);
                } else {
                  let rangeElemCells2 = [];

                  // DON'T fire from obstructed position
                  // this.cellsToHighlight.push(rangeElem)

                  let dirToFire;
                  let diff = 0;
                  if (rangeElem.x === targetPos.x && rangeElem.y > targetPos.y) {
                    dirToFire = "north";
                    diff = rangeElem.y - targetPos.y;
                    for (var i = 0; i < diff; i++) {
                      rangeElemCells2.push({
                        x: rangeElem.x,
                        y: rangeElem.y - i,
                      });
                      // this.cellsToHighlight.push({x:rangeElem.x, y: rangeElem.y - i})
                    }
                  }
                  if (rangeElem.x > targetPos.x && rangeElem.y === targetPos.y) {
                    dirToFire = "west";
                    diff = rangeElem.x - targetPos.x;
                    for (var i = 0; i < diff; i++) {
                      rangeElemCells2.push({
                        x: rangeElem.x - i,
                        y: rangeElem.y,
                      });
                      // this.cellsToHighlight.push({x:rangeElem.x - i, y: rangeElem.y})
                    }
                  }
                  if (rangeElem.x === targetPos.x && rangeElem.y < targetPos.y) {
                    dirToFire = "south";
                    diff = targetPos.y - rangeElem.y;
                    for (var i = 0; i < diff; i++) {
                      rangeElemCells2.push({
                        x: rangeElem.x,
                        y: rangeElem.y + i,
                      });
                      // this.cellsToHighlight.push({x:rangeElem.x, y: rangeElem.y + i})
                    }
                  }
                  if (rangeElem.x < targetPos.x && rangeElem.y === targetPos.y) {
                    dirToFire = "east";
                    diff = targetPos.x - rangeElem.x;
                    for (var i = 0; i < diff; i++) {
                      rangeElemCells2.push({
                        x: rangeElem.x + i,
                        y: rangeElem.y,
                      });
                      // this.cellsToHighlight.push({x:rangeElem.x + i, y: rangeElem.y})
                    }
                  } else {
                    // console.log('exception! rangeElem,targetPos',rangeElem,targetPos);
                  }

                  // let rangeElemCells = [];
                  // switch(indx) {
                  //   case 0:
                  //     rangeElemCells = [
                  //       // {x:rangeElem - 5, y: rangeElem.y },
                  //       {x:rangeElem.x - 4, y: rangeElem.y },
                  //       {x:rangeElem.x - 3, y: rangeElem.y },
                  //       {x:rangeElem.x - 2, y: rangeElem.y },
                  //       {x:rangeElem.x - 1, y: rangeElem.y },
                  //     ]
                  //   break;
                  //   case 1:
                  //     rangeElemCells = [
                  //       // {x:rangeElem + 5, y: rangeElem.y },
                  //       {x:rangeElem.x + 4, y: rangeElem.y },
                  //       {x:rangeElem.x + 3, y: rangeElem.y },
                  //       {x:rangeElem.x + 2, y: rangeElem.y },
                  //       {x:rangeElem.x + 1, y: rangeElem.y },
                  //     ]
                  //   break;
                  //   case 2:
                  //     rangeElemCells = [
                  //       // {x:rangeElem, y: rangeElem.y + 5},
                  //       {x:rangeElem.x, y: rangeElem.y + 4},
                  //       {x:rangeElem.x, y: rangeElem.y + 3},
                  //       {x:rangeElem.x, y: rangeElem.y + 2},
                  //       {x:rangeElem.x, y: rangeElem.y + 1},
                  //     ]
                  //   break;
                  //   case 3:
                  //     rangeElemCells = [
                  //       // {x:rangeElem, y: rangeElem.y - 5},
                  //       {x:rangeElem.x, y: rangeElem.y - 4},
                  //       {x:rangeElem.x, y: rangeElem.y - 3},
                  //       {x:rangeElem.x, y: rangeElem.y - 2},
                  //       {x:rangeElem.x, y: rangeElem.y - 1},
                  //     ]
                  //   break;
                  //   // case 4:
                  //   //   rangeElemCells = [
                  //   //     {x:rangeElem, y: rangeElem.y - 5},
                  //   //     {x:rangeElem, y: rangeElem.y - 4},
                  //   //     {x:rangeElem, y: rangeElem.y - 3},
                  //   //     {x:rangeElem, y: rangeElem.y - 2},
                  //   //     {x:rangeElem, y: rangeElem.y - 1},
                  //   //   ]
                  //   // break;
                  // }

                  // IS FIRE POSITION FREE?
                  let rngElCellFree = true;
                  let cellRef3 = this.gridInfo.find(
                    (elema) =>
                      elema.number.x === rangeElem.x && elema.number.y === rangeElem.y
                  );
                  if (cellRef3) {
                    if (
                      cellRef3.levelData.charAt(0) === "z" ||
                      cellRef3.levelData.charAt(0) === "y" ||
                      cellRef3.terrain.type === "deep" ||
                      cellRef3.terrain.type === "hazard"
                    ) {
                      rngElCellFree = false;
                    } else {
                    }
                  } else if (!cellRef3) {
                    rngElCellFree = false;
                  }

                  let clearToShoot = false;
                  // IS SIGHT OBSTRUCTED?
                  if (rngElCellFree === true) {
                    let obstructions = [];
                    for (const cellx of rangeElemCells2) {
                      let cellRef4 = this.gridInfo.find(
                        (elemb) =>
                          elemb.number.x === cellx.x && elemb.number.y === cellx.y
                      );

                      if (
                        cellRef4.levelData.charAt(0) === "y" ||
                        cellRef4.levelData.charAt(0) === "z"
                      ) {
                        // clearToShoot = false;
                        obstructions.push(cellx);
                      }
                      if (
                        cellRef4.levelData.charAt(0) !== "y" &&
                        cellRef4.levelData.charAt(0) !== "z"
                      ) {
                        // clearToShoot = true;
                        // obstructions.push(cellx)
                      }
                    }

                    // if (clearToShoot === true) {
                    if (obstructions.length === 0) {
                      freeSpaces.push(rangeElem);
                      // this.cellsToHighlight = rangeElemCells2;
                      // console.log('rangeElemCells2',rangeElemCells2);
                      // console.log('found path to safe bow range',targetPos);
                    } else {
                      // console.log('target obstructed @',obstructions);
                    }
                  } else {
                    console.log("your safe path is blocked");
                  }
                }
              }

              if (freeSpaces[0]) {
                // console.log('freeSpaces',freeSpaces);
                targetPos = freeSpaces[0];
                // console.log('found path to safe bow range',targetPos);
              } else {
                console.log(
                  "No free or unobstructed firing positions at this distance for crossbow"
                );
                if (aiPlayer.ai.pathfindingRanges.crossbow > 1) {
                  aiPlayer.ai.pathfindingRanges.crossbow--;
                }
                aiPlayer.ai.safeRange = false;
                aiPlayer.ai.targetAcquired = false;

                let fieldItemScan = [];
                for (const cell of this.gridInfo) {
                  if (cell.item.name !== "") {
                    fieldItemScan.push({
                      name: cell.item.name,
                      type: cell.item.type,
                      subType: cell.item.subType,
                      effect: cell.item.effect,
                      location: { x: cell.number.x, y: cell.number.y },
                    });
                  }
                }
                if (
                  fieldItemScan.find((x) => x.type === "spear") ||
                  fieldItemScan.find((x) => x.type === "sword")
                ) {
                  aiPlayer.ai.upgradeWeapon = true;
                  aiPlayer.ai.organizing.weaponPriorityIndex = 1;
                } else {
                  aiPlayer.currentWeapon = {
                    name: "",
                    type: "",
                    effect: "",
                  };
                  console.log(
                    "no crossbow fire position or other gear in the field. switching to unarmed"
                  );
                }
              }
            }

            if (aiPlayer.currentWeapon.type === "spear") {
              let range = aiPlayer.ai.pathfindingRanges.spear;
              candidateTargets = [
                { x: targetPos.x - range, y: targetPos.y },
                { x: targetPos.x + range, y: targetPos.y },
                { x: targetPos.x, y: targetPos.y + range },
                { x: targetPos.x, y: targetPos.y - range },
              ];

              // for (const rangeElem of candidateTargets)  {
              //   let indx = candidateTargets.findIndex(rng => rng.x === rangeElem.x && rng.y === rangeElem.y)
              //
              //   let pursuitTargetRef = this.gridInfo.find(elem => elem.number.x === rangeElem.x && elem.number.y === rangeElem.y)
              //
              //   if (!pursuitTargetRef) {
              //    // console.log('range element is out of bounds');
              //   } else {
              //
              //
              //     let rangeElemCells;
              //
              //     switch(indx) {
              //       case 0:
              //         rangeElemCells = [
              //           {x:rangeElem - 2, y: rangeElem.y },
              //           {x:rangeElem - 1, y: rangeElem.y },
              //         ]
              //       break;
              //       case 1:
              //         rangeElemCells = [
              //           {x:rangeElem + 2, y: rangeElem.y },
              //           {x:rangeElem + 1, y: rangeElem.y },
              //         ]
              //       break;
              //       case 2:
              //         rangeElemCells = [
              //           {x:rangeElem, y: rangeElem.y + 2},
              //           {x:rangeElem, y: rangeElem.y + 1},
              //         ]
              //       break;
              //       case 3:
              //         rangeElemCells = [
              //           {x:rangeElem, y: rangeElem.y - 2},
              //           {x:rangeElem, y: rangeElem.y - 1},
              //         ]
              //       break;
              //     }
              //
              //     let rngElCellFree = true;
              //     for (const rngElCell of rangeElemCells) {
              //
              //       for (const plyr of this.players) {
              //         if (plyr.currentPosition.cell.number.x === rngElCell.x && plyr.currentPosition.cell.number.y === rngElCell.y) {
              //           rngElCellFree = false;
              //         }
              //         let cellRef3 = this.gridInfo.find(elema => elema.number.x === rngElCell.x && elema.number.y === rngElCell.y)
              //         if (cellRef3) {
              //           if (
              //             cellRef3.levelData.charAt(0) ===  'z' ||
              //             cellRef3.levelData.charAt(0) ===  'y' ||
              //             cellRef3.terrain.type ===  'deep' ||
              //             cellRef3.terrain.type ===  'hazard'
              //           ) {
              //             rngElCellFree = false;
              //           }
              //         }
              //
              //       }
              //     }
              //     if (rngElCellFree === true) {
              //       targetPos = rangeElem;
              //       // console.log('found path to safe spear range');
              //     } else {
              //       console.log('your safe path is blocked');
              //     }
              //   }
              // }

              let freeSpaces = [];

              for (const rangeElem of candidateTargets) {
                // this.cellsToHighlight.push({x:rangeElem.x, y: rangeElem.y})
                let indx = candidateTargets.findIndex(
                  (rng) => rng.x === rangeElem.x && rng.y === rangeElem.y
                );

                let pursuitTargetRef = this.gridInfo.find(
                  (elem) => elem.number.x === rangeElem.x && elem.number.y === rangeElem.y
                );

                if (!pursuitTargetRef) {
                  // console.log('range element is  out of bounds',rangeElem,'indx',indx);
                } else {
                  let rangeElemCells2 = [];

                  let dirToFire;
                  let diff = 0;
                  if (rangeElem.x === targetPos.x && rangeElem.y > targetPos.y) {
                    dirToFire = "north";
                    diff = rangeElem.y - targetPos.y;
                    for (var i = 0; i < diff; i++) {
                      rangeElemCells2.push({
                        x: rangeElem.x,
                        y: rangeElem.y - i,
                      });
                      // this.cellsToHighlight.push({x:rangeElem.x, y: rangeElem.y - i})
                    }
                  }
                  if (rangeElem.x > targetPos.x && rangeElem.y === targetPos.y) {
                    dirToFire = "west";
                    diff = rangeElem.x - targetPos.x;
                    for (var i = 0; i < diff; i++) {
                      rangeElemCells2.push({
                        x: rangeElem.x - i,
                        y: rangeElem.y,
                      });
                      // this.cellsToHighlight.push({x:rangeElem.x - i, y: rangeElem.y})
                    }
                  }
                  if (rangeElem.x === targetPos.x && rangeElem.y < targetPos.y) {
                    dirToFire = "south";
                    diff = targetPos.y - rangeElem.y;
                    for (var i = 0; i < diff; i++) {
                      rangeElemCells2.push({
                        x: rangeElem.x,
                        y: rangeElem.y + i,
                      });
                      // this.cellsToHighlight.push({x:rangeElem.x, y: rangeElem.y + i})
                    }
                  }
                  if (rangeElem.x < targetPos.x && rangeElem.y === targetPos.y) {
                    dirToFire = "east";
                    diff = targetPos.x - rangeElem.x;
                    for (var i = 0; i < diff; i++) {
                      rangeElemCells2.push({
                        x: rangeElem.x + i,
                        y: rangeElem.y,
                      });
                      // this.cellsToHighlight.push({x:rangeElem.x + i, y: rangeElem.y})
                    }
                  } else {
                    // console.log('exception! rangeElem,targetPos',rangeElem,targetPos);
                  }

                  // IS attack POSITION FREE?
                  let rngElCellFree = true;
                  let cellRef3 = this.gridInfo.find(
                    (elema) =>
                      elema.number.x === rangeElem.x && elema.number.y === rangeElem.y
                  );
                  if (cellRef3) {
                    if (
                      cellRef3.levelData.charAt(0) === "z" ||
                      cellRef3.levelData.charAt(0) === "y" ||
                      cellRef3.terrain.type === "deep" ||
                      cellRef3.terrain.type === "hazard"
                    ) {
                      rngElCellFree = false;
                    } else {
                    }
                  } else if (!cellRef3) {
                    rngElCellFree = false;
                  }

                  let clearToShoot = false;
                  // IS SIGHT OBSTRUCTED?
                  if (rngElCellFree === true) {
                    let obstructions = [];
                    for (const cellx of rangeElemCells2) {
                      let cellRef4 = this.gridInfo.find(
                        (elemb) =>
                          elemb.number.x === cellx.x && elemb.number.y === cellx.y
                      );

                      if (
                        cellRef4.levelData.charAt(0) === "y" ||
                        cellRef4.levelData.charAt(0) === "z"
                      ) {
                        // clearToShoot = false;
                        obstructions.push(cellx);
                      }
                      if (
                        cellRef4.levelData.charAt(0) !== "y" &&
                        cellRef4.levelData.charAt(0) !== "z"
                      ) {
                        // clearToShoot = true;
                        // obstructions.push(cellx)
                      }
                    }

                    // if (clearToShoot === true) {
                    if (obstructions.length === 0) {
                      freeSpaces.push(rangeElem);
                      // this.cellsToHighlight = rangeElemCells2;
                      // console.log('rangeElemCells2',rangeElemCells2);
                      // console.log('found path to safe bow range',targetPos);
                    } else {
                      console.log("target obstructed @", obstructions);
                    }
                  } else {
                    console.log("your safe path is blocked");
                  }
                }
              }

              if (freeSpaces[0]) {
                // console.log('freeSpaces',freeSpaces);
                targetPos = freeSpaces[0];
                // console.log('found path to safe spear range',targetPos);
              } else {
                console.log(
                  "No free or unobstructed firing positions at this distance for spear"
                );
                if (aiPlayer.ai.pathfindingRanges.spear > 1) {
                  aiPlayer.ai.pathfindingRanges.spear--;
                }
                aiPlayer.ai.safeRange = false;
                aiPlayer.ai.targetAcquired = false;
              }
            }
            if (
              aiPlayer.currentWeapon.type === "sword" ||
              aiPlayer.currentWeapon.name === ""
            ) {
              candidateTargets = [
                { x: targetPos.x - 2, y: targetPos.y },
                { x: targetPos.x + 2, y: targetPos.y },
                { x: targetPos.x, y: targetPos.y + 2 },
                { x: targetPos.x, y: targetPos.y - 2 },
              ];

              for (const rangeElem of candidateTargets) {
                let indx = candidateTargets.findIndex(
                  (rng) => rng.x === rangeElem.x && rng.y === rangeElem.y
                );

                let pursuitTargetRef = this.gridInfo.find(
                  (elem) => elem.number.x === rangeElem.x && elem.number.y === rangeElem.y
                );

                if (!pursuitTargetRef) {
                  // console.log('range element is out of bounds');
                } else {
                  let rangeElemCells;

                  switch (indx) {
                    case 0:
                      rangeElemCells = [{ x: rangeElem - 1, y: rangeElem.y }];
                      break;
                    case 1:
                      rangeElemCells = [{ x: rangeElem + 1, y: rangeElem.y }];
                      break;
                    case 2:
                      rangeElemCells = [{ x: rangeElem, y: rangeElem.y + 1 }];
                      break;
                    case 3:
                      rangeElemCells = [{ x: rangeElem, y: rangeElem.y - 1 }];
                      break;
                  }

                  let rngElCellFree = true;
                  for (const rngElCell of rangeElemCells) {
                    for (const plyr of this.players) {
                      if (
                        plyr.currentPosition.cell.number.x === rngElCell.x &&
                        plyr.currentPosition.cell.number.y === rngElCell.y
                      ) {
                        rngElCellFree = false;
                      }
                      let cellRef3 = this.gridInfo.find(
                        (elema) =>
                          elema.number.x === rngElCell.x && elema.number.y === rngElCell.y
                      );
                      if (cellRef3) {
                        if (
                          cellRef3.levelData.charAt(0) === "z" ||
                          cellRef3.levelData.charAt(0) === "y" ||
                          cellRef3.terrain.type === "deep" ||
                          cellRef3.terrain.type === "hazard"
                        ) {
                          rngElCellFree = false;
                        }
                      }
                    }
                  }
                  if (rngElCellFree === true) {
                    targetPos = rangeElem;
                    // console.log('found path to safe sword range',targetPos);
                  } else {
                    console.log("your safe path is blocked");
                  }
                }
              }
            }
          }

          // this.pathArray[targetPos.x][targetPos.y] = 0;
          // this.pathArray[aiPos.x][aiPos.y] = 0;
        }
        if (aiPlayer.ai.mission === "patrol") {
          aiPos = aiPlayer.currentPosition.cell.number;
          targetPos = patrolDest;

          // this.pathArray[targetPos.x][targetPos.y] = 0;
        }
        if (aiPlayer.ai.mission === "engage") {
        }
        if (aiPlayer.ai.mission === "defend") {
          aiPos = aiPlayer.currentPosition.cell.number;
          targetPos = defendDest;

          console.log("pathfinding targetPos", targetPos);
          // this.pathArray[targetPos.x][targetPos.y] = 0;
        }
        if (aiPlayer.ai.mission === "retreat") {
          // console.log('get retreat path',aiPlayer.ai.retreating.point);
          aiPos = aiPlayer.currentPosition.cell.number;
          targetPos = {
            x: aiPlayer.ai.retreating.point.x,
            y: aiPlayer.ai.retreating.point.y,
          };
        }
        if (aiPlayer.ai.mission === "retrieve") {
          console.log("get retrive path", aiPlayer.ai.retrieving.point);
          aiPos = aiPlayer.currentPosition.cell.number;
          targetPos = {
            x: aiPlayer.ai.retrieving.point.x,
            y: aiPlayer.ai.retrieving.point.y,
          };
        }

        this.easyStar.setGrid(this.pathArray);
        this.easyStar.setAcceptableTiles([0]);

        // PLAYER CELLS TO AVOID
        for (const plyr of this.players) {
          // console.log('building pathfind obstacles checking plyr',plyr.number);
          if (
            plyr.dead.state !== true &&
            plyr.falling.state !== true &&
            plyr.respawn !== true &&
            plyr.number !== aiPlayer.number &&
            plyr.number !== targetPlayer.number
          ) {
            // console.log('avoid plyr',plyr.number,'@',plyr.currentPosition.cell.number.x, plyr.currentPosition.cell.number.y);
            this.easyStar.avoidAdditionalPoint(
              plyr.currentPosition.cell.number.x,
              plyr.currentPosition.cell.number.y
            );
          }
        }

        // AVOID PATHS THAT GO CLOSE TO ENEMY PLAYERS
        if (aiPlayer.ai.mission === "retreat" || aiPlayer.ai.mission === "retrieve") {
          for (const plyr of this.players) {
            if (plyr.ai.state !== true) {
              console.log(
                aiPlayer.ai.mission,
                " careful pathfinding. enemy is plyr #",
                plyr.number
              );
              let rng;
              let span;

              if (plyr.currentWeapon.type === "sword" || plyr.currentWeapon.name === "") {
                rng = 1;
              } else {
                rng = 2;
              }
              span = rng * 2 + 1;
              let cornerCell = undefined;
              let whichCorner;

              while (!cornerCell) {
                let whichCorner2 = this.rnJesus(1, 4);

                switch (whichCorner2) {
                  case 1:
                    cornerCell = this.gridInfo.find(
                      (elem) =>
                        elem.number.x === plyr.currentPosition.cell.number.x + rng &&
                        elem.number.y === plyr.currentPosition.cell.number.y + rng
                    );
                    whichCorner = "southEast";
                    break;
                  case 2:
                    cornerCell = this.gridInfo.find(
                      (elem) =>
                        elem.number.x === plyr.currentPosition.cell.number.x - rng &&
                        elem.number.y === plyr.currentPosition.cell.number.y - rng
                    );
                    whichCorner = "northWest";
                    break;
                  case 3:
                    cornerCell = this.gridInfo.find(
                      (elem) =>
                        elem.number.x === plyr.currentPosition.cell.number.x - rng &&
                        elem.number.y === plyr.currentPosition.cell.number.y + rng
                    );
                    whichCorner = "southWest";
                    break;
                  case 4:
                    cornerCell = this.gridInfo.find(
                      (elem) =>
                        elem.number.x === plyr.currentPosition.cell.number.x + rng &&
                        elem.number.y === plyr.currentPosition.cell.number.y - rng
                    );
                    whichCorner = "northEast";
                    break;
                }
              }

              if (cornerCell) {
                // console.log('cornerCell',cornerCell.number);

                for (var i = 0; i < span; i++) {
                  let startCell;
                  switch (whichCorner) {
                    case "southEast":
                      startCell = {
                        x: cornerCell.number.x - i,
                        y: cornerCell.number.y,
                      };
                      break;
                    case "northEast":
                      startCell = {
                        x: cornerCell.number.x - i,
                        y: cornerCell.number.y,
                      };
                      break;
                    case "southWest":
                      startCell = {
                        x: cornerCell.number.x + i,
                        y: cornerCell.number.y,
                      };
                      break;
                    case "northWest":
                      startCell = {
                        x: cornerCell.number.x + i,
                        y: cornerCell.number.y,
                      };
                      break;
                  }
                  // console.log('startCell',startCell,i);

                  for (var j = 0; j < span; j++) {
                    let cell;

                    switch (whichCorner) {
                      case "southEast":
                        cell = {
                          x: startCell.x,
                          y: startCell.y - j,
                        };
                        break;
                      case "northEast":
                        cell = {
                          x: startCell.x,
                          y: startCell.y + j,
                        };
                        break;
                      case "southWest":
                        cell = {
                          x: startCell.x,
                          y: startCell.y - j,
                        };
                        break;
                      case "northWest":
                        cell = {
                          x: startCell.x,
                          y: startCell.y + j,
                        };
                        break;
                    }
                    // console.log('cell',cell,j);

                    if (
                      cell.x <= this.gridWidth &&
                      cell.x >= 0 &&
                      cell.y <= this.gridWidth &&
                      cell.y >= 0
                    ) {
                      // console.log(aiPlayer.ai.mission,'avoid cell ',cell);
                      this.easyStar.avoidAdditionalPoint(cell.x, cell.y);
                    }
                  }
                }
              }
            }
          }

          // AVOID DEBUFFS!!
          if (aiPlayer.ai.mission === "retrive") {
            let fieldItemScan = [];
            for (const cell of this.gridInfo) {
              if (cell.item.name !== "") {
                fieldItemScan.push({
                  name: cell.item.name,
                  type: cell.item.type,
                  subType: cell.item.subType,
                  effect: cell.item.effect,
                  location: { x: cell.number.x, y: cell.number.y },
                });
              }
            }

            let nerfItemPositions = [];
            for (const item of fieldItemScan) {
              switch (item.name) {
                case "moveSpeedDown":
                  nerfItemPositions.push(item);
                  break;
                case "hpDown":
                  nerfItemPositions.push(item);
                  break;
                case "focusDown":
                  nerfItemPositions.push(item);
                  break;
                case "strengthDown":
                  nerfItemPositions.push(item);
                  break;
              }
            }

            for (const nerf of nerfItemPositions) {
              this.easyStar.avoidAdditionalPoint(nerf.location.x, nerf.location.y);
            }
          }
        }

        // '**_*_0.0_a_0**'
        // barrierType(a,b,c)BarrierPosition(n,s,e,w)_obstacle_x.y_terrain_elevationNumber(0,1,2)ElevationType(a,b,c)ElevationPosition(n,s,e,w)

        // TERRAIN & OBSTACLE CELLS TO AVOID
        for (const cell2 of this.gridInfo) {
          let terrainInfo3 = cell2.levelData.length - 1;
          if (
            cell2.levelData.split("_")[1] !== "*" ||
            cell2.terrain.type === "deep" ||
            cell2.terrain.type === "hazard" ||
            // cell2.barrier.state === true ||
            cell2.void.state === true
          ) {
            this.easyStar.avoidAdditionalPoint(cell2.number.x, cell2.number.y);
          }
        }

        // FIND PATH!
        this.players[aiPlayer.number - 1].ai.easyStarPath = this.easyStar.findPath(
          aiPos.x,
          aiPos.y,
          targetPos.x,
          targetPos.y,
          function (path) {
            if (path === null) {
              cancelPath = true;
              console.log("Path was not found...for player", aiPlayer.number);
            } else {
              pathSet = path;
            }
          }
        );

        this.easyStar.setIterationsPerCalculation(4000);
        this.easyStar.calculate();
        setTimeout(() => {
          // console.log('plyr',aiPlayer.number,'pathSet',pathSet,this.players[aiPlayer.number-1].ai.easyStarPath);

          if (cancelPath === true) {
            console.log("cancel path");
            this.easyStar = new Easystar.js();
            this.players[aiPlayer.number - 1].ai.targetAcquired = false;
          }
          this.aiParsePath(pathSet, aiPlayer.number);
        }, 50);
      }
    }

    this.players[aiPlayer.number - 1] = aiPlayer;

    this.aiAct(aiPlayer);
  };
  aiParsePath = (path, aiPlayer) => {
    // console.log('parsing path',path);
    // ..
    let instructions = [];
    let init = true;
    let initDirection = this.players[aiPlayer - 1].direction;
    let direction;

    if (
      this.players[aiPlayer - 1].ai.mission !== "patrol" &&
      this.players[aiPlayer - 1].ai.mission !== "defend"
    ) {
      if (this.players[aiPlayer - 1].ai.safeRange !== true) {
        path.pop();
      }

      // if (path.length > 1) {
      //   path.pop();
      // }
    }
    if (this.players[aiPlayer - 1].ai.mission === "patrol") {
      // if (path.length > 2) {
      //   path.pop();
      // }
    }
    // if (path.length > 1) {
    //   path.pop();
    // }
    // path.pop();

    for (const [key, value] of Object.entries(path)) {
      let currentCell = path[key - 1];
      let nextCell = path[key];
      // console.log(key-1,'currentCell',currentCell,'nextCell',nextCell);
      if (currentCell) {
        let oldDirection = direction;
        let newDirection;
        if (init === true) {
          oldDirection = initDirection;
          init = false;
        }

        if (nextCell.x === currentCell.x && nextCell.y === currentCell.y - 1) {
          newDirection = "north";
        }
        if (nextCell.x === currentCell.x && nextCell.y === currentCell.y + 1) {
          newDirection = "south";
        }
        if (nextCell.x === currentCell.x - 1 && nextCell.y === currentCell.y) {
          newDirection = "west";
        }
        if (nextCell.x === currentCell.x + 1 && nextCell.y === currentCell.y) {
          newDirection = "east";
        }

        if (oldDirection === newDirection) {
          if (
            this.players[aiPlayer - 1].ai.mission === "patrol" &&
            this.players[aiPlayer - 1].ai.patrolling.checkin !== "enroute"
          ) {
            instructions.push(
              {
                keyword: "move_" + newDirection,
                count: 0,
                limit: 1,
              },
              {
                keyword: "long_wait",
                count: 0,
                limit: 25,
              }
            );
          } else {
            instructions.push({
              keyword: "move_" + newDirection,
              count: 0,
              limit: 1,
            });
          }
        }
        if (oldDirection !== newDirection) {
          if (
            this.players[aiPlayer - 1].ai.mission === "patrol" &&
            this.players[aiPlayer - 1].ai.patrolling.checkin !== "enroute"
          ) {
            instructions.push(
              {
                keyword: "move_" + newDirection,
                count: 0,
                limit: 1,
              },
              {
                keyword: "long_wait",
                count: 0,
                limit: 25,
              },
              {
                keyword: "move_" + newDirection,
                count: 0,
                limit: 1,
              },
              {
                keyword: "long_wait",
                count: 0,
                limit: 25,
              }
            );
          } else {
            instructions.push(
              {
                keyword: "move_" + newDirection,
                count: 0,
                limit: 1,
              },
              {
                keyword: "move_" + newDirection,
                count: 0,
                limit: 1,
              }
            );
          }
        }

        direction = newDirection;
      }
    }
    // instructions.shift();
    // instructions.pop();

    // console.log('this.pathArray',this.pathArray);
    // console.log('path',path,'player',aiPlayer);
    // console.log('parse path instructions',instructions);

    // console.log('player',aiPlayer,this.players[aiPlayer-1].ai.currentInstruction,'mission',this.players[aiPlayer-1].ai.mission,'instructions',instructions);
    // if (this.players[aiPlayer-1].ai.mission === 'retreat') {
    //   console.log('retreat instructions',instructions,'player',aiPlayer,this.players[aiPlayer-1].ai.currentInstruction,'path',path);
    // }
    if (this.players[aiPlayer - 1].ai.mission === "retrieve") {
      console.log(
        "retrieve instructions",
        instructions,
        "player",
        aiPlayer,
        this.players[aiPlayer - 1].ai.currentInstruction,
        "path",
        path
      );
    }

    this.players[aiPlayer - 1].ai.pathArray = path;
    this.players[aiPlayer - 1].ai.instructions = instructions;
    this.players[aiPlayer - 1].ai.currentInstruction = 0;
  };
  aiAct = (plyr) => {
    let currentInstruction = plyr.ai.instructions[plyr.ai.currentInstruction];

    if (currentInstruction) {
      let targetCell = this.gridInfo.find(
        (elem) =>
          elem.number.x === plyr.target.cell1.number.x &&
          elem.number.y === plyr.target.cell1.number.y
      );
      let playerCell = this.gridInfo.find(
        (elem) =>
          elem.number.x === plyr.currentPosition.cell.number.x &&
          elem.number.y === plyr.currentPosition.cell.number.y
      );

      let pathIndx = plyr.ai.pathArray.findIndex(
        (elem) =>
          elem.x === plyr.currentPosition.cell.number.x &&
          elem.y === plyr.currentPosition.cell.number.y
      );
      let currentPathStep = plyr.ai.pathArray[pathIndx];
      let nextPathStep = plyr.ai.pathArray[pathIndx + 1];
      let nextPathStepCell = undefined;
      if (nextPathStep) {
        nextPathStepCell = this.gridInfo.find(
          (elem) => elem.number.x === nextPathStep.x && elem.number.y === nextPathStep.y
        );
      }

      // console.log('total instructions',plyr.ai.instructions.length,'currentInstruction',plyr.ai.currentInstruction,plyr.moving.state, !plyr.turning.state,'keyword',currentInstruction.keyword,'limit',currentInstruction.limit,'instructions',plyr.ai.instructions,'deflected',plyr.success.deflected.state);
      // console.log('ai act',plyr.ai.currentInstruction,currentInstruction,'mission',plyr.ai.mission,'instructions',plyr.ai.instructions,'newMoveDelay.state',plyr.newMoveDelay.state);

      this.keyPressed[plyr.number - 1] = {
        north: false,
        south: false,
        east: false,
        west: false,
        attack: false,
        defend: false,
        strafe: false,
        dodge: false,
        pull: false,
        kick: false,
        cycleWeapon: false,
        cycleArmor: false,
        discardWeapon: false,
        discardArmor: false,
        uiMenu: false,
        playerMenu: false,
        rotateRight: false,
        rotateLeft: false,
      };

      switch (currentInstruction.keyword) {
        case "short_wait":
          // console.log('ai act -- short_wait');
          currentInstruction.limit = 15;
          if (currentInstruction.count < currentInstruction.limit) {
            currentInstruction.count++;
          } else if (currentInstruction.count >= currentInstruction.limit) {
            plyr.ai.currentInstruction++;
          }
          break;
        case "long_wait":
          // console.log('ai act -- long_wait');
          currentInstruction.limit = 25;
          if (currentInstruction.count < currentInstruction.limit) {
            currentInstruction.count++;
          } else if (currentInstruction.count >= currentInstruction.limit) {
            plyr.ai.currentInstruction++;
          }
          break;
        case "move_north":
          // console.log('ai act -- move_north');
          if (
            plyr.newMoveDelay.state !== true &&
            plyr.moving.state !== true &&
            !plyr.turning.state &&
            plyr.success.deflected.state !== true &&
            plyr.action === "idle"
          ) {
            let inDanger = false;
            if (plyr.direction === "north") {
              if (!targetCell) {
                // console.log('heading off the edge');
                inDanger = true;
              } else {
                if (
                  targetCell.void.state === true ||
                  targetCell.terrain.type === "deep" ||
                  targetCell.terrain.type === "hazard"
                ) {
                  // console.log('heading for mid-grid danger',targetCell.number);
                  inDanger = true;
                }
              }
            }

            if (inDanger === false) {
              // console.log('safe: move_north');
              // currentInstruction.limit = 1;
              this.keyPressed[plyr.number - 1].north = true;
              this.players[plyr.number - 1].turnCheckerDirection = "north";
              // plyr.ai.currentInstruction++;
              if (currentInstruction.limit === 1) {
                plyr.ai.currentInstruction++;
              } else {
                if (currentInstruction.count < currentInstruction.limit) {
                  currentInstruction.count++;
                } else if (currentInstruction.count >= currentInstruction.limit) {
                  plyr.ai.currentInstruction++;
                }
              }
            } else {
              // console.log('danger: move_north');
              plyr.ai.currentInstruction++;
              plyr.ai.resetInstructions = true;
            }
            // console.log('inDanger',inDanger);
          }
          break;
        case "move_south":
          // console.log('ai act -- move_south');

          if (
            plyr.newMoveDelay.state !== true &&
            plyr.moving.state !== true &&
            !plyr.turning.state &&
            plyr.success.deflected.state !== true &&
            plyr.action === "idle"
          ) {
            let inDanger = false;
            if (plyr.direction === "south") {
              if (!targetCell) {
                // console.log('heading off the edge');
                inDanger = true;
              } else {
                if (
                  targetCell.void.state === true ||
                  targetCell.terrain.type === "deep" ||
                  targetCell.terrain.type === "hazard"
                ) {
                  // console.log('heading for mid-grid danger',targetCell.number);
                  inDanger = true;
                }
              }
            }

            if (inDanger === false) {
              // console.log('safe: move_south');

              // currentInstruction.limit = 1;
              this.keyPressed[plyr.number - 1].south = true;
              this.players[plyr.number - 1].turnCheckerDirection = "south";
              // plyr.ai.currentInstruction++;
              if (currentInstruction.limit === 1) {
                plyr.ai.currentInstruction++;
              } else {
                if (currentInstruction.count < currentInstruction.limit) {
                  currentInstruction.count++;
                } else if (currentInstruction.count >= currentInstruction.limit) {
                  plyr.ai.currentInstruction++;
                }
              }
            } else {
              // console.log('danger: move_south');
              plyr.ai.currentInstruction++;
              plyr.ai.resetInstructions = true;
            }
          }
          break;
        case "move_east":
          // console.log('ai act -- move_east');
          if (
            plyr.newMoveDelay.state !== true &&
            plyr.moving.state !== true &&
            !plyr.turning.state &&
            plyr.success.deflected.state !== true &&
            plyr.action === "idle"
          ) {
            let inDanger = false;
            if (plyr.direction === "east") {
              if (!targetCell) {
                // console.log('heading off the edge');
                inDanger = true;
              } else {
                if (
                  targetCell.void.state === true ||
                  targetCell.terrain.type === "deep" ||
                  targetCell.terrain.type === "hazard"
                ) {
                  // console.log('heading for mid-grid danger',targetCell.number);
                  inDanger = true;
                }
              }
            }

            if (inDanger === false) {
              // console.log('safe: move_east');
              // currentInstruction.limit = 1;
              this.keyPressed[plyr.number - 1].east = true;
              this.players[plyr.number - 1].turnCheckerDirection = "east";
              // plyr.ai.currentInstruction++;
              if (currentInstruction.limit === 1) {
                plyr.ai.currentInstruction++;
              } else {
                if (currentInstruction.count < currentInstruction.limit) {
                  currentInstruction.count++;
                } else if (currentInstruction.count >= currentInstruction.limit) {
                  plyr.ai.currentInstruction++;
                }
              }
            } else {
              // console.log('danger: : move_east');
              plyr.ai.currentInstruction++;
              plyr.ai.resetInstructions = true;
            }
          }
          break;
        case "move_west":
          // console.log('ai act -- move_west');
          if (
            plyr.newMoveDelay.state !== true &&
            plyr.moving.state !== true &&
            !plyr.turning.state &&
            plyr.success.deflected.state !== true &&
            plyr.action === "idle"
          ) {
            let inDanger = false;
            if (plyr.direction === "west") {
              if (!targetCell) {
                // console.log('heading off the edge');
                inDanger = true;
              } else {
                if (
                  targetCell.void.state === true ||
                  targetCell.terrain.type === "deep" ||
                  targetCell.terrain.type === "hazard"
                ) {
                  // console.log('heading for mid-grid danger',targetCell.number);
                  inDanger = true;
                }
              }
            }

            if (inDanger === false) {
              // console.log('safe: move_west');
              // currentInstruction.limit = 1;
              this.keyPressed[plyr.number - 1].west = true;
              this.players[plyr.number - 1].turnCheckerDirection = "west";
              // plyr.ai.currentInstruction++;
              if (currentInstruction.limit === 1) {
                plyr.ai.currentInstruction++;
              } else {
                if (currentInstruction.count < currentInstruction.limit) {
                  currentInstruction.count++;
                } else if (currentInstruction.count >= currentInstruction.limit) {
                  plyr.ai.currentInstruction++;
                }
              }
            } else {
              // console.log('danger: move_west');
              plyr.ai.currentInstruction++;
              plyr.ai.resetInstructions = true;
            }
          }
          break;
        case "strafe_south":
          // console.log('ai act -- strafe_south');
          if (
            plyr.newMoveDelay.state !== true &&
            plyr.moving.state !== true &&
            !plyr.turning.state &&
            plyr.success.deflected.state !== true &&
            plyr.action === "idle"
          ) {
            let inDanger = false;
            // if (plyr.direction === 'south') {
            if (!targetCell) {
              // console.log('heading off the edge');
              inDanger = true;
            } else {
              if (
                targetCell.void.state === true ||
                targetCell.terrain.type === "deep" ||
                targetCell.terrain.type === "hazard"
              ) {
                // console.log('heading for mid-grid danger');
                inDanger = true;
              }
            }
            // }

            if (inDanger === false) {
              // currentInstruction.limit = 1;
              this.keyPressed[plyr.number - 1].strafe = true;
              this.keyPressed[plyr.number - 1].south = true;

              // this.players[plyr.number-1].turnCheckerDirection = 'south';
              // plyr.ai.currentInstruction++;
              if (currentInstruction.limit === 1) {
                plyr.ai.currentInstruction++;
              } else {
                if (currentInstruction.count < currentInstruction.limit) {
                  currentInstruction.count++;
                } else if (currentInstruction.count >= currentInstruction.limit) {
                  plyr.ai.currentInstruction++;
                }
              }
            } else {
              // console.log('danger');
              plyr.ai.currentInstruction++;
              plyr.ai.resetInstructions = true;
            }
          }
          break;
        case "strafe_north":
          // console.log('ai act -- strafe_north');
          if (
            plyr.newMoveDelay.state !== true &&
            plyr.moving.state !== true &&
            !plyr.turning.state &&
            plyr.success.deflected.state !== true &&
            plyr.action === "idle"
          ) {
            let inDanger = false;
            // if (plyr.direction === 'north') {
            if (!targetCell) {
              // console.log('heading off the edge');
              inDanger = true;
            } else {
              if (
                targetCell.void.state === true ||
                targetCell.terrain.type === "deep" ||
                targetCell.terrain.type === "hazard"
              ) {
                // console.log('heading for mid-grid danger');
                inDanger = true;
              }
            }
            // }

            if (inDanger === false) {
              // currentInstruction.limit = 1;
              this.keyPressed[plyr.number - 1].strafe = true;
              this.keyPressed[plyr.number - 1].north = true;

              // this.players[plyr.number-1].turnCheckerDirection = 'north';
              // plyr.ai.currentInstruction++;
              if (currentInstruction.limit === 1) {
                plyr.ai.currentInstruction++;
              } else {
                if (currentInstruction.count < currentInstruction.limit) {
                  currentInstruction.count++;
                } else if (currentInstruction.count >= currentInstruction.limit) {
                  plyr.ai.currentInstruction++;
                }
              }
            } else {
              // console.log('danger');
              plyr.ai.currentInstruction++;
              plyr.ai.resetInstructions = true;
            }
          }
          break;
        case "strafe_east":
          // console.log('ai act -- strafe_east');
          if (
            plyr.newMoveDelay.state !== true &&
            plyr.moving.state !== true &&
            !plyr.turning.state &&
            plyr.success.deflected.state !== true &&
            plyr.action === "idle"
          ) {
            let inDanger = false;
            // if (plyr.direction === 'east') {
            if (!targetCell) {
              // console.log('heading off the edge');
              inDanger = true;
            } else {
              if (
                targetCell.void.state === true ||
                targetCell.terrain.type === "deep" ||
                targetCell.terrain.type === "hazard"
              ) {
                // console.log('heading for mid-grid danger');
                inDanger = true;
              }
            }
            // }

            if (inDanger === false) {
              // currentInstruction.limit = 1;
              this.keyPressed[plyr.number - 1].strafe = true;
              this.keyPressed[plyr.number - 1].east = true;

              // this.players[plyr.number-1].turnCheckerDirection = 'east';
              // plyr.ai.currentInstruction++;
              if (currentInstruction.limit === 1) {
                plyr.ai.currentInstruction++;
              } else {
                if (currentInstruction.count < currentInstruction.limit) {
                  currentInstruction.count++;
                } else if (currentInstruction.count >= currentInstruction.limit) {
                  plyr.ai.currentInstruction++;
                }
              }
            } else {
              // console.log('danger');
              plyr.ai.currentInstruction++;
              plyr.ai.resetInstructions = true;
            }
          }
          break;
        case "strafe_west":
          // console.log('ai act -- strafe_west');
          if (
            plyr.newMoveDelay.state !== true &&
            plyr.moving.state !== true &&
            !plyr.turning.state &&
            plyr.success.deflected.state !== true &&
            plyr.action === "idle"
          ) {
            let inDanger = false;
            // if (plyr.direction === 'west') {
            if (!targetCell) {
              // console.log('heading off the edge');
              inDanger = true;
            } else {
              if (
                targetCell.void.state === true ||
                targetCell.terrain.type === "deep" ||
                targetCell.terrain.type === "hazard"
              ) {
                // console.log('heading for mid-grid danger');
                inDanger = true;
              }
            }
            // }

            if (inDanger === false) {
              // currentInstruction.limit = 1;
              this.keyPressed[plyr.number - 1].strafe = true;
              this.keyPressed[plyr.number - 1].west = true;

              // this.players[plyr.number-1].turnCheckerDirection = 'west';
              // plyr.ai.currentInstruction++;
              if (currentInstruction.limit === 1) {
                plyr.ai.currentInstruction++;
              } else {
                if (currentInstruction.count < currentInstruction.limit) {
                  currentInstruction.count++;
                } else if (currentInstruction.count >= currentInstruction.limit) {
                  plyr.ai.currentInstruction++;
                }
              }
            } else {
              // console.log('danger');
              plyr.ai.currentInstruction++;
              plyr.ai.resetInstructions = true;
            }
          }
          break;
        case "flank_north":
          // console.log('ai act -- flank_north');
          if (plyr.flanking.state !== true && plyr.action !== "flanking") {
            // console.log('flanking north @ ai act');
            // currentInstruction.limit = 1;
            this.keyPressed[plyr.number - 1].dodge = true;
            this.keyPressed[plyr.number - 1].north = true;
            if (currentInstruction.count < currentInstruction.limit) {
              currentInstruction.count++;
            } else if (currentInstruction.count >= currentInstruction.limit) {
              plyr.ai.currentInstruction++;
            }
          }
          break;
        case "flank_south":
          // console.log('ai act -- flank_south');
          if (plyr.flanking.state !== true && plyr.action !== "flanking") {
            // console.log('flanking south @ ai act');
            // currentInstruction.limit = 1;
            this.keyPressed[plyr.number - 1].dodge = true;
            this.keyPressed[plyr.number - 1].south = true;
            if (currentInstruction.count < currentInstruction.limit) {
              currentInstruction.count++;
            } else if (currentInstruction.count >= currentInstruction.limit) {
              plyr.ai.currentInstruction++;
            }
          }
          break;
        case "flank_east":
          // console.log('ai act -- flank_east');
          if (plyr.flanking.state !== true && plyr.action !== "flanking") {
            // console.log('flanking east @ ai act');
            // currentInstruction.limit = 1;
            this.keyPressed[plyr.number - 1].dodge = true;
            this.keyPressed[plyr.number - 1].east = true;
            if (currentInstruction.count < currentInstruction.limit) {
              currentInstruction.count++;
            } else if (currentInstruction.count >= currentInstruction.limit) {
              plyr.ai.currentInstruction++;
            }
          }
          break;
        case "flank_west":
          // console.log('ai act -- flank_west');
          if (plyr.flanking.state !== true && plyr.action !== "flanking") {
            // console.log('flanking west @ ai act');
            // currentInstruction.limit = 1;
            this.keyPressed[plyr.number - 1].dodge = true;
            this.keyPressed[plyr.number - 1].west = true;
            if (currentInstruction.count < currentInstruction.limit) {
              currentInstruction.count++;
            } else if (currentInstruction.count >= currentInstruction.limit) {
              plyr.ai.currentInstruction++;
            }
          }
          break;
        case "attack":
          // console.log('ai act -- attack');
          let atkPeak;
          if (plyr.currentWeapon.name === "") {
            atkPeak = plyr.attacking.animRef.peak.unarmed;
          } else {
            atkPeak = plyr.attacking.animRef.peak[plyr.currentWeapon.type];
          }
          currentInstruction.limit = atkPeak + 2;
          this.keyPressed[plyr.number - 1].attack = true;
          if (plyr.moving.state !== true) {
            if (currentInstruction.count < currentInstruction.limit) {
              currentInstruction.count++;
            } else if (currentInstruction.count >= currentInstruction.limit) {
              plyr.ai.currentInstruction++;
            }
          }
          break;
        case "long_defend":
          // console.log('ai act -- long defend');
          currentInstruction.limit = 25;
          this.keyPressed[plyr.number - 1].defend = true;
          if (currentInstruction.count < currentInstruction.limit) {
            currentInstruction.count++;
          } else if (currentInstruction.count >= currentInstruction.limit) {
            plyr.ai.currentInstruction++;
          }
          break;
        case "short_defend":
          // console.log('ai act -- short defend');
          currentInstruction.limit = 15;
          this.keyPressed[plyr.number - 1].defend = true;
          if (currentInstruction.count < currentInstruction.limit) {
            currentInstruction.count++;
          } else if (currentInstruction.count >= currentInstruction.limit) {
            plyr.ai.currentInstruction++;
          }
          break;
        case "dodge":
          // console.log('ai act -- dodge');
          currentInstruction.limit = 1;
          this.keyPressed[plyr.number - 1].dodge = true;
          if (currentInstruction.count < currentInstruction.limit) {
            currentInstruction.count++;
          } else if (currentInstruction.count >= currentInstruction.limit) {
            plyr.ai.currentInstruction++;
          }
          break;
        case "pickup":
          console.log("ai act -- pickup", currentInstruction.limit);
          // currentInstruction.limit = 10;
          // this.keyPressed[plyr.number-1].defend = true;
          this.keyPressed[plyr.number - 1].cycleWeapon = true;

          if (currentInstruction.count < currentInstruction.limit) {
            currentInstruction.count++;
          } else if (currentInstruction.count >= currentInstruction.limit) {
            plyr.ai.currentInstruction++;
          }
          break;
        case "drop_weapon":
          console.log("ai act -- drop_weapon");
          // currentInstruction.limit = 10;
          this.keyPressed[plyr.number - 1].defend = true;
          if (currentInstruction.count > 3) {
            this.keyPressed[plyr.number - 1].cycleWeapon = true;
          }

          if (currentInstruction.count < currentInstruction.limit) {
            currentInstruction.count++;
          } else if (currentInstruction.count >= currentInstruction.limit) {
            plyr.ai.currentInstruction++;
          }
          break;
      }

      if (plyr.ai.currentInstruction === plyr.ai.instructions.length) {
        // console.log('NO MORE INSTRUCTIONS!!');
        if (plyr.ai.engaging.state === true) {
          plyr.ai.engaging.state = false;
          plyr.ai.engaging.targetAction = "";
        }
      }
      if (plyr.ai.mission === "engage" && plyr.currentWeapon.type === "crossbow") {
        if (plyr.ai.currentInstruction === plyr.ai.instructions.length - 1) {
          if (plyr.ai.engaging.state === true) {
            plyr.ai.engaging.state = false;
            plyr.ai.engaging.targetAction = "";
          }
        }
      }

      let index = plyr.ai.instructions.indexOf(currentInstruction);
      if (
        index >= plyr.ai.instructions.length - 1 &&
        plyr.ai.mission === "patrol" &&
        plyr.ai.patrolling.checkin === "checkedIn"
      ) {
        // console.log('patrol instructions complete');
        plyr.ai.instructions = [];
        this.players[plyr.number - 1].ai.patrolling.loopControl = false;
      }
      if (
        index >= plyr.ai.instructions.length - 1 &&
        plyr.ai.mission === "defend" &&
        plyr.ai.defending.checkin === "checkedIn"
      ) {
        // console.log('defend instructions complete');
        plyr.ai.instructions = [];
      }
    } else {
      this.keyPressed[plyr.number - 1] = {
        north: false,
        south: false,
        east: false,
        west: false,
        northEast: false,
        northWest: false,
        southEast: false,
        southWest: false,
        attack: false,
        defend: false,
        strafe: false,
        cycleWeapon: false,
        cycleArmor: false,
        dodge: false,
        menu: false,
      };
    }
  };
  updatePathArray = () => {
    // console.log('updating pathArray');

    let pathArray = [];

    for (const [key, value] of Object.entries(this["levelData" + this.gridWidth])) {
      let row = [];
      for (const elem3 of value) {
        // let terrainInfo2 = elem3.length-1;
        // let cell = this.gridInfo.find(elem2 => elem2.levelData === elem3)
        //
        // if (cell) {
        //   let playerCell = false;
        //   for (const plyr of this.players) {
        //     if (
        //       plyr.currentPosition.cell.number.x === cell.number.x &&
        //       plyr.currentPosition.cell.number.y === cell.number.y
        //     ) {
        //       playerCell = true;
        //     }
        //   }
        //   if (playerCell === true) {
        //     row.push(0)
        //     // row.push(1)
        //   } else {
        //     if (
        //       elem3.charAt(terrainInfo2) === 'j' ||
        //       elem3.charAt(terrainInfo2) === 'h' ||
        //       elem3.charAt(terrainInfo2) === 'i' ||
        //       elem3.charAt(0) !== 'x' ||
        //       cell.void.state === true
        //     ) {
        //       row.push(1)
        //     } else {
        //       row.push(0)
        //     }
        //     // row.push(0)
        //   }
        // }

        row.push(0);
      }
      pathArray.push(row);
    }
    this.pathArray = pathArray;
  };

  gameLoop = () => {
    // IF PRESSED SETTINGS KEY, COUNT
    // PAUSE GAME IF SETTINGS OPENED
    if (this.showSettingsKeyPress.state === true) {
      if (this.showSettingsKeyPress.count < this.showSettingsKeyPress.limit) {
        this.showSettingsKeyPress.count++;
      }
      if (this.showSettingsKeyPress.count >= this.showSettingsKeyPress.limit) {
        if (this.state.showSettings !== true) {
          this.setState({
            showSettings: true,
          });
          if (this.showSettingsCanvasData.state === true) {
            this.settingsFormGridWidthUpdate(this.settingsGridWidth);
          }

          // this.redrawSettingsGrid();
        } else {
          // this.updateSettingsFormAiDataData = {};
          this.settingsFormAiStartPosList = [];
          this.setState({
            showSettings: false,
          });
        }
        this.showSettingsKeyPress = {
          state: false,
          count: 0,
          limit: this.showSettingsKeyPress.limit,
        };
      }
    }

    if (this.state.showSettings !== true) {
      // let ts = window.performance && window.performance.now ? window.performance.now() : new Date().getTime();
      this.stepper.currentTime = new Date().getTime();
      this.stepper.deltaTime = this.stepper.currentTime - this.stepper.lastTime;

      if (this.stepper.deltaTime > this.stepper.interval) {
        this.time++;

        if (this.time === 300) {
          //   this.openVoid = true;
          // OR
          //   this.customCellToVoid({x:2,y:2})
          // this.players[1].ai.retreating.state = false;
          // this.players[1].ai.retreating.checkin = undefined;
          // this.players[1].ai.mission = 'retreat';
          // this.players[1].ai.retreating.safe = false;
        }

        this.setState({
          stateUpdater: "..",
        });

        if (this.gamepad === true) {
          this.pollGamepads();
        }

        // REMOVE AI PLAYER!
        if (this.removeAi && this.addAiCount.state !== true) {
          let aiPlayer = this.players[this.removeAi - 1];
          let newArray = this.players.filter((x) => x !== aiPlayer);
          this.players = [];
          this.players = newArray;
          this.removeAi = undefined;
        }

        for (const player of this.players) {
          this.playerUpdate(
            player,
            this.state.canvas,
            this.state.context,
            this.state.canvas2,
            this.state.context2,
            this.state.canvas3,
            this.state.context3
          );
        }

        this.stepper.lastTime =
          this.stepper.currentTime - (this.stepper.deltaTime % this.stepper.interval);
      }
    }

    requestAnimationFrame(this.gameLoop);
  };
  playerUpdate = (player, canvas, context, canvas2, context2, canvas3, context3) => {
    // console.log('updating player',player.number,this.currentPlayer);

    let keyPressedDirection;
    if (player.ai.state === true && player.dead.state === true) {
    } else {
      for (const [key, value] of Object.entries(this.keyPressed[player.number - 1])) {
        // console.log(`${key}: ${value} ....${player.number}`);

        if (
          key !== "strafe" &&
          key !== "attack" &&
          key !== "defend" &&
          key !== "dodge" &&
          key !== "pull" &&
          key !== "kick" &&
          key !== "cycleWeapon" &&
          key !== "cycleArmor" &&
          key !== "discardWeapon" &&
          key !== "discardArmor" &&
          key !== "uiMenu" &&
          key !== "playerMenu" &&
          key !== "rotateRight" &&
          key !== "rotateLeft" &&
          value === true
        ) {
          // if (player.ai.state === true) {
          //   console.log('ai pressed',key,'plyr',player.number);
          // }
          // console.log('pressed1',key,'plyr',player.number);

          keyPressedDirection = key;
        }
        if (
          key !== "east" &&
          key !== "west" &&
          key !== "east" &&
          key !== "west" &&
          value === true
        ) {
          // console.log('pressed2',key,'plyr',player.number);
        }
      }
    }

    let nextPosition;

    if (this.time === 50 && player.number === 1) {
      this.toggleCameraCustomView();
      // this.setAutoCamera("test", player);
      // this.setAutoCamera('attackFocus',player);
      // this.setAutoCamera('attackFocusBreak',player);
      // this.setAutoCamera('playerSpawnFocus',player);
      // this.setAutoCamera('aiSpawnFocus',player);
      // this.setAutoCamera('pushbackPan',player);
      // this.setAutoCamera('followBolt',player);
      // console.log(
      //   "xxx",
      //   this.gridInfo.filter((x) => x.obstacle.state === true || x.barrier.state === true && x.).length
      // );
      // this.projectileTester(this.gridInfo.find((x) => x.number.x === 3 && x.number.y === 0));
      // let testTraps = this.customObstacleBarrierTrapSet("activateInactive", "");
      // let testTraps = this.customObstacleBarrierTrapSet("shuffleActive","")
      // let testTraps = this.customObstacleBarrierTrapSet("refreshActive","")
      // let testTraps = this.customObstacleBarrierTrapSet("setNewRandom", "");
      // let testTraps = this.customObstacleBarrierTrapSet(
      //   "setNewCustom",
      //   this.customTrapSetNewCustomTestData
      // );
      // for (const trap of testTraps) {
      //   this.gridInfo.find((x) => x.number.x === trap.location.x && x.number.y === trap.location.y)[trap.type].trap = trap.trap;
      // }
      // player = this.setElasticCounter("test", "start", true, player);
    }
    if (this.time === 100 && player.number === 2) {
      // this.pushBack(player, "east");
      // this.setDeflection(player, "parried", false);
      // let testTraps = this.customObstacleBarrierTrapSet("refreshActive", "");
    }

    // DYING
    if (player.dead.state === true) {
      if (player.dead.count > 0 && player.dead.count < player.dead.limit + 1) {
        player.dead.count++;
        // console.log('player',player.number,'dying',player.dead.count);
      } else if (player.dead.count >= player.dead.limit) {
        player.dead.count = 0;
      }
    }
    if (player.dead.state === true && player.dead.count === 0) {
      // console.log('done dying remove from board');
      player.nextPosition = {
        x: -30,
        y: -30,
      };
    }

    // OPEN VOID!!???
    if (this.openVoid === true) {
      if (this.cellToVoid.state !== true) {
        // console.log('set a new cell to void');

        let cell = {
          x: 0,
          y: 0,
        };

        let voidChance = Math.round(1000 / this.gridWidth);
        let openVoid = this.rnJesus(1, voidChance);

        if (openVoid === 1) {
          // console.log('boom');
          cell.x = this.rnJesus(0, this.gridWidth);
          cell.y = this.rnJesus(0, this.gridWidth);

          this.cellToVoid.state = true;
          this.cellToVoid.x = cell.x;
          this.cellToVoid.y = cell.y;
          this.cellToVoid.count = 1;
        }
      } else if (this.cellToVoid.state === true) {
        // console.log('already voiding a cell');
        if (this.cellToVoid.count < this.cellToVoid.limit) {
          this.cellToVoid.count++;
          // console.log('cv',this.cellToVoid.count);
        } else if (this.cellToVoid.count >= this.cellToVoid.limit) {
          // console.log('summon void now',this.cellToVoid.x,this.cellToVoid.y);

          let cell = {
            x: this.cellToVoid.x,
            y: this.cellToVoid.y,
          };

          this.voidSummon(cell);

          this.cellToVoid = {
            state: false,
            x: 0,
            y: 0,
            count: 0,
            limit: this.cellToVoid.limit,
          };

          if (this.voidCustomCell === true) {
            // console.log('void custom cell switch off');
            this.openVoid = false;
            this.voidCustomCell = false;
          }
        }
      }
    }
    // LIMIT CELL VOID EVENT!!
    if (this.voidTimer.count < this.voidTimer.limit) {
      this.voidTimer.count++;
      // console.log('void count',this.voidTimer.count);
    }
    if (this.voidTimer.count >= this.voidTimer.limit) {
      this.openVoid = false;
      // console.log('void off');
    }

    // BLOOD SACRIFICE!!
    if (this.bloodSacrificeEvent.state === true) {
      if (this.bloodSacrificeEvent.count < this.bloodSacrificeEvent.limit) {
        this.bloodSacrificeEvent.count++;
      } else if (this.bloodSacrificeEvent.count >= this.bloodSacrificeEvent.limit) {
        if (this.cellToVoid.state !== true) {
          this.bloodSacrificeEvent.state = false;
          this.openVoid = false;
          console.log("Blood Sacrifice event is now over.");
          if (this.bloodSacrificeEvent.restore === true) {
            for (const cell of this.bloodSacrificeVoidedCells) {
              // console.log('restoring cells after blood Sacrifice',cell);
              if (cell.terrain.name !== "void") {
                cell.void.state = false;
              }
            }

            this.bloodSacrificeVoidedCells = [];
            this.bloodSacrificeEvent.restore = false;
          }
        }
      }
    }

    // STAMINA!!
    if (player.stamina.current < player.stamina.max) {
      player.stamina.current += 0.05;
      player.stamina.current = +(
        Math.round(player.stamina.current + "e+" + 3) +
        "e-" +
        3
      );

      if (player.stamina.current >= player.stamina.max) {
        player.stamina.current = player.stamina.max;
      }
      if (player.stamina.current < 0) {
        // console.log('stamina lower limit reset for player ',player.number);
        player.stamina.current = 0;
      }
      if (player.stamina.current === 1) {
        // console.log('OUT OF STAMINA @ player update');
        player.flanking = {
          checking: false,
          preFlankDirection: "",
          direction: "",
          state: false,
          step: 0,
          target1: { x: 0, y: 0 },
          target2: { x: 0, y: 0 },
        };
        player.dodging = {
          countState: false,
          state: false,
          count: 0,
          limit: player.dodging.limit,
          peak: {
            start: player.dodging.peak.start,
            end: player.dodging.peak.end,
          },
          direction: "",
        };

        this.attackedCancel(player);

        if (player.success.deflected.state !== true) {
          this.setDeflection(player, "outOfStamina", false);
        }

        if (!player.popups.find((x) => x.msg === "outOfStamina")) {
          player.popups.push({
            state: false,
            count: 0,
            limit: 20,
            type: "",
            position: "",
            msg: "outOfStamina",
            img: "",
          });
        }
      }

      // AI RETREAT ON LOW STAMINA
      if (player.stamina.current <= 4) {
        if (player.ai.state === true) {
          console.log("ai player", player.number, " almost out of stamina. Retreat");
          player.ai.mission = "retreat";

          if (!player.popups.find((x) => x.msg === "missionRetreat")) {
            player.popups.push({
              state: false,
              count: 0,
              limit: 30,
              type: "",
              position: "",
              msg: "missionRetreat",
              img: "",
            });
          }
        }
      }
    }

    // CHECK AND SET DEFLECTION!!
    // if (player.success.deflected.state === true && player.success.deflected.count < player.success.deflected.limit && player.success.deflected.predeflect !== true) {
    if (
      player.success.deflected.state === true &&
      player.success.deflected.count < player.success.deflected.limit
    ) {
      player.action = "deflected";
      player.success.deflected.count++;

      if (player.success.deflected.count === 2) {
        // console.log('count',player.success.deflected.count,'limit',player.success.deflected.limit,'type',player.success.deflected.type);

        if (
          player.success.deflected.type === "bluntAttacked" ||
          player.success.deflected.type === "defended"
        ) {
          if (!player.popups.find((x) => x.msg === "guardBroken")) {
            player.popups.push({
              state: false,
              count: 0,
              limit: player.success.deflected.limit,
              type: "",
              position: "",
              msg: "guardBroken",
              img: "",
            });
          }
        }

        if (player.success.deflected.type === "parried") {
          if (!player.popups.find((x) => x.msg === "attackParried")) {
            player.popups.push({
              state: false,
              count: 0,
              limit: player.success.deflected.limit,
              type: "",
              position: "",
              msg: "attackParried",
              img: "",
            });
          }
        }
        if (player.success.deflected.type === "attacked") {
          if (!player.popups.find((x) => x.msg === "injured")) {
            player.popups.push({
              state: false,
              count: 0,
              limit: player.success.deflected.limit,
              type: "",
              position: "",
              msg: "injured",
              img: "",
            });
          }
        }
        if (player.success.deflected.type === "outOfStamina") {
          if (!player.popups.find((x) => x.msg === player.success.deflected.type)) {
            player.popups.push({
              state: false,
              count: 0,
              limit: player.success.deflected.limit,
              type: "",
              position: "",
              msg: player.success.deflected.type,
              img: "",
            });
          }
        }
      }

      // if (player.ai.state === true) {
      //   player.ai.instructions = []
      //   player.ai.currentInstruction = 0
      //   if (player.ai.mission === 'engage') {
      //     player.ai.engaging.targetAction = ''
      //   }
      // }
    }
    //END DEFLECTION, SPIN & DROP
    else if (
      player.success.deflected.state === true &&
      player.success.deflected.count >= player.success.deflected.limit
    ) {
      // console.log('deflect end',player.success.deflected.type);
      // DEFLECT SPIN!
      let shouldSpin;
      if (player.success.deflected.type === "attacked") {
        shouldSpin = this.rnJesus(1, 5);
      }
      if (player.success.deflected.type === "defended") {
        shouldSpin = this.rnJesus(1, 10);
      }

      if (player.success.deflected.type === "outOfStamina") {
        shouldSpin = this.rnJesus(1, 2);
      }
      if (player.success.deflected.type === "parried") {
        shouldSpin = 1;
      }
      let newDirection;
      if (shouldSpin === 1) {
        switch (player.direction) {
          case "north":
            if (shouldSpin === 1) {
              newDirection = "east";
            } else {
              newDirection = "west";
            }
            break;
          case "south":
            if (shouldSpin === 1) {
              newDirection = "east";
            } else {
              newDirection = "west";
            }
            break;
          case "east":
            if (shouldSpin === 1) {
              newDirection = "north";
            } else {
              newDirection = "south";
            }
            break;
          case "west":
            if (shouldSpin === 1) {
              newDirection = "north";
            } else {
              newDirection = "south";
            }
            break;
        }
        player.direction = newDirection;
      }

      player.action = "idle";

      this.unsetDeflection(player);

      // CANCEL AI ATTACK, DEFEND!!
      if (player.ai.state === true) {
        if (player.ai.state === true) {
          player.attacking = {
            state: false,
            count: 0,
            limit: player.attacking.limit,
            strength: 0,
            direction: "",
            directionType: "", //thrust or slash
            animRef: player.attacking.animRef,
            peak: false,
            peakCount: 0,
            charge: 0,
            chargePeak: false,
            blunt: false,
            clashing: {
              state: false,
              count: 0,
              limit: player.attacking.clashing.limit,
            },
          };
        }

        player.defending = {
          state: false,
          count: 0,
          limit: player.defending.limit,
          animRef: player.defending.animRef,
          peak: false,
          peakCount: 0,
          decay: {
            state: false,
            count: 0,
            limit: player.defending.decay.limit,
          },
          direction: "",
          directionType: "", //thrust or slash
        };

        player.ai.targetAqcuiredReset = true;
      }

      if (player.dead.state !== true && player.falling.state !== true) {
        let shouldDeflectDrop = this.rnJesus(1, player.crits.guardBreak);
        if (shouldDeflectDrop === 1) {
          this.deflectDrop(player);
        }
      }
    }

    // CELLS TO HIGHLIGHT V2!!
    for (const cell3 of this.cellsToHighlight2) {
      if (cell3.limit > 0) {
        if (cell3.count < cell3.limit) {
          cell3.count++;
        } else if (cell3.count >= cell3.limit) {
          let index = this.cellsToHighlight2.indexOf(cell3);
          this.cellsToHighlight2.splice(index, 1);
        }
      }
    }

    // MOUSED OVER CELL
    if (
      this.mouseOverCell.cell &&
      this.mouseOverCell.state === false &&
      this.mouseMoving !== true
    ) {
      if (this.mouseOverCell.count < this.mouseOverCell.threshold) {
        this.mouseOverCell.count++;
        // console.log('mouse not moving but moused over cell is counting',this.mouseOverCell.count);
      }
      if (this.mouseOverCell.count >= this.mouseOverCell.threshold) {
        this.mouseOverCell.count = 0;
        this.mouseOverCell.state = true;
        this.clicked.cell = this.mouseOverCell.cell;
        let plyrPresent = false;
        for (const plyr of this.players) {
          if (
            plyr.currentPosition.cell.number.x === this.mouseOverCell.cell.number.x &&
            plyr.currentPosition.cell.number.y === this.mouseOverCell.cell.number.y
          ) {
            this.clicked.player = plyr;
            plyrPresent = true;
          }
        }
        if (plyrPresent !== true) {
          this.clicked.player = undefined;
        }
        this.showCellInfoBox = true;
      }
    }
    // SWITCH OFF ATER TIME IF MOUSE MOVED OUT OF GRID
    if (this.mouseOverCellSwitchOff.state === true) {
      if (this.mouseOverCellSwitchOff.count < this.mouseOverCellSwitchOff.limit) {
        this.mouseOverCellSwitchOff.count++;
      }
      if (this.mouseOverCellSwitchOff.count >= this.mouseOverCellSwitchOff.limit) {
        this.mouseOverCellSwitchOff = {
          state: false,
          count: 0,
          limit: this.mouseOverCellSwitchOff.limit,
        };
        this.showCellInfoBox = false;
        this.mouseOverCell = {
          state: false,
          cell: undefined,
          count: 0,
          threshold: this.mouseOverCell.threshold,
        };
      }
    }
    this.mouseMoving = false;

    // DEFLECTED PLAYER CAN'T DO ANYTHING!!
    if (
      player.success.deflected.state === false &&
      player.dead.state !== true &&
      this.camera.state !== true
    ) {
      // AI STRAFE SWITCH ON!!
      if (player.ai.state === true && this.keyPressed[player.number - 1]) {
        if (this.keyPressed[player.number - 1].strafe === true) {
          this.players[player.number - 1].strafing.state = true;
        }
      }

      // MOVE CANCEL/RETURN
      if (player.moving.state === true) {
        // console.log("player ", player.number, " ", player.action, " : ", player.moving.step);
        let canCancelMove = false;

        if (
          this.keyPressed[player.number - 1].north === true ||
          this.keyPressed[player.number - 1].south === true ||
          this.keyPressed[player.number - 1].east === true ||
          this.keyPressed[player.number - 1].west === true
        ) {
          let oldDirection;
          let newDirection;
          if (this.keyPressed[player.number - 1].north === true) {
            newDirection = "north";
          }
          if (this.keyPressed[player.number - 1].south === true) {
            newDirection = "south";
          }
          if (this.keyPressed[player.number - 1].east === true) {
            newDirection = "east";
          }
          if (this.keyPressed[player.number - 1].west === true) {
            newDirection = "west";
          }
          if (player.strafing.state === true) {
            if (newDirection === this.getOppositeDirection(player.strafing.direction)) {
              canCancelMove = true;
            }
            oldDirection = player.strafing.direction;
          } else {
            if (newDirection === this.getOppositeDirection(player.direction)) {
              canCancelMove = true;
            }
            oldDirection = player.direction;
          }

          if (
            player.drowning === true ||
            player.pushBack.state === true ||
            player.falling.state === true ||
            player.pushing.state === true ||
            player.pulling.state === true ||
            player.pushed.state === true ||
            player.pulled.state === true
          ) {
            canCancelMove = false;
            console.log(
              "cannot cancel move when being pushed back, falling, drowning, pulling, pushing, and being pushed or pulled"
            );
          }

          if (player.moveCancel.state !== true && canCancelMove === true) {
            // console.log("new input direction", newDirection, player.moving.step);
            // player.speed.move = 0.2;
            let inTime = false;
            let inTimeThresh;
            let threshIndx;
            if (player.jumping.state === true) {
              inTimeThresh = 0.4;
            } else {
              let indx3 = player.speed.range.indexOf(player.speed.move);
              threshIndx = Math.ceil(this.moveStepRef[indx3].length / 2);
              // inTimeThresh = this.moveStepRef[indx3][threshIndx];
              inTimeThresh = this.moveStepRef[indx3][threshIndx + 1];
              // console.log("inTimeThresh", inTimeThresh, "step", player.moving.step);
            }
            if (player.moving.step < inTimeThresh) {
              inTime = true;
            }

            if (inTime === true) {
              if (player.stamina.current - this.staminaCostRef.move >= 0) {
                player.stamina.current -= this.staminaCostRef.move;

                this.moveSpeed = player.speed.move;
                if (player.jumping.state === true) {
                  player.jumping = {
                    checking: false,
                    state: false,
                  };
                }
                if (player.flanking.state === true) {
                  player.flanking = {
                    checking: false,
                    preFlankDirection: "",
                    direction: "",
                    state: false,
                    step: 0,
                    target1: { x: 0, y: 0 },
                    target2: { x: 0, y: 0 },
                  };
                }
                let originalDest = player.target.cell1;

                player.moveCancel = {
                  state: true,
                  oldDirection: oldDirection,
                  newDirection: newDirection,
                  returningTo: {},
                  returningFrom: {},
                };

                if (player.strafing.state !== true) {
                  player.strafing.state = true;
                  player.strafing.direction = newDirection;
                } else {
                  if (
                    player.strafing.direction ===
                    this.getOppositeDirection(player.direction)
                  ) {
                    player.strafing.state = false;
                    player.strafing.direction = "";
                  } else {
                    player.strafing.direction = newDirection;
                  }
                }

                let newTarget = this.getTarget(player);

                let indx3 = player.speed.range.indexOf(player.speed.move);
                let indx4 = this.moveStepRef[indx3].indexOf(player.moving.step);
                let newIndx = this.moveStepRef[indx3].length - (indx4 + 1);
                let newStep = this.moveStepRef[indx3][newIndx - 1];

                // // move speeds
                // [0.05, 0.1, 0.125, 0.2],
                // // Move speed step indices
                // [
                //   0.05, 0.1, 0.15, 0.2, 0.25, 0.3, 0.35, 0.4, 0.45, 0.5, 0.55, 0.6, 0.65, 0.7, 0.75, 0.8,
                //   0.85, 0.9, 0.95, 1,
                // ],
                // [0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1],
                // [0.125, 0.25, 0.375, 0.5, 0.625, 0.75, 0.875, 1],
                // [0.2, 0.4, 0.6, 0.8, 1],

                player.action = "moving";
                player.moving = {
                  state: true,
                  step: newStep,
                  course: "",
                  origin: {
                    number: originalDest.number,
                    center: originalDest.center,
                  },
                  destination: newTarget.cell1.center,
                };

                nextPosition = this.lineCrementer(player);
                player.nextPosition = nextPosition;
                // console.log(
                //   "can move cancel/ return: starting"
                //   // originalDest.number,
                //   // newTarget.cell1.number,
                // );

                if (
                  this.mouseOverCell.state === true &&
                  this.mouseOverCell.cell.number.x ===
                    player.currentPosition.cell.number.x &&
                  this.mouseOverCell.cell.number.y ===
                    player.currentPosition.cell.number.y
                ) {
                  this.clicked.player = player;
                }
              } else {
                player.stamina.current = 0;
                player.statusDisplay = {
                  state: true,
                  status: "Out of Stamina",
                  count: 0,
                  limit: player.statusDisplay.limit,
                };
              }
            } else {
              console.log("too late to move cancel. move step is", player.moving.step);
            }
          } else if (player.moveCancel.state === true) {
            // console.log("already move cancelling");
          }
        }
      }
      // DON'T READ INPUTS. JUST MOVE!!
      if (player.moving.state === true) {
        // console.log("player ", player.number, " ", player.action, " : ", player.moving.step);

        nextPosition = this.lineCrementer(player);
        player.nextPosition = nextPosition;
        if (player.moveCancel.state === true) {
          // console.log(
          //   "move cancel/ returning...",
          //   player.moving.step,
          //   nextPosition,
          //   player.currentPosition.cell.numbers
          // );
        }

        let atDestRanges1 = [false, false, false, false];
        let atDestRanges2 = [false, false, false, false];
        let refCell1 = this.gridInfo.find(
          (x) =>
            x.number.x === player.target.cell1.number.x &&
            x.number.y === player.target.cell1.number.y
        );
        let refCell2 = this.gridInfo.find(
          (x) =>
            x.number.x === player.target.cell2.number.x &&
            x.number.y === player.target.cell2.number.y
        );

        if (player.target.cell1.void === true) {
          if (player.falling.state === true) {
            // console.log('...');
          } else {
            player.action = "moving";
            // console.log('stepping into the void',player.action,player.moving.step);
          }
        }

        if (player.jumping.state !== true) {
          let destRngIndx = undefined;

          if (
            nextPosition.x >= player.target.cell1.center.x - 1 &&
            nextPosition.x <= player.target.cell1.center.x + 1 &&
            nextPosition.y >= player.target.cell1.center.y - 1 &&
            nextPosition.y <= player.target.cell1.center.y + 1
          ) {
            atDestRanges1[0] = true;
            destRngIndx = 0;
          }
          if (
            nextPosition.x === player.target.cell1.center.x - 0.25 &&
            nextPosition.y === player.target.cell1.center.y + 0.5
          ) {
            atDestRanges1[1] = true;
            destRngIndx = 1;
          }
          if (
            nextPosition.x === player.target.cell1.center.x &&
            nextPosition.y === player.target.cell1.center.y
          ) {
            atDestRanges1[2] = true;
            destRngIndx = 2;
          }
          if (
            nextPosition.x === player.target.cell1.center.x - 5 &&
            nextPosition.y === player.target.cell1.center.y - 5
          ) {
            atDestRanges1[3] = true;
            destRngIndx = 3;
          }

          // FLANKING POPUP 1
          if (player.flanking.state === true || player.action === "flanking") {
            // console.log('flanking moving');
            if (!player.popups.find((x) => x.msg === "flanking2")) {
              player.popups.push({
                state: false,
                count: 0,
                limit: 20,
                type: "",
                position: "",
                msg: "flanking2",
                img: "",
              });
            }
          }
          if (player.popups.find((x) => x.msg === "dodging")) {
            player.popups.splice(
              player.popups.findIndex((x) => x.msg === "dodging"),
              1
            );
          }

          for (const el of atDestRanges1) {
            if (el === true) {
              let indx = atDestRanges1.indexOf(el);

              player.newMoveDelay.state = true;

              if (refCell1) {
                player.currentPosition.cell.number = player.target.cell1.number;
                player.currentPosition.cell.center = player.target.cell1.center;
              }

              player.action = "idle";
              player.moving = {
                state: false,
                step: 0,
                course: "",
                origin: {
                  number: {
                    x: player.target.cell1.number.x,
                    y: player.target.cell1.number.y,
                  },
                  center: {
                    x: player.target.cell1.center.x,
                    y: player.target.cell1.center.y,
                  },
                },
                destination: {
                  x: 0,
                  y: 0,
                },
              };

              if (player.strafing.state === true) {
                if (
                  player.pulling.state === true ||
                  player.pushed.state === true ||
                  player.pulled.state === true
                ) {
                  // player.strafing.direction = '';
                  player.strafeReleaseHook = true;
                }

                // CONTINUOUS STRAFING CHECK
                if (this.keyPressed[player.number - 1].strafe !== true) {
                  // console.log("continuous strafe check");
                  player.strafing.state = false;
                  player.strafing.direction = "";
                } else {
                  // console.log("continuous strafe check 2", player.moveCancel.state);
                  if (player.moveCancel.state === true) {
                    player.strafing.state = false;
                  }
                  player.strafing.direction = "";
                }
              }

              // PULLED, PUSHED PLAYERS
              if (player.pushing.state === true) {
                player.pushing = {
                  state: false,
                  targetCell: undefined,
                  moveSpeed: 0,
                };
              }
              if (player.pulling.state === true) {
                player.pulling = {
                  state: false,
                  targetCell: undefined,
                  moveSpeed: 0,
                };
                player.postPull.state = true;
              }
              let deflectPullPushedPlayer = false;
              if (player.pulled.state === true) {
                player.pulled = {
                  state: false,
                  puller: 0,
                  moveSpeed: 0,
                };
                deflectPullPushedPlayer = true;
              }
              if (player.pushed.state === true) {
                player.pushed = {
                  state: false,
                  pusher: 0,
                  moveSpeed: 0,
                };
                deflectPullPushedPlayer = true;
              }
              // PUSHED & PULLED PLAYERS DEFLECT?
              if (
                deflectPullPushedPlayer === true &&
                this.gridInfo.find(
                  (x) =>
                    x.number.x === player.currentPosition.cell.number.x &&
                    x.number.y === player.currentPosition.cell.number.y
                ).terrain.type !== "deep"
              ) {
                // console.log('pulled pushed player at destination. deflect?');

                if (this.rnJesus(1, player.crits.guardBreak) === 1) {
                  this.setDeflection(player, "bluntAttacked", false);
                }
              }

              // PUSHBACK MOVEMENT
              if (player.pushBack.state === true) {
                // console.log('player',player.number,'finished moving pushed back',player.flanking.state);

                // CANCEL AI ATTACK, DEFEND!!
                if (player.ai.state === true) {
                  if (player.ai.state === true) {
                    player.attacking = {
                      state: false,
                      count: 0,
                      limit: player.attacking.limit,
                      strength: 0,
                      direction: "",
                      directionType: "", //thrust or slash
                      animRef: player.attacking.animRef,
                      peak: false,
                      peakCount: 0,
                      charge: 0,
                      chargePeak: false,
                      blunt: false,
                      clashing: {
                        state: false,
                        count: 0,
                        limit: player.attacking.clashing.limit,
                      },
                    };
                  }

                  player.defending = {
                    state: false,
                    count: 0,
                    limit: player.defending.limit,
                    animRef: player.defending.animRef,
                    peak: false,
                    peakCount: 0,
                    decay: {
                      state: false,
                      count: 0,
                      limit: player.defending.decay.limit,
                    },
                    direction: "",
                    directionType: "", //thrust or slash
                  };

                  player.ai.targetAqcuiredReset = true;
                }

                player.pushBack.state = false;
                player.strafing = {
                  state: false,
                  direction: "",
                };
                player.speed.move = player.pushBack.prePushMoveSpeed;
              }
              if (player.moveCancel.state === true) {
                // console.log("arrived! reset move cancel");
                player.moveCancel.state = false;
              }

              if (!refCell1) {
                player.falling.state = true;
                player.action = "falling";

                this.players[player.number - 1].moving = {
                  state: true,
                  step: 0,
                  course: "",
                  origin: {
                    number: player.currentPosition.cell.number,
                    center: player.currentPosition.cell.center,
                  },
                  destination: {
                    x: player.currentPosition.cell.center.x,
                    y: player.currentPosition.cell.center.y,
                  },
                };

                nextPosition = this.lineCrementer(player);
                this.players[player.number - 1].nextPosition = nextPosition;

                if (!player.popups.find((x) => x.msg === "falling")) {
                  player.popups.push({
                    state: false,
                    count: 0,
                    limit: 30,
                    type: "",
                    position: "",
                    msg: "falling",
                    img: "",
                  });
                }
              } else {
                if (
                  player.drowning !== true &&
                  player.dead.state !== true &&
                  player.pushBack.state !== true
                ) {
                  this.getTarget(player);
                }

                this.checkDestination(player, false);

                if (refCell1.obstacle.state === true) {
                  this.obstaclePlayerOverlap(
                    "player",
                    refCell2,
                    player,
                    refCell1.obstacle
                  );
                }
              }
              break;
            }
          }
        }

        if (player.jumping.state === true) {
          // console.log(
          //   "mid jump",
          //   player.moving.step
          //   // player.currentPosition.cell.number,
          // );

          if (
            nextPosition.x >= player.target.cell1.center.x - 1 &&
            nextPosition.x <= player.target.cell1.center.x + 1 &&
            nextPosition.y >= player.target.cell1.center.y - 1 &&
            nextPosition.y <= player.target.cell1.center.y + 1
          ) {
            atDestRanges1[0] = true;
          }
          if (
            nextPosition.x === player.target.cell1.center.x - 0.25 &&
            nextPosition.y === player.target.cell1.center.y + 0.5
          ) {
            atDestRanges1[1] = true;
          }
          if (
            nextPosition.x === player.target.cell1.center.x &&
            nextPosition.y === player.target.cell1.center.y
          ) {
            atDestRanges1[2] = true;
          }
          if (
            nextPosition.x === player.target.cell1.center.x - 5 &&
            nextPosition.y === player.target.cell1.center.y - 5
          ) {
            atDestRanges1[3] = true;
          }

          for (const el of atDestRanges1) {
            if (el === true) {
              let blocked = false;
              let blockType = "";

              if (refCell2.barrier.state === true) {
                if (
                  refCell2.barrier.position ===
                  this.getOppositeDirection(player.direction)
                ) {
                  blocked = true;
                  blockType = "cell2";
                }
              }

              // CHECK 1ST CELL 2ND BECAUSE OF OVERWRITE W/ BARRIERS IN 2 CELLS
              if (refCell1.barrier.state === true) {
                if (refCell1.barrier.position === player.direction) {
                  blocked = true;
                  blockType = "cell1";
                }
              }

              if (blocked === true) {
                this.jumpCollisionCheck("barrier", blockType, player);

                // console.log('barrier bloackage ',blockType);
              }

              // console.log("@ mid jump cell 1", player.target.cell1.number);
              break;
            }
          }

          if (
            nextPosition.x >= player.target.cell2.center.x - 1 &&
            nextPosition.x <= player.target.cell2.center.x + 1 &&
            nextPosition.y >= player.target.cell2.center.y - 1 &&
            nextPosition.y <= player.target.cell2.center.y + 1
          ) {
            atDestRanges2[0] = true;
          }
          if (
            nextPosition.x === player.target.cell2.center.x - 0.25 &&
            nextPosition.y === player.target.cell2.center.y + 0.5
          ) {
            atDestRanges2[1] = true;
          }
          if (
            nextPosition.x === player.target.cell2.center.x &&
            nextPosition.y === player.target.cell2.center.y
          ) {
            atDestRanges2[2] = true;
          }
          if (
            nextPosition.x === player.target.cell2.center.x - 5 &&
            nextPosition.y === player.target.cell2.center.y - 5
          ) {
            atDestRanges2[3] = true;
          }

          for (const el of atDestRanges2) {
            if (el === true) {
              // console.log("at jump destination", player.target.cell2.number);
              // console.log('next position is destination a',player.number);
              player.newMoveDelay.state = true;

              let blocked = false;
              let blockType = "";
              let blockSubType = "";

              for (const plyr of this.players) {
                if (
                  plyr.number !== player.number &&
                  plyr.moving.state !== true &&
                  plyr.currentPosition.cell.number.x === player.target.cell2.number.x &&
                  plyr.currentPosition.cell.number.y === player.target.cell2.number.y
                ) {
                  blocked = true;
                  blockType = "player";
                  blockSubType = "cell2";
                }
              }

              if (refCell2.obstacle.state === true) {
                blocked = true;
                blockType = "obstacle";
                blockSubType = "cell2";
              }

              if (blocked === true) {
                this.jumpCollisionCheck(blockType, blockSubType, player);
              }

              if (blocked !== true) {
                player.jumping.state = false;
                player.currentPosition.cell.number = player.target.cell2.number;
                player.currentPosition.cell.center = player.target.cell2.center;
                player.strafing.state = false;
                player.action = "idle";
                player.moving = {
                  state: false,
                  step: 0,
                  course: "",
                  origin: {
                    number: {
                      x: player.target.cell2.number.x,
                      y: player.target.cell2.number.y,
                    },
                    center: {
                      x: player.target.cell2.center.x,
                      y: player.target.cell2.center.y,
                    },
                  },
                  destination: {
                    x: 0,
                    y: 0,
                  },
                };

                if (player.pushBack.state !== true) {
                  this.getTarget(player);
                }

                if (refCell2.obstacle.state === true) {
                  this.obstaclePlayerOverlap(
                    "player",
                    refCell2,
                    player,
                    refCell2.obstacle
                  );
                }

                this.checkDestination(player, false);

                // console.log('no blockage. Arrived at jump dest');
              }

              break;
            }
          }
        }
      }

      // CAN READ INPUTS
      else if (player.moving.state === false) {
        // COLLISION/ MOVEMENT OVERLAP PUSHBACK!!
        // if neither is pulling/pushng or pulled/pushed
        for (const plyr4 of this.players) {
          if (
            player.number !== plyr4.number &&
            player.currentPosition.cell.number.x ===
              plyr4.currentPosition.cell.number.x &&
            player.currentPosition.cell.number.y ===
              plyr4.currentPosition.cell.number.y &&
            player.pushBack.state !== true &&
            plyr4.pushBack.state !== true &&
            plyr4.dead.state !== true
          ) {
            let nopushpull = true;
            if (
              player.pulled.state === true ||
              player.pushed.state === true ||
              player.pulling.state === true ||
              player.pushing.state === true ||
              plyr4.pulled.state === true ||
              plyr4.pushed.state === true ||
              plyr4.pulling.state === true ||
              plyr4.pushing.state === true
            ) {
              nopushpull = false;
              // console.log('player cell overlap but 1 is pushing/pulling the other');
            }
            // console.log('buck up btwn plyrs',player.number,plyr4.number,"@",player.currentPosition.cell.number,plyr4.currentPosition.cell.number);
            // console.log('plyrs pushed back?',player.pushBack.state,plyr4.pushBack.state);
            // console.log('plyrs moving?',player.moving.state,plyr4.moving.state);
            if (nopushpull === true) {
              let playerAPushDir2 = this.getOppositeDirection(plyr4.direction);
              let playerBPushDir2 = this.getOppositeDirection(player.direction);

              if (player.flanking.state === true || player.action === "flanking") {
                player.flanking = {
                  checking: false,
                  direction: "",
                  state: false,
                  step: 0,
                  target1: { x: 0, y: 0 },
                  target2: { x: 0, y: 0 },
                };
                player.action = "idle";
              }
              if (plyr4.flanking.state === true || plyr4.action === "flanking") {
                plyr4.flanking = {
                  checking: false,
                  direction: "",
                  state: false,
                  step: 0,
                  target1: { x: 0, y: 0 },
                  target2: { x: 0, y: 0 },
                };
                plyr4.action = "idle";
              }
              // playerAPushDir2 = "north";
              if (playerAPushDir2 === playerBPushDir2) {
                playerBPushDir2 = ["north", "south", "east", "west"].filter(
                  (x) => x !== playerAPushDir2
                )[0];
              }
              let canPush = this.pushBack(plyr4, playerAPushDir2);
              let canPush2 = this.pushBack(player, playerBPushDir2);
            }
          }
        }

        // // IDLE ANIM STEPPER!
        if (player.action === "idle") {
          // player.idleAnim.state = true
          if (player.idleAnim.count < player.idleAnim.limit) {
            // console.log('player.idleAnim.count',player.idleAnim.count);
            player.idleAnim.count++;
          }
          if (player.idleAnim.count >= player.idleAnim.limit) {
            player.idleAnim.count = 0;
            player.idleAnim.state = false;
          }
        } else if (player.action !== "idle") {
          // player.idleAnim.state = false;
          player.idleAnim.count = 0;
        }

        // TURNER!!
        if (player.turning.state === true && player.flanking.state !== true) {
          if (player.turning.delayCount < player.turning.limit) {
            player.turning.delayCount++;
            // console.log('turning...',player.turning.delayCount);
          }
          if (player.turning.delayCount >= player.turning.limit) {
            player.direction = player.turning.toDirection;
            player.turnCheckerDirection = "";
            player.turning = {
              state: false,
              toDirection: "",
              delayCount: 0,
              limit: player.turning.limit,
            };

            this.getTarget(player);
            // console.log('turned/ turn complete');
          }
        }

        // KEY PRESS RELEASE CHECKS!!

        // DEFEND FEINT
        if (
          this.keyPressed[player.number - 1].defend === false &&
          player.defending.state === true
        ) {
          // console.log('player',player.number,' defend key release');
          let canFeint = false;

          let defendType = player.currentWeapon.type;
          if (player.currentWeapon.name === "") {
            defendType = "unarmed";
          }

          if (player.defending.decay.state !== true) {
            if (player.defending.count < player.defending.peakCount) {
              canFeint = true;
            }
          } else {
            if (
              player.defending.decay.count < player.defending.decay.limit &&
              player.defending.peak !== true
            ) {
              canFeint = true;
            }
          }
          if (canFeint === true) {
            player.defending = {
              state: false,
              count: 0,
              limit: player.defending.limit,
              animRef: player.defending.animRef,
              peak: false,
              peakCount: 0,
              decay: {
                state: false,
                count: 0,
                limit: player.defending.decay.limit,
              },
              direction: "",
              directionType: "", //thrust or slash
            };
            player.action = "idle";

            player.stamina.current += this.staminaCostRef.defend.pre;

            if (player.popups.find((x) => x.msg === "defending")) {
              player.popups.splice(
                player.popups.findIndex((x) => x.msg === "defending"),
                1
              );
            }
            if (player.falling.state !== true && player.moving.state !== true) {
              player.action = "idle";
            }

            // RESET ELASTIC COUNTER
            if (
              player.elasticCounter.state === true &&
              player.elasticCounter.type === "defending"
            ) {
              player.elasticCounter.state = false;
            }

            if (this.camera.customView.state !== true && player.ai.state !== true) {
              this.setAutoCamera("defendFocusBreak", player);
            }

            console.log("defend feinted");
          } else {
            if (player.defending.peak === true) {
              console.log("peak defense. cant feint");
            } else {
              // console.log("too late to feint defense");
            }
          }
        }

        // PRE PULL FEINT
        if (
          this.keyPressed[player.number - 1].pull === false &&
          player.prePull.state === true
        ) {
          // console.log("player was pre pulling. reset");
          player.prePull = {
            state: false,
            count: 0,
            limit: player.prePull.limit,
            targetCell: undefined,
            direction: "",
            puller: 0,
          };

          if (player.newPushPullDelay.state !== true) {
            player.newPushPullDelay.state = true;
          }

          if (player.falling.state !== true && player.moving.state !== true) {
            player.action = "idle";
          }
        }

        // ATTACK FEINT
        if (
          this.keyPressed[player.number - 1].attack === false &&
          player.attacking.state === true
        ) {
          let directionalActionResult = this.checkSetAttackDefendDirectionalInput(
            "windup",
            "attacking",
            player
          );
          player = directionalActionResult.player;
          let chargeType = "normal";
          if (directionalActionResult.charging === true) {
            chargeType = "charged";
          }

          let atkPeak;
          let atkType = player.currentWeapon.type;
          let blunt = "normal";
          if (player.currentWeapon.name === "") {
            atkType = "unarmed";
          }
          if (player.attacking.blunt === true) {
            blunt = "blunt";
          }

          if (player.attacking.count < player.attacking.peakCount) {
            console
              .log
              // "attack windup key release before peak. feinting. refund stamina part"
              ();

            player.action = "idle";
            player.attacking = {
              state: false,
              count: 0,
              limit: player.attacking.limit,
              strength: 0,
              direction: "",
              directionType: "", //thrust or slash
              animRef: player.attacking.animRef,
              peak: false,
              peakCount: 0,
              charge: 0,
              chargePeak: false,
              blunt: false,
              clashing: {
                state: false,
                count: 0,
                limit: player.attacking.clashing.limit,
              },
            };
            player.stamina.current += this.staminaCostRef.attack[atkType][blunt].pre;

            // RESET ELASTIC COUNTER
            if (
              player.elasticCounter.state === true &&
              player.elasticCounter.type === "attacking"
            ) {
              player.elasticCounter.state = false;
            }

            let popup = player.popups.find((x) => x.msg === "attacking");
            if (popup) {
              player.popups.splice(
                player.popups.findIndex((x) => x.msg === "attacking"),
                1
              );
            }
            popup = player.popups.find((x) => x.msg === "charging");
            if (popup) {
              player.popups.splice(
                player.popups.findIndex((x) => x.msg === "charging"),
                1
              );
            }

            if (this.camera.customView.state !== true && player.ai.state !== true) {
              this.setAutoCamera("attackFocusBreak", player);
            }
          } else {
            // console.log("too late to feint attack");
          }
        }

        // DODGE RELEASE/FEINT
        if (
          player.dodging.countState === true &&
          player.dodging.count <= player.dodging.peak.start - player.crits.dodge &&
          this.keyPressed[player.number - 1].dodge !== true &&
          player.flanking.state !== true
        ) {
          console.log("released dodge key while winding up. cancel dodge.");
          player.stamina.current += this.staminaCostRef.dodge.pre;
          player.action = "idle";
          player.dodging = {
            countState: false,
            state: false,
            count: 0,
            limit: player.dodging.limit,
            peak: {
              start: player.dodging.peak.start,
              end: player.dodging.peak.end,
            },
            direction: "",
          };
          if (
            player.elasticCounter.state === true &&
            player.elasticCounter.type === "dodging"
          ) {
            player.elasticCounter.state = false;
          }

          if (player.popups.find((x) => x.msg === "dodging")) {
            player.popups.splice(
              player.popups.findIndex((x) => x.msg === "dodging"),
              1
            );
          }
        }

        // STRAFE RELEASE
        if (player.strafeReleaseHook === true) {
          player.strafing.state = false;
          player.strafeReleaseHook = false;
          this.getTarget(player);
          player.strafing.direction = "";
          // console.log('strafe release hook');
        }

        // CELL BY CELL MOVEMENT DELAY COUNTER!
        if (player.newMoveDelay.state === true) {
          if (player.newMoveDelay.count < player.newMoveDelay.limit) {
            player.newMoveDelay.count++;
            // console.log('newMoveDelay.count',player.newMoveDelay.count);
          }
          if (player.newMoveDelay.count >= player.newMoveDelay.limit) {
            player.newMoveDelay = {
              state: false,
              count: 0,
              limit: player.newMoveDelay.limit,
            };
          }
        }

        // ATTACKING!
        if (player.attacking.state === true) {
          let directionalActionResult = this.checkSetAttackDefendDirectionalInput(
            "windup",
            "attacking",
            player
          );
          player = directionalActionResult.player;
          let chargeType = "normal";
          if (directionalActionResult.charging === true) {
            chargeType = "charged";
          }

          let attackPeak;
          let stamAtkType = player.currentWeapon.type;

          if (player.currentWeapon.type === "") {
            stamAtkType = "unarmed";
          }

          let blunt = "normal";
          if (player.attacking.blunt === true) {
            blunt = "blunt";
            // console.log("blunt attack");
          }

          if (player.attacking.directionType === "") {
            attackPeak = 0;
          } else {
            attackPeak =
              player.attacking.animRef.peak[stamAtkType][player.attacking.directionType][
                chargeType
              ];
          }

          if (
            player.attacking.peakCount === 0 ||
            player.attacking.count < player.attacking.peakCount
            // chargeType === "charged"
          ) {
            // console.log(
            //   "attacking peakCount changed. was",
            //   player.attacking.peakCount,
            //   "now",
            //   attackPeak
            // );
            player.attacking.peakCount = attackPeak;
          }

          if (
            player.attacking.limit === 0 ||
            player.attacking.count < player.attacking.peakCount
            // chargeType === "charged"
          ) {
            // console.log(
            //   "attacking limit changed. was",
            //   player.attacking.limit,
            //   "now",
            //   player.attacking.animRef.limit[stamAtkType][player.attacking.directionType][
            //     chargeType
            //   ]
            // );
            player.attacking.limit =
              player.attacking.animRef.limit[stamAtkType][player.attacking.directionType][
                chargeType
              ];
          }

          // STEP ATTACKING COUNT
          if (player.attacking.count < player.attacking.limit) {
            if (player.attacking.count < player.attacking.peakCount) {
              console.log(
                "atk windup:",
                player.attacking.direction,
                "counts:",
                player.attacking.count,
                player.attacking.peakCount,
                player.attacking.limit,
                chargeType === "charged"
              );
              player.attacking.peak = false;
              player.attacking.chargePeak = false;
            }

            player.action = "attacking";
            player.attacking.count++;

            // APPLY BLUNT ATTACK
            if (
              player.dodging.countState === true ||
              player.dodging.state === true ||
              this.keyPressed[player.number - 1].dodge === true
            ) {
              console.log("was attacking then pressed dodging. blunt attack");

              if (player.attacking.blunt !== true) {
                player.dodging = {
                  countState: false,
                  state: false,
                  count: 0,
                  limit: player.dodging.limit,
                  peak: {
                    start: player.dodging.peak.start,
                    end: player.dodging.peak.end,
                  },
                  direction: "",
                };
                this.keyPressed[player.number - 1].dodge = false;
                player.attacking.blunt = true;

                // RESET DODGE ELASTIC COUNTER
                if (
                  player.elasticCounter.state === true &&
                  player.elasticCounter.type === "dodging"
                ) {
                  player.elasticCounter.state = false;
                }
              }
            }

            // ATTACK START POPUP, GET TARGET, CELLS UNDER ATTACK & AUTO CAM
            if (player.attacking.count <= 2) {
              if (!player.popups.find((x) => x.msg === "attackStart")) {
                player.popups.push({
                  state: false,
                  count: 0,
                  limit: 5,
                  type: "",
                  position: "",
                  msg: "attackStart",
                  img: "",
                });
              }

              this.getTarget(player);

              // CELLS UNDER PRE ATTACK!
              let cellUnderPreAttack1 = this.gridInfo.find(
                (elem) =>
                  elem.number.x === player.target.cell1.number.x &&
                  elem.number.y === player.target.cell1.number.y
              );
              let cellUnderPreAttack2;
              if (player.currentWeapon.type === "spear") {
                cellUnderPreAttack2 = this.gridInfo.find(
                  (elem) =>
                    elem.number.x === player.target.cell2.number.x &&
                    elem.number.y === player.target.cell2.number.y
                );
              }
              if (player.currentWeapon.type === "spear") {
                this.cellsUnderPreAttack.push({
                  number: {
                    x: player.target.cell1.number.x,
                    y: player.target.cell1.number.y,
                  },
                  count: 1,
                  limit: 8,
                });
                this.cellsUnderPreAttack.push({
                  number: {
                    x: player.target.cell2.number.x,
                    y: player.target.cell2.number.y,
                  },
                  count: 1,
                  limit: 8,
                });
              }
              if (
                player.currentWeapon.type === "sword" ||
                player.currentWeapon.type === ""
              ) {
                // console.log('sword/unarmed melee target',player.target);

                this.cellsUnderPreAttack.push({
                  number: {
                    x: player.target.cell1.number.x,
                    y: player.target.cell1.number.y,
                  },
                  count: 1,
                  limit: 8,
                });
              }

              // if (player.currentWeapon.type === 'crossbow' && player.attacking.blunt === true) {
              if (player.currentWeapon.type === "crossbow") {
                // console.log('crossbow melee target',player.target);

                this.cellsUnderPreAttack.push({
                  number: {
                    x: player.target.cell1.number.x,
                    y: player.target.cell1.number.y,
                  },
                  count: 1,
                  limit: 8,
                });
              }

              // console.log('this.cellsUnderPreAttack',this.cellsUnderPreAttack[0],this.cellsUnderPreAttack[1]);

              // CAMERA ATTACK FOCUS
              if (
                this.camera.customView.state !== true &&
                this.settingAutoCamera === false &&
                player.ai.state !== true &&
                this.camera.preInstructions.length === 0 &&
                this.camera.instructions.length === 0
              ) {
                if (this.players[0].dead.state !== true) {
                  if (player.number === 1) {
                    this.setAutoCamera("attackFocus", player);
                  }
                } else if (player.number === 2) {
                  this.setAutoCamera("attackFocus", player);
                }
              } else {
                console.log("no setting auto cam: attackFocus");
              }
            }

            // SHOW ATTACKING POPUP
            if (player.attacking.count > 2) {
              if (!player.popups.find((x) => x.msg === "attacking")) {
                let limit = player.attackinglimit - player.attacking.count;
                if (limit === 0) {
                  limit = 5;
                }
                if (!player.popups.find((x) => x.msg === "attacking")) {
                  player.popups.push({
                    state: false,
                    count: 0,
                    limit: limit,
                    type: "",
                    position: "",
                    msg: "attacking",
                    img: "",
                  });
                }
              }
              // else {
              //   console.log('beep2',player.attacking.animRef.limit[stamAtkType]-player.attacking.count);
              //   player.popups.find(x => x.msg === "attacking").limit = player.attacking.animRef.limit[stamAtkType]-player.attacking.count
              // }
            }
            let dirInputThresh = Math.ceil(
              player.attacking.animRef.peak.unarmed.thrust.normal / 2
            );
            if (player.attacking.count === dirInputThresh) {
              if (player.elasticCounter.state !== true) {
                player = this.setElasticCounter("attacking", "windup", false, player);
              }
            }
          }

          let executeAttack = false;
          if (
            player.elasticCounter.state !== true &&
            player.elasticCounter.type !== "attacking" &&
            player.elasticCounter.subType !== "peak"
          ) {
            if (
              chargeType !== "charged" &&
              player.attacking.charge > 0 &&
              player.attacking.count >
                player.attacking.animRef.peak[stamAtkType][player.attacking.directionType]
                  .normal &&
              player.attacking.count <
                player.attacking.animRef.peak[stamAtkType][player.attacking.directionType]
                  .charged
            ) {
              console.log(
                "not currently charging, but past non charge peak. charge attack released early...adjusting peak"
              );
              console.log(
                "counts",
                player.attacking.count,
                player.attacking.animRef.peak[stamAtkType][player.attacking.directionType]
                  .normal
              );
              executeAttack = true;
              attackPeak =
                player.attacking.animRef.peak[stamAtkType][player.attacking.directionType]
                  .normal;
              player.attacking.limit =
                player.attacking.animRef.limit[stamAtkType][
                  player.attacking.directionType
                ].charged;
              player.attacking.peakCount = attackPeak;
            } else if (player.attacking.count === attackPeak) {
              executeAttack = true;
              player.attacking.peakCount = attackPeak;
              console.log(
                "execute ",
                chargeType,
                " attack at peak normally",
                player.attacking.charge,
                player.attacking.blunt
              );
            }
          } else {
            // console.log("attack peak already reached/passed");
          }

          // TIME TO ATTACK IS NOW!
          if (executeAttack === true) {
            // WEAPON STAMINA COST!!
            if (
              player.stamina.current -
                this.staminaCostRef.attack[stamAtkType][blunt].peak >=
              0
            ) {
              player.stamina.current -=
                this.staminaCostRef.attack[stamAtkType][blunt].peak;

              let melee = true;

              console.log(
                "atk peak:",
                player.attacking.direction,
                "counts:",
                player.attacking.count,
                player.attacking.peakCount,
                player.attacking.limit,
                chargeType === "charged"
              );

              player = this.setElasticCounter("attacking", "peak", false, player);

              player.attacking.peak = true;
              if (player.attacking.charge > 0) {
                player.attacking.chargePeak = true;
              }

              // CREATE NEW PROJECTILE
              if (
                player.currentWeapon.type === "crossbow" &&
                player.attacking.blunt !== true &&
                player.items.ammo > 0
              ) {
                // console.log('firing crossbow');
                melee = false;

                let projectileResult = this.projectileCreator("player", player, "bolt");
                player = projectileResult.owner;

                this.projectiles.push(projectileResult.projectile);

                this.getBoltTarget(projectileResult.projectile);
              }
              // NO PROJECTILE AMMO
              if (
                player.currentWeapon.type === "crossbow" &&
                player.attacking.blunt !== true &&
                player.items.ammo <= 0
              ) {
                // console.log('no ammo!');
                this.players[player.number - 1].statusDisplay = {
                  state: true,
                  status: "out of ammo",
                  count: 1,
                  limit: this.players[player.number - 1].statusDisplay.limit,
                };
                player.currentWeapon.effect = "ammo+0";

                if (!player.popups.find((x) => x.msg === "outOfAmmo")) {
                  player.popups.push({
                    state: false,
                    count: 0,
                    limit: 30,
                    type: "",
                    position: "",
                    msg: "outOfAmmo",
                    img: "",
                  });
                }
              }

              if (
                player.currentWeapon.type === "crossbow" &&
                player.attacking.blunt === true
              ) {
                melee = true;
              }

              if (melee === true) {
                this.getTarget(player);
                this.meleeAttackPeak("player", player);
              }
            }

            // OUT OF STAMINA
            else {
              player.attacking.count = attackPeak + 1;
              player.stamina.current = 0;
              player.statusDisplay = {
                state: true,
                status: "Out of Stamina",
                count: 1,
                limit: player.statusDisplay.limit,
              };
            }
          }

          // ATTACK COOLDOWN AND END!
          if (
            executeAttack !== true &&
            player.attacking.count > player.attacking.peakCount &&
            player.attacking.count < player.attacking.limit
          ) {
            console.log(
              "atk cooldown:",
              player.attacking.direction,
              "counts:",
              player.attacking.count,
              player.attacking.peakCount,
              player.attacking.limit,
              chargeType === "charged"
            );
            player.attacking.peak = false;
            player.attacking.chargePeak = false;
            player.attacking.blunt = false;
          }

          if (player.attacking.count >= player.attacking.limit) {
            player.attacking = {
              state: false,
              count: 0,
              limit: player.attacking.limit,
              strength: 0,
              direction: "",
              directionType: "", //thrust or slash
              animRef: player.attacking.animRef,
              peak: false,
              peakCount: 0,
              charge: 0,
              chargePeak: false,
              blunt: false,
              clashing: {
                state: false,
                count: 0,
                limit: player.attacking.clashing.limit,
              },
            };
            player.action = "idle";

            // AUTO CAM (ATK FOCUS BREAK)
            if (
              this.camera.customView.state !== true &&
              // this.settingAutoCamera === false &&
              player.ai.state !== true &&
              this.camera.preInstructions.length === 0 &&
              this.camera.instructions.length === 0
            ) {
              this.setAutoCamera("attackFocusBreak", player);
            } else {
              console.log("no setting auto cam: attackFocusBreak");
            }

            if (player.popups.find((x) => x.msg === "attacking")) {
              player.popups.splice(
                player.popups.findIndex((x) => x.msg === "attacking"),
                1
              );
            }

            console.log("attack end");
          }
        }
        // CLASHING
        if (player.attacking.clashing.state === true) {
          if (!player.popups.find((x) => x.msg === "clashing")) {
            player.popups.push({
              state: false,
              count: 0,
              limit: player.attacking.clashing.limit,
              type: "",
              position: "",
              msg: "clashing",
              img: "",
            });
          }
          if (player.attacking.clashing.count < player.attacking.clashing.limit) {
            player.attacking.clashing.count++;
          }
          if (player.attacking.clashing.count >= player.attacking.clashing.limit) {
            player.attacking.clashing = {
              state: false,
              count: 0,
              limit: 10,
            };
          }
        }

        // DEFENDING!!
        if (player.defending.state === true) {
          player = this.checkSetAttackDefendDirectionalInput(
            "windup",
            "defending",
            player
          ).player;

          let defendDecayLimitPercentage = 0.55; // calc & increase this based on defend stats

          let defendType = player.currentWeapon.type;
          if (player.currentWeapon.name === "") {
            defendType = "unarmed";
          }

          let defendPeak =
            player.defending.animRef.peak[defendType][player.defending.directionType];

          let defenseValueDecreased = false;
          if (
            player.defending.decay.state !== true &&
            defendPeak !== player.defending.peakCount
          ) {
            if (defendPeak > player.defending.peakCount) {
              defenseValueDecreased = true;
            }
            console.log(
              "defend peak changed from",
              player.defending.peakCount,
              "to",
              defendPeak
            );
            player.defending.peakCount = defendPeak;
          }

          let limit =
            player.defending.animRef.limit[defendType][player.defending.directionType];
          if (player.defending.decay.state !== true && limit !== player.defending.limit) {
            console.log("defend limit changed from", player.defending.limit, "to", limit);
            player.defending.limit = limit;
          }

          if (
            player.defending.count < defendPeak &&
            player.defending.decay.state !== true
          ) {
            player.defending.count++;
            player.action = "defending";
            player.defending.peak = false;
            console.log(
              "defend windup:",
              player.defending.direction,
              "counts",
              player.defending.count,
              defendPeak,
              player.defending.limit
            );
            if (!player.popups.find((x) => x.msg === "defending")) {
              player.popups.push({
                state: false,
                count: 0,
                limit: player.defending.limit,
                type: "",
                position: "",
                msg: "defending",
                img: "",
              });
            }

            if (player.defending.count <= 2) {
              // CAMERA DEFEND FOCUS
              if (
                this.camera.customView.state !== true &&
                this.settingAutoCamera === false &&
                player.ai.state !== true &&
                this.camera.preInstructions.length === 0 &&
                this.camera.instructions.length === 0
              ) {
                if (this.players[0].dead.state !== true) {
                  if (player.number === 1) {
                    this.setAutoCamera("defendFocus", player);
                  }
                } else if (player.number === 2) {
                  this.setAutoCamera("defendFocus", player);
                }
              } else {
                // console.log("no setting auto cam: defendFocus");
              }
            }
          }

          if (
            defenseValueDecreased === true &&
            player.defending.count > player.defending.peakCount
          ) {
            console.log(
              "defend was deirectional now non directional & pask peak. Execute defend"
            );
            player.defending.peakCount = player.defending.count;
          }

          let executeDefend = false;
          if (
            player.elasticCounter.subType !== "windup" &&
            player.defending.count === player.defending.peakCount &&
            player.defending.decay.state !== true
          ) {
            executeDefend = true;
          }

          // PEAK, START DECAY
          if (executeDefend === true) {
            if (player.stamina.current - this.staminaCostRef.defend.peak >= 0) {
              player.action = "defending";
              player.defending.peak = true;
              player.defending.count++;
              player.defending.decay.state = true;
              player.defending.decay.count = 0;
              player.defending.decay.limit = Math.ceil(
                (player.defending.limit - defendPeak) * defendDecayLimitPercentage
              );
              player.stamina.current =
                player.stamina.current - this.staminaCostRef.defend.peak;

              if (!player.popups.find((x) => x.msg === "defending")) {
                player.popups.push({
                  state: false,
                  count: 0,
                  limit: player.defending.limit,
                  type: "",
                  position: "",
                  msg: "defending",
                  img: "",
                });
              }

              player = this.setElasticCounter("defending", "peak", false, player);
              console.log(
                "defend peak:",
                player.defending.direction,
                "counts",
                player.defending.count,
                defendPeak,
                player.defending.limit,
                "decay:",
                player.defending.decay.state,
                player.defending.decay.count,
                player.defending.decay.limit
              );
            }
            // OUT OF STAMINA
            else {
              console.log("not enough stamina for peak defend. reset stamina");
              player.action = "idle";
              player.defending = {
                state: false,
                count: 0,
                limit: player.defending.limit,
                animRef: player.defending.animRef,
                peak: false,
                peakCount: 0,
                decay: {
                  state: false,
                  count: 0,
                  limit: player.defending.decay.limit,
                },
                direction: "",
                directionType: "", //thrust or slash
              };
              player.stamina.current = 0;
              player.statusDisplay = {
                state: true,
                status: "Out of Stamina",
                count: 1,
                limit: player.statusDisplay.limit,
              };

              if (!player.popups.find((x) => x.msg === "outOfStamina")) {
                player.popups.push({
                  state: false,
                  count: 0,
                  limit: 10,
                  type: "",
                  position: "",
                  msg: "outOfStamina",
                  img: "",
                });
              }
            }
          }

          // DECAY!!
          if (player.defending.decay.state === true) {
            if (player.defending.decay.count < player.defending.decay.limit) {
              player.action = "defending";
              player.defending.decay.count++;
              if (player.defending.decay.count >= this.defendPeakAllowance) {
                player.defending.peak = false;
                // console.log(
                //   "peak defend over: count",
                //   player.defending.count,
                //   defendPeak,
                //   player.defending.decay.state
                // );
              }

              if (!player.popups.find((x) => x.msg === "defending")) {
                player.popups.push({
                  state: false,
                  count: 0,
                  limit: player.defending.decay.limit,
                  type: "",
                  position: "",
                  msg: "defending",
                  img: "",
                });
              }
              player = this.setElasticCounter("defending", "decay", false, player);
              console.log(
                "defend decay:",
                player.defending.direction,
                "counts",
                player.defending.count,
                defendPeak,
                player.defending.limit,
                "decay:",
                player.defending.decay.state,
                player.defending.decay.count,
                player.defending.decay.limit
              );
            }

            if (player.defending.decay.count >= player.defending.decay.limit) {
              player.defending.decay.state = false;
              player.defending.decay.count = 0;
              player.defending.count = defendPeak + player.defending.decay.limit;
              console.log(
                "defend decay end:",
                player.defending.direction,
                "counts",
                player.defending.count,
                defendPeak,
                player.defending.limit
              );
            }
          }

          // DEFEND COOLDOWN
          if (
            player.defending.decay.state !== true &&
            player.defending.count > defendPeak
          ) {
            if (player.defending.count < player.defending.limit) {
              player.defending.count++;
              console.log(
                "defend cooldown:",
                player.defending.direction,
                "counts",
                player.defending.count,
                defendPeak,
                player.defending.limit
              );
            }
            if (player.defending.count >= player.defending.limit) {
              player.action = "idle";
              player.defending = {
                state: false,
                count: 0,
                limit: player.defending.limit,
                animRef: player.defending.animRef,
                peak: false,
                peakCount: 0,
                decay: {
                  state: false,
                  count: 0,
                  limit: player.defending.decay.limit,
                },
                direction: "",
                directionType: "", //thrust or slash
              };

              if (player.popups.find((x) => x.msg === "defending")) {
                player.popups.splice(
                  player.popups.findIndex((x) => x.msg === "defending"),
                  1
                );
              }

              // AUTO CAM (DEF FOCUS BREAK)
              if (
                this.camera.customView.state !== true &&
                // this.settingAutoCamera === false &&
                player.ai.state !== true &&
                this.camera.preInstructions.length === 0 &&
                this.camera.instructions.length === 0
              ) {
                this.setAutoCamera("defendFocusBreak", player);
              } else {
                console.log("no setting auto cam: defendFocusBreak");
              }
              // RESET ELASTIC COUNTER
              if (
                player.elasticCounter.state === true &&
                player.elasticCounter.type === "defending"
              ) {
                player.elasticCounter.state = false;
              }
              console.log("defend end");
            }
          }
        }

        // PUSHING/PULLING
        // NEW PUSH/PULL DELAY AFTER LAST ATTEMPT
        if (player.newPushPullDelay.state === true) {
          if (player.newPushPullDelay.count < player.newPushPullDelay.limit) {
            player.newPushPullDelay.count++;
            // console.log('new push pull delay');
          }
          if (player.newPushPullDelay.count >= player.newPushPullDelay.limit) {
            player.newPushPullDelay.state = false;
            player.newPushPullDelay.count = 0;
          }
        }
        // PUSH KEY RELEASE
        if (
          player.prePush.state === true &&
          this.keyPressed[player.number - 1][player.prePush.direction] !== true
        ) {
          // console.log('mid prePush but key released. reset prePush');
          player.prePush = {
            state: false,
            count: 0,
            limit: player.prePush.limit,
            targetCell: undefined,
            direction: "",
            pusher: undefined,
          };

          if (player.newPushPullDelay.state !== true) {
            player.newPushPullDelay.state = true;
          }
        }

        // PULL CHECK
        if (player.postPull.state === true) {
          if (player.postPull.count < player.postPull.limit) {
            player.postPull.count++;
            // console.log('post pull count',player.postPull.count);
          }
          if (player.postPull.count >= player.postPull.limit) {
            // console.log('post pull limit');
            player.postPull = {
              state: false,
              count: 0,
              limit: player.postPull.limit,
            };
          }
        }

        // // DODGE STEPPER!
        let dodgeCondition = false;
        if (player.crits.dodge > 4) {
          player.crits.dodge = 4;
        }
        if (
          player.dodging.countState === true &&
          player.dodging.count <= player.dodging.peak.start - player.crits.dodge &&
          this.keyPressed[player.number - 1].dodge === true
        ) {
          dodgeCondition = true;
        }
        if (
          player.dodging.countState === true &&
          player.dodging.count > player.dodging.peak.start - player.crits.dodge
        ) {
          dodgeCondition = true;
        }
        if (dodgeCondition === true && player.flanking.state !== true) {
          let startMod = player.crits.dodge;
          let endMod = player.crits.dodge;
          if (player.crits.dodge > 5) {
            player.crits.dodge = 5;
          }
          // START & ENDMODS CAN'T MAKE DODGE WIND UP & COOLDOWN < 2
          if (player.dodging.peak.start - startMod < 2) {
            startMod = player.dodging.peak.start - 2;
          }
          if (player.dodging.peak.end + endMod > player.dodging.limit - 2) {
            endMod = player.dodging.limit - (2 + player.dodging.peak.end);
          }

          // HAVE STAMIN FOR DODGE
          if (player.dodging.count === 0) {
            if (player.stamina.current - this.staminaCostRef.dodge.peak >= 0) {
              player.stamina.current =
                player.stamina.current - this.staminaCostRef.dodge.peak;
              player.dodging.count++;
              player.action = "dodging";

              // CHOOSE DODGE DIRECTION
              let whichDirection = this.rnJesus(1, 2);
              switch (player.direction) {
                case "north":
                  if (whichDirection === 1) {
                    player.dodging.direction = "east";
                  } else {
                    player.dodging.direction = "west";
                  }
                  break;
                case "south":
                  if (whichDirection === 1) {
                    player.dodging.direction = "east";
                  } else {
                    player.dodging.direction = "west";
                  }
                  break;
                case "east":
                  if (whichDirection === 1) {
                    player.dodging.direction = "north";
                  } else {
                    player.dodging.direction = "south";
                  }
                  break;
                case "west":
                  if (whichDirection === 1) {
                    player.dodging.direction = "north";
                  } else {
                    player.dodging.direction = "south";
                  }
                  break;
              }

              if (!player.popups.find((x) => x.msg === "dodgeStart")) {
                player.popups.push({
                  state: false,
                  count: 0,
                  limit: 5,
                  type: "",
                  position: "",
                  msg: "dodgeStart",
                  img: "",
                });
              }

              player = this.setElasticCounter("dodging", "", true, player);
            } else {
              player.stamina.current = 0;
              player.dodging = {
                countState: false,
                state: false,
                count: 0,
                limit: player.dodging.limit,
                peak: {
                  start: player.dodging.peak.start,
                  end: player.dodging.peak.end,
                },
                direction: "",
              };
              player.action = "idle";
              player.statusDisplay = {
                state: true,
                status: "Out of Stamina",
                count: 1,
                limit: player.statusDisplay.limit,
              };
            }
          }
          if (player.dodging.count >= 1 && player.dodging.count < player.dodging.limit) {
            player.dodging.count++;
            player.action = "dodging";
            console.log("dodge count", player.dodging.count);

            if (!player.popups.find((x) => x.msg === "dodging")) {
              player.popups.push({
                state: false,
                count: 0,
                limit: player.dodging.limit,
                type: "",
                position: "",
                msg: "dodging",
                img: "",
              });
            }
          }
          // PEAK START
          if (player.dodging.count === player.dodging.peak.start - startMod) {
            // console.log("dodge count", player.dodging.count);
            // player.popups.push(
            //   {
            //     state: false,
            //     count: 0,
            //     limit: (player.dodging.peak.end + endMod)-(player.dodging.peak.start + startMod),
            //     type: '',
            //     position: '',
            //     msg: 'dodgeSuccess',
            //     img: '',
            //
            //   }
            // )
          }

          // PEAK DURATION
          if (
            player.dodging.count > player.dodging.peak.start - startMod &&
            player.dodging.count < player.dodging.peak.end + endMod
          ) {
            player.dodging.state = true;

            console.log("dodge peak", player.dodging.count);
          }

          // IF DODGE IS BEFORE OR AFTER PEAK, STATE OFF
          if (
            player.dodging.count < player.dodging.peak.start - startMod ||
            player.dodging.count > player.dodging.peak.end + endMod
          ) {
            player.dodging.state = false;
            player.dodging.direction = "";
            // console.log('dodge peak off');
          }
          if (player.dodging.count >= player.dodging.limit) {
            player.action = "idle";
            player.dodging = {
              countState: false,
              state: false,
              count: 0,
              limit: player.dodging.limit,
              peak: {
                start: player.dodging.peak.start,
                end: player.dodging.peak.end,
              },
              direction: "",
            };
          }
        }

        // RESET MOVE SPEED POST PUSHBACK
        if (
          player.pushBack.state !== true &&
          player.pushBack.prePushBackMoveSpeed !== 0
        ) {
          player.speed.move = player.player.pushBack.prePushBackMoveSpeed;
          player.player.pushBack.prePushBackMoveSpeed = 0;
        }

        // COMPLETE PUSHBACK DEFLECT FLOW!
        if (
          player.pushBack.state === false &&
          player.success.deflected.predeflect === true &&
          player.moving.state === false
        ) {
          // console.log('predefelct --> pushback ---> deflect');

          this.setDeflection(player, player.success.deflected.type, false);
        }

        // CONTINUE, COMPLETE PLAYER HALF PUSHBACK
        if (player.halfPushBack.state === true) {
          if (player.halfPushBack.countUp.state === true) {
            player.action = "deflected";

            if (player.halfPushBack.countUp.count < player.halfPushBack.countUp.limit) {
              if (player.halfPushBack.countUp.count === 1) {
                // console.log('player 1/2 pushback start');
              }

              player.halfPushBack.countUp.count++;
              // console.log('player 1/2 pushback count up',player.halfPushBack.countUp.count);
            }

            if (player.halfPushBack.countUp.count >= player.halfPushBack.countUp.limit) {
              player.halfPushBack.countUp = {
                state: false,
                count: 0,
                limit: player.halfPushBack.countUp.limit,
              };
              // console.log('player 1/2 pushback peak');
              // this.handleHalfPushBackResult('player',player);
              player.halfPushBack.countDown.state = true;
            }
          }

          if (player.halfPushBack.countDown.state === true) {
            if (
              player.halfPushBack.countDown.count < player.halfPushBack.countDown.limit
            ) {
              player.halfPushBack.countDown.count++;
              // console.log('player 1/2 pushback count down',player.halfPushBack.countDown.count);
            }

            if (
              player.halfPushBack.countDown.count >= player.halfPushBack.countDown.limit
            ) {
              player.halfPushBack.countDown = {
                state: false,
                count: 0,
                limit: player.halfPushBack.countDown.limit,
              };

              // console.log('player 1/2 pushback end');
              this.handleHalfPushBackResult("player", player);
              player.halfPushBack.state = false;
              player.action = "idle";
            }
          }
        }

        // ELASTIC COUNTER
        if (
          player.elasticCounter.state === true &&
          player.elasticCounter.type !== "deflected"
        ) {
          // player.action = player.elasticCounter.type;

          // IF PAUSE IS START, COUNT PAUSE 1ST
          if (
            player.elasticCounter.pause.preState === true &&
            player.elasticCounter.pause.type === "start"
          ) {
            player.elasticCounter.pause.preState = false;
            player.elasticCounter.pause.state = true;
            // console.log("start pause, turn on pause");
          }

          // IF PAUSE IS NOT START, COUNT UP
          if (
            player.elasticCounter.pause.type !== "start" &&
            player.elasticCounter.countUp.state !== true &&
            player.elasticCounter.countDown.state !== true &&
            player.elasticCounter.pause.state !== true
          ) {
            player.elasticCounter.countUp.state = true;
            // console.log("pause is not start. count up");
          }

          // COUNT UP
          if (player.elasticCounter.countUp.state === true) {
            if (
              player.elasticCounter.countUp.count < player.elasticCounter.countUp.limit
            ) {
              if (player.elasticCounter.countUp.count === 0) {
                // console.log("elastic count up start");
              }

              player.elasticCounter.countUp.count++;
              // console.log("elastic counting up: ", player.elasticCounter.countUp.count);
            }

            // FINISH COUNT UP
            if (
              player.elasticCounter.countUp.count >= player.elasticCounter.countUp.limit
            ) {
              // RESET COUNT UP
              player.elasticCounter.countUp = {
                state: false,
                count: 0,
                limit: player.elasticCounter.countUp.limit,
              };
              // console.log("finished count up. elastic counter peak");

              // IF PAUSE IS PEAK, COUNT PAUSE AT PEAK
              if (
                player.elasticCounter.pause.preState === true &&
                player.elasticCounter.pause.type === "peak"
              ) {
                player.elasticCounter.pause.preState = false;
                player.elasticCounter.pause.state = true;
                // console.log("peak pause. turn on pause");
              }

              // IF PAUSE IS NOT PEAK, COUNT DOWM
              if (player.elasticCounter.pause.type !== "peak") {
                player.elasticCounter.countDown.state = true;
                // console.log("pause is not peak. count down");
              }
            }
          }

          // COUNT PAUSE
          if (player.elasticCounter.pause.state === true) {
            // console.log('pause count. type: ',player.elasticCounter.pause.type);

            // COUNT PAUSE
            if (player.elasticCounter.pause.count < player.elasticCounter.pause.limit) {
              if (player.elasticCounter.pause.count === 0) {
                // console.log("pause count start");
              }

              player.elasticCounter.pause.count++;
              // console.log("pause counting: ", player.elasticCounter.pause.count);
            }

            // FINISH PAUSE
            if (player.elasticCounter.pause.count >= player.elasticCounter.pause.limit) {
              // console.log("pause count finished");

              // IF PAUSE IS START, COUNT UP
              if (player.elasticCounter.pause.type === "start") {
                player.elasticCounter.countUp.state = true;
                // console.log("start pause count finished. count up");
              }

              // IF PAUSE IS PEAK, COUNT DOWN
              if (player.elasticCounter.pause.type === "peak") {
                player.elasticCounter.countDown.state = true;
                // console.log("peak pause count finished. count down");
              }

              // IF PAUSE IS END, TURN OFF ELASTIC COUNT
              if (player.elasticCounter.pause.type === "end") {
                player.elasticCounter.state = false;
                // console.log("end pause count finished. turn off elastic count");
              }

              // RESET PAUSE COUNT
              player.elasticCounter.pause.state = false;
              player.elasticCounter.pause.count = 0;
            }
          }

          // COUNT DOWN
          if (player.elasticCounter.countDown.state === true) {
            // COUNT DOWN
            if (
              player.elasticCounter.countDown.count <
              player.elasticCounter.countDown.limit
            ) {
              if (player.elasticCounter.countDown.count === 1) {
                // console.log(
                //   "elastic count down start",
                //   player.elasticCounter.countDown.limit
                // );
              }

              player.elasticCounter.countDown.count++;
              // console.log(
              //   "elastic counting down: ",
              //   player.elasticCounter.countDown.count
              // );
            }

            // FINISH COUNT DOWN
            if (
              player.elasticCounter.countDown.count >=
              player.elasticCounter.countDown.limit
            ) {
              player.elasticCounter.countDown = {
                state: false,
                count: 0,
                limit: player.elasticCounter.countDown.limit,
              };
              // console.log("finished count down.");

              // IF PAUSE IS END, COUNT PAUSE
              if (
                player.elasticCounter.pause.preState === true &&
                player.elasticCounter.pause.type === "end"
              ) {
                player.elasticCounter.pause.preState = false;
                player.elasticCounter.pause.state = true;
                // console.log("end pause. turn on pause");
              }

              // IF PAUSE IS NOT END, TURN OFF ELASTIC COUNTER
              if (player.elasticCounter.pause.type !== "end") {
                player.elasticCounter.state = false;
                player.elasticCounter.type = "";
                // console.log("pause is not end. turn off elastic count");
              }

              // if (player.elasticCounter !== "dodging") {
              //   player.action = "idle";
              // }
            }
          }
        }

        // DISCARD GEAR STEPPER!!
        if (player.discardGear.state === true) {
          if (player.discardGear.count < player.discardGear.limit) {
            player.discardGear.count++;
          } else if (player.discardGear.count >= player.discardGear.limit) {
            player.discardGear = {
              state: false,
              count: 0,
              limit: player.discardGear.limit,
            };
          }
        }

        // WEAPON/ARMOR CYCLE CHECK!!
        if (
          this.keyPressed[player.number - 1].cycleWeapon === true &&
          player.cycleWeapon.state === false
        ) {
          if (player.cycleWeapon.count < player.cycleWeapon.limit) {
            player.cycleWeapon.count++;
            // console.log('player.cycleWeapon.count',player.cycleWeapon.count);
          }
          if (player.cycleWeapon.count >= player.cycleWeapon.limit) {
            if (
              this.keyPressed[player.number - 1].cycleWeapon === true &&
              player.items.weapons.length > 1
            ) {
              // console.log('cycling weapon',player.items);

              // let currentIndex = player.items.weapons.indexOf(player.currentWeapon);
              let currentIndex = player.items.weaponIndex;
              let newIndex;
              // console.log(player.items.weapons,player.currentWeapon,currentIndex,player.items.weapons[currentIndex]);
              if (currentIndex + 1 > player.items.weapons.length - 1) {
                newIndex = 0;
              } else {
                newIndex = currentIndex + 1;
              }
              player.items.weaponIndex = newIndex;
              player.currentWeapon = player.items.weapons[newIndex];

              if (
                !player.popups.find((x) => x.msg === player.items.weapons[newIndex].type)
              ) {
                player.popups.push({
                  state: false,
                  count: 0,
                  limit: 30,
                  type: "",
                  position: "",
                  msg: player.items.weapons[newIndex].type,
                  img: "",
                });
              }

              // console.log(player.items.weapons,player.currentWeapon,newIndex,player.items.weapons[newIndex]);
            }
            if (
              this.keyPressed[player.number - 1].cycleWeapon === true &&
              player.items.weapons.length === 1
            ) {
              if (player.currentWeapon.type === "crossbow" && player.items.ammo === 0) {
                player.currentWeapon = {
                  name: "",
                  type: "",
                  effect: "",
                };
                console.log("only have empty crossbow left, switching to unarmed");
              } else {
                player.currentWeapon = player.items.weapons[0];
                // console.log('nothing to cycle through');
                this.players[player.number - 1].statusDisplay = {
                  state: true,
                  status: "no weapons to cycle!",
                  count: 1,
                  limit: this.players[player.number - 1].statusDisplay.limit,
                };

                if (!player.popups.find((x) => x.msg === "stop")) {
                  player.popups.push({
                    state: false,
                    count: 0,
                    limit: 30,
                    type: "",
                    position: "",
                    msg: "stop",
                    img: "",
                  });
                }
              }
            }

            player.cycleWeapon = {
              state: false,
              count: 0,
              limit: player.cycleWeapon.limit,
            };

            let myCell = this.gridInfo.find(
              (cell) =>
                cell.number.x === player.currentPosition.cell.number.x &&
                cell.number.y === player.currentPosition.cell.number.y
            );
            // if (myCell.item.name !== '') {
            //   // console.log('found an item. picking it up');
            //   this.checkDestination(player)
            // }
          }
        } else if (
          this.keyPressed[player.number - 1].cycleWeapon === true &&
          player.cycleWeapon.state === true
        ) {
          console.log("already cycling weapon");
        }
        if (
          this.keyPressed[player.number - 1].cycleArmor === true &&
          player.cycleArmor.state === false
        ) {
          if (player.cycleArmor.count < player.cycleArmor.limit) {
            player.cycleArmor.count++;
            // console.log('player.cycleArmor.count',player.cycleArmor.count);
          }
          if (player.cycleArmor.count >= player.cycleArmor.limit) {
            if (
              this.keyPressed[player.number - 1].cycleArmor === true &&
              player.items.armor.length > 0
            ) {
              // console.log('cycling armor');

              // let currentIndex = player.items.armor.indexOf(player.currentArmor);
              let currentIndex = player.items.armorIndex;
              let newIndex;
              if (currentIndex + 1 > player.items.armor.length - 1) {
                newIndex = 0;
              } else {
                newIndex = currentIndex + 1;
              }

              switch (player.currentArmor.effect) {
                case "hpUp":
                  if (player.hp > 1) {
                    // console.log('armor cycle debuff hp',player.hp);
                    player.hp = player.hp - 1;
                    // console.log('armor cycle debuff hp',player.hp);
                  }
                  break;
                case "speedUp":
                  let currentSpd1 = player.speed.range.indexOf(player.speed.move);
                  if (player.speed.move > 0.05) {
                    // console.log('armor cycle debuff speed',player.speed.move);
                    player.speed.move = player.speed.range[currentSpd1 - 1];
                    // console.log('armor cycle debuff speed',player.speed.move);
                  }
                  break;
              }

              switch (player.items.armor[newIndex].effect) {
                case "hpUp":
                  if (player.hp < 3) {
                    // console.log('armor cycle buff hp',player.hp);
                    player.hp = player.hp + 1;
                    // console.log('armor cycle buff hp',player.hp);

                    player.statusDisplay = {
                      state: true,
                      status: "hpUp",
                      count: 1,
                      limit: player.statusDisplay.limit,
                    };
                  }
                  break;
                case "speedUp":
                  let currentSpd2 = player.speed.range.indexOf(player.speed.move);
                  if (player.speed.move < 0.2) {
                    // console.log('armor cycle buff speed',player.speed.move);
                    player.speed.move = player.speed.range[currentSpd2 + 1];
                    // console.log('armor cycle buff speed',player.speed.move);

                    player.statusDisplay = {
                      state: true,
                      status: "speedUp",
                      count: 1,
                      limit: player.statusDisplay.limit,
                    };
                  }
                  break;
              }

              player.items.armorIndex = newIndex;
              player.currentArmor = player.items.armor[newIndex];

              if (
                player.items.armor[newIndex].type !== "" &&
                !player.popups.find((x) => x.msg === player.items.armor[newIndex].type)
              ) {
                player.popups.push({
                  state: false,
                  count: 0,
                  limit: 30,
                  type: "",
                  position: "",
                  msg: player.items.armor[newIndex].type,
                  img: "",
                });
              }
              if (
                player.items.armor[newIndex].type === "" &&
                !player.popups.find((x) => x.msg === "stop")
              ) {
                player.popups.push({
                  state: false,
                  count: 0,
                  limit: 30,
                  type: "",
                  position: "",
                  msg: "stop",
                  img: "",
                });
              }
            }
            if (
              this.keyPressed[player.number - 1].cycleArmor === true &&
              player.items.armor.length === 0
            ) {
              console.log("no armor to cycle through");
              this.players[player.number - 1].statusDisplay = {
                state: true,
                status: "no armor to cycle!",
                count: 1,
                limit: this.players[player.number - 1].statusDisplay.limit,
              };

              if (!player.popups.find((x) => x.msg === "stop")) {
                player.popups.push({
                  state: false,
                  count: 0,
                  limit: 30,
                  type: "",
                  position: "",
                  msg: "stop",
                  img: "",
                });
              }
            }

            player.cycleArmor = {
              state: false,
              count: 0,
              limit: player.cycleArmor.limit,
            };

            let myCell = this.gridInfo.find(
              (cell) =>
                cell.number.x === player.currentPosition.cell.number.x &&
                cell.number.y === player.currentPosition.cell.number.y
            );
            // if (myCell.item.name !== '') {
            //   // console.log('found an item. picking it up');
            //   this.checkDestination(player)
            // }
          }
        } else if (
          this.keyPressed[player.number - 1].cycleArmor === true &&
          player.cycleArmor.state === true
        ) {
          console.log("already cycling armor");
        }

        // ITEM PICKUP/DROP ANIM COUNTER!
        if (player.itemDrop.state === true) {
          if (player.itemDrop.count < player.itemDrop.limit) {
            player.itemDrop.count++;
            // console.log('dropping item anim');
          } else if (player.itemDrop.count >= player.itemDrop.limit) {
            player.itemDrop = {
              state: false,
              count: 0,
              limit: 10,
              item: {
                name: "",
              },
              gear: {
                type: "",
              },
            };
          }
        }
        if (player.itemPickup.state === true) {
          if (player.itemPickup.count < player.itemPickup.limit) {
            player.itemPickup.count++;
            // console.log('picking item anim');
          } else if (player.itemPickup.count >= player.itemPickup.limit) {
            player.itemPickup = {
              state: false,
              count: 0,
              limit: 10,
              item: {
                name: "",
              },
              gear: {
                type: "",
              },
            };
          }
        }

        // FLANKING!
        if (player.flanking.state === true) {
          // RESET DODGING
          this.players[player.number - 1].dodging = {
            countState: false,
            state: false,
            count: 0,
            limit: player.dodging.limit,
            peak: {
              start: player.dodging.peak.start,
              end: player.dodging.peak.end,
            },
            direction: "",
          };

          if (
            player.elasticCounter.state === true &&
            player.elasticCounter.type === "dodging"
          ) {
            player.elasticCounter.state = false;
          }

          if (this.players[player.number - 1].popups.find((x) => x.msg === "dodging")) {
            this.players[player.number - 1].popups.splice(
              this.players[player.number - 1].popups.findIndex(
                (x) => x.msg === "dodging"
              ),
              1
            );
          }

          if (player.flanking.step === 2) {
            // console.log(
            //   "flanking step 2 plyr dir: ",
            //   player.direction,
            //   " pre-flank dir: ",
            //   player.flanking.preFlankDirection,
            //   " flank dir: ",
            //   player.flanking.direction,
            //   "current position: ",
            //   player.currentPosition.cell.number,
            //   " strafing: ",
            //   player.strafing.state,
            //   " move step: ",
            //   player.moving.step
            // );
            // console.log(
            //   "flanking step 2: ",
            //   player.moving.state,
            //   player.moving.step,
            //   "-",
            //   player.turning.state
            // );
            // console.log("3", player.currentPosition.cell.number);

            player.direction = this.getOppositeDirection(player.flanking.direction);
            player.turning.toDirection = this.getOppositeDirection(
              player.flanking.direction
            );

            player.flanking = {
              checking: false,
              direction: "",
              preFlankDirection: "",
              state: false,
              step: 0,
              target1: { x: 0, y: 0 },
              target2: { x: 0, y: 0 },
            };

            if (player.popups.find((x) => x.msg === "flanking2")) {
              player.popups.splice(
                player.popups.findIndex((y) => y.msg === "flanking2"),
                1
              );
            }
          }
          if (player.flanking.step === 1) {
            // console.log(
            //   "flanking step 1 plyr dir: ",
            //   player.direction,
            //   " pre-flank dir: ",
            //   player.flanking.preFlankDirection,
            //   " flank dir: ",
            //   player.flanking.direction,
            //   "current position: ",
            //   player.currentPosition.cell.number,
            //   " strafing: ",
            //   player.strafing.state,
            //   " move step: ",
            //   player.moving.step
            // );
            // console.log("flanking step 1: ");
            // console.log("2", player.currentPosition.cell.number);
            let continueFlank = false;
            if (
              this.keyPressed[player.number - 1].north === true ||
              this.keyPressed[player.number - 1].south === true ||
              this.keyPressed[player.number - 1].east === true ||
              this.keyPressed[player.number - 1].west === true
            ) {
              if (player.flanking.direction === keyPressedDirection) {
                console.log(
                  "already flanking in this direction. no move interrupt. continue flank"
                );
                continueFlank = true;
              } else {
                console.log(
                  "flanking cancelled by move input!",
                  player.flanking.direction,
                  player.turning.toDirection,
                  player.direction,
                  keyPressedDirection
                );
                player.action = "idle";
                player.turning.toDirection = player.direction;

                this.players[player.number - 1].statusDisplay = {
                  state: true,
                  status: "flanking cancelled!",
                  count: 1,
                  limit: this.players[player.number - 1].statusDisplay.limit,
                };
                player.flanking = {
                  checking: false,
                  direction: "",
                  preFlankDirection: "",
                  state: false,
                  step: 0,
                  target1: { x: 0, y: 0 },
                  target2: { x: 0, y: 0 },
                };

                if (player.popups.find((x) => x.msg === "flanking2")) {
                  player.popups.splice(
                    player.popups.findIndex((y) => y.msg === "flanking2"),
                    1
                  );
                }
                if (!player.popups.find((x) => x.msg === "noFlanking")) {
                  player.popups.push({
                    state: false,
                    count: 0,
                    limit: 30,
                    type: "",
                    position: "",
                    msg: "noFlanking",
                    img: "",
                  });
                }
              }
            } else {
              continueFlank = true;
            }

            if (continueFlank === true) {
              let target = this.getTarget(player);

              let myCell = this.gridInfo.find(
                (elem2) =>
                  elem2.number.x === player.currentPosition.cell.number.x &&
                  elem2.number.y === player.currentPosition.cell.number.y
              );
              let myCellBlock = this.checkMyCellBarrier(player.direction, myCell);

              if (target.cell1.free === true && myCellBlock !== true) {
                player.flanking.step = 2;
                player.flanking.target2 = target.cell1.number;
                // player.action = 'moving';
                player.action = "flanking";
                player.moving = {
                  state: true,
                  step: 0,
                  course: "",
                  origin: {
                    number: {
                      x: player.currentPosition.cell.number.x,
                      y: player.currentPosition.cell.number.y,
                    },
                    center: {
                      x: player.currentPosition.cell.center.x,
                      y: player.currentPosition.cell.center.y,
                    },
                  },
                  destination: target.cell1.center,
                };
                nextPosition = this.lineCrementer(player);
                player.nextPosition = nextPosition;

                if (player.ai.state === true) {
                  this.keyPressed[player.number - 1].dodge = false;
                }

                if (!player.popups.find((x) => x.msg === "flanking2")) {
                  player.popups.push({
                    state: false,
                    count: 0,
                    limit: 20,
                    type: "",
                    position: "",
                    msg: "flanking2",
                    img: "",
                  });
                }

                if (
                  this.players[player.number - 1].popups.find((x) => x.msg === "dodging")
                ) {
                  this.players[player.number - 1].popups.splice(
                    this.players[player.number - 1].popups.findIndex(
                      (x) => x.msg === "dodging"
                    ),
                    1
                  );
                }
              } else {
                // console.log(
                //   "cancel flanking 2",
                //   player.flanking.direction,
                //   player.flanking.preFlankDirection,
                //   player.direction
                // );
                player.action = "idle";
                player.turning.toDirection = player.direction;

                this.players[player.number - 1].statusDisplay = {
                  state: true,
                  status: "flanking cancelled!",
                  count: 1,
                  limit: this.players[player.number - 1].statusDisplay.limit,
                };
                player.flanking = {
                  checking: false,
                  direction: "",
                  preFlankDirection: "",
                  state: false,
                  step: 0,
                  target1: { x: 0, y: 0 },
                  target2: { x: 0, y: 0 },
                };

                if (player.popups.find((x) => x.msg === "flanking2")) {
                  player.popups.splice(
                    player.popups.findIndex((y) => y.msg === "flanking2"),
                    1
                  );
                }
                if (!player.popups.find((x) => x.msg === "noFlanking")) {
                  player.popups.push({
                    state: false,
                    count: 0,
                    limit: 30,
                    type: "",
                    position: "",
                    msg: "noFlanking",
                    img: "",
                  });
                }
              }
            }
          }
        }
        // START
        if (
          this.keyPressed[player.number - 1].dodge === true &&
          player.flanking.state !== true &&
          player.attacking.state !== true
        ) {
          if (
            this.keyPressed[player.number - 1].north === true ||
            this.keyPressed[player.number - 1].south === true ||
            this.keyPressed[player.number - 1].east === true ||
            this.keyPressed[player.number - 1].west === true
          ) {
            if (player.strafing.state !== true && player.flanking.state !== true) {
              const cancelDodge = () => {
                // RESET DODGING
                this.players[player.number - 1].stamina.current +=
                  this.staminaCostRef.dodge.pre;
                this.players[player.number - 1].dodging = {
                  countState: false,
                  state: false,
                  count: 0,
                  limit: player.dodging.limit,
                  peak: {
                    start: player.dodging.peak.start,
                    end: player.dodging.peak.end,
                  },
                  direction: "",
                };
                player.action = "idle";
                if (
                  player.elasticCounter.state === true &&
                  player.elasticCounter.type === "dodging"
                ) {
                  player.elasticCounter.state = false;
                }
              };

              const continueDodge = () => {
                player.dodging.countState = true;
              };
              let canFlank1 = false;

              if (player.dodging.countState === true && player.dodging.state !== true) {
                if (
                  player.dodging.count <=
                  player.dodging.peak.start - player.crits.dodge
                ) {
                  canFlank1 = true;
                  console.log("can flank before dodge peak start");
                } else {
                  console.log("too late in dodge windup to flank");
                  continueDodge();
                }
              }
              if (player.dodging.countState === true && player.dodging.state === true) {
                console.log("peak dodging. can't flank");
              }
              if (player.dodging.countState !== true && player.dodging.state !== true) {
                console.log("highly unlikely. can flank anyway");
                canFlank1 = true;
              }

              if (canFlank1 === true) {
                cancelDodge();
                if (keyPressedDirection !== player.direction) {
                  let canFlank2 = false;
                  switch (player.direction) {
                    case "north":
                      if (
                        keyPressedDirection === "east" ||
                        keyPressedDirection === "west"
                      ) {
                        canFlank2 = true;
                      }
                      break;
                    case "south":
                      if (
                        keyPressedDirection === "east" ||
                        keyPressedDirection === "west"
                      ) {
                        canFlank2 = true;
                      }
                      break;
                    case "west":
                      if (
                        keyPressedDirection === "north" ||
                        keyPressedDirection === "south"
                      ) {
                        canFlank2 = true;
                      }
                      break;
                    case "east":
                      if (
                        keyPressedDirection === "north" ||
                        keyPressedDirection === "south"
                      ) {
                        canFlank2 = true;
                      }
                      break;
                  }

                  if (canFlank2 === true) {
                    if (player.stamina.current - this.staminaCostRef.flank >= 0) {
                      // console.log('flanking step',keyPressedDirection,player.direction);
                      this.players[player.number - 1].flanking.checking = true;
                      this.players[player.number - 1].flanking.direction =
                        keyPressedDirection;
                      this.players[player.number - 1].flanking.preFlankDirection =
                        player.direction;

                      let target = this.getTarget(player);

                      let myCell = this.gridInfo.find(
                        (elem2) =>
                          elem2.number.x === player.currentPosition.cell.number.x &&
                          elem2.number.y === player.currentPosition.cell.number.y
                      );
                      let myCellBlock = this.checkMyCellBarrier(
                        keyPressedDirection,
                        myCell
                      );

                      // if (target.cell1.free === true) {
                      if (target.cell1.free === true && myCellBlock !== true) {
                        player.stamina.current =
                          player.stamina.current - this.staminaCostRef.flank;
                        // console.log('flank stam check1. cost',this.staminaCostRef.flank,'stam',player.stamina.current);

                        // console.log('flanking step 0 plyr dir: ',player.direction,' pre-flank dir: ',player.flanking.preFlankDirection,' flank dir: ',player.flanking.direction,"current position: ",player.currentPosition.cell.number,' strafing: ',player.strafing.state,' move step: ',player.moving.step);

                        this.players[player.number - 1].flanking.checking = false;
                        this.players[player.number - 1].flanking.state = true;
                        this.players[player.number - 1].flanking.step = 1;
                        this.players[player.number - 1].flanking.target1 =
                          target.cell1.number;
                        // console.log('this.players[player.number-1].flanking.target1',this.players[player.number-1].flanking.target1);
                        // player.action = 'moving';

                        if (
                          !player.popups.find((x) => x.msg === "preAction2") &&
                          !player.popups.find((x) => x.msg === "dodgeStart")
                        ) {
                          player.popups.push({
                            state: false,
                            count: 0,
                            limit: 5,
                            type: "",
                            position: "",
                            msg: "preAction2",
                            img: "",
                          });
                        }

                        player.action = "flanking";
                        player.moving = {
                          state: true,
                          step: 0,
                          course: "",
                          origin: {
                            number: {
                              x: player.currentPosition.cell.number.x,
                              y: player.currentPosition.cell.number.y,
                            },
                            center: {
                              x: player.currentPosition.cell.center.x,
                              y: player.currentPosition.cell.center.y,
                            },
                          },
                          destination: target.cell1.center,
                        };
                        nextPosition = this.lineCrementer(player);
                        player.nextPosition = nextPosition;
                        // console.log("1", player.currentPosition.cell.number);
                        if (
                          this.mouseOverCell.state === true &&
                          this.mouseOverCell.cell.number.x ===
                            player.currentPosition.cell.number.x &&
                          this.mouseOverCell.cell.number.y ===
                            player.currentPosition.cell.number.y
                        ) {
                          this.clicked.player = undefined;
                        }
                      } else {
                        // console.log(
                        //   "cancel flanking 1",
                        //   player.flanking.direction,
                        //   player.flanking.preFlankDirection,
                        //   player.direction,
                        //   player.action
                        // );
                        player.action = "idle";
                        player.turning.toDirection = player.direction;

                        this.players[player.number - 1].flanking.checking = false;
                        this.players[player.number - 1].flanking.state = false;
                        this.players[player.number - 1].flanking.direction = "";
                        this.players[player.number - 1].flanking.preFlankDirection = "";

                        if (!player.popups.find((x) => x.msg === "noFlanking")) {
                          player.popups.push({
                            state: false,
                            count: 0,
                            limit: 30,
                            type: "",
                            position: "",
                            msg: "noFlanking",
                            img: "",
                          });
                        }
                        if (player.popups.find((x) => x.msg === "flanking2")) {
                          player.popups.splice(
                            player.popups.findIndex((y) => y.msg === "flanking2"),
                            1
                          );
                        }
                      }
                    } else {
                      // console.log('flank stam check. cost',this.staminaCostRef.flank,'stam',player.stamina.current);
                      player.action = "idle";
                      player.stamina.current = 0;
                      player.statusDisplay = {
                        state: true,
                        status: "Out of Stamina",
                        count: 1,
                        limit: player.statusDisplay.limit,
                      };
                    }
                  } else {
                    console.log("cant flank2 incompatible direction");
                  }
                }
                if (keyPressedDirection === player.direction) {
                  console.log("!! dodge roll key combo!! or kick");
                }
              }
            } else {
              console.log("already strafing and/or flanking. cant start flank");
            }
          }
        }

        // BREAK FROM PULLED/PUSHED CHECK
        let plyrPullPushed = false;
        let plyrPullPushedPlyr = 0;
        let breakPulledPushed = false;
        for (const plyr of this.players) {
          if (plyr.prePush.state === true) {
            if (
              plyr.target.cell1.number.x === player.currentPosition.cell.number.x &&
              plyr.target.cell1.number.y === player.currentPosition.cell.number.y
            ) {
              // console.log('player is being pre pushed by plyr',plyr.number);
              plyrPullPushed = true;
              plyrPullPushedPlyr = plyr.number;
            }
          }
          if (plyr.prePull.state === true) {
            if (
              plyr.target.cell1.number.x === player.currentPosition.cell.number.x &&
              plyr.target.cell1.number.y === player.currentPosition.cell.number.y
            ) {
              // console.log('player is being pre pulled by plyr',plyr.number);
              plyrPullPushed = true;
              plyrPullPushedPlyr = plyr.number;
            }
          }
        }

        // CAN READ MOVE INPUTS!!
        if (
          player.attacking.state === false &&
          player.defending.state === false &&
          player.defending.count < 1 &&
          player.dodging.state === false &&
          player.dodging.countState === false &&
          player.turning.state !== true &&
          player.postPull.state !== true &&
          player.defending.decay.state !== true &&
          player.flanking.state !== true &&
          player.jumping.state !== true &&
          player.turning.state !== true &&
          player.halfPushBack.state !== true &&
          player.elasticCounter.state !== true &&
          player.pulling.state !== true &&
          player.pushing.state !== true &&
          player.itemDrop.state !== true &&
          player.itemPickup.state !== true
        ) {
          // CONFIRM MOVE KEYPRESS!!
          if (
            this.keyPressed[player.number - 1].north === true ||
            this.keyPressed[player.number - 1].south === true ||
            this.keyPressed[player.number - 1].east === true ||
            this.keyPressed[player.number - 1].west === true ||
            this.keyPressed[player.number - 1].northEast === true ||
            this.keyPressed[player.number - 1].northWest === true ||
            this.keyPressed[player.number - 1].southEast === true ||
            this.keyPressed[player.number - 1].southWest === true
          ) {
            if (plyrPullPushed === true) {
              breakPulledPushed = true;
            }

            if (player.newMoveDelay.state !== true) {
              // MOVE IF DIRECTION ALIGNS & NOT STRAFING!!
              if (
                keyPressedDirection === player.direction &&
                player.strafing.state === false
              ) {
                let target = this.getTarget(player);

                if (
                  target.cell1.free === true &&
                  player.target.cell1.void === false &&
                  target.myCellBlock !== true
                ) {
                  if (player.dead.state === true && player.dead.count === 0) {
                    player.nextPosition = {
                      x: -30,
                      y: -30,
                    };
                  } else if (player.turning.delayCount === 0) {
                    if (player.stamina.current - this.staminaCostRef.move >= 0) {
                      player.stamina.current -= this.staminaCostRef.move;

                      player.action = "moving";
                      player.moving = {
                        state: true,
                        step: 0,
                        course: "",
                        origin: {
                          number: {
                            x: player.currentPosition.cell.number.x,
                            y: player.currentPosition.cell.number.y,
                          },
                          center: {
                            x: player.currentPosition.cell.center,
                            y: player.currentPosition.cell.center,
                          },
                        },
                        destination: target.cell1.center,
                      };
                      nextPosition = this.lineCrementer(player);
                      player.nextPosition = nextPosition;

                      if (
                        this.mouseOverCell.state === true &&
                        this.mouseOverCell.cell.number.x ===
                          player.currentPosition.cell.number.x &&
                        this.mouseOverCell.cell.number.y ===
                          player.currentPosition.cell.number.y
                      ) {
                        this.clicked.player = undefined;
                      }
                    } else {
                      player.stamina.current = 0;
                      player.statusDisplay = {
                        state: true,
                        status: "Out of Stamina",
                        count: 0,
                        limit: player.statusDisplay.limit,
                      };
                    }
                  }
                }

                if (target.cell1.free !== true && target.myCellBlock !== true) {
                  if (
                    target.cell1.occupant.type === "obstacle" &&
                    player.pushing.state !== true
                  ) {
                    this.preObstaclePushCheck(player, target);
                  }
                  if (
                    target.cell1.occupant.type === "player" &&
                    player.pushing.state !== true
                  ) {
                    this.prePlayerPushCheck(player, target);
                  }
                  if (player.pushing.state === true) {
                    // console.log('You are already pushing something');
                  }
                }

                if (player.target.cell1.void === true && target.myCellBlock !== true) {
                  // console.log('target is VOID!!',target.cell1.center.x,target.cell1.center.y);

                  if (player.stamina.current - this.staminaCostRef.move >= 0) {
                    player.stamina.current -= this.staminaCostRef.move;

                    this.moveSpeed = player.speed.move;

                    player.moving = {
                      state: true,
                      step: 0,
                      course: "",
                      origin: {
                        number: player.currentPosition.cell.number,
                        center: player.currentPosition.cell.center,
                      },
                      destination: target.cell1.center,
                    };

                    nextPosition = this.lineCrementer(player);
                    player.nextPosition = nextPosition;

                    if (
                      this.mouseOverCell.state === true &&
                      this.mouseOverCell.cell.number.x ===
                        player.currentPosition.cell.number.x &&
                      this.mouseOverCell.cell.number.y ===
                        player.currentPosition.cell.number.y
                    ) {
                      this.clicked.player = undefined;
                    }
                  } else {
                    player.stamina.current = 0;
                    player.statusDisplay = {
                      state: true,
                      status: "Out of Stamina",
                      count: 0,
                      limit: player.statusDisplay.limit,
                    };
                  }
                }
              }
            }

            // CHANGE DIRECTION IF NOT STRAFING!!
            if (
              keyPressedDirection !== player.direction &&
              player.strafing.state === false &&
              player.turning.state !== true
            ) {
              // console.log('change player direction to',keyPressedDirection);
              // console.log('player',player.number,player.direction,' turn-start',keyPressedDirection);

              if (player.stamina.current - this.staminaCostRef.turn >= 0) {
                player.stamina.current -= this.staminaCostRef.turn;

                // console.log('start turning');
                player.turning.state = true;
                player.turning.toDirection = keyPressedDirection;
              } else {
                player.stamina.current = 0;
                player.statusDisplay = {
                  state: true,
                  status: "Out of Stamina",
                  count: 0,
                  limit: player.statusDisplay.limit,
                };
              }
            }

            if (player.newMoveDelay.state !== true) {
              // MOVE WHILE STRAFING!!
              if (
                keyPressedDirection !== player.direction &&
                player.strafing.state === true
              ) {
                player.strafing.direction = keyPressedDirection;
                let target = this.getTarget(player);

                if (target.cell1.free === true && target.myCellBlock !== true) {
                  if (player.stamina.current - this.staminaCostRef.strafe >= 0) {
                    player.stamina.current -= this.staminaCostRef.strafe;
                    this.moveSpeed = player.speed.move;

                    // console.log('start strafing');
                    player.action = "strafe moving";
                    player.moving = {
                      state: true,
                      step: 0,
                      course: "",
                      origin: {
                        number: {
                          x: player.currentPosition.cell.number.x,
                          y: player.currentPosition.cell.number.y,
                        },
                        center: {
                          x: player.currentPosition.cell.center.x,
                          y: player.currentPosition.cell.center.y,
                        },
                      },
                      destination: target.cell1.center,
                    };
                    nextPosition = this.lineCrementer(player);
                    player.nextPosition = nextPosition;

                    if (
                      this.mouseOverCell.state === true &&
                      this.mouseOverCell.cell.number.x ===
                        player.currentPosition.cell.number.x &&
                      this.mouseOverCell.cell.number.y ===
                        player.currentPosition.cell.number.y
                    ) {
                      this.clicked.player = undefined;
                    }
                  } else {
                    player.stamina.current = 0;
                    player.statusDisplay = {
                      state: true,
                      status: "Out of Stamina",
                      count: 0,
                      limit: player.statusDisplay.limit,
                    };
                  }
                }

                if (target.cell1.free === false || target.myCellBlock === true) {
                  // console.log('here',player.direction);
                }
              }

              // JUMPING!!
              if (
                keyPressedDirection === player.direction &&
                player.strafing.state === true &&
                player.jumping.checking !== true &&
                player.jumping.state !== true
              ) {
                let alarmedPopup = false;
                this.players[player.number - 1].jumping.checking = true;
                let target = this.getTarget(player);

                let myCell = this.gridInfo.find(
                  (elem) =>
                    elem.number.x === player.currentPosition.cell.number.x &&
                    elem.number.y === player.currentPosition.cell.number.y
                );
                let cell1 = this.gridInfo.find(
                  (elem) =>
                    elem.number.x === target.cell1.number.x &&
                    elem.number.y === target.cell1.number.y
                );
                let cell2 = this.gridInfo.find(
                  (elem) =>
                    elem.number.x === target.cell2.number.x &&
                    elem.number.y === target.cell2.number.y
                );
                // console.log('cell1',cell1);
                // console.log('cell2',cell2);

                let cellsWithinBounds = true;
                if (!cell1 || !cell2) {
                  cellsWithinBounds = false;
                } else {
                  if (cell1.number.x < 0 || cell1.number.x > this.gridWidth) {
                    cellsWithinBounds = false;
                  }
                  if (cell1.number.y < 0 || cell1.number.y > this.gridWidth) {
                    cellsWithinBounds = false;
                  }
                }

                if (cellsWithinBounds === true) {
                  // CAN ONLY JUMP OVER HAZARDS, DEEP OR VOID
                  if (
                    cell1.void.state === true ||
                    cell1.terrain.type === "deep" ||
                    cell1.terrain.type === "hazard"
                  ) {
                    // console.log('a');

                    // CHECK ALL 3 JUMPING CELLS FOR BARRIERS BASED ON POSITION
                    let myCellBlocked = false;
                    let cell1BarrierNear = false;
                    let cell1BarrierFar = false;
                    let cell2Barrier = false;
                    if (
                      myCell.barrier.state === true &&
                      myCell.barrier.position === player.direction
                    ) {
                      myCellBlocked = true;
                    }
                    if (cell1.barrier.state === true) {
                      if (cell1.barrier.position === player.direction) {
                        cell1BarrierFar = true;
                      }
                      if (
                        cell1.barrier.position ===
                        this.getOppositeDirection(player.direction)
                      ) {
                        cell1BarrierNear = true;
                      }
                    }
                    if (cell2.barrier.state === true) {
                      if (
                        cell2.barrier.position ===
                        this.getOppositeDirection(player.direction)
                      ) {
                        cell2Barrier = true;
                      }
                    }

                    if (
                      // cell1.obstacle.state !== true &&
                      // cell2.obstacle.state !== true &&
                      cell1BarrierNear !== true &&
                      // cell2Barrier !== true &&
                      myCellBlocked !== true
                    ) {
                      // console.log('no obstacles at jump destination');

                      if (cell2.void.state !== true && cell2.terrain.type !== "deep") {
                        if (player.stamina.current - this.staminaCostRef.jump >= 0) {
                          // console.log('can jump',player.stamina.current);
                          this.players[player.number - 1].jumping.checking = false;
                          this.players[player.number - 1].jumping.state = true;
                          player.action = "jumping";
                          player.stamina.current =
                            player.stamina.current - this.staminaCostRef.jump;

                          player.moving = {
                            state: true,
                            step: 0,
                            course: "",
                            origin: {
                              number: player.currentPosition.cell.number,
                              center: player.currentPosition.cell.center,
                            },
                            destination: target.cell2.center,
                          };

                          nextPosition = this.lineCrementer(player);
                          // nextPosition = this.jumpCrementer(player);
                          player.nextPosition = nextPosition;

                          // RESET CELL INFO PLAYER
                          if (
                            this.mouseOverCell.state === true &&
                            this.mouseOverCell.cell.number.x ===
                              player.currentPosition.cell.number.x &&
                            this.mouseOverCell.cell.number.y ===
                              player.currentPosition.cell.number.y
                          ) {
                            this.clicked.player = undefined;
                          }
                        } else {
                          // this.getTarget(player);
                          this.players[player.number - 1].jumping.checking = false;
                          player.action = "idle";
                          player.stamina.current = 0;
                          player.statusDisplay = {
                            state: true,
                            status: "Out of Stamina",
                            count: 0,
                            limit: player.statusDisplay.limit,
                          };
                        }
                      } else {
                        // console.log('can only jump over voids or deep water cell 2');
                        this.players[player.number - 1].jumping.checking = false;
                        alarmedPopup = true;
                      }
                    } else {
                      // console.log('jump obstacle detected');
                      this.players[player.number - 1].jumping.checking = false;
                      alarmedPopup = true;

                      if (cell1.obstacle.state === true) {
                        console.log("can't jump! obstacle in cell1");
                      }
                      // if (cell2.obstacle.state === true) {
                      //   console.log("can't jump! obstacle in cell2");
                      // }
                      if (myCellBlocked === true) {
                        console.log("can't jump! barrier in player cell blocking");
                      }
                      if (cell1BarrierNear === true) {
                        console.log("can't jump! barrier cell 1 blocking");
                      }
                      // if (cell2Barrier === true) {
                      //   console.log("can't jump! barrier cell 2 blocking");
                      // }
                    }
                  } else {
                    // console.log('can only jump over voids, hazards or deep water cell 2');
                    this.players[player.number - 1].jumping.checking = false;
                    alarmedPopup = true;
                  }
                } else {
                  // console.log('cell out of bounds');
                  this.players[player.number - 1].jumping.checking = false;
                  alarmedPopup = true;
                }

                if (alarmedPopup === true) {
                  if (
                    !this.players[player.number - 1].popups.find(
                      (x) => x.msg === "alarmed"
                    )
                  ) {
                    this.players[player.number - 1].popups.push({
                      state: false,
                      count: 0,
                      limit: 30,
                      type: "",
                      position: "",
                      msg: "alarmed",
                      img: "",
                    });
                  }
                  console.log("cant jump fwd here. Check for can kick");
                }
              }
            }
          }
        }

        // CAN READ NON-MOVE INPUTS!!
        if (
          player.strafing.state === false &&
          player.turning.state !== true &&
          player.postPull.state !== true &&
          player.halfPushBack.state !== true &&
          player.elasticCounter.state !== true &&
          player.pulling.state !== true &&
          player.pushing.state !== true &&
          player.itemDrop.state !== true &&
          player.itemPickup.state !== true
        ) {
          // ATTACKING/DEFENDING
          if (
            this.keyPressed[player.number - 1].attack === true ||
            this.keyPressed[player.number - 1].defend === true
          ) {
            // ALREADY ATTACKING/DEFENDING!!
            if (player.attacking.state === true || player.defending.state === true) {
              if (this.keyPressed[player.number - 1].attack === true) {
                // console.log("already attacking");
              }
              if (this.keyPressed[player.number - 1].defend === true) {
                // console.log('already defending',player.number);
              }
            }

            // START ATTACK/DEFEND!!
            if (
              player.attacking.state === false &&
              player.defending.state === false &&
              player.defending.decay.state !== true
            ) {
              if (
                this.keyPressed[player.number - 1].attack === true &&
                player.success.deflected.state !== true &&
                this.keyPressed[player.number - 1].defend !== true
              ) {
                let atkType = player.currentWeapon.type;
                let blunt = "normal";
                if (player.attacking.blunt === true) {
                  atkType = "blunt";
                  blunt = "blunt";
                }
                if (player.currentWeapon.name === "") {
                  atkType = "unarmed";
                }

                // BLUNT ATTACK!!
                if (this.keyPressed[player.number - 1].dodge === true) {
                  // console.log('start blunt attack');
                  if (
                    player.dodging.countState === true ||
                    player.dodging.state === true ||
                    this.keyPressed[player.number - 1].dodge === true
                  ) {
                    console.log(
                      "was dodging, now blunt attacking. cancel dodge. return dodge stamina"
                    );
                    player.stamina.current += this.staminaCostRef.dodge.peak;
                    player.dodging = {
                      countState: false,
                      state: false,
                      count: 0,
                      limit: player.dodging.limit,
                      peak: {
                        start: player.dodging.peak.start,
                        end: player.dodging.peak.end,
                      },
                      direction: "",
                    };
                    if (
                      player.elasticCounter.state === true &&
                      player.elasticCounter.type === "dodging"
                    ) {
                      player.elasticCounter.state = false;
                    }
                  }
                  this.keyPressed[player.number - 1].dodge = false;

                  let popup = player.popups.find((x) => x.msg === "dodging");
                  if (popup) {
                    player.popups.splice(
                      player.popups.findIndex((x) => x.msg === "dodging"),
                      1
                    );
                  }
                  let popup2 = player.popups.find((x) => x.msg === "dodgeStart");
                  if (popup2) {
                    player.popups.splice(
                      player.popups.findIndex((x) => x.msg === "dodgeStart"),
                      1
                    );
                  }

                  player.attacking.blunt = true;
                  atkType = "blunt";
                }

                player = this.checkSetAttackDefendDirectionalInput(
                  "init",
                  "attacking",
                  player
                ).player;

                player.action = "attacking";
                player.attacking.state = true;
                player.attacking.count = 1;

                // console.log("start attack");

                if (plyrPullPushed === true) {
                  breakPulledPushed = true;
                }
              }

              if (
                this.keyPressed[player.number - 1].defend === true &&
                player.defending.decay.state !== true &&
                this.keyPressed[player.number - 1].attack !== true
              ) {
                // console.log('start defending',player.number);

                // console.log('start defending');
                if (plyrPullPushed === true) {
                  breakPulledPushed = true;
                }

                if (
                  player.defending.count === 0 &&
                  player.defending.decay.state !== true
                ) {
                  player = this.checkSetAttackDefendDirectionalInput(
                    "init",
                    "defending",
                    player
                  ).player;

                  player.defending.state = true;
                  player.defending.count = 1;

                  if (!player.popups.find((x) => x.msg === "preAction1")) {
                    player.popups.push({
                      state: false,
                      count: 0,
                      limit: 5,
                      type: "",
                      position: "",
                      msg: "preAction1",
                      img: "",
                    });
                  }
                } else {
                  // console.log('cant start defend. might already be in progress');
                }
              }
            }
          }

          // PRE PULL
          if (this.keyPressed[player.number - 1].pull === true) {
            this.getTarget(player);

            if (
              player.target.cell1.occupant.type === "obstacle" &&
              player.pulling.state !== true
            ) {
              // console.log('pulling obstacle trigger north',player.prePull.state,player.prePull.count);
              this.preObstaclePullCheck(
                player,
                player.target,
                this.getOppositeDirection(player.direction)
              );
            }
            if (
              player.target.cell1.occupant.type === "player" &&
              player.pulling.state !== true
            ) {
              // console.log('pulling player trigger north',player.prePull.state,player.prePull.count);
              this.prePlayerPullCheck(
                player,
                player.target,
                this.getOppositeDirection(player.direction)
              );
            }
          }

          // DODGE START
          else if (
            this.keyPressed[player.number - 1].dodge === true &&
            this.keyPressed[player.number - 1].attack !== true &&
            this.keyPressed[player.number - 1].defend !== true
          ) {
            if (player.attacking.state !== true && player.defending.state !== true) {
              if (player.dodging.state !== true && player.dodging.countState !== true) {
                console.log("start dodge wind up");
                player.dodging.countState = true;

                if (plyrPullPushed === true) {
                  breakPulledPushed = true;
                }
              }
              if (player.dodging.state === true || player.dodging.countState === true) {
                console.log("already dodging");
              }
            } else {
              console.log("cant dodge while already attacking or defending");
            }
          }

          // DISCARD GEAR/PICKUP GEAR & ITEMS!!
          if (
            this.keyPressed[player.number - 1].discardWeapon === true &&
            player.discardGear.state !== true
          ) {
            this.discardGear(player, "weapon");
            player.discardGear.state = true;
          }
          if (
            this.keyPressed[player.number - 1].discardArmor === true &&
            player.discardGear.state !== true
          ) {
            this.discardGear(player, "armor");
            player.discardGear.state = true;
          }
        }

        // BREAK FROM PULLED, PUSHED COMPLETE
        if (breakPulledPushed === true) {
          console.log(
            "player ",
            player.number,
            " was being pre-pulled/pushed by ",
            plyrPullPushedPlyr,
            " break pulling/pushing and deflect?"
          );

          let shouldDeflect = this.rnJesus(1, player.crits.guardBreak);
          if (shouldDeflect === 1) {
            this.setDeflection(
              this.players[plyrPullPushedPlyr - 1],
              "bluntAttacked",
              false
            );
          }

          // POPUPS
          if (this.players[plyrPullPushedPlyr - 1].prePush.state === true) {
            if (
              !this.players[plyrPullPushedPlyr - 1].popups.find((x) => x.msg === "noPush")
            ) {
              this.players[plyrPullPushedPlyr - 1].popups.push({
                state: false,
                count: 0,
                limit: 25,
                type: "",
                position: "",
                msg: "noPush",
                img: "",
              });
            }

            if (
              this.players[plyrPullPushedPlyr - 1].popups.find((x) => x.msg === "prePush")
            ) {
              this.players[plyrPullPushedPlyr - 1].popups.splice(
                this.players[plyrPullPushedPlyr - 1].popups.findIndex(
                  (x) => x.msg === "prePush"
                ),
                1
              );
            }
            if (
              this.players[plyrPullPushedPlyr - 1].popups.find((x) => x.msg === "noPush")
            ) {
              this.players[plyrPullPushedPlyr - 1].popups.splice(
                this.players[plyrPullPushedPlyr - 1].popups.findIndex(
                  (x) => x.msg === "canPush"
                ),
                1
              );
            }
          }
          if (this.players[plyrPullPushedPlyr - 1].prePull.state === true) {
            if (
              !this.players[plyrPullPushedPlyr - 1].popups.find((x) => x.msg === "noPull")
            ) {
              this.players[plyrPullPushedPlyr - 1].popups.push({
                state: false,
                count: 0,
                limit: 25,
                type: "",
                position: "",
                msg: "noPull",
                img: "",
              });
            }

            if (
              this.players[plyrPullPushedPlyr - 1].popups.find((x) => x.msg === "prePull")
            ) {
              this.players[plyrPullPushedPlyr - 1].popups.splice(
                this.players[plyrPullPushedPlyr - 1].popups.findIndex(
                  (x) => x.msg === "prePull"
                ),
                1
              );
            }
            if (
              this.players[plyrPullPushedPlyr - 1].popups.find((x) => x.msg === "canPull")
            ) {
              this.players[plyrPullPushedPlyr - 1].popups.splice(
                this.players[plyrPullPushedPlyr - 1].popups.findIndex(
                  (x) => x.msg === "canPull"
                ),
                1
              );
            }
          }

          this.players[plyrPullPushedPlyr - 1].pushing = {
            state: false,
            targetCell: undefined,
            moveSpeed: 0,
          };
          this.players[plyrPullPushedPlyr - 1].pulling = {
            state: false,
            targetCell: undefined,
            moveSpeed: 0,
          };
          this.players[plyrPullPushedPlyr - 1].prePush = {
            state: false,
            count: 0,
            limit: this.players[plyrPullPushedPlyr - 1].prePush.limit,
            targetCell: undefined,
            direction: "",
            pusher: undefined,
          };
          this.players[plyrPullPushedPlyr - 1].prePull = {
            state: false,
            count: 0,
            limit: this.players[plyrPullPushedPlyr - 1].prePull.limit,
            targetCell: undefined,
            direction: "",
            puller: undefined,
          };

          if (this.players[plyrPullPushedPlyr - 1].newPushPullDelay.state !== true) {
            this.players[plyrPullPushedPlyr - 1].newPushPullDelay.state = true;
          }

          if (
            this.players[plyrPullPushedPlyr - 1].popups.find((x) => x.msg === "prePush")
          ) {
            this.players[plyrPullPushedPlyr - 1].popups.splice(
              this.players[plyrPullPushedPlyr - 1].popups.findIndex(
                (x) => x.msg === "prePush"
              ),
              1
            );
          }
          if (
            this.players[plyrPullPushedPlyr - 1].popups.find((x) => x.msg === "prePull")
          ) {
            this.players[plyrPullPushedPlyr - 1].popups.splice(
              this.players[plyrPullPushedPlyr - 1].popups.findIndex(
                (x) => x.msg === "prePull"
              ),
              1
            );
          }
        }
      }

      // DISPLAY ATTACK AND DEFENSE SUCCESS!
      if (player.success.attackSuccess.state === true) {
        if (player.success.attackSuccess.count < player.success.attackSuccess.limit) {
          player.success.attackSuccess.count++;
        } else if (
          player.success.attackSuccess.count >= player.success.attackSuccess.limit
        ) {
          player.success.attackSuccess = {
            state: false,
            count: 0,
            limit: player.success.attackSuccess.limit,
          };
        }
      }
      if (player.success.defendSuccess.state === true) {
        if (player.success.defendSuccess.count < player.success.defendSuccess.limit) {
          player.success.defendSuccess.count++;
        } else if (
          player.success.defendSuccess.count >= player.success.defendSuccess.limit
        ) {
          player.success.defendSuccess = {
            state: false,
            count: 0,
            limit: player.success.defendSuccess.limit,
          };
        }
      }
    } else {
      // console.log('sorry no key presses right now. you are deflected');
    }

    // DEFLECTION ELASTIC COUNTER
    if (
      player.elasticCounter.state === true &&
      player.elasticCounter.type === "deflected"
    ) {
      player.action = player.elasticCounter.type;

      // IF PAUSE IS START, COUNT PAUSE 1ST
      if (
        player.elasticCounter.pause.preState === true &&
        player.elasticCounter.pause.type === "start"
      ) {
        player.elasticCounter.pause.preState = false;
        player.elasticCounter.pause.state = true;
        // console.log('start pause, turn on pause');
      }

      // IF PAUSE IS NOT START, COUNT UP
      if (
        player.elasticCounter.pause.type !== "start" &&
        player.elasticCounter.countUp.state !== true &&
        player.elasticCounter.countDown.state !== true &&
        player.elasticCounter.pause.state !== true
      ) {
        player.elasticCounter.countUp.state = true;
      }

      // COUNT UP
      if (player.elasticCounter.countUp.state === true) {
        if (
          player.elasticCounter.countUp.count <
          player.elasticCounter.countUp.limit + 1
        ) {
          if (player.elasticCounter.countUp.count === 0) {
            // console.log('elastic count up start');
          }

          player.elasticCounter.countUp.count++;
          // console.log('elastic counting up: ',player.elasticCounter.countUp.count);
        }

        // FINISH COUNT UP
        if (
          player.elasticCounter.countUp.count >=
          player.elasticCounter.countUp.limit + 1
        ) {
          // RESET COUNT UP
          player.elasticCounter.countUp = {
            state: false,
            count: 0,
            limit: player.elasticCounter.countUp.limit,
          };
          // console.log('finished count up. elastic counter peak');

          // IF PAUSE IS PEAK, COUNT PAUSE AT PEAK
          if (
            player.elasticCounter.pause.preState === true &&
            player.elasticCounter.pause.type === "peak"
          ) {
            player.elasticCounter.pause.preState = false;
            player.elasticCounter.pause.state = true;
            // console.log('peak pause. turn on pause');
          }

          // IF PAUSE IS NOT PEAK, COUNT DOWM
          if (player.elasticCounter.pause.type !== "peak") {
            player.elasticCounter.countDown.state = true;
            // console.log('pause is not peak. count down');
          }
        }
      }

      // COUNT PAUSE
      if (player.elasticCounter.pause.state === true) {
        // console.log('pause count. type: ',player.elasticCounter.pause.type);

        // COUNT PAUSE
        if (player.elasticCounter.pause.count < player.elasticCounter.pause.limit + 1) {
          if (player.elasticCounter.pause.count === 0) {
            // console.log('pause count start');
          }

          player.elasticCounter.pause.count++;
          // console.log('pause counting: ',player.elasticCounter.pause.count);
        }

        // FINISH PAUSE
        if (player.elasticCounter.pause.count >= player.elasticCounter.pause.limit + 1) {
          // console.log('pause count finished');

          // IF PAUSE IS START, COUNT UP
          if (player.elasticCounter.pause.type === "start") {
            player.elasticCounter.countUp.state = true;
            // console.log('start pause count finished. count up');
          }

          // IF PAUSE IS PEAK, COUNT DOWN
          if (player.elasticCounter.pause.type === "peak") {
            player.elasticCounter.countDown.state = true;
            // console.log('peak pause count finished. count down');
          }

          // IF PAUSE IS END, TURN OFF ELASTIC COUNT
          if (player.elasticCounter.pause.type === "end") {
            player.elasticCounter.state = false;
            // player.action = "idle";
            // console.log('end pause count finished. turn off elastic count');
          }

          // RESET PAUSE COUNT
          player.elasticCounter.pause.state = false;
          player.elasticCounter.pause.count = 0;
        }
      }

      // COUNT DOWN
      if (player.elasticCounter.countDown.state === true) {
        // COUNT DOWN
        if (
          player.elasticCounter.countDown.count <
          player.elasticCounter.countDown.limit + 1
        ) {
          if (player.elasticCounter.countDown.count === 1) {
            // console.log('elastic count down start');
          }

          player.elasticCounter.countDown.count++;
          // console.log('elastic counting down: ',player.elasticCounter.countDown.count);
        }

        // FINISH COUNT DOWN
        if (
          player.elasticCounter.countDown.count >=
          player.elasticCounter.countDown.limit + 1
        ) {
          player.elasticCounter.countDown = {
            state: false,
            count: 0,
            limit: player.elasticCounter.countDown.limit,
          };
          // console.log('finished count down. elastic counter end');

          // IF PAUSE IS END, COUNT PAUSE
          if (
            player.elasticCounter.pause.preState === true &&
            player.elasticCounter.pause.type === "end"
          ) {
            player.elasticCounter.pause.preState = false;
            player.elasticCounter.pause.state = true;

            // console.log('end pause. turn on pause');
          }

          // IF PAUSE IS NOT END, TURN OFF ELASTIC COUNTER
          if (player.elasticCounter.pause.type !== "end") {
            player.elasticCounter.state = false;
            player.action = "idle";

            // reset deflected here?
            // console.log('pause is not end. turn off elastic count',player.success.deflected.state,player.success.deflected.count,'/',player.success.deflected.limit);
          }
        }
      }
    }

    // CHECK CELL UNDER ATTACK & PRE ATTACK!!
    for (const cell of this.cellsUnderAttack) {
      if (cell.limit > 0) {
        if (cell.count < cell.limit) {
          cell.count++;
        } else if (cell.count >= cell.limit) {
          let index = this.cellsUnderAttack.indexOf(cell);
          this.cellsUnderAttack.splice(index, 1);
        }
      }
    }
    for (const cell2 of this.cellsUnderPreAttack) {
      if (cell2.limit > 0) {
        if (cell2.count < cell2.limit) {
          cell2.count++;
        } else if (cell2.count >= cell2.limit) {
          let index = this.cellsUnderPreAttack.indexOf(cell2);
          this.cellsUnderPreAttack.splice(index, 1);
        }
      }
    }

    // OBSTACLE
    // MOVING & FALLING
    // CHECK OBSTACLE/BARRIER TRAPS AND UPDATE CELL BARRIER/OBSTACLE
    for (let cell of this.gridInfo) {
      if (
        cell.obstacle.state === true &&
        cell.obstacle.moving.state === true &&
        cell.obstacle.moving.falling.state !== true
      ) {
        // console.log("tracking moving obstacle", cell.obstacle.moving.origin);

        let destCellRef = this.gridInfo.find(
          (x) =>
            x.number.x === cell.obstacle.moving.destination.number.x &&
            x.number.y === cell.obstacle.moving.destination.number.y
        );

        let obstacleCrementObj = undefined;
        if (!destCellRef) {
          obstacleCrementObj = this.obstacleMoveCrementer(cell, {
            center: cell.obstacle.moving.destination.center,
          });
        } else {
          obstacleCrementObj = this.obstacleMoveCrementer(cell, destCellRef);
        }

        cell.obstacle.moving.nextPosition = obstacleCrementObj.pos;
        cell.obstacle.moving.step = obstacleCrementObj.step;
        nextPosition = obstacleCrementObj.pos;

        let atDestRanges = [false, false, false, false];

        let destRngIndx = undefined;
        if (
          nextPosition.x >= cell.obstacle.moving.destination.center.x - 1 &&
          nextPosition.x <= cell.obstacle.moving.destination.center.x + 1 &&
          nextPosition.y >= cell.obstacle.moving.destination.center.y - 1 &&
          nextPosition.y <= cell.obstacle.moving.destination.center.y + 1
        ) {
          atDestRanges[0] = true;
          destRngIndx = 0;
        }
        if (
          nextPosition.x === cell.obstacle.moving.destination.center.x - 0.25 &&
          nextPosition.y === cell.obstacle.moving.destination.center.y + 0.5
        ) {
          atDestRanges[1] = true;
          destRngIndx = 1;
        }
        if (
          nextPosition.x === cell.obstacle.moving.destination.center.x &&
          nextPosition.y === cell.obstacle.moving.destination.center.y
        ) {
          atDestRanges[2] = true;
          destRngIndx = 2;
        }
        if (
          nextPosition.x === cell.obstacle.moving.destination.center.x - 5 &&
          nextPosition.y === cell.obstacle.moving.destination.center.y - 5
        ) {
          atDestRanges[3] = true;
          destRngIndx = 3;
        }

        for (const el of atDestRanges) {
          if (el === true) {
            let indx = atDestRanges.indexOf(el);
            // console.log('obstacle at destination');

            if (destCellRef) {
              // console.log("obstacle at in bounds destination", cell.obstacle);

              let cell2 = cell;
              let originLevelData = cell2.levelData.split("_");
              originLevelData[1] = "*";

              let originCellRef = this.gridInfo.find(
                (x) =>
                  x.number.x === cell.obstacle.moving.origin.number.x &&
                  x.number.y === cell.obstacle.moving.origin.number.y
              );
              let destCellRef = this.gridInfo.find(
                (x) =>
                  x.number.x === cell.obstacle.moving.destination.number.x &&
                  x.number.y === cell.obstacle.moving.destination.number.y
              );

              if (
                destCellRef.void.state === true ||
                destCellRef.terrain.type === "deep"
              ) {
                destCellRef.obstacle = {
                  state: true,
                  id: cell2.obstacle.id,
                  trap: cell2.obstacle.trap,
                  name: cell2.obstacle.name,
                  type: cell2.obstacle.type,
                  hp: cell2.obstacle.hp,
                  destructible: cell2.obstacle.destructible,
                  locked: cell2.obstacle.locked,
                  weight: cell2.obstacle.weight,
                  height: cell2.obstacle.height,
                  items: cell2.obstacle.items,
                  effects: cell2.obstacle.effects,
                  moving: {
                    state: false,
                    step: 0,
                    origin: {
                      number: {
                        x: undefined,
                        y: undefined,
                      },
                      center: {
                        x: undefined,
                        y: undefined,
                      },
                    },
                    destination: {
                      number: {
                        x: undefined,
                        y: undefined,
                      },
                      center: {
                        x: undefined,
                        y: undefined,
                      },
                    },
                    currentPosition: {
                      x: undefined,
                      y: undefined,
                    },
                    nextPosition: {
                      x: destCellRef.center.x,
                      y: destCellRef.center.y,
                    },
                    moveSpeed: 0,
                    pushable: true,
                    pushed: false,
                    pusher: undefined,
                    falling: {
                      state: true,
                      count: 0,
                      limit: cell2.obstacle.moving.falling.limit,
                    },
                  },
                };

                destCellRef.obstacle.moving.nextPosition.x -= this.floorImageWidth / 2;
                destCellRef.obstacle.moving.nextPosition.y -= this.floorImageHeight / 2;
              }
              if (
                destCellRef.void.state !== true &&
                destCellRef.terrain.type !== "deep"
              ) {
                destCellRef.obstacle = {
                  id: cell2.obstacle.id,
                  trap: cell2.obstacle.trap,
                  state: true,
                  name: cell2.obstacle.name,
                  type: cell2.obstacle.type,
                  hp: cell2.obstacle.hp,
                  destructible: cell2.obstacle.destructible,
                  locked: cell2.obstacle.locked,
                  weight: cell2.obstacle.weight,
                  height: cell2.obstacle.height,
                  items: cell2.obstacle.items,
                  effects: cell2.obstacle.effects,
                  moving: {
                    state: false,
                    step: 0,
                    origin: {
                      number: originCellRef.number,
                      center: {
                        x: undefined,
                        y: undefined,
                      },
                    },
                    destination: {
                      number: destCellRef.number,
                      center: {
                        x: undefined,
                        y: undefined,
                      },
                    },
                    currentPosition: {
                      x: undefined,
                      y: undefined,
                    },
                    nextPosition: {
                      x: undefined,
                      y: undefined,
                    },
                    moveSpeed: 0,
                    pushable: true,
                    pushed: false,
                    pusher: undefined,
                    falling: cell2.obstacle.moving.falling,
                  },
                };
              }

              destCellRef.levelData = cell2.levelData;

              originCellRef.obstacle = {
                id: "",
                trap: {},
                state: false,
                name: "",
                type: "",
                hp: 0,
                destructible: {
                  state: false,
                  weapons: [],
                  leaveRubble: false,
                },
                locked: {
                  state: false,
                  key: "",
                },
                weight: 1,
                height: 0.5,
                items: [],
                effects: [],
                moving: {
                  state: false,
                  step: 0,
                  origin: {
                    number: {
                      x: undefined,
                      y: undefined,
                    },
                    center: {
                      x: undefined,
                      y: undefined,
                    },
                  },
                  destination: {
                    number: {
                      x: undefined,
                      y: undefined,
                    },
                    center: {
                      x: undefined,
                      y: undefined,
                    },
                  },
                  currentPosition: {
                    x: undefined,
                    y: undefined,
                  },
                  nextPosition: {
                    x: undefined,
                    y: undefined,
                  },
                  moveSpeed: 0,
                  pushable: true,
                  pushed: false,
                  pusher: undefined,
                  falling: {
                    state: false,
                    count: 0,
                    limit: 25,
                  },
                },
              };
              originCellRef.levelData = originLevelData.join("_");

              for (const obs of this.obstacleBarrierToDestroy) {
                if (
                  originCellRef.number.x === obs.cell.number.x &&
                  originCellRef.number.y === obs.cell.number.y &&
                  destCellRef.void.state !== true
                ) {
                  this.obstacleBarrierToDestroy.push({
                    type: "obstacle",
                    action: "damage",
                    count: 0,
                    limit: 30,
                    complete: false,
                    cell: destCellRef,
                  });
                }
              }

              for (const plyr of this.players) {
                if (
                  plyr.currentPosition.cell.number.x === destCellRef.number.x &&
                  plyr.currentPosition.cell.number.y === destCellRef.number.y
                ) {
                  this.obstaclePlayerOverlap(
                    "obstacle",
                    destCellRef,
                    plyr,
                    destCellRef.obstacle
                  );
                }
              }
              this.obstacleCheckDestination(destCellRef, player);
            } else {
              // console.log('obstacle at out of bounds destination',cell.obstacle.moving.origin.center,cell.obstacle.moving.nextPosition);
              let cell2 = cell;
              let originLevelData = cell2.levelData.split("_");
              originLevelData[1] = "*";

              cell2.obstacle.moving.falling = {
                state: true,
                count: 0,
                limit: cell2.obstacle.moving.falling.limit,
              };

              cell2.obstacle.moving.nextPosition.x -= this.floorImageWidth / 2;
              cell2.obstacle.moving.nextPosition.y -= this.floorImageHeight / 2;

              this.obstaclesOutOfBoundsFall.push(cell2.obstacle);

              let originCellRef = this.gridInfo.find(
                (x) =>
                  x.number.x === cell.obstacle.moving.origin.number.x &&
                  x.number.y === cell.obstacle.moving.origin.number.y
              );

              originCellRef.obstacle = {
                id: 0,
                trap: {},
                state: false,
                name: "",
                type: "",
                hp: 0,
                destructible: {
                  state: false,
                  weapons: [],
                  leaveRubble: false,
                },
                locked: {
                  state: false,
                  key: "",
                },
                weight: 1,
                height: 0.5,
                items: [],
                effects: [],
                moving: {
                  state: false,
                  step: 0,
                  origin: {
                    number: {
                      x: undefined,
                      y: undefined,
                    },
                    center: {
                      x: undefined,
                      y: undefined,
                    },
                  },
                  destination: {
                    number: {
                      x: undefined,
                      y: undefined,
                    },
                    center: {
                      x: undefined,
                      y: undefined,
                    },
                  },
                  currentPosition: {
                    x: undefined,
                    y: undefined,
                  },
                  nextPosition: {
                    x: undefined,
                    y: undefined,
                  },
                  moveSpeed: 0,
                  pushable: true,
                  pushed: false,
                  pusher: undefined,
                  falling: {
                    state: false,
                    count: 0,
                    limit: 25,
                  },
                },
              };
              originCellRef.levelData = originLevelData.join("_");
            }

            break;
          }
        }

        // if (cell.obstacle.moving.step >= 1) {
        //
        // }
      }

      // step falling.count
      if (cell.obstacle.state === true && cell.obstacle.moving.falling.state === true) {
        // console.log('falling obstacle');
        if (cell.obstacle.moving.falling.count < cell.obstacle.moving.falling.limit) {
          cell.obstacle.moving.falling.count++;
          // console.log('obstacle falling in bounds a count',cell.obstacle.moving.falling.count,'position',cell.obstacle.moving.nextPosition);
        }
        if (cell.obstacle.moving.falling.count >= cell.obstacle.moving.falling.limit) {
          let cell2 = cell;
          let levelData = cell2.levelData.split("_");
          levelData[1] = "*";
          cell.levelData = levelData.join("_");
          cell.obstacle = {
            id: 0,
            trap: {},
            state: false,
            name: "",
            type: "",
            hp: 0,
            destructible: {
              state: false,
              weapons: [],
              leaveRubble: false,
            },
            locked: {
              state: false,
              key: "",
            },
            weight: 1,
            height: 0.5,
            items: [],
            effects: [],
            moving: {
              state: false,
              step: 0,
              origin: {
                number: {
                  x: undefined,
                  y: undefined,
                },
                center: {
                  x: undefined,
                  y: undefined,
                },
              },
              destination: {
                number: {
                  x: undefined,
                  y: undefined,
                },
                center: {
                  x: undefined,
                  y: undefined,
                },
              },
              currentPosition: {
                x: undefined,
                y: undefined,
              },
              nextPosition: {
                x: undefined,
                y: undefined,
              },
              moveSpeed: 0,
              pushable: true,
              pushed: false,
              pusher: undefined,
              falling: {
                state: false,
                count: 0,
                limit: 10,
              },
            },
          };
          // console.log('obstacle falling in bounds over');
        }
      }

      // CHECK OBSTACLE/BARRIER TRAPS AND UPDATE CELL BARRIER/OBSTACLE
      if (cell.obstacle.state === true) {
        if (cell.obstacle.trap?.state === true) {
          cell = this.obstacleBarrierTrapChecker(cell, "obstacle");
        }
      }
      if (cell.barrier.state === true) {
        if (cell.barrier.trap?.state === true) {
          cell = this.obstacleBarrierTrapChecker(cell, "barrier");
        }
      }
    }
    for (const elem of this.obstaclesOutOfBoundsFall) {
      if (elem.moving.falling.count < elem.moving.falling.limit) {
        elem.moving.falling.count++;
        // obstacle.moving.nextPosition.y += (obstacle.moving.falling.count*5)
        // console.log('obstacle falling out of bounds a count',elem.moving.falling.count,'position',elem.moving.nextPosition);
      }
      if (elem.moving.falling.count >= elem.moving.falling.limit) {
        // console.log('obstacle falling out of bounds over');
        let index = this.obstaclesOutOfBoundsFall.indexOf(elem);
        this.obstaclesOutOfBoundsFall.splice(index, 1);
      }
    }
    // OBSTACLE/BARRIER DAMAGE/DESTROY
    for (const cell of this.obstacleBarrierToDestroy) {
      if (cell.limit > 0) {
        if (cell.count < cell.limit) {
          cell.count++;
        } else if (cell.count >= cell.limit) {
          let index = this.obstacleBarrierToDestroy.indexOf(cell);
          this.obstacleBarrierToDestroy.splice(index, 1);
        }
      }
    }
    // HALF PUSHED BACK
    for (const halfPushBackObstacle of this.halfPushBackObstacles) {
      if (halfPushBackObstacle.state === true) {
        if (halfPushBackObstacle.countUp.state === true) {
          if (halfPushBackObstacle.countUp.count < halfPushBackObstacle.countUp.limit) {
            if (halfPushBackObstacle.countUp.count === 1) {
              // console.log("obstacle 1/2 pushback start", halfPushBackObstacle.myCellNo);
            }

            halfPushBackObstacle.countUp.count++;
            // console.log("obstacle 1/2 pushback count up", halfPushBackObstacle.countUp.count);
          }

          if (halfPushBackObstacle.countUp.count >= halfPushBackObstacle.countUp.limit) {
            halfPushBackObstacle.countUp = {
              state: false,
              count: 0,
              limit: halfPushBackObstacle.countUp.limit,
            };

            // console.log('obstacle 1/2 pushback peak');
            // this.handleHalfPushBackResult('obstacle',halfPushBackObstacle);
            halfPushBackObstacle.countDown.state = true;
          }
        }

        if (halfPushBackObstacle.countDown.state === true) {
          if (
            halfPushBackObstacle.countDown.count < halfPushBackObstacle.countDown.limit
          ) {
            halfPushBackObstacle.countDown.count++;
            // console.log('obstacle 1/2 pushback count down',halfPushBackObstacle.countDown.count);
          }

          if (
            halfPushBackObstacle.countDown.count >= halfPushBackObstacle.countDown.limit
          ) {
            halfPushBackObstacle.countDown = {
              state: false,
              count: 0,
              limit: halfPushBackObstacle.countDown.limit,
            };

            // console.log("obstacle 1/2 pushback end");
            this.handleHalfPushBackResult("obstacle", halfPushBackObstacle);
            halfPushBackObstacle.state = false;
          }
        }
      }

      if (halfPushBackObstacle.state !== true) {
        let index = this.halfPushBackObstacles.indexOf(halfPushBackObstacle);
        this.halfPushBackObstacles.splice(index, 1);
      }
    }

    // ITEMS TO DROP
    // -call itemdrop crementer and set position like w/ movement
    for (const cell of this.obstacleItemsToDrop) {
      if (cell.limit > 0) {
        if (cell.count < cell.limit) {
          cell.count++;
        } else if (cell.count >= cell.limit) {
          let index = this.obstacleItemsToDrop.indexOf(cell);
          this.obstacleItemsToDrop.splice(index, 1);
        }
      }
    }

    // ITEMS FALLING/SINKING

    // STATUS DISPLAY STEPPER!!
    if (
      player.statusDisplay.state === true &&
      player.statusDisplay.count < player.statusDisplay.limit
    ) {
      // console.log('stepping status display');
      player.statusDisplay.count++;
    } else if (
      player.statusDisplay.state === true &&
      player.statusDisplay.count >= player.statusDisplay.limit
    ) {
      // console.log('hide status display');
      player.statusDisplay = {
        state: false,
        status: "",
        count: 0,
        limit: player.statusDisplay.limit,
      };
    }

    // POPUPS
    // Testing
    if (this.time === 50 || this.time === 300) {
      let newArray = [];
      let x = 0;
      let y = 0;
      for (const [key, value] of Object.entries(this.popupImageRef)) {
        newArray.push(key);
      }
      for (var i = 0; i < 1; i++) {
        // if (
        //   !player.popups.find((x) => x.msg === newArray[i]) &&
        //   // player.number === 2 &&
        //   newArray[i] !== "hpUp" &&
        //   newArray[i] !== "hpDown"
        // ) {
        //   player.popups.push({
        //     state: false,
        //     count: 0,
        //     limit: 30,
        //     type: "",
        //     position: "",
        //     msg: newArray[i],
        //     img: "",
        //     cell: this.gridInfo.find(
        //       (x) =>
        //         x.number.x === player.currentPosition.cell.number.x &&
        //         x.number.y === player.currentPosition.cell.number.y
        //     ),
        //   });
        // }
        // if (
        //   newArray[i] !==  "hpUp" &&
        //   newArray[i] !==  "hpDown" &&
        //   !this.cellPopups.find(x => x.msg === newArray[i] && x.cell.number.x === 1 && x.cell.number.y === 5)
        // ) {
        //   this.cellPopups.push(
        //     {
        //       state: false,
        //       count: 0,
        //       limit: 35,
        //       type: '',
        //       position: '',
        //       msg: newArray[i],
        //       img: '',
        //       cell: this.gridInfo.find(x => x.number.x === 1 && x.number.y === 5)
        //     }
        //   )
        // }
        // if (!this.cellPopups.find((x) => x.msg === "test" && x.cell.number.x === 4 && x.cell.number.y === 3)) {
        //   this.cellPopups.push({
        //     state: false,
        //     count: 0,
        //     limit: 35,
        //     type: "",
        //     position: "",
        //     msg: "bgvgv",
        //     color: "",
        //     img: "",
        //     cell: this.gridInfo.find((x) => x.number.x === 4 && x.number.y === 3),
        //   });
        // }
      }
    }
    //PLAYER
    if (player.popups.length > 0) {
      for (const popup of player.popups) {
        let indx = player.popups.findIndex((x) => x === popup);
        if (popup.state === true && popup.position !== "northWest") {
          if (popup.limit > 0) {
            if (popup.state === true && popup.count < popup.limit) {
              popup.count++;
            }
            if (popup.count >= popup.limit) {
              player.popups.splice(indx, 1);
            }
          }
          if (popup.limit === 0) {
            // check if the player state it relates to is true, if not remove it
          }
        }
      }

      let currentPopupCount = player.popups.filter((x) => x.state === true).length;
      for (const popup2 of player.popups) {
        if (currentPopupCount < 8) {
          let indx = player.popups.findIndex((x) => x === popup2);
          if (popup2.state === false) {
            popup2.state = true;
            currentPopupCount++;
            // console.log('turn on new popup',popup2.msg);
          }
        } else {
          // console.log('currentPopup display full..',popup2.msg);
        }
      }
    }
    // CELL
    if (this.cellPopups.length > 0) {
      for (const popup of this.cellPopups) {
        let indx = this.cellPopups.findIndex((x) => x === popup);
        if (popup.state === true) {
          if (popup.limit > 0) {
            if (popup.state === true && popup.count < popup.limit) {
              popup.count++;
            }
            if (popup.count >= popup.limit) {
              this.cellPopups.splice(indx, 1);
            }
          }
          if (popup.limit === 0) {
            // check if the player state it relates to is true, if not remove it
          }
        }
      }

      let currentPopupCount = this.cellPopups.filter((x) => x.state === true).length;
      for (const popup2 of this.cellPopups) {
        if (currentPopupCount < 8) {
          let indx = this.cellPopups.findIndex((x) => x === popup2);
          if (popup2.state === false) {
            popup2.state = true;
            currentPopupCount++;
            // console.log('turn on new popup',popup2.msg);
          }
        } else {
          // console.log('currentPopup display full..',popup2.msg);
        }
      }
    }

    // CAMERA
    if (this.setInitZoom.state === true) {
      if (this.setInitZoom.gridWidth >= 12) {
        // if (this.setInitZoom.windowWidth < 1100) {

        if (this.camera.zoom.x - 1 >= this.zoomThresh) {
          this.camera.zoom.x -= 0.02;
          this.camera.zoom.y -= 0.02;
          this.camera.zoomDirection = "out";

          let zoom = this.camera.zoom.x;
          let diff = 1 - zoom;

          // this.camera.zoomFocusPan.x = (diff*(canvas.width/2));
          // this.camera.zoomFocusPan.y = (diff*(canvas.width/2))-(diff*(canvas.width/6));

          // TRY THESE FOR CAM SMOOTHNESS
          this.camera.zoomFocusPan.x =
            (canvas.width / 2) * (1 - zoom) + 1 + this.camera.pan.x * zoom;
          this.camera.zoomFocusPan.y =
            (canvas.height / 2) * (1 - zoom) + 1 + this.camera.pan.y * zoom;

          this.camera.mode = "zoom";
          this.setZoomPan(canvas);
          this.findFocusCell("panToCell", "", {}, canvas, context);
        }

        if (this.camera.zoom.x - 1 < this.zoomThresh) {
          this.setInitZoom.state = false;
        }

        // }
        if (this.setInitZoom.windowWidth > 1100) {
        }
      }

      if (this.setInitZoom.gridWidth < 12) {
        // if (this.setInitZoom.windowWidth < 1100) {

        if (this.camera.zoom.x - 1 >= this.zoomThresh) {
          this.camera.zoom.x -= 0.02;
          this.camera.zoom.y -= 0.02;
          // this.camera.zoomDirection = 'in';
          this.camera.zoomDirection = "out";

          let zoom = this.camera.zoom.x;
          let diff = 1 - zoom;

          // this.camera.zoomFocusPan.x = (diff*(canvas.width/2));
          // this.camera.zoomFocusPan.y = (diff*(canvas.width/2))-(diff*(canvas.width/6));

          // TRY THESE FOR CAM SMOOTHNESS
          this.camera.zoomFocusPan.x =
            (canvas.width / 2) * (1 - zoom) + 1 + this.camera.pan.x * zoom;
          this.camera.zoomFocusPan.y =
            (canvas.height / 2) * (1 - zoom) + 1 + this.camera.pan.y * zoom;

          this.camera.mode = "zoom";

          // console.log('zooming out to init',this.camera.zoom.x-1);
          // this.setCameraFocus('input',canvas, context, canvas2, context2);
          this.setZoomPan(canvas);
          this.findFocusCell("panToCell", "", {}, canvas, context);
        }

        if (this.camera.zoom.x - 1 < this.zoomThresh) {
          this.setInitZoom.state = false;
        }

        // }
      }
      // console.log('zooming out to init',this.camera.zoom.x-1);
    }
    //INPUT MODE SWITCH
    if (this.toggleCameraMode === false && this.camera.state === true) {
      this.camera.startCount = 0;
    }
    if (
      this.camera.state === false &&
      this.toggleCameraMode === false &&
      this.camera.startCount >= this.camera.startLimit &&
      this.camera.instructionType === "default"
    ) {
      // console.log('welcome to input camera mode');

      let canStart = true;
      if (
        this.camera.instructions.length > 0 ||
        this.camera.preInstructions.length > 0 ||
        this.settingAutoCamera === true ||
        this.autoCamPanWaitingForPath === true
        // this.toggleCameraMode === false
      ) {
        canStart = false;
      }
      if (this.camera.customView.state === false) {
        if (
          this.camera.zoom.x - 1 > this.zoomThresh ||
          this.camera.zoom.x - 1 < this.zoomThresh
        ) {
          canStart = false;
        }
        // if ((this.camera.zoom.x-1) > (this.zoomThresh+.01) || (this.camera.zoom.x-1) < (this.zoomThresh-.01)) {
        //   canStart = false;
        // }
        if (this.camera.pan.x < -1 || this.camera.pan.x > -1) {
          canStart = false;
        }
        if (this.camera.pan.y < -1 || this.camera.pan.y > -1) {
          canStart = false;
        }
      }

      if (canStart === true) {
        this.camera.startCount = 0;
        this.camera.state = true;
        this.camera.fixed = true;
      }
      if (canStart === false) {
        this.camera.startCount = 0;
        console.log("auto cam is probably engaged. Can't start input cam");
      }
    }
    if (this.toggleCameraMode === true) {
      let state = this.toggleCameraMode;

      if (
        this.camera.state === false &&
        state === true &&
        this.camera.startCount < this.camera.startLimit
      ) {
        // console.log('starting camera mode ...');
        this.camera.startCount++;
      }
      if (
        this.camera.state === true &&
        state === true &&
        this.camera.startCount < this.camera.startLimit
      ) {
        // console.log('leaving camera mode ...');
        this.camera.startCount++;
      }
      if (
        this.camera.state === true &&
        state === true &&
        this.camera.startCount >= this.camera.startLimit
      ) {
        // console.log('thank you for using the camera');
        this.camera.startCount = 0;
        this.camera.state = false;
        this.camera.fixed = false;

        if (
          this.camera.customView.state !== true &&
          this.settingAutoCamera === false &&
          this.camera.preInstructions.length === 0 &&
          this.camera.instructions.length === 0
          // (this.camera.zoom.x-1) > this.zoomThresh
        ) {
          this.setAutoCamera("zoomReset", player);
        }
      }
    }
    //INDICATOR COUNTER
    if (this.camera.limits.state.zoom === true || this.camera.limits.state.pan === true) {
      if (this.camera.limits.state.count < this.camera.limits.state.limit) {
        this.camera.limits.state.count++;
      }
    }
    if (this.camera.limits.state.zoom === true || this.camera.limits.state.pan === true) {
      if (this.camera.limits.state.count >= this.camera.limits.state.limit) {
        this.camera.limits.state.count = 0;
        this.camera.limits.state.zoom = false;
        this.camera.limits.state.pan = false;
      }
    }
    //INPUT MODE CONTROLS
    if (this.camera.state === true && this.camera.instructionType === "default") {
      let setFocus = false;
      let setZoomPan = false;
      let findFocusCell = false;

      // IDLE ANIM STEPPER!
      if (player.action === "idle") {
        // player.idleAnim.state = true
        if (player.idleAnim.count < player.idleAnim.limit) {
          // console.log('player.idleAnim.count',player.idleAnim.count);
          player.idleAnim.count++;
        }
        if (player.idleAnim.count >= player.idleAnim.limit) {
          player.idleAnim.count = 0;
          player.idleAnim.state = false;
        }
      } else if (player.action !== "idle") {
        // player.idleAnim.state = false;
        player.idleAnim.count = 0;
      }

      if (this.keyPressed[player.number - 1].attack === true) {
        // if mode is pan and x or y are outside threshold +/- 2, log pan value, special value = true
        this.camera.mode = "zoom";
      }
      if (this.keyPressed[player.number - 1].defend === true) {
        this.camera.mode = "pan";
      }
      if (this.keyPressed[player.number - 1].dodge === true) {
        if (
          this.camera.customView.keyPressCount.start <
          this.camera.customView.keyPressCount.limit
        ) {
          this.camera.customView.keyPressCount.start++;
        }
        if (
          this.camera.customView.keyPressCount.start >=
          this.camera.customView.keyPressCount.limit
        ) {
          this.camera.customView.keyPressCount.start = 0;
          this.toggleCameraCustomView();
        }
      }

      if (this.camera.mode === "zoom") {
        if (
          this.keyPressed[player.number - 1].north === true &&
          this.keyPressed[player.number - 1].south !== true &&
          this.camera.zoom.x < this.camera.limits.zoom.max
        ) {
          this.camera.zoom.x += 0.02;
          this.camera.zoom.y += 0.02;
          this.camera.zoomDirection = "in";
          setFocus = true;
          setZoomPan = true;

          // console.log('zooming in',this.camera.zoom.x);
        }
        if (
          this.keyPressed[player.number - 1].north === true &&
          this.camera.zoom.x >= this.camera.limits.zoom.max
        ) {
          this.camera.limits.state.zoom = true;
          // console.log('zoom in limit',this.camera.limits.state.zoom);
        }
        if (
          this.keyPressed[player.number - 1].south === true &&
          this.keyPressed[player.number - 1].north !== true &&
          this.camera.zoom.x > this.camera.limits.zoom.min
        ) {
          this.camera.zoom.x -= 0.02;
          this.camera.zoom.y -= 0.02;
          this.camera.zoomDirection = "out";
          setFocus = true;
          setZoomPan = true;

          // console.log('zooming out',this.camera.zoom.x);
        }
        if (
          this.keyPressed[player.number - 1].south === true &&
          this.camera.zoom.x <= this.camera.limits.zoom.min
        ) {
          // console.log('zoom out limit');
          this.camera.limits.state.zoom = true;
        }
      }

      if (this.camera.mode === "pan") {
        // ONLY PAN IF CANT SEE WHOLE MAP
        let canPan = false;

        if (this.gridWidth >= 12) {
          // if (this.camera.zoom.x > .8) {
          if (this.camera.zoom.x - 1 > this.zoomThresh) {
            canPan = true;
          }
        } else {
          if (this.camera.zoom.x - 1 > this.zoomThresh) {
            canPan = true;
          }
        }

        if (canPan === true) {
          // console.log('canPan',canPan);

          if (
            this.keyPressed[player.number - 1].north === true &&
            this.keyPressed[player.number - 1].south !== true &&
            this.keyPressed[player.number - 1].east !== true &&
            this.keyPressed[player.number - 1].west !== true &&
            this.camera.pan.y < this.camera.limits.pan.y.max
          ) {
            this.camera.pan.y += 10;
            this.camera.adjustedPan.y += 10 * this.camera.zoom.x;
            this.camera.panDirection = "north";
            setFocus = true;
            setZoomPan = true;
            findFocusCell = true;

            // console.log('input panning north',this.camera.pan.y);
          }
          if (
            this.keyPressed[player.number - 1].north === true &&
            this.camera.pan.y >= this.camera.limits.pan.y.max
          ) {
            // console.log('pan limit north',this.camera.pan.y,'/',this.camera.limits.pan.y.max);
            this.camera.limits.state.pan = true;
          }
          if (
            this.keyPressed[player.number - 1].south === true &&
            this.keyPressed[player.number - 1].north !== true &&
            this.keyPressed[player.number - 1].west !== true &&
            this.keyPressed[player.number - 1].east !== true &&
            this.camera.pan.y > this.camera.limits.pan.y.min
          ) {
            this.camera.pan.y -= 10;
            this.camera.adjustedPan.y -= 10 * this.camera.zoom.x;
            this.camera.panDirection = "south";
            setFocus = true;
            setZoomPan = true;
            findFocusCell = true;

            // console.log('input panning south',this.camera.pan.y);
          }
          if (
            this.keyPressed[player.number - 1].south === true &&
            this.camera.pan.y <= this.camera.limits.pan.y.min
          ) {
            // console.log('pan limit south',this.camera.pan.y,'/',this.camera.limits.pan.y.min);
            this.camera.limits.state.pan = true;
          }
          if (
            this.keyPressed[player.number - 1].east === true &&
            this.keyPressed[player.number - 1].west !== true &&
            this.keyPressed[player.number - 1].north !== true &&
            this.keyPressed[player.number - 1].south !== true &&
            this.camera.pan.x > this.camera.limits.pan.x.min
          ) {
            this.camera.pan.x -= 10;
            this.camera.adjustedPan.x -= 10 * this.camera.zoom.x;
            this.camera.panDirection = "east";
            setFocus = true;
            setZoomPan = true;
            findFocusCell = true;

            // console.log('input panning east',this.camera.pan.x);
          }
          if (
            this.keyPressed[player.number - 1].east === true &&
            this.camera.pan.x <= this.camera.limits.pan.x.min
          ) {
            // console.log('pan limit east',this.camera.pan.x,'/',this.camera.limits.pan.x.min);
            this.camera.limits.state.pan = true;
          }
          if (
            this.keyPressed[player.number - 1].west === true &&
            this.keyPressed[player.number - 1].east !== true &&
            this.keyPressed[player.number - 1].north !== true &&
            this.keyPressed[player.number - 1].south !== true &&
            this.camera.pan.x < this.camera.limits.pan.x.max
          ) {
            this.camera.pan.x += 10;
            this.camera.adjustedPan.x += 10 * this.camera.zoom.x;
            this.camera.panDirection = "west";
            setFocus = true;
            setZoomPan = true;
            findFocusCell = true;

            // console.log('input panning west',this.camera.pan.x);
          }
          if (
            this.keyPressed[player.number - 1].west === true &&
            this.camera.pan.x >= this.camera.limits.pan.x.max
          ) {
            // console.log('pan limit west',this.camera.pan.x,'/',this.camera.limits.pan.x.max);
            this.camera.limits.state.pan = true;
          }
        } else {
          // console.log('cant pan at this zoom');
          // this.camera.limits.state.pan = true;

          if (
            this.keyPressed[player.number - 1].north === true ||
            this.keyPressed[player.number - 1].south === true ||
            this.keyPressed[player.number - 1].east === true ||
            this.keyPressed[player.number - 1].west === true
          ) {
            this.camera.limits.state.pan = true;
          }
        }
      }

      // ADJUST PAN WHEN ZOOMING TO KEEP CENTERED
      if (setZoomPan === true) {
        this.setZoomPan(canvas);
        findFocusCell = true;
      }

      //SET CAMERA FOCUS
      if (setFocus === true) {
        // this.setCameraFocus('input',canvas, context, canvas2, context2);
      }

      if (findFocusCell) {
        this.findFocusCell("panToCell", "", {}, canvas, context);
      }
    }
    // RESET
    if (this.resetCameraSwitch === true) {
      // console.log('resetting camera');

      this.resetCameraSwitch = false;
      this.camera = {
        state: true,
        startCount: 0,
        startLimit: 4,
        mode: "pan",
        fixed: false,
        target: {
          type: "player",
          plyrNo: 1,
          cell: {
            x: undefined,
            y: undefined,
          },
        },
        focus: {
          x: undefined,
          y: undefined,
        },
        focusCell: {
          x: this.camera.focusCell.x,
          y: this.camera.focusCell.y,
        },
        cellToPanOrigin: {
          x: undefined,
          y: undefined,
        },
        zoom: {
          x: 1,
          y: 1,
        },
        zoomDirection: "in",
        pan: {
          x: 1,
          y: 1,
        },
        panDirection: "east",
        zoomFocusPan: {
          x: -1,
          y: -1,
        },
        adjustedPan: {
          x: 1,
          y: 1,
        },
        limits: {
          zoom: {
            min: 0.5,
            max: 2.5,
          },
          pan: {
            x: {
              min: -400,
              max: 400,
            },
            y: {
              min: -200,
              max: 200,
            },
          },
          state: {
            count: 0,
            limit: 10,
            zoom: false,
            pan: false,
          },
        },
        instructionType: "default",
        currentPreInstruction: 0,
        preInstructions: [],
        currentInstruction: 0,
        instructions: [],
        customView: {
          state: false,
          zoom: 0,
          pan: {
            x: 0,
            y: 0,
          },
          keyPressCount: {
            start: 0,
            limit: 4,
          },
        },
      };

      this.setZoomPan(canvas);

      // this.setCameraFocus('reset', canvas, context, canvas2, context2);
    }
    // AUTO CAMERA
    if (this.camera.state !== true && this.camera.fixed !== true) {
      if (this.camera.instructionType === "default") {
        // PRE/RAW INSTRUCTIONS!!
        if (
          this.camera.preInstructions.length > 0 &&
          this.camera.instructions.length === 0 &&
          this.autoCamPanWaitingForPath !== true
        ) {
          // console.log('step through auto camera pre instructions',this.camera.preInstructions);

          let preInstruction =
            this.camera.preInstructions[this.camera.currentPreInstruction];
          // let indx = this.camera.preInstructions.indexOf(preInstruction)
          let focusCell = {
            x: undefined,
            y: undefined,
          };
          // console.log('Step through pre instructions...','preInstructions',preInstruction);

          let speed = null;
          switch (preInstruction.split("_")[0]) {
            case "moveTo":
              speed = preInstruction.split("_")[3];
              if (
                preInstruction.split("_")[0] === "moveTo" &&
                this.autoCamPanWaitingForPath !== true
              ) {
                this.autoCamPanWaitingForPath = true;
                focusCell.x = parseInt(preInstruction.split("_")[1]);
                focusCell.y = parseInt(preInstruction.split("_")[2]);

                this.findFocusCell(
                  "cellToPan",
                  "moveTo",
                  focusCell,
                  canvas,
                  context,
                  speed
                );
              }
              break;
            case "zoom":
              if (preInstruction.split("_")[1] === "outToInit") {
                let zoomSteps = (
                  (this.camera.zoom.x - 1 - this.zoomThresh) /
                  0.02
                ).toFixed(0);
                zoomSteps = parseInt(zoomSteps);
                if (zoomSteps === 0) {
                  zoomSteps = 1;
                }
                if (zoomSteps < 0) {
                  zoomSteps = zoomSteps * -1;
                }

                this.camera.instructions.push({
                  action: "zoom_out_" + zoomSteps,
                  // action:'zoom_outToInit',
                  action2: "",
                  count: 0,
                  count2: 0,
                  limit: zoomSteps,
                  // limit: 1,
                  limit2: 0,
                  speed: "",
                });
              }
              if (preInstruction.split("_")[1] === "inToInit") {
                let zoomSteps = (
                  (this.zoomThresh - (this.camera.zoom.x - 1)) /
                  0.02
                ).toFixed(0);
                zoomSteps = parseInt(zoomSteps);
                if (zoomSteps === 0) {
                  zoomSteps = 1;
                }
                if (zoomSteps < 0) {
                  zoomSteps = zoomSteps * -1;
                }

                this.camera.instructions.push({
                  action: "zoom_in_" + zoomSteps,
                  // action:'zoom_outToInit',
                  action2: "",
                  count: 0,
                  count2: 0,
                  limit: zoomSteps,
                  // limit: 1,
                  limit2: 0,
                  speed: "",
                });
              } else if (
                preInstruction.split("_")[1] !== "inToInit" &&
                preInstruction.split("_")[1] !== "outToInit"
              ) {
                this.camera.instructions.push({
                  action: "zoom_" + preInstruction.split("_")[1],
                  action2: "",
                  count: 0,
                  count2: 0,
                  limit: parseInt(preInstruction.split("_")[2]),
                  limit2: 0,
                  speed: "",
                });
              }

              break;
            case "waitFor":
              this.camera.instructions.push({
                action: "wait",
                action2: "",
                count: 0,
                count2: 0,
                limit: parseInt(preInstruction.split("_")[1]),
                limit2: 0,
                speed: "",
              });

              break;
            case "move&&zoom":
              speed = preInstruction.split("_")[4];
              if (this.autoCamPanWaitingForPath !== true) {
                this.autoCamPanWaitingForPath = true;
                focusCell.x = parseInt(preInstruction.split("_")[2]);
                focusCell.y = parseInt(preInstruction.split("_")[3]);

                this.findFocusCell(
                  "cellToPan",
                  "move&&zoom_" +
                    preInstruction.split("_")[1] +
                    "_" +
                    preInstruction.split("_")[5],
                  focusCell,
                  canvas,
                  context,
                  speed
                );
              }

              break;
          }

          if (
            this.camera.currentPreInstruction ===
            this.camera.preInstructions.length - 1
          ) {
            // console.log("this is the last preInstruction. Empty array");
            this.camera.preInstructions = [];
            this.camera.currentPreInstruction = 0;
            // console.log('camera instructions',this.camera.instructions);
          } else {
            this.camera.currentPreInstruction++;
          }

          // console.log("auto camera: pre instruction parsed: ", this.camera.instructions);
        }

        const increment = (mode, direction) => {
          if (mode === "zoom") {
            this.camera.mode = "zoom";

            switch (direction) {
              case "in":
                if (this.camera.zoom.x >= this.camera.limits.zoom.max) {
                  this.camera.limits.state.zoom = true;
                  // console.log('auto cam zoom in limit fast',this.camera.zoom.x,'/',this.camera.limits.zoom.max,this.camera.instructions[this.camera.currentInstruction].count);
                } else {
                  this.camera.zoom.x += 0.02;
                  this.camera.zoom.y += 0.02;
                  this.camera.zoomDirection = "in";
                  // console.log('auto cam zooming in fast ',this.camera.instructions[this.camera.currentInstruction].count);
                }
                break;
              case "out":
                if (this.camera.zoom.x <= this.camera.limits.zoom.min) {
                  this.camera.limits.state.zoom = true;
                  // console.log('auto cam zoom in limit fast ',this.camera.zoom.x,'/',this.camera.limits.zoom.min,this.camera.instructions[this.camera.currentInstruction].count);
                } else {
                  this.camera.zoom.x -= 0.02;
                  this.camera.zoom.y -= 0.02;
                  this.camera.zoomDirection = "out";
                  // console.log('auto cam zooming out fast ',this.camera.instructions[this.camera.currentInstruction].count);
                }
                break;
              case "outToInit":
                // this.setInitZoom.state = true;
                if (this.setInitZoom.state !== true) {
                  this.setInitZoom = {
                    state: true,
                    windowWidth: window.innerWidth,
                    gridWidth: this.gridWidth,
                  };
                }

                break;
            }

            this.setZoomPan(canvas);
            this.findFocusCell("panToCell", "", {}, canvas, context);
          }
          if (mode === "pan") {
            this.camera.mode = "pan";

            switch (direction) {
              case "north":
                if (this.camera.pan.y >= this.camera.limits.pan.y.max) {
                  // console.log('auto cam pan limit north fast ',this.camera.pan.y,'/',this.camera.limits.pan.y.max,this.camera.instructions[this.camera.currentInstruction].count);
                  this.camera.limits.state.pan = true;
                } else {
                  this.camera.pan.y += 1;
                  this.camera.adjustedPan.y += 1 * this.camera.zoom.x;
                  this.camera.panDirection = "north";
                  // console.log('auto cam panning north fast ',this.camera.instructions[this.camera.currentInstruction].count)
                }
                break;
              case "south":
                if (this.camera.pan.y <= this.camera.limits.pan.y.min) {
                  // console.log('auto cam pan limit south fast ',this.camera.pan.y,'/',this.camera.limits.pan.y.min,this.camera.instructions[this.camera.currentInstruction].count);
                  this.camera.limits.state.pan = true;
                } else {
                  this.camera.pan.y -= 1;
                  this.camera.adjustedPan.y -= 1 * this.camera.zoom.x;
                  this.camera.panDirection = "south";
                  // console.log('auto cam panning south fast ',this.camera.instructions[this.camera.currentInstruction].count)
                }
                break;
              case "east":
                if (this.camera.pan.x <= this.camera.limits.pan.x.min) {
                  // console.log('auto cam pan limit east fast ',this.camera.pan.x,'/',this.camera.limits.pan.x.min,this.camera.instructions[this.camera.currentInstruction].count);
                  this.camera.limits.state.pan = true;
                } else {
                  this.camera.pan.x -= 1;
                  this.camera.adjustedPan.x -= 1 * this.camera.zoom.x;
                  this.camera.panDirection = "east";
                  // console.log('auto cam panning east fast ',this.camera.instructions[this.camera.currentInstruction].count)
                }
                break;
              case "west":
                if (
                  this.keyPressed[player.number - 1].west === true &&
                  this.camera.pan.x >= this.camera.limits.pan.x.max
                ) {
                  // console.log('auto cam pan limit west fast ',this.camera.pan.x,'/',this.camera.limits.pan.x.max,this.camera.instructions[this.camera.currentInstruction].count);
                  this.camera.limits.state.pan = true;
                } else {
                  this.camera.pan.x += 1;
                  this.camera.adjustedPan.x += 1 * this.camera.zoom.x;
                  this.camera.panDirection = "west";
                  // console.log('auto cam panning west fast ',this.camera.instructions[this.camera.currentInstruction].count)
                }
                break;
            }

            this.setZoomPan(canvas);
            this.findFocusCell("panToCell", "", {}, canvas, context);
          }
        };

        // PARSED INSTRUCTIONS!
        let secondaryAction = false;
        let tertiaryAction = false;
        let currentInstruction = this.camera.instructions[this.camera.currentInstruction];
        if (
          this.camera.instructions.length > 0 &&
          this.camera.currentInstruction < this.camera.instructions.length
        ) {
          // console.log(this.camera.zoom.x-1,'auto camera: stepping through all instructions... current',this.camera.currentInstruction,this.camera.instructions[this.camera.currentInstruction]);

          if (this.camera.instructions[this.camera.currentInstruction]) {
            if (this.camera.instructions[this.camera.currentInstruction].action !== "") {
              if (
                this.camera.instructions[this.camera.currentInstruction].count <
                this.camera.instructions[this.camera.currentInstruction].limit
              ) {
                if (
                  this.camera.instructions[this.camera.currentInstruction].action ===
                  "wait"
                ) {
                  // waiting/ do nothing
                  // console.log('waiting',this.camera.instructions[this.camera.currentInstruction].count);
                  this.camera.instructions[this.camera.currentInstruction].count++;
                } else {
                  if (
                    this.camera.instructions[this.camera.currentInstruction].speed ===
                    "fast"
                  ) {
                    for (
                      var i = 0;
                      i < this.camera.instructions[this.camera.currentInstruction].limit;
                      i++
                    ) {
                      if (
                        this.camera.instructions[
                          this.camera.currentInstruction
                        ].action.split("_")[0] === "zoom"
                      ) {
                        // console.log('fast zooming ',this.camera.instructions[this.camera.currentInstruction].action.split("_")[1],' primary. coount:  ',this.camera.instructions[this.camera.currentInstruction].count);

                        increment(
                          "zoom",
                          this.camera.instructions[
                            this.camera.currentInstruction
                          ].action.split("_")[1]
                        );

                        if (
                          this.camera.instructions[this.camera.currentInstruction]
                            .action2 !== "" &&
                          this.camera.instructions[this.camera.currentInstruction]
                            .count2 <
                            this.camera.instructions[this.camera.currentInstruction]
                              .limit2
                        ) {
                          secondaryAction = true;
                          if (
                            this.camera.instructions[
                              this.camera.currentInstruction
                            ].action2.split("_")[0] === "zoom"
                          ) {
                            increment(
                              "zoom",
                              this.camera.instructions[
                                this.camera.currentInstruction
                              ].action2.split("_")[1]
                            );
                          }
                          if (
                            this.camera.instructions[
                              this.camera.currentInstruction
                            ].action2.split("_")[0] === "pan"
                          ) {
                            if (
                              this.camera.instructions[
                                this.camera.currentInstruction
                              ].action.split("_")[0] === "pan"
                            ) {
                              for (let index = 0; index < 2; index++) {
                                // console.log('slow panning ',this.camera.instructions[this.camera.currentInstruction].action2.split("_")[1],' secondary. count: ',this.camera.instructions[this.camera.currentInstruction].count2);

                                increment(
                                  "pan",
                                  this.camera.instructions[
                                    this.camera.currentInstruction
                                  ].action2.split("_")[1]
                                );
                              }
                            } else {
                              increment(
                                "pan",
                                this.camera.instructions[
                                  this.camera.currentInstruction
                                ].action2.split("_")[1]
                              );
                            }
                          }
                        }

                        if (
                          this.camera.instructions[this.camera.currentInstruction].action3
                        ) {
                          if (
                            this.camera.instructions[this.camera.currentInstruction]
                              .action3 !== "" &&
                            this.camera.instructions[this.camera.currentInstruction]
                              .count3 <
                              this.camera.instructions[this.camera.currentInstruction]
                                .limit3
                          ) {
                            tertiaryAction = true;
                            if (
                              this.camera.instructions[
                                this.camera.currentInstruction
                              ].action3.split("_")[0] === "zoom"
                            ) {
                              increment(
                                "zoom",
                                this.camera.instructions[
                                  this.camera.currentInstruction
                                ].action3.split("_")[1]
                              );
                            }
                            if (
                              this.camera.instructions[
                                this.camera.currentInstruction
                              ].action3.split("_")[0] === "pan"
                            ) {
                              if (
                                this.camera.instructions[
                                  this.camera.currentInstruction
                                ].action2.split("_")[0] === "pan"
                              ) {
                                for (let index = 0; index < 2; index++) {
                                  // console.log('slow panning ',this.camera.instructions[this.camera.currentInstruction].action2.split("_")[1],' secondary. count: ',this.camera.instructions[this.camera.currentInstruction].count2);

                                  increment(
                                    "pan",
                                    this.camera.instructions[
                                      this.camera.currentInstruction
                                    ].action3.split("_")[1]
                                  );
                                }
                              } else {
                                increment(
                                  "pan",
                                  this.camera.instructions[
                                    this.camera.currentInstruction
                                  ].action3.split("_")[1]
                                );
                              }
                            }
                          }
                        }
                      }

                      if (
                        this.camera.instructions[
                          this.camera.currentInstruction
                        ].action.split("_")[0] === "pan"
                      ) {
                        // console.log('fast panning ',this.camera.instructions[this.camera.currentInstruction].action.split("_")[1],' primary. count: ',this.camera.instructions[this.camera.currentInstruction].count);

                        increment(
                          "pan",
                          this.camera.instructions[
                            this.camera.currentInstruction
                          ].action.split("_")[1]
                        );

                        if (
                          this.camera.instructions[this.camera.currentInstruction]
                            .action2 !== "" &&
                          this.camera.instructions[this.camera.currentInstruction]
                            .count2 <
                            this.camera.instructions[this.camera.currentInstruction]
                              .limit2
                        ) {
                          secondaryAction = true;
                          if (
                            this.camera.instructions[
                              this.camera.currentInstruction
                            ].action2.split("_")[0] === "zoom"
                          ) {
                            increment(
                              "zoom",
                              this.camera.instructions[
                                this.camera.currentInstruction
                              ].action2.split("_")[1]
                            );
                          }
                          if (
                            this.camera.instructions[
                              this.camera.currentInstruction
                            ].action2.split("_")[0] === "pan"
                          ) {
                            if (
                              this.camera.instructions[
                                this.camera.currentInstruction
                              ].action.split("_")[0] === "pan"
                            ) {
                              for (let index = 0; index < 2; index++) {
                                // console.log('slow panning ',this.camera.instructions[this.camera.currentInstruction].action2.split("_")[1],' secondary. count: ',this.camera.instructions[this.camera.currentInstruction].count2);

                                increment(
                                  "pan",
                                  this.camera.instructions[
                                    this.camera.currentInstruction
                                  ].action2.split("_")[1]
                                );
                              }
                            } else {
                              increment(
                                "pan",
                                this.camera.instructions[
                                  this.camera.currentInstruction
                                ].action2.split("_")[1]
                              );
                            }
                          }
                        }

                        if (
                          this.camera.instructions[this.camera.currentInstruction].action3
                        ) {
                          if (
                            this.camera.instructions[this.camera.currentInstruction]
                              .action3 !== "" &&
                            this.camera.instructions[this.camera.currentInstruction]
                              .count3 <
                              this.camera.instructions[this.camera.currentInstruction]
                                .limit3
                          ) {
                            tertiaryAction = true;
                            if (
                              this.camera.instructions[
                                this.camera.currentInstruction
                              ].action3.split("_")[0] === "zoom"
                            ) {
                              increment(
                                "zoom",
                                this.camera.instructions[
                                  this.camera.currentInstruction
                                ].action3.split("_")[1]
                              );
                            }
                            if (
                              this.camera.instructions[
                                this.camera.currentInstruction
                              ].action3.split("_")[0] === "pan"
                            ) {
                              if (
                                this.camera.instructions[
                                  this.camera.currentInstruction
                                ].action2.split("_")[0] === "pan"
                              ) {
                                for (let index = 0; index < 2; index++) {
                                  // console.log('slow panning ',this.camera.instructions[this.camera.currentInstruction].action2.split("_")[1],' secondary. count: ',this.camera.instructions[this.camera.currentInstruction].count2);

                                  increment(
                                    "pan",
                                    this.camera.instructions[
                                      this.camera.currentInstruction
                                    ].action3.split("_")[1]
                                  );
                                }
                              } else {
                                increment(
                                  "pan",
                                  this.camera.instructions[
                                    this.camera.currentInstruction
                                  ].action3.split("_")[1]
                                );
                              }
                            }
                          }
                        }
                      }

                      this.camera.instructions[this.camera.currentInstruction].count++;
                      // console.log('1a');
                      if (secondaryAction === true) {
                        this.camera.instructions[this.camera.currentInstruction].count2++;
                      }
                      if (tertiaryAction === true) {
                        this.camera.instructions[this.camera.currentInstruction].count3++;
                      }
                    }
                  } else {
                    if (
                      this.camera.instructions[
                        this.camera.currentInstruction
                      ].action.split("_")[0] === "zoom"
                    ) {
                      // console.log('slow zooming ',this.camera.instructions[this.camera.currentInstruction].action.split("_")[1],' primary. count: ',this.camera.instructions[this.camera.currentInstruction].count);

                      increment(
                        "zoom",
                        this.camera.instructions[
                          this.camera.currentInstruction
                        ].action.split("_")[1]
                      );

                      if (
                        this.camera.instructions[this.camera.currentInstruction]
                          .action2 !== "" &&
                        this.camera.instructions[this.camera.currentInstruction].count2 <
                          this.camera.instructions[this.camera.currentInstruction].limit2
                      ) {
                        secondaryAction = true;
                        if (
                          this.camera.instructions[
                            this.camera.currentInstruction
                          ].action2.split("_")[0] === "zoom"
                        ) {
                          increment(
                            "zoom",
                            this.camera.instructions[
                              this.camera.currentInstruction
                            ].action2.split("_")[1]
                          );
                        }
                        if (
                          this.camera.instructions[
                            this.camera.currentInstruction
                          ].action2.split("_")[0] === "pan"
                        ) {
                          if (
                            this.camera.instructions[
                              this.camera.currentInstruction
                            ].action.split("_")[0] === "pan"
                          ) {
                            for (let index = 0; index < 2; index++) {
                              // console.log('slow panning ',this.camera.instructions[this.camera.currentInstruction].action2.split("_")[1],' secondary. count: ',this.camera.instructions[this.camera.currentInstruction].count2);

                              increment(
                                "pan",
                                this.camera.instructions[
                                  this.camera.currentInstruction
                                ].action2.split("_")[1]
                              );
                            }
                          } else {
                            increment(
                              "pan",
                              this.camera.instructions[
                                this.camera.currentInstruction
                              ].action2.split("_")[1]
                            );
                          }
                        }
                      }

                      if (
                        this.camera.instructions[this.camera.currentInstruction].action3
                      ) {
                        if (
                          this.camera.instructions[this.camera.currentInstruction]
                            .action3 !== "" &&
                          this.camera.instructions[this.camera.currentInstruction]
                            .count3 <
                            this.camera.instructions[this.camera.currentInstruction]
                              .limit3
                        ) {
                          tertiaryAction = true;
                          if (
                            this.camera.instructions[
                              this.camera.currentInstruction
                            ].action3.split("_")[0] === "zoom"
                          ) {
                            increment(
                              "zoom",
                              this.camera.instructions[
                                this.camera.currentInstruction
                              ].action3.split("_")[1]
                            );
                          }
                          if (
                            this.camera.instructions[
                              this.camera.currentInstruction
                            ].action3.split("_")[0] === "pan"
                          ) {
                            if (
                              this.camera.instructions[
                                this.camera.currentInstruction
                              ].action2.split("_")[0] === "pan"
                            ) {
                              for (let index = 0; index < 2; index++) {
                                // console.log('slow panning ',this.camera.instructions[this.camera.currentInstruction].action2.split("_")[1],' secondary. count: ',this.camera.instructions[this.camera.currentInstruction].count2);

                                increment(
                                  "pan",
                                  this.camera.instructions[
                                    this.camera.currentInstruction
                                  ].action3.split("_")[1]
                                );
                              }
                            } else {
                              increment(
                                "pan",
                                this.camera.instructions[
                                  this.camera.currentInstruction
                                ].action3.split("_")[1]
                              );
                            }
                          }
                        }
                      }
                    }

                    if (
                      this.camera.instructions[
                        this.camera.currentInstruction
                      ].action.split("_")[0] === "pan"
                    ) {
                      // console.log('slow panning ',this.camera.instructions[this.camera.currentInstruction].action.split("_")[1],' primary. count: ',this.camera.instructions[this.camera.currentInstruction].count);

                      increment(
                        "pan",
                        this.camera.instructions[
                          this.camera.currentInstruction
                        ].action.split("_")[1]
                      );

                      if (
                        this.camera.instructions[this.camera.currentInstruction]
                          .action2 !== "" &&
                        this.camera.instructions[this.camera.currentInstruction].count2 <
                          this.camera.instructions[this.camera.currentInstruction].limit2
                      ) {
                        secondaryAction = true;
                        if (
                          this.camera.instructions[
                            this.camera.currentInstruction
                          ].action2.split("_")[0] === "zoom"
                        ) {
                          increment(
                            "zoom",
                            this.camera.instructions[
                              this.camera.currentInstruction
                            ].action2.split("_")[1]
                          );
                        }
                        if (
                          this.camera.instructions[
                            this.camera.currentInstruction
                          ].action2.split("_")[0] === "pan"
                        ) {
                          if (
                            this.camera.instructions[
                              this.camera.currentInstruction
                            ].action.split("_")[0] === "pan"
                          ) {
                            for (let index = 0; index < 2; index++) {
                              // console.log('slow panning ',this.camera.instructions[this.camera.currentInstruction].action2.split("_")[1],' secondary. count: ',this.camera.instructions[this.camera.currentInstruction].count2);

                              increment(
                                "pan",
                                this.camera.instructions[
                                  this.camera.currentInstruction
                                ].action2.split("_")[1]
                              );
                            }
                          } else {
                            increment(
                              "pan",
                              this.camera.instructions[
                                this.camera.currentInstruction
                              ].action2.split("_")[1]
                            );
                          }
                        }
                      }

                      if (
                        this.camera.instructions[this.camera.currentInstruction].action3
                      ) {
                        if (
                          this.camera.instructions[this.camera.currentInstruction]
                            .action3 !== "" &&
                          this.camera.instructions[this.camera.currentInstruction]
                            .count3 <
                            this.camera.instructions[this.camera.currentInstruction]
                              .limit3
                        ) {
                          tertiaryAction = true;
                          if (
                            this.camera.instructions[
                              this.camera.currentInstruction
                            ].action3.split("_")[0] === "zoom"
                          ) {
                            increment(
                              "zoom",
                              this.camera.instructions[
                                this.camera.currentInstruction
                              ].action3.split("_")[1]
                            );
                          }
                          if (
                            this.camera.instructions[
                              this.camera.currentInstruction
                            ].action3.split("_")[0] === "pan"
                          ) {
                            if (
                              this.camera.instructions[
                                this.camera.currentInstruction
                              ].action2.split("_")[0] === "pan"
                            ) {
                              for (let index = 0; index < 2; index++) {
                                // console.log('slow panning ',this.camera.instructions[this.camera.currentInstruction].action2.split("_")[1],' secondary. count: ',this.camera.instructions[this.camera.currentInstruction].count2);

                                increment(
                                  "pan",
                                  this.camera.instructions[
                                    this.camera.currentInstruction
                                  ].action3.split("_")[1]
                                );
                              }
                            } else {
                              increment(
                                "pan",
                                this.camera.instructions[
                                  this.camera.currentInstruction
                                ].action3.split("_")[1]
                              );
                            }
                          }
                        }
                      }
                    }

                    this.camera.instructions[this.camera.currentInstruction].count++;
                    // console.log('1b');
                    if (secondaryAction === true) {
                      this.camera.instructions[this.camera.currentInstruction].count2++;
                    }
                    if (tertiaryAction === true) {
                      this.camera.instructions[this.camera.currentInstruction].count3++;
                    }
                  }
                }
              } else {
                if (secondaryAction === true) {
                  // if (this.camera.instructions[this.camera.currentInstruction].count >= this.camera.instructions[this.camera.currentInstruction].limit) {
                  //   // this.camera.currentInstruction++;
                  //     console.log('finished primary instruction w/ secondary');
                  // }
                  // if (this.camera.instructions[this.camera.currentInstruction].count2 >= this.camera.instructions[this.camera.currentInstruction].limit2) {
                  //     this.camera.currentInstruction++;
                  //     console.log('finished secondary instruction');
                  //     // secondaryAction = false;
                  //     // continueSecondary = true;
                  // }
                } else {
                  if (
                    this.camera.instructions[this.camera.currentInstruction].count >=
                    this.camera.instructions[this.camera.currentInstruction].limit
                  ) {
                    this.camera.currentInstruction++;
                    // console.log("finished primary instruction only");
                  }
                }
              }
            }
          }

          // FINISHED CAMERA INSTRUCTIONS
          if (this.camera.currentInstruction >= this.camera.instructions.length) {
            this.camera.instructions = [];
            this.camera.currentInstruction = 0;
            this.settingAutoCamera = false;
            // console.log("finished auto camera instructions");
          }
        }
      }

      if (this.camera.instructionType === "story") {
        // if there are nstructions, execute and step instructions.count, remove from array
        //
        // use a cameraInstructionRef to adjust the camera values accordingly, and push to this.camera.instructions
        //
        // if this is the last instruction, set the instructionType back to default
      }
    }

    // MENU

    if (
      player.ai.state !== true &&
      this.keyPressed[player.number - 1].playerMenu === true
    ) {
      // toggle the menu here
    }

    // // CHECK PROJECTILES!!
    this.projectileTracker();

    // ADD COM PLAYER!
    if (this.addAiPlayerKeyPress === true) {
      // this.addAiRandomPlayer('random')
      // this.addAiRandomPlayer('pursue')
      // this.addAiRandomPlayer('patrol')
      // this.addAiRandomPlayer('defend')
      this.addAiPlayer();
    }
    if (this.addAiCount.state === true) {
      if (this.addAiCount.count < this.addAiCount.limit) {
        this.addAiCount.count++;
      }
      if (this.addAiCount.count >= this.addAiCount.limit) {
        this.addAiCount = {
          state: false,
          count: 0,
          limit: this.addAiCount.limit,
        };
      }
    }

    // SYNC W/ GLOBAL PLAYER DATA
    this.players[player.number - 1] = player;

    // AI EVALUATE
    if (player.ai.state === true) {
      this.aiEvaluate(player);
    }

    // DRAW EVERYTHING
    this.drawPlayerStep(player.number, canvas, context, canvas2, context2);
  };
  drawPlayerStep = (playerNumber, canvas, context, canvas2, context2) => {
    // console.log('drawing player step',playerNumber);

    let gridInfo = [];
    class Point {
      constructor(x, y) {
        this.x = x;
        this.y = y;
      }
    }
    let wall = this.wallRef.current;
    let wall2 = this.wall2Ref.current;
    let wall3 = this.wall3Ref.current;

    canvas.width = this.canvasWidth;
    canvas.height = this.canvasHeight;

    let floorImageWidth = this.floorImageWidth;
    let floorImageHeight = this.floorImageHeight;
    let wallImageWidth = this.wallImageWidth;
    let wallImageHeight = this.wallImageHeight;
    let sceneX = this.canvasWidth / 2;
    let sceneY = this.sceneY;
    let tileWidth = this.tileWidth;

    gridInfo = this.gridInfo;

    let player = this.players[playerNumber - 1];

    let updatedPlayerImg;
    let newDirection;

    if (player.falling.state === true) {
      // console.log('player',player.number,'falling count',player.falling.count,'limit',player.falling.limit,'position',player.nextPosition,'action',player.action);
      if (player.falling.count === player.falling.limit) {
        this.killPlayer(player);
      }
    }

    context.clearRect(0, 0, this.canvasWidth, this.canvasHeight);
    context2.clearRect(0, 0, this.canvasWidth, this.canvasHeight);

    context.translate(this.camera.zoomFocusPan.x, this.camera.zoomFocusPan.y);
    context2.translate(this.camera.zoomFocusPan.x, this.camera.zoomFocusPan.y);

    context.scale(this.camera.zoom.x, this.camera.zoom.y);
    context2.scale(this.camera.zoom.x, this.camera.zoom.y);

    for (var x = 0; x < this.gridWidth + 1; x++) {
      for (var y = 0; y < this.gridWidth + 1; y++) {
        let p = new Point();
        p.x = x * tileWidth;
        p.y = y * tileWidth;
        let iso = this.cartesianToIsometric(p);
        let offset = { x: floorImageWidth / 2, y: floorImageHeight };
        iso.x += sceneX;
        iso.y += sceneY;
        let center = {
          x: iso.x - offset.x / 2 + 23,
          y: iso.y - offset.y / 2 - 2,
        };

        let floor;
        let drawFloor = true;
        let gridInfoCell = this.gridInfo.find(
          (elem) => elem.number.x === x && elem.number.y === y
        );
        gridInfoCell.center = center;
        gridInfoCell.drawCenter = center;
        floor = this.floorImgs[gridInfoCell.terrain.name];

        // VOID
        // FLOOR
        if (gridInfoCell.void.state === true) {
          // drawFloor = false;
          floor = this.floorImgs.void3;
        }
        //BLINKER!!
        if (
          this.cellToVoid.state === true &&
          this.cellToVoid.x === x &&
          this.cellToVoid.y === y
        ) {
          if (this.cellToVoid.count === 1) {
            if (
              !this.cellPopups.find(
                (x) =>
                  x.msg === "cellVoiding" &&
                  x.cell.number.x === gridInfoCell.number.x &&
                  x.cell.number.y === gridInfoCell.number.y
              )
            ) {
              this.cellPopups.push({
                state: false,
                count: 0,
                limit: 35,
                type: "",
                position: "",
                msg: "cellVoiding",
                color: "",
                img: "",
                cell: this.gridInfo.find(
                  (x) =>
                    x.number.x === gridInfoCell.number.x &&
                    x.number.y === gridInfoCell.number.y
                ),
              });
            }
          }
          if (this.cellToVoid.count % 5 === 0) {
            floor = this.floorImgs.void3;
            // drawFloor = false;
          } else {
            floor = this.floorImgs.void2;
            // drawFloor = true;
          }
        }

        // DROWNING
        for (const plyrb of this.players) {
          if (plyrb.drowning === true) {
            if (
              plyrb.currentPosition.cell.number.x === x &&
              plyrb.currentPosition.cell.number.y === y
            ) {
              // console.log('player',plyrb.number,'drowning count',plyrb.falling.count,'position',plyrb.nextPosition);
              if (plyrb.falling.count % 2 === 0) {
                // drawFloor = false;
                floor = this.floorImgs.void3;
              } else {
                // floor = floorImgs.stone
                floor = this.floorImgs[gridInfoCell.terrain.name];
              }
            }
          }
        }

        // FALLING OBSTACLE DEEP BLINKER
        if (
          gridInfoCell.obstacle.state === true &&
          gridInfoCell.obstacle.moving.falling.state === true &&
          gridInfoCell.terrain.type === "deep"
        ) {
          if (gridInfoCell.obstacle.moving.falling.count % 3 === 0) {
            floor = this.floorImgs.void3;
          } else {
            floor = this.floorImgs[gridInfoCell.terrain.name];
          }
        }

        // CELLS UNDER ATTACK & PREATTACK!!
        if (this.cellsUnderAttack.length > 0) {
          for (const cll of this.cellsUnderAttack) {
            if (cll.number.x === x && cll.number.y === y) {
              floor = this.floorAttackRef.current;
            }
          }
        }
        if (this.cellsUnderPreAttack.length > 0) {
          for (const cll2 of this.cellsUnderPreAttack) {
            if (cll2.number.x === x && cll2.number.y === y) {
              floor = this.floorAttack2Ref.current;
            }
          }
        }
        // CELLS TO HIGHLIGHT
        if (this.cellsToHighlight.length > 0) {
          for (const cll2 of this.cellsToHighlight) {
            if (cll2.x === x && cll2.y === y) {
              floor = this.floorVoidRef.current;
            }
          }
        }
        // CELLS TO HIGHLIGHT V2!!
        if (this.cellsToHighlight2.length > 0) {
          for (const cll3 of this.cellsToHighlight2) {
            if (cll3.number.x === x && cll3.number.y === y) {
              floor = this.floorHighlightRef.current;
            }
          }
        }

        // FLOOR
        if (drawFloor === true) {
          context.drawImage(floor, iso.x - offset.x, iso.y - offset.y);
        }

        // RUBBLE
        if (gridInfoCell.rubble === true) {
          context.drawImage(this.floorImgs.rubble, iso.x - offset.x, iso.y - offset.y);
        }

        // CELL COORD LABEL
        context.fillStyle = "black";
        context.fillText(
          "" + x + "," + y + "",
          iso.x - offset.x / 2 + 18,
          iso.y - offset.y / 2 + 12
        );
        context.fillStyle = "black";
        context.fillRect(center.x, center.y, 5, 5);

        // CELL VERTEX POINTS
        let vertices = [
          { x: center.x, y: center.y + tileWidth / 2 },
          { x: center.x + tileWidth, y: center.y },
          { x: center.x, y: center.y - tileWidth / 2 },
          { x: center.x - tileWidth, y: center.y },
        ];
        for (const vertex of vertices) {
          context.fillStyle = "yellow";
          context.fillRect(vertex.x - 2.5, vertex.y - 2.5, 5, 5);
        }
        gridInfoCell.vertices = vertices;

        // TARGET HIGHLIGHT!!
        let floorHighlight;
        for (const plyr3 of this.players) {
          if (x === plyr3.target.cell1.number.x && y === plyr3.target.cell1.number.y) {
            if (
              plyr3.ai.state !== true &&
              plyr3.dead.state !== true &&
              plyr3.falling.state !== true &&
              plyr3.drowning !== true
            ) {
              switch (plyr3.number) {
                case 1:
                  floorHighlight = "purple";
                  break;
                case 2:
                  floorHighlight = "red";
                  break;
              }
            }
            if (
              plyr3.ai.state === true &&
              plyr3.dead.state !== true &&
              plyr3.falling.state !== true &&
              plyr3.drowning !== true
            ) {
              floorHighlight = "brown";
            }
            if (plyr3.dead.state !== true) {
              context.lineWidth = 5;
              context.beginPath();
              for (const vertex of vertices) {
                context.strokeStyle = floorHighlight;

                context.lineTo(vertex.x, vertex.y);
              }
              context.closePath();
              context.stroke();
            }
          }
        }

        // MOUSED OVER CELL
        if (
          this.mouseOverCell.state === true &&
          x === this.mouseOverCell.cell.number.x &&
          y === this.mouseOverCell.cell.number.y
        ) {
          context.lineWidth = 5;
          context.beginPath();
          for (const vertex of vertices) {
            context.strokeStyle = "orange";
            context.lineTo(vertex.x, vertex.y);
          }
          context.closePath();
          context.stroke();
        }

        // IN GAME ITEM PLACEMENT!!
        if (gridInfoCell.item.name !== "" && gridInfoCell.void.state !== true) {
          let hide = false;
          if (this.obstacleItemsToDrop.length > 0) {
            for (const cell of this.obstacleItemsToDrop) {
              if (
                gridInfoCell.number.x === cell.target.x &&
                gridInfoCell.number.y === cell.target.y &&
                gridInfoCell.item.name === cell.item.name
              ) {
                hide = true;
              }
            }
          }

          if (hide !== true) {
            let itemImg;
            let fillClr;
            if (gridInfoCell.item.type === "item") {
              switch (gridInfoCell.item.name) {
                case "moveSpeedUp":
                  fillClr = "purple";
                  itemImg = this.itemImgs[gridInfoCell.item.name];
                  break;
                case "moveSpeedDown":
                  fillClr = "blue";
                  itemImg = this.itemImgs[gridInfoCell.item.name];
                  break;
                case "hpUp":
                  fillClr = "yellow";
                  itemImg = this.itemImgs[gridInfoCell.item.name];
                  break;
                case "hpDown":
                  fillClr = "brown";
                  itemImg = this.itemImgs[gridInfoCell.item.name];
                  break;
                case "focusUp":
                  fillClr = "white";
                  itemImg = this.itemImgs[gridInfoCell.item.name];
                  break;
                case "focusDown":
                  fillClr = "black";
                  itemImg = this.itemImgs[gridInfoCell.item.name];
                  break;
                case "strengthUp":
                  fillClr = "green";
                  itemImg = this.itemImgs[gridInfoCell.item.name];
                  break;
                case "strengthDown":
                  fillClr = "red";
                  itemImg = this.itemImgs[gridInfoCell.item.name];
                  break;
                case "ammo5":
                  fillClr = "#283618";
                  itemImg = this.itemImgs[gridInfoCell.item.name];
                  break;
                case "ammo10":
                  fillClr = "#283618";
                  itemImg = this.itemImgs[gridInfoCell.item.name];
                  break;
              }
            } else if (gridInfoCell.item.type === "weapon") {
              switch (gridInfoCell.item.subType) {
                case "sword":
                  fillClr = "orange";
                  itemImg = this.itemImgs[gridInfoCell.item.subType];
                  break;
                case "spear":
                  fillClr = "maroon";
                  itemImg = this.itemImgs[gridInfoCell.item.subType];
                  break;
                case "crossbow":
                  fillClr = "navy";
                  itemImg = this.itemImgs[gridInfoCell.item.subType];
                  break;
              }
            } else if (gridInfoCell.item.type === "armor") {
              switch (gridInfoCell.item.subType) {
                case "helmet":
                  fillClr = "grey";
                  itemImg = this.itemImgs[gridInfoCell.item.subType];
                  break;
                case "mail":
                  fillClr = "olive";
                  itemImg = this.itemImgs[gridInfoCell.item.subType];
                  break;
                case "greaves":
                  fillClr = "#b5179e";
                  itemImg = this.itemImgs[gridInfoCell.item.subType];
                  break;
              }
            }

            context.drawImage(itemImg, center.x - 15, center.y - 15);

            // context.fillStyle = fillClr;
            // context.beginPath();
            // context.arc(center.x, center.y, 10, 0, 2 * Math.PI);
            // context.fill();
          }
        }

        //POPUPS
        // CELL HIGHLIGHT
        for (const popup of this.cellPopups) {
          if (
            popup.state === true &&
            x === popup.cell.number.x &&
            y === popup.cell.number.y
          ) {
            context.lineWidth = 5;
            context.beginPath();
            for (const vertex of vertices) {
              context.strokeStyle = popup.color;
              context.lineTo(vertex.x, vertex.y);
            }
            context.closePath();
            context.stroke();
          }
        }
        // CELL POPUPS
        if (x === this.gridWidth && y === this.gridWidth) {
          // console.log(this.pickupAmmoRef.current);

          for (const popup of this.cellPopups) {
            let popupBorderColor = "black";
            if (popup.state === true) {
              // console.log('drawing a popup');
              let popupDrawCoords;
              if (popup.position === "" || !popup.position) {
                let currentPopups = this.cellPopups.filter((x) => x.state === true);
                let currentPopupsThisCell = this.cellPopups.filter(
                  (x) =>
                    x.state === true &&
                    x.cell.number.x === popup.cell.number.x &&
                    x.cell.number.y === popup.cell.number.y
                );
                let positions = [
                  "north",
                  "east",
                  "south",
                  "west",
                  "northEast",
                  "northWest",
                  "southEast",
                  "southWest",
                ];

                if (popup.color === "") {
                  popup.color = this.cellColorRef.find(
                    (x) => x.x === popup.cell.number.x && x.y === popup.cell.number.y
                  ).color;
                }

                // REMOVE POSITIONS OF POPUPS ALREADY DRAWN FOR THIS CELL
                for (const popup2 of currentPopupsThisCell) {
                  if (popup2.position && popup2.position !== "") {
                    let indx = positions.indexOf(popup2.position);
                    positions.splice(indx, 1);
                  }
                }

                let dir = undefined;
                let dirs = [];

                for (const plyr2 of this.players) {
                  if (plyr2.ai.state !== true) {
                    let myPos = popup.cell.number;
                    let invalidPos =
                      this.players[plyr2.number - 1].currentPosition.cell.number;
                    // let invalidPositions = [invalidPos];

                    // GET DIRECTION OF PLAYER CELL RELATIVE TO ME
                    dir = this.getDirectionFromCells(myPos, invalidPos);

                    if (dir && positions.includes(dir) === true) {
                      positions.splice(positions.indexOf(dir), 1);
                      // console.log('dont draw over player @',dir,'choose frome these position',positions);
                    }

                    // GET DIRECTION THAT ALL OTHER PLAYER'S POPUPS OCCUPY, RELATIVE TO ME
                    for (const pop of plyr2.popups) {
                      dir = undefined;

                      if (pop.state === true) {
                        let invalidPos2 = {
                          x: undefined,
                          y: undefined,
                        };

                        invalidPos2 = this.getCellFromDirection(
                          1,
                          invalidPos,
                          pop.position
                        );

                        // let dir = undefined;

                        dir = this.getDirectionFromCells(myPos, invalidPos2);

                        if (dir && positions.includes(dir) === true) {
                          positions.splice(positions.indexOf(dir), 1);
                          // console.log('dont draw over player @',dir,'choose frome these position',positions);
                        }
                      }
                    }
                  }
                }

                // GET DIRECTION OF CELLS THAT AREN'T THIS CELL'S POPUPS' POPUPS CELLS RELATIVE TO ME
                for (const popup2 of currentPopups) {
                  dir = undefined;

                  if (
                    popup.cell.number.x !== popup2.cell.number.x &&
                    popup.cell.number.y !== popup2.cell.number.y &&
                    popup2.msg !== popup.msg &&
                    popup2.state === true
                  ) {
                    let myPos = popup.cell.number;
                    let cellPos = popup2.cell.number;
                    let invalidPos2 = {
                      x: undefined,
                      y: undefined,
                    };

                    invalidPos2 = this.getCellFromDirection(1, cellPos, popup2.position);

                    dir = this.getDirectionFromCells(myPos, invalidPos2);

                    if (dir && positions.includes(dir) === true) {
                      positions.splice(positions.indexOf(dir), 1);
                      // console.log('dont draw over player @',dir,'choose frome these position',positions);
                    }
                  }
                }

                if (!positions[0]) {
                  // console.log('no open positions for', popup.msg);
                  popup.state = false;
                  popup.count = 0;
                } else {
                  popup.position = positions[0];
                }

                popup.img = this.popupImageRef[popup.msg];

                popupDrawCoords = this.popupDrawCalc(
                  popup.position,
                  { x: popup.cell.center.x - 25, y: popup.cell.center.y - 15 },
                  0
                );
                this.drawPopupBubble(
                  context,
                  popupDrawCoords.origin.x,
                  popupDrawCoords.origin.y,
                  this.popupSize,
                  this.popupSize,
                  5,
                  popupDrawCoords.anchor.x,
                  popupDrawCoords.anchor.y,
                  popup.color
                );
                // context.fillStyle = 'black';
                // context.fillText(""+popup.type+"", popupDrawCoords.origin.x+10, popupDrawCoords.origin.y+5);
                // console.log('popup.msg',popup.msg,popup.img);
                let centerPopupOffset = (this.popupSize - this.popupImgSize) / 2;
                context.drawImage(
                  popup.img,
                  popupDrawCoords.origin.x + centerPopupOffset,
                  popupDrawCoords.origin.y + centerPopupOffset,
                  this.popupImgSize,
                  this.popupImgSize
                );
              } else {
                let dir = undefined;
                let dirs = [];

                let currentPopupsNotThis = this.cellPopups.filter(
                  (x) =>
                    x.state === true &&
                    x.msg !== popup.msg &&
                    x.cell.number.x !== popup.cell.number.x &&
                    x.cell.number.y !== popup.cell.number.y
                );

                for (const plyr2 of this.players) {
                  if (plyr2.ai.state !== true) {
                    let myPos = popup.cell.number;
                    let invalidPos =
                      this.players[plyr2.number - 1].currentPosition.cell.number;

                    // invalidpostions2 push plyr2 position
                    // for player popups
                    //   invalid cell = pop.cell.number + popup position mod, invalposits2 push invalidcell
                    //

                    dir = this.getDirectionFromCells(myPos, invalidPos);

                    dirs.push(dir);

                    for (const pop of plyr2.popups) {
                      if (pop.state === true) {
                        let invalidPos2 = {
                          x: undefined,
                          y: undefined,
                        };

                        invalidPos2 = this.getCellFromDirection(
                          1,
                          invalidPos,
                          pop.position
                        );

                        dir = this.getDirectionFromCells(myPos, invalidPos2);

                        // if (dir && positions.includes(dir) === true) {
                        //   positions.splice(positions.indexOf(dir),1);
                        //   // console.log('dont draw over player @',dir,'choose frome these position',positions);
                        // }
                        dirs.push(dir);
                      }
                    }
                  }
                }

                for (const popup2 of currentPopupsNotThis) {
                  dir = undefined;

                  if (popup2.msg !== popup.msg && popup2.state === true) {
                    let myPos = popup.cell.number;

                    let cellPos = popup2.cell.number;
                    let invalidPos2 = {
                      x: undefined,
                      y: undefined,
                    };

                    invalidPos2 = this.getCellFromDirection(1, cellPos, popup2.position);

                    dir = this.getDirectionFromCells(myPos, invalidPos2);

                    dirs.push(dir);
                  }
                }

                // if (popup.position === dir ) {
                if (dirs.find((x) => x === popup.position)) {
                  // for (const pop of this.cellPopups) {
                  //   pop.position = '';
                  //   pop.state = false;
                  // }
                  this.cellPopups.find(
                    (x) =>
                      x.msg === popup.msg &&
                      x.cell.number.x === popup.cell.number.x &&
                      x.cell.number.x === popup.cell.number.x
                  ).state = false;
                  this.cellPopups.find(
                    (x) =>
                      x.msg === popup.msg &&
                      x.cell.number.x === popup.cell.number.x &&
                      x.cell.number.x === popup.cell.number.x
                  ).position = "";
                  // console.log('reconsidering...',popup.msg);
                } else {
                  popup.img = this.popupImageRef[popup.msg];
                  popupDrawCoords = this.popupDrawCalc(
                    popup.position,
                    {
                      x: popup.cell.center.x - 25,
                      y: popup.cell.center.y - 15,
                    },
                    0
                  );
                  // this.drawPopupBubble2(context,popupDrawCoords.origin.x,popupDrawCoords.origin.y,this.popupSize,this.popupSize,2)
                  this.drawPopupBubble(
                    context,
                    popupDrawCoords.origin.x,
                    popupDrawCoords.origin.y,
                    this.popupSize,
                    this.popupSize,
                    5,
                    popupDrawCoords.anchor.x,
                    popupDrawCoords.anchor.y,
                    popup.color
                  );
                  // context.fillStyle = 'black';
                  // context.fillText(""+popup.type+"", popupDrawCoords.origin.x+10, popupDrawCoords.origin.y+5);
                  // console.log('popup.msg',popup.msg);
                  let centerPopupOffset = (this.popupSize - this.popupImgSize) / 2;
                  context.drawImage(
                    popup.img,
                    popupDrawCoords.origin.x + centerPopupOffset,
                    popupDrawCoords.origin.y + centerPopupOffset,
                    this.popupImgSize,
                    this.popupImgSize
                  );
                }
              }
            }
          }
        }

        // DRAWN PLAYERS!!
        const playerDrawLog = (
          x,
          y,
          plyr,
          finalAnimIndex,
          updatedPlayerImg,
          sx,
          sy,
          sWidth,
          sHeight,
          pointxthisplayerDrawWidth2,
          pointythisplayerDrawHeight2,
          thisplayerDrawWidth,
          thisplayerDrawHeight
        ) => {
          console.log("** playerDrawLog **");
          // console.log("-- player --", plyr.number);
          // console.log("-- strafing --", plyr.strafing.state);
          // console.log("-- turning --", plyr.turning.state);
          console.log("-- currently drawing --", x, y);
          // console.log(
          //   "-- current position --",
          //   plyr.currentPosition.cell.number.x,
          //   plyr.currentPosition.cell.number.y
          // );
          // console.log("-- moving state --", plyr.moving.state);
          // console.log("-- moving step --", plyr.moving.step);
          // console.log("-- target --", plyr.target.cell1.number.x, plyr.target.cell1.number.y);
          // console.log("-- direction --", plyr.direction);
          console.log(
            "-- origin --",
            plyr.moving.origin.number.x,
            plyr.moving.origin.number.y
          );
          // console.log("-- action --", plyr.action);
          // console.log("updatedPlayerImg", updatedPlayerImg);

          // console.log("finalAnimIndex", finalAnimIndex);
          // console.log("updatedPlayerImg", updatedPlayerImg);
          // console.log("sx", sx);
          // console.log("sy", sy);
          // console.log("sWidth", sWidth);
          // console.log("sHeight", sHeight);
          // console.log("point.x - this.playerDrawWidth / 2", pointxthisplayerDrawWidth2);
          // console.log("point.y - this.playerDrawHeight / 2", pointythisplayerDrawHeight2);
          // console.log("this.playerDrawWidth", thisplayerDrawWidth);
          // console.log("this.playerDrawHeight", thisplayerDrawHeight);
        };

        for (let plyr of this.players) {
          let point = {
            x: plyr.nextPosition.x,
            y: plyr.nextPosition.y,
          };
          let newCharDarwPoint = {
            x: plyr.nextPosition.x - this.floorImageHeight / 2,
            y: plyr.nextPosition.y - this.floorImageHeight,
          };

          let weapon = plyr.currentWeapon.type;
          if (plyr.currentWeapon.type === "" || !plyr.currentWeapon.type) {
            weapon = "unarmed";
          }

          let finalAnimIndex;

          if (plyr.attacking.state === true && plyr.success.deflected.state !== true) {
            plyr.action = "attacking";
          }
          let frameIndexBase;
          let increment;
          let frameTypeIndex;
          let remainder;
          let newIndex;
          // SET ANIMATION INDEX USED FOR SPRITE SHEET STEPPING BASED ON ACTION
          // FOR TESTING BY CALLING ONLY @ 1 CELL
          if (
            plyr.currentPosition.cell.number.x === x &&
            plyr.currentPosition.cell.number.y === y &&
            plyr.number === 1
          ) {
            switch (plyr.action) {
              case "moving":
                let moveSpeed = plyr.speed.move;
                if (plyr.terrainMoveSpeed.state === true) {
                  moveSpeed = plyr.terrainMoveSpeed.speed;
                }
                if (plyr.pushing.state === true) {
                  moveSpeed = plyr.pushing.moveSpeed;
                }
                if (plyr.pulling.state === true) {
                  moveSpeed = plyr.pulling.moveSpeed;
                }
                if (plyr.pushed.state === true) {
                  moveSpeed = plyr.pushed.moveSpeed;
                }
                if (plyr.pulled.state === true) {
                  moveSpeed = plyr.pulled.moveSpeed;
                }
                let rangeIndex = plyr.speed.range.indexOf(moveSpeed);
                let moveAnimIndex = this.moveStepRef[rangeIndex].indexOf(
                  plyr.moving.step
                );
                finalAnimIndex = moveAnimIndex + 1;
                // console.log(
                //   "anim testing mv spd",
                //   plyr.speed.move,
                //   "step",
                //   plyr.moving.step,
                //   "plyr",
                //   plyr.number,
                //   "index",
                //   finalAnimIndex
                // );
                if (plyr.target.cell1.void == true) {
                  // console.log('anim testing mv void spd',plyr.speed.move,'step',plyr.moving.step,'plyr',plyr.number,'index',finalAnimIndex);
                }
                break;
              case "jumping":
                let rangeIndex4 = plyr.speed.range.indexOf(0.1);
                let moveAnimIndex4 = this.moveStepRef[rangeIndex4].indexOf(
                  plyr.moving.step
                );
                finalAnimIndex = moveAnimIndex4;
                // console.log('anim testing mv spd',plyr.speed.move,'step',plyr.moving.step,'plyr',plyr.number,'index',finalAnimIndex);
                break;
              case "strafe moving":
                if (plyr.pushBack.state === true) {
                  let rangeIndex3 = plyr.speed.range.indexOf(plyr.speed.move);
                  let moveAnimIndex3 = this.moveStepRef[rangeIndex3].indexOf(
                    plyr.moving.step
                  );
                  finalAnimIndex = moveAnimIndex3;
                  // console.log('anim testing pushback spd',plyr.speed.move,'step',plyr.moving.step,'plyr',plyr.number);
                } else {
                  let moveSpeed = plyr.speed.move;
                  // if (plyr.pushing.state === true) {
                  //   moveSpeed = plyr.pushing.moveSpeed;
                  // }
                  if (plyr.pulling.state === true) {
                    moveSpeed = plyr.pulling.moveSpeed;
                  }
                  if (plyr.pushed.state === true) {
                    moveSpeed = plyr.pushed.moveSpeed;
                  }
                  if (plyr.pulled.state === true) {
                    moveSpeed = plyr.pulled.moveSpeed;
                  }
                  let rangeIndex2 = plyr.speed.range.indexOf(moveSpeed);
                  let moveAnimIndex2 = this.moveStepRef[rangeIndex2].indexOf(
                    plyr.moving.step
                  );
                  finalAnimIndex = moveAnimIndex2;
                  // console.log('anim testing strafe mv spd',plyr.speed.move,'step',plyr.moving.step,'plyr',plyr.number);
                }
                break;
              case "flanking":
                let rangeIndex6 = plyr.speed.range.indexOf(0.2);
                let moveAnimIndex6 = this.moveStepRef[rangeIndex6].indexOf(
                  plyr.moving.step
                );
                finalAnimIndex = moveAnimIndex6;
                // console.log('flanking step',plyr.flanking.step,'step',plyr.moving.step);
                // console.log('anim testing mv spd',plyr.speed.move,'step',plyr.moving.step,'plyr',plyr.number,'index',finalAnimIndex);
                break;
              case "attacking":
                // let animIndex = plyr.attacking.count -1;
                let animIndex;
                // if (
                //   plyr.elasticCounter.state === true &&
                //   plyr.elasticCounter.type === "attacking"
                // ) {
                //   if (plyr.elasticCounter.countUp.state === true) {
                //     animIndex = plyr.elasticCounter.countUp.count - 1;
                //   }
                //   if (plyr.elasticCounter.pause.state === true) {
                //     if (plyr.elasticCounter.pause.count < 11) {
                //       animIndex = plyr.elasticCounter.pause.count - 1;
                //     } else {
                //       if (plyr.elasticCounter.pause.count % 10 === 0) {
                //         animIndex = 9;
                //         // animIndex5 = 10;
                //         // animIndex5 = (plyr.elasticCounter.pause.count-mod)
                //       } else {
                //         let mod = Math.floor(plyr.elasticCounter.pause.count / 10) * 10;
                //         animIndex = plyr.elasticCounter.pause.count - mod - 1;
                //       }
                //     }
                //   }
                //   if (plyr.elasticCounter.countDown.state === true) {
                //     animIndex = plyr.elasticCounter.countDown.count - 1;
                //   }
                // } else {
                //   animIndex = plyr.attacking.count - 1;
                // }
                animIndex = plyr.attacking.count - 1;

                frameIndexBase =
                  this.actionAnimFrameTypeCountRef[plyr.action].sheetLength /
                  this.actionAnimFrameTypeCountRef[plyr.action].typeCount;
                increment = Math.ceil(
                  plyr[plyr.action].limit /
                    this.actionAnimFrameTypeCountRef[plyr.action].typeCount
                );
                frameTypeIndex = Math.floor(plyr[plyr.action].count / increment);
                remainder = plyr[plyr.action].count % increment;
                newIndex = frameIndexBase * frameTypeIndex + remainder;

                finalAnimIndex = newIndex;
                // finalAnimIndex = animIndex;
                // console.log(
                //   "anim testing atk",
                //   plyr.attacking.count,
                //   plyr.attacking.limit,
                //   finalAnimIndex
                // );
                break;
              case "defending":
                let animIndex2 = plyr.defending.count - 1;
                // if (plyr.defending.decay.state !== true) {
                //   if (plyr.defending.count > 0) {
                //     finalAnimIndex = animIndex2;
                //     // console.log('anim testing def wind up',plyr.defending.count,'plyr',plyr.number, animIndex2);
                //   }
                //   if (plyr.defending.count === 0) {
                //     let animIndex2a = 5;
                //     finalAnimIndex = animIndex2a;
                //     // console.log('anim testing def held',plyr.defending.count,'plyr',plyr.number, animIndex2a);
                //   }
                // }
                // if (plyr.defending.decay.state === true) {
                //   if (plyr.defending.decay.count < 11) {
                //     animIndex2 = plyr.defending.decay.count - 1;
                //   } else {
                //     if (plyr.defending.decay.count % 10 === 0) {
                //       animIndex2 = 9;
                //     } else {
                //       let mod = Math.floor(plyr.defending.decay.count / 10) * 10;
                //       animIndex2 = plyr.defending.decay.count - mod - 1;
                //     }
                //   }
                //   finalAnimIndex = animIndex2;
                // }
                frameIndexBase =
                  this.actionAnimFrameTypeCountRef[plyr.action].sheetLength /
                  this.actionAnimFrameTypeCountRef[plyr.action].typeCount;
                increment = Math.ceil(
                  plyr[plyr.action].limit /
                    this.actionAnimFrameTypeCountRef[plyr.action].typeCount
                );
                frameTypeIndex = Math.floor(plyr[plyr.action].count / increment);
                remainder = plyr[plyr.action].count % increment;
                newIndex = frameIndexBase * frameTypeIndex + remainder;

                finalAnimIndex = newIndex;

                break;
              case "idle":
                if (plyr.number === 1) {
                  // console.log('anim testing idle',plyr.idleAnim.count,'plyr',plyr.number);
                }
                if (plyr.number === 2) {
                  // console.log('anim testing idle',plyr.idleAnim.count,'plyr',plyr.number);
                }
                let animIndex3 = plyr.idleAnim.count + 1;
                finalAnimIndex = animIndex3;
                // finalAnimIndex = 1;
                break;
              case "falling":
                let animIndex4 = plyr.falling.count - 1;
                finalAnimIndex = animIndex4;
                // console.log("anim testing fall", plyr.falling.count, "plyr", plyr.number);
                break;
              case "deflected":
                let animIndex5 = plyr.success.deflected.count - 1;
                // if (
                //   plyr.elasticCounter.state === true &&
                //   plyr.elasticCounter.type === "deflected"
                // ) {
                //   if (plyr.elasticCounter.countUp.state === true) {
                //     animIndex5 = plyr.elasticCounter.countUp.count - 1;
                //   }
                //   if (plyr.elasticCounter.pause.state === true) {
                //     if (plyr.elasticCounter.pause.count < 11) {
                //       animIndex5 = plyr.elasticCounter.pause.count - 1;
                //     } else {
                //       if (plyr.elasticCounter.pause.count % 10 === 0) {
                //         animIndex5 = 9;
                //         // animIndex5 = 10;
                //         // animIndex5 = (plyr.elasticCounter.pause.count-mod)
                //       } else {
                //         let mod = Math.floor(plyr.elasticCounter.pause.count / 10) * 10;
                //         animIndex5 = plyr.elasticCounter.pause.count - mod - 1;
                //       }
                //     }
                //   }
                //   if (plyr.elasticCounter.countDown.state === true) {
                //     animIndex5 = plyr.elasticCounter.countDown.count - 1;
                //   }
                // }

                if (plyr.halfPushBack.state === true) {
                  if (plyr.halfPushBack.countUp.state === true) {
                    animIndex5 = plyr.halfPushBack.countUp.count - 1;
                  }
                  if (plyr.halfPushBack.countDown.state === true) {
                    animIndex5 = plyr.halfPushBack.countDown.count - 1;
                  }
                }
                finalAnimIndex = animIndex5;
                // console.log('anim testing dflct',plyr.success.deflected.count,'plyr',plyr.number);
                break;
              case "dodging":
                let animIndex7 = plyr.dodging.count - 1;
                // if (
                //   plyr.elasticCounter.state === true &&
                //   plyr.elasticCounter.type === "dodging"
                // ) {
                //   if (plyr.elasticCounter.countUp.state === true) {
                //     // animIndex7 = plyr.elasticCounter.countUp.count-1;
                //     if (plyr.elasticCounter.countUp.count < 11) {
                //       animIndex7 = plyr.elasticCounter.countUp.count - 1;
                //     } else {
                //       if (plyr.elasticCounter.countUp.count % 10 === 0) {
                //         animIndex7 = 9;
                //         // animIndex5 = 10;
                //         // animIndex5 = (plyr.elasticCounter.pause.count-mod)
                //       } else {
                //         let mod = Math.floor(plyr.elasticCounter.countUp.count / 10) * 10;
                //         animIndex7 = plyr.elasticCounter.countUp.count - mod - 1;
                //       }
                //     }
                //   }
                //   if (plyr.elasticCounter.pause.state === true) {
                //     if (plyr.elasticCounter.pause.count < 11) {
                //       animIndex7 = plyr.elasticCounter.pause.count - 1;
                //     } else {
                //       if (plyr.elasticCounter.pause.count % 10 === 0) {
                //         animIndex7 = 9;
                //         // animIndex5 = 10;
                //         // animIndex5 = (plyr.elasticCounter.pause.count-mod)
                //       } else {
                //         let mod = Math.floor(plyr.elasticCounter.pause.count / 10) * 10;
                //         animIndex7 = plyr.elasticCounter.pause.count - mod - 1;
                //       }
                //     }
                //   }
                //   if (plyr.elasticCounter.countDown.state === true) {
                //     // animIndex7 = plyr.elasticCounter.countDown.count-1;
                //     if (plyr.elasticCounter.countDown.count < 11) {
                //       animIndex7 = plyr.elasticCounter.countDown.count - 1;
                //     } else {
                //       if (plyr.elasticCounter.countDown.count % 10 === 0) {
                //         animIndex7 = 9;
                //         // animIndex5 = 10;
                //         // animIndex5 = (plyr.elasticCounter.pause.count-mod)
                //       } else {
                //         let mod =
                //           Math.floor(plyr.elasticCounter.countDown.count / 10) * 10;
                //         animIndex7 = plyr.elasticCounter.countDown.count - mod - 1;
                //       }
                //     }
                //   }
                // }
                finalAnimIndex = animIndex7;
                // console.log(
                //   "anim testing dodge",
                //   plyr.dodging.count,
                //   "plyr",
                //   plyr.number
                // );
                break;
            }
          }
          // FOR TESTING BY CALLING ONLY @ 1 CELL

          // REAL DEAL
          switch (plyr.action) {
            case "moving":
              let moveSpeed = plyr.speed.move;
              if (plyr.terrainMoveSpeed.state === true) {
                moveSpeed = plyr.terrainMoveSpeed.speed;
              }
              if (plyr.pushing.state === true) {
                moveSpeed = plyr.pushing.moveSpeed;
              }
              if (plyr.pulling.state === true) {
                moveSpeed = plyr.pulling.moveSpeed;
              }
              if (plyr.pushed.state === true) {
                moveSpeed = plyr.pushed.moveSpeed;
              }
              if (plyr.pulled.state === true) {
                moveSpeed = plyr.pulled.moveSpeed;
              }
              let rangeIndex = plyr.speed.range.indexOf(moveSpeed);
              let moveAnimIndex = this.moveStepRef[rangeIndex].indexOf(plyr.moving.step);
              finalAnimIndex = moveAnimIndex + 1;
              // console.log('anim testing mv spd',plyr.speed.move,'step',plyr.moving.step,'plyr',plyr.number,'index',finalAnimIndex);
              if (plyr.target.cell1.void == true) {
                // console.log('anim testing mv void spd',plyr.speed.move,'step',plyr.moving.step,'plyr',plyr.number,'index',finalAnimIndex);
              }
              break;
            case "jumping":
              let rangeIndex4 = plyr.speed.range.indexOf(0.1);
              let moveAnimIndex4 = this.moveStepRef[rangeIndex4].indexOf(
                plyr.moving.step
              );
              finalAnimIndex = moveAnimIndex4;
              // console.log('anim testing mv spd',plyr.speed.move,'step',plyr.moving.step,'plyr',plyr.number,'index',finalAnimIndex);
              break;
            case "strafe moving":
              if (plyr.pushBack.state === true) {
                let rangeIndex3 = plyr.speed.range.indexOf(plyr.speed.move);
                let moveAnimIndex3 = this.moveStepRef[rangeIndex3].indexOf(
                  plyr.moving.step
                );
                finalAnimIndex = moveAnimIndex3;
                // console.log('anim testing pushback spd',plyr.speed.move,'step',plyr.moving.step,'plyr',plyr.number);
              } else {
                let moveSpeed = plyr.speed.move;
                // if (plyr.pushing.state === true) {
                //   moveSpeed = plyr.pushing.moveSpeed;
                // }
                if (plyr.pulling.state === true) {
                  moveSpeed = plyr.pulling.moveSpeed;
                }
                if (plyr.pushed.state === true) {
                  moveSpeed = plyr.pushed.moveSpeed;
                }
                if (plyr.pulled.state === true) {
                  moveSpeed = plyr.pulled.moveSpeed;
                }
                let rangeIndex2 = plyr.speed.range.indexOf(moveSpeed);
                let moveAnimIndex2 = this.moveStepRef[rangeIndex2].indexOf(
                  plyr.moving.step
                );
                finalAnimIndex = moveAnimIndex2;
                // console.log('anim testing strafe mv spd',plyr.speed.move,'step',plyr.moving.step,'plyr',plyr.number);
              }
              break;
            case "flanking":
              let rangeIndex6 = plyr.speed.range.indexOf(0.2);
              let moveAnimIndex6 = this.moveStepRef[rangeIndex6].indexOf(
                plyr.moving.step
              );
              finalAnimIndex = moveAnimIndex6;
              // console.log('flanking step',plyr.flanking.step,'step',plyr.moving.step);
              // console.log('anim testing mv spd',plyr.speed.move,'step',plyr.moving.step,'plyr',plyr.number,'index',finalAnimIndex);
              break;
            case "attacking":
              // let animIndex = plyr.attacking.count -1;
              let animIndex;

              // if (
              //   plyr.elasticCounter.state === true &&
              //   plyr.elasticCounter.type === "attacking"
              // ) {
              //   if (plyr.elasticCounter.countUp.state === true) {
              //     animIndex = plyr.elasticCounter.countUp.count - 1;
              //   }
              //   if (plyr.elasticCounter.pause.state === true) {
              //     if (plyr.elasticCounter.pause.count < 11) {
              //       animIndex = plyr.elasticCounter.pause.count - 1;
              //     } else {
              //       if (plyr.elasticCounter.pause.count % 10 === 0) {
              //         animIndex = 9;
              //         // animIndex5 = 10;
              //         // animIndex5 = (plyr.elasticCounter.pause.count-mod)
              //       } else {
              //         let mod = Math.floor(plyr.elasticCounter.pause.count / 10) * 10;
              //         animIndex = plyr.elasticCounter.pause.count - mod - 1;
              //       }
              //     }
              //   }
              //   if (plyr.elasticCounter.countDown.state === true) {
              //     animIndex = plyr.elasticCounter.countDown.count - 1;
              //   }
              // } else {
              //   animIndex = plyr.attacking.count - 1;
              // }

              // animIndex = plyr.attacking.count - 1;
              // finalAnimIndex = animIndex;
              frameIndexBase =
                this.actionAnimFrameTypeCountRef[plyr.action].sheetLength /
                this.actionAnimFrameTypeCountRef[plyr.action].typeCount;
              increment = Math.ceil(
                plyr[plyr.action].limit /
                  this.actionAnimFrameTypeCountRef[plyr.action].typeCount
              );
              frameTypeIndex = Math.floor(plyr[plyr.action].count / increment);
              remainder = plyr[plyr.action].count % increment;
              newIndex = frameIndexBase * frameTypeIndex + remainder;

              finalAnimIndex = newIndex;
              // console.log('anim testing atk',plyr.attacking.count,'plyr',plyr.number);
              break;
            case "defending":
              let animIndex2 = plyr.defending.count - 1;

              // if (plyr.defending.decay.state !== true) {
              //   if (plyr.defending.count > 0) {
              //     finalAnimIndex = animIndex2;
              //     // console.log('anim testing def wind up',plyr.defending.count,'plyr',plyr.number, animIndex2);
              //   }
              //   if (plyr.defending.count === 0) {
              //     let animIndex2a = 5;
              //     finalAnimIndex = animIndex2a;
              //     // console.log('anim testing def held',plyr.defending.count,'plyr',plyr.number, animIndex2a);
              //   }
              // }
              // if (plyr.defending.decay.state === true) {
              //   if (plyr.defending.decay.count < 11) {
              //     animIndex2 = plyr.defending.decay.count - 1;
              //   } else {
              //     if (plyr.defending.decay.count % 10 === 0) {
              //       animIndex2 = 9;
              //     } else {
              //       let mod = Math.floor(plyr.defending.decay.count / 10) * 10;
              //       animIndex2 = plyr.defending.decay.count - mod - 1;
              //     }
              //   }
              //   finalAnimIndex = animIndex2;
              // }
              frameIndexBase =
                this.actionAnimFrameTypeCountRef[plyr.action].sheetLength /
                this.actionAnimFrameTypeCountRef[plyr.action].typeCount;
              increment = Math.ceil(
                plyr[plyr.action].limit /
                  this.actionAnimFrameTypeCountRef[plyr.action].typeCount
              );
              frameTypeIndex = Math.floor(plyr[plyr.action].count / increment);
              remainder = plyr[plyr.action].count % increment;
              newIndex = frameIndexBase * frameTypeIndex + remainder;

              finalAnimIndex = newIndex;

              break;
            case "idle":
              if (plyr.number === 1) {
                // console.log('anim testing idle',plyr.idleAnim.count,'plyr',plyr.number);
              }
              if (plyr.number === 2) {
                // console.log('anim testing idle',plyr.idleAnim.count,'plyr',plyr.number);
              }
              let animIndex3 = plyr.idleAnim.count + 1;
              finalAnimIndex = animIndex3;
              // finalAnimIndex = 1;
              break;
            case "falling":
              let animIndex4 = plyr.falling.count - 1;
              finalAnimIndex = animIndex4;
              // console.log('anim testing fall',plyr.falling.count,'plyr',plyr.number);
              break;
            case "deflected":
              let animIndex5 = plyr.success.deflected.count - 1;

              // if (
              //   plyr.elasticCounter.state === true &&
              //   plyr.elasticCounter.type === "deflected"
              // ) {
              //   if (plyr.elasticCounter.countUp.state === true) {
              //     animIndex5 = plyr.elasticCounter.countUp.count - 1;
              //   }
              //   if (plyr.elasticCounter.pause.state === true) {
              //     if (plyr.elasticCounter.pause.count < 11) {
              //       animIndex5 = plyr.elasticCounter.pause.count - 1;
              //     } else {
              //       if (plyr.elasticCounter.pause.count % 10 === 0) {
              //         animIndex5 = 9;
              //         // animIndex5 = 10;
              //         // animIndex5 = (plyr.elasticCounter.pause.count-mod)
              //       } else {
              //         let mod = Math.floor(plyr.elasticCounter.pause.count / 10) * 10;
              //         animIndex5 = plyr.elasticCounter.pause.count - mod - 1;
              //       }
              //     }
              //   }
              //   if (plyr.elasticCounter.countDown.state === true) {
              //     animIndex5 = plyr.elasticCounter.countDown.count - 1;
              //   }
              // }
              if (plyr.halfPushBack.state === true) {
                if (plyr.halfPushBack.countUp.state === true) {
                  animIndex5 = plyr.halfPushBack.countUp.count - 1;
                }
                if (plyr.halfPushBack.countDown.state === true) {
                  animIndex5 = plyr.halfPushBack.countDown.count - 1;
                }
              }
              finalAnimIndex = animIndex5;
              // console.log('anim testing dflct',plyr.success.deflected.count,'plyr',plyr.number);
              break;
            case "dodging":
              let animIndex7 = plyr.dodging.count - 1;

              // if (
              //   plyr.elasticCounter.state === true &&
              //   plyr.elasticCounter.type === "dodging"
              // ) {
              //   if (plyr.elasticCounter.countUp.state === true) {
              //     // animIndex7 = plyr.elasticCounter.countUp.count-1;

              //     if (plyr.elasticCounter.countUp.count < 11) {
              //       animIndex7 = plyr.elasticCounter.countUp.count - 1;
              //     } else {
              //       if (plyr.elasticCounter.countUp.count % 10 === 0) {
              //         animIndex7 = 9;
              //         // animIndex5 = 10;
              //         // animIndex5 = (plyr.elasticCounter.pause.count-mod)
              //       } else {
              //         let mod = Math.floor(plyr.elasticCounter.countUp.count / 10) * 10;
              //         animIndex7 = plyr.elasticCounter.countUp.count - mod - 1;
              //       }
              //     }
              //   }
              //   if (plyr.elasticCounter.pause.state === true) {
              //     if (plyr.elasticCounter.pause.count < 11) {
              //       animIndex7 = plyr.elasticCounter.pause.count - 1;
              //     } else {
              //       if (plyr.elasticCounter.pause.count % 10 === 0) {
              //         animIndex7 = 9;
              //         // animIndex5 = 10;
              //         // animIndex5 = (plyr.elasticCounter.pause.count-mod)
              //       } else {
              //         let mod = Math.floor(plyr.elasticCounter.pause.count / 10) * 10;
              //         animIndex7 = plyr.elasticCounter.pause.count - mod - 1;
              //       }
              //     }
              //   }
              //   if (plyr.elasticCounter.countDown.state === true) {
              //     // animIndex7 = plyr.elasticCounter.countDown.count-1;

              //     if (plyr.elasticCounter.countDown.count < 11) {
              //       animIndex7 = plyr.elasticCounter.countDown.count - 1;
              //     } else {
              //       if (plyr.elasticCounter.countDown.count % 10 === 0) {
              //         animIndex7 = 9;
              //         // animIndex5 = 10;
              //         // animIndex5 = (plyr.elasticCounter.pause.count-mod)
              //       } else {
              //         let mod = Math.floor(plyr.elasticCounter.countDown.count / 10) * 10;
              //         animIndex7 = plyr.elasticCounter.countDown.count - mod - 1;
              //       }
              //     }
              //   }
              // }

              finalAnimIndex = animIndex7;
              // console.log('anim testing dodge',plyr.dodging.count,'plyr',plyr.number);
              break;
          }

          // SPRITE SHEET CHAR AVATAR & ACTION SWITCH!
          if (plyr.ai.state === false) {
            switch (plyr.action) {
              case "idle":
                updatedPlayerImg = this.playerImgs[plyr.number - 1].idle[weapon];
                break;
              case "moving":
                if (plyr.pushing.state === true) {
                  updatedPlayerImg = this.playerImgs[plyr.number - 1].pushing[weapon];
                }
                if (plyr.pulled.state === true) {
                  updatedPlayerImg = this.playerImgs[plyr.number - 1].pulled[weapon];
                }
                if (plyr.pushed.state === true) {
                  updatedPlayerImg = this.playerImgs[plyr.number - 1].pushed[weapon];
                } else {
                  updatedPlayerImg = this.playerImgs[plyr.number - 1].walking[weapon];
                }

                break;
              case "jumping":
                updatedPlayerImg = this.playerImgs[plyr.number - 1].jumping[weapon];
                break;
              case "flanking":
                updatedPlayerImg = this.playerImgs[plyr.number - 1].flanking[weapon];
                break;
              case "strafe moving":
                if (plyr.pushBack.state === true) {
                  updatedPlayerImg = this.playerImgs[plyr.number - 1].pushBack[weapon];
                }
                if (plyr.pulling.state === true) {
                  updatedPlayerImg = this.playerImgs[plyr.number - 1].pulling[weapon];
                }
                if (plyr.pulled.state === true) {
                  updatedPlayerImg = this.playerImgs[plyr.number - 1].pulled[weapon];
                }
                if (plyr.pushed.state === true) {
                  updatedPlayerImg = this.playerImgs[plyr.number - 1].pushed[weapon];
                } else {
                  updatedPlayerImg = this.playerImgs[plyr.number - 1].strafing[weapon];
                }
                break;
              case "falling":
                updatedPlayerImg = this.playerImgs[plyr.number - 1].falling[weapon];
                break;
              case "attacking":
                updatedPlayerImg = this.playerImgs[plyr.number - 1].attacking[weapon];
                break;
              case "defending":
                updatedPlayerImg = this.playerImgs[plyr.number - 1].defending[weapon];
                break;
              case "deflected":
                updatedPlayerImg = this.playerImgs[plyr.number - 1].deflected[weapon];
                break;
              case "dodging":
                updatedPlayerImg = this.playerImgs[plyr.number - 1].dodging[weapon];
                break;
              case "dead":
                updatedPlayerImg = this.playerImgs[plyr.number - 1].idle[weapon];
                break;
            }
          }
          if (plyr.ai.state === true) {
            let plyrImgIndex;
            if (plyr.ai.imgType === "A") {
              plyrImgIndex = 2;
            } else if (plyr.ai.imgType === "B") {
              plyrImgIndex = 3;
            }

            switch (plyr.action) {
              case "idle":
                updatedPlayerImg = this.playerImgs[plyrImgIndex].idle[weapon];
                break;
              case "moving":
                if (plyr.pushing.state === true) {
                  updatedPlayerImg = this.playerImgs[plyrImgIndex].pushing[weapon];
                }
                if (plyr.pulled.state === true) {
                  updatedPlayerImg = this.playerImgs[plyrImgIndex].pulled[weapon];
                }
                if (plyr.pushed.state === true) {
                  updatedPlayerImg = this.playerImgs[plyrImgIndex].pushed[weapon];
                } else {
                  updatedPlayerImg = this.playerImgs[plyrImgIndex].walking[weapon];
                }
                break;
              case "jumping":
                updatedPlayerImg = this.playerImgs[plyrImgIndex].jumping[weapon];
                break;
              case "flanking":
                updatedPlayerImg = this.playerImgs[plyrImgIndex].flanking[weapon];
                break;
              case "strafe moving":
                if (plyr.pushBack.state === true) {
                  updatedPlayerImg = this.playerImgs[plyrImgIndex].pushBack[weapon];
                }
                if (plyr.pulling.state === true) {
                  updatedPlayerImg = this.playerImgs[plyrImgIndex].pulling[weapon];
                }
                if (plyr.pulled.state === true) {
                  updatedPlayerImg = this.playerImgs[plyrImgIndex].pulled[weapon];
                }
                if (plyr.pushed.state === true) {
                  updatedPlayerImg = this.playerImgs[plyrImgIndex].pushed[weapon];
                } else {
                  updatedPlayerImg = this.playerImgs[plyrImgIndex].strafing[weapon];
                }
                break;
              case "falling":
                updatedPlayerImg = this.playerImgs[plyrImgIndex].falling[weapon];
                break;
              case "attacking":
                updatedPlayerImg = this.playerImgs[plyrImgIndex].attacking[weapon];
                break;
              case "defending":
                updatedPlayerImg = this.playerImgs[plyrImgIndex].defending[weapon];
                break;
              case "deflected":
                updatedPlayerImg = this.playerImgs[plyrImgIndex].deflected[weapon];
                break;
              case "dodging":
                updatedPlayerImg = this.playerImgs[plyrImgIndex].dodging[weapon];
                break;
              case "dead":
                updatedPlayerImg = this.playerImgs[plyrImgIndex].idle[weapon];
                break;
            }
          }

          // SET SPRITE SHEET CLIP LOCATION!
          let dirs = ["north", "south", "east", "west"];
          let dirIndex = dirs.indexOf(plyr.direction);
          let sHeight = this.charSpriteHeight;
          let sWidth = this.charSpriteWidth;
          let sy = dirIndex * sHeight;
          let sx = (finalAnimIndex - 1) * sWidth;

          // PLAYER OUTLINES
          if (this.showPlayerOutlines === true) {
            // PLAYER OUTLINES
            let popupCoordObject = {
              north: this.popupDrawCalc(
                "north",
                { x: plyr.nextPosition.x - 25, y: plyr.nextPosition.y - 25 },
                plyr.number
              ),
              west: this.popupDrawCalc(
                "west",
                { x: plyr.nextPosition.x - 25, y: plyr.nextPosition.y - 25 },
                plyr.number
              ),
              south: this.popupDrawCalc(
                "south",
                { x: plyr.nextPosition.x - 25, y: plyr.nextPosition.y - 25 },
                plyr.number
              ),
            };
            let origin = popupCoordObject.west;
            let width = popupCoordObject.north.pt4.x - origin.pt3.x;
            let height = popupCoordObject.south.pt2.y - origin.pt3.y;
            context.strokeStyle = "red";
            context.lineWidth = 2;
            context.beginPath();
            context.roundRect(origin.pt3.x, origin.pt3.y, width, height, 2);
            context.stroke();

            let origin2 = {
              x: plyr.nextPosition.x - this.floorImageHeight / 2,
              y: plyr.nextPosition.y - this.floorImageHeight,
            };
            let height2 =
              plyr.nextPosition.y +
              this.floorImageHeight / 2 +
              2 -
              (plyr.nextPosition.y - this.floorImageHeight);
            let width2 = this.playerDrawWidth + 2;
            context.strokeStyle = "blue";
            context.lineWidth = 2;
            context.beginPath();
            context.roundRect(
              origin2.x,
              origin2.y,
              width2 + 2,
              this.playerDrawHeight * 1.5,
              2
            );
            // context.roundRect(origin2.x, origin2.y, width2, height2, 2);
            // context.roundRect(
            //   origin2.x,
            //   origin2.y,
            //   this.playerDrawWidth,
            //   this.playerDrawHeight * 1.5,
            //   2
            // );
            // context.roundRect(
            //   origin2.x,
            //   origin2.y,
            //   this.playerDrawWidth + 2,
            //   this.floorImageHeight * 1.5,
            //   2
            // );
            context.stroke();
          }

          //PLAYER DEPTH SORTING!!
          let elasticCountCalcResult;

          // IN-GRID MOVING & MID STRAFE KEY RELEASE
          if (
            plyr.target.cell1.void === false &&
            plyr.moving.state === true &&
            plyr.falling.state !== true &&
            plyr.jumping.state !== true
          ) {
            let jumpYCalc = 10 - this.moveStepRef[1].indexOf(plyr.moving.step);

            let direction = plyr.direction;

            if (plyr.strafing.direction !== "") {
              direction = plyr.strafing.direction;
            }
            if (direction === "north") {
              if (
                x === plyr.moving.origin.number.x &&
                y === plyr.moving.origin.number.y
              ) {
                if (plyr.jumping.state === true) {
                  context.drawImage(
                    updatedPlayerImg,
                    sx,
                    sy,
                    sWidth,
                    sHeight,
                    newCharDarwPoint.x - 5,
                    newCharDarwPoint.y - 10 - jumpYCalc * 3,
                    this.playerDrawWidth2,
                    this.playerDrawHeight2
                  );
                } else {
                  context.drawImage(
                    updatedPlayerImg,
                    sx,
                    sy,
                    sWidth,
                    sHeight,
                    newCharDarwPoint.x - 5,
                    newCharDarwPoint.y - 10,
                    this.playerDrawWidth2,
                    this.playerDrawHeight2
                  );
                }
              }
            }
            if (direction === "west") {
              if (
                x === plyr.moving.origin.number.x &&
                y === plyr.moving.origin.number.y
              ) {
                if (plyr.jumping.state === true) {
                  context.drawImage(
                    updatedPlayerImg,
                    sx,
                    sy,
                    sWidth,
                    sHeight,
                    newCharDarwPoint.x - 5,
                    newCharDarwPoint.y - 10 - jumpYCalc * 3,
                    this.playerDrawWidth2,
                    this.playerDrawHeight2
                  );
                } else {
                  context.drawImage(
                    updatedPlayerImg,
                    sx,
                    sy,
                    sWidth,
                    sHeight,
                    newCharDarwPoint.x - 5,
                    newCharDarwPoint.y - 10,
                    this.playerDrawWidth2,
                    this.playerDrawHeight2
                  );
                }
              }
            }
            if (direction === "east") {
              if (
                x === plyr.moving.origin.number.x + 1 &&
                y === plyr.moving.origin.number.y
              ) {
                if (plyr.jumping.state === true) {
                  context.drawImage(
                    updatedPlayerImg,
                    sx,
                    sy,
                    sWidth,
                    sHeight,
                    newCharDarwPoint.x - 5,
                    newCharDarwPoint.y - 10 - jumpYCalc * 3,
                    this.playerDrawWidth2,
                    this.playerDrawHeight2
                  );
                } else {
                  context.drawImage(
                    updatedPlayerImg,
                    sx,
                    sy,
                    sWidth,
                    sHeight,
                    newCharDarwPoint.x - 5,
                    newCharDarwPoint.y - 10,
                    this.playerDrawWidth2,
                    this.playerDrawHeight2
                  );
                }
              }
            }
            if (direction === "south") {
              if (
                x === plyr.moving.origin.number.x &&
                y === plyr.moving.origin.number.y + 1
              ) {
                if (plyr.jumping.state === true) {
                  context.drawImage(
                    updatedPlayerImg,
                    sx,
                    sy,
                    sWidth,
                    sHeight,
                    newCharDarwPoint.x - 5,
                    newCharDarwPoint.y - 10 - jumpYCalc * 3,
                    this.playerDrawWidth2,
                    this.playerDrawHeight2
                  );
                } else {
                  context.drawImage(
                    updatedPlayerImg,
                    sx,
                    sy,
                    sWidth,
                    sHeight,
                    newCharDarwPoint.x - 5,
                    newCharDarwPoint.y - 10,
                    this.playerDrawWidth2,
                    this.playerDrawHeight2
                  );
                }
              }
            }

            if (plyr.pushBack.state === true) {
              // context.drawImage(indicatorImgs.pushback, point.x-20, point.y-20, 35,35);
            }
          }
          // STATIONARY & HALFPUSH BACK
          else if (
            plyr.moving.state === false &&
            plyr.ghost.state !== true &&
            plyr.dodging.state !== true &&
            plyr.elasticCounter.state !== true &&
            plyr.action !== "attacking"
          ) {
            if (
              plyr.halfPushBack.state === true &&
              plyr.success.deflected.state !== true
            ) {
              elasticCountCalcResult = this.calcElasticCountCoords(
                "halfPushBack",
                "player",
                plyr
              );
              let finalCoords = this.calcElasticCountCoords(
                "halfPushBack",
                "player",
                plyr
              ).coords;
              let drawCell = this.calcElasticCountCoords(
                "halfPushBack",
                "player",
                plyr
              ).drawCell;
              plyr = this.calcElasticCountCoords("halfPushBack", "player", plyr).player;

              if (x === 0 && y === 0) {
                // this.testDraw.push({
                //   color: "purple",
                //   x: finalCoords.x,
                //   y: finalCoords.y,
                //   direction: plyr.direction,
                // });
              }

              finalCoords.x -= 5;
              finalCoords.y -= 10;

              // if (x === drawCell.x && y === drawCell.y) {
              //
              //   context.drawImage(updatedPlayerImg, sx, sy, sWidth, sHeight, finalCoords.x, finalCoords.y, this.playerDrawWidth, this.playerDrawHeight)
              //
              // }

              if (
                !this.gridInfo.find(
                  (x) =>
                    x.number.x ===
                      this.getCellFromDirection(
                        1,
                        plyr.currentPosition.cell.number,
                        plyr.halfPushBack.direction
                      ).x &&
                    x.number.y ===
                      this.getCellFromDirection(
                        1,
                        plyr.currentPosition.cell.number,
                        plyr.halfPushBack.direction
                      ).y
                )
              ) {
                if (
                  x === plyr.currentPosition.cell.number.x &&
                  y === plyr.currentPosition.cell.number.y
                ) {
                  context.drawImage(
                    updatedPlayerImg,
                    sx,
                    sy,
                    sWidth,
                    sHeight,
                    finalCoords.x,
                    finalCoords.y,
                    this.playerDrawWidth2,
                    this.playerDrawHeight2
                  );
                }
              } else {
                if (plyr.direction === "north") {
                  if (
                    x === plyr.currentPosition.cell.number.x &&
                    y === plyr.currentPosition.cell.number.y + 1
                  ) {
                    context.drawImage(
                      updatedPlayerImg,
                      sx,
                      sy,
                      sWidth,
                      sHeight,
                      finalCoords.x,
                      finalCoords.y,
                      this.playerDrawWidth2,
                      this.playerDrawHeight2
                    );
                  }
                }
                if (plyr.direction === "east") {
                  if (
                    x === plyr.currentPosition.cell.number.x &&
                    y === plyr.currentPosition.cell.number.y
                  ) {
                    context.drawImage(
                      updatedPlayerImg,
                      sx,
                      sy,
                      sWidth,
                      sHeight,
                      finalCoords.x,
                      finalCoords.y,
                      this.playerDrawWidth2,
                      this.playerDrawHeight2
                    );
                  }
                }
                if (plyr.direction === "west") {
                  if (
                    x === plyr.currentPosition.cell.number.x + 1 &&
                    y === plyr.currentPosition.cell.number.y
                  ) {
                    context.drawImage(
                      updatedPlayerImg,
                      sx,
                      sy,
                      sWidth,
                      sHeight,
                      finalCoords.x,
                      finalCoords.y,
                      this.playerDrawWidth2,
                      this.playerDrawHeight2
                    );
                  }
                }
                if (plyr.direction === "south") {
                  if (
                    x === plyr.currentPosition.cell.number.x + 1 &&
                    y === plyr.currentPosition.cell.number.y
                  ) {
                    context.drawImage(
                      updatedPlayerImg,
                      sx,
                      sy,
                      sWidth,
                      sHeight,
                      finalCoords.x,
                      finalCoords.y,
                      this.playerDrawWidth2,
                      this.playerDrawHeight2
                    );
                  }
                }
              }
            } else {
              if (
                x === plyr.moving.origin.number.x &&
                y === plyr.moving.origin.number.y &&
                plyr.success.deflected.state === false
              ) {
                context.drawImage(
                  updatedPlayerImg,
                  sx,
                  sy,
                  sWidth,
                  sHeight,
                  newCharDarwPoint.x - 5,
                  newCharDarwPoint.y - 10,
                  this.playerDrawWidth2,
                  this.playerDrawHeight2
                );
              }
            }
          }
          // VOID/EDGE MOVE
          else if (
            plyr.target.cell1.void === true &&
            plyr.moving.state === true &&
            plyr.falling.state !== true &&
            plyr.jumping.state !== true
          ) {
            // console.log('heading for thevoid @ draw step');
            // if (
            //   x === plyr.currentPosition.cell.number.x &&
            //   y === plyr.currentPosition.cell.number.y
            // ) {
            //   console.log('heading for thevoid @ draw step',plyr.target.cell1.number);
            // }

            if (
              plyr.moving.origin.number.x === this.gridWidth &&
              plyr.moving.origin.number.y !== 0 &&
              plyr.moving.origin.number.y !== this.gridWidth
            ) {
              if (
                x === plyr.moving.origin.number.x &&
                y === plyr.moving.origin.number.y + 1
              ) {
                context.drawImage(
                  updatedPlayerImg,
                  sx,
                  sy,
                  sWidth,
                  sHeight,
                  newCharDarwPoint.x - 5,
                  newCharDarwPoint.y - 10,
                  this.playerDrawWidth2,
                  this.playerDrawHeight2
                );
                // context.fillStyle = "black";
                // context.fillRect(point.x, point.y,5,5);
              }
            }
            if (
              plyr.moving.origin.number.x === this.gridWidth &&
              plyr.moving.origin.number.y === 0
            ) {
              if (
                x === plyr.moving.origin.number.x &&
                y === plyr.moving.origin.number.y
              ) {
                context.drawImage(
                  updatedPlayerImg,
                  sx,
                  sy,
                  sWidth,
                  sHeight,
                  newCharDarwPoint.x - 5,
                  newCharDarwPoint.y - 10,
                  this.playerDrawWidth2,
                  this.playerDrawHeight2
                );
                // context.fillStyle = "black";
                // context.fillRect(point.x, point.y,5,5);
              }
            }
            if (
              plyr.moving.origin.number.x === this.gridWidth &&
              plyr.moving.origin.number.y === this.gridWidth
            ) {
              if (
                x === plyr.moving.origin.number.x &&
                y === plyr.moving.origin.number.y
              ) {
                context.drawImage(
                  updatedPlayerImg,
                  sx,
                  sy,
                  sWidth,
                  sHeight,
                  newCharDarwPoint.x - 5,
                  newCharDarwPoint.y - 10,
                  this.playerDrawWidth2,
                  this.playerDrawHeight2
                );
                // context.fillStyle = "black";
                // context.fillRect(point.x, point.y,5,5);
              }
            }
            if (
              plyr.moving.origin.number.x === 0 &&
              plyr.moving.origin.number.y === this.gridWidth
            ) {
              if (
                x === plyr.moving.origin.number.x &&
                y === plyr.moving.origin.number.y
              ) {
                context.drawImage(
                  updatedPlayerImg,
                  sx,
                  sy,
                  sWidth,
                  sHeight,
                  newCharDarwPoint.x - 5,
                  newCharDarwPoint.y - 10,
                  this.playerDrawWidth2,
                  this.playerDrawHeight2
                );
                // context.fillStyle = "black";
                // context.fillRect(point.x, point.y,5,5);
              }
            }
            if (plyr.moving.origin.number.x === 0 && plyr.moving.origin.number.y === 0) {
              if (
                x === plyr.moving.origin.number.x &&
                y === plyr.moving.origin.number.y
              ) {
                context.drawImage(
                  updatedPlayerImg,
                  sx,
                  sy,
                  sWidth,
                  sHeight,
                  newCharDarwPoint.x - 5,
                  newCharDarwPoint.y - 10,
                  this.playerDrawWidth2,
                  this.playerDrawHeight2
                );
                // context.fillStyle = "black";
                // context.fillRect(point.x, point.y,5,5);
              }
            } else {
              if (
                x === plyr.moving.origin.number.x + 1 &&
                y === plyr.moving.origin.number.y
              ) {
                context.drawImage(
                  updatedPlayerImg,
                  sx,
                  sy,
                  sWidth,
                  sHeight,
                  newCharDarwPoint.x - 5,
                  newCharDarwPoint.y - 10,
                  this.playerDrawWidth2,
                  this.playerDrawHeight2
                );
                // context.fillStyle = "black";
                // context.fillRect(point.x, point.y,5,5);
              }
            }
          }

          // ELASTIC COUNTER ATTACKING
          if (
            (plyr.attacking.state === true || plyr.action === "attacking") &&
            plyr.moving.state === false &&
            plyr.ghost.state !== true &&
            plyr.dodging.state !== true
          ) {
            if (
              plyr.elasticCounter.state === true &&
              plyr.elasticCounter.type === "attacking"
            ) {
              let finalCoords = this.calcElasticCountCoords(
                "attacking",
                "player",
                plyr
              ).coords;
              let drawCell = this.calcElasticCountCoords(
                "attacking",
                "player",
                plyr
              ).drawCell;
              plyr = this.calcElasticCountCoords("attacking", "player", plyr).player;
              finalCoords.x -= 5;
              finalCoords.y -= 10;

              // test logging
              if (x === this.gridWidth && y === this.gridWidth) {
                if (plyr.elasticCounter.countUp.state === true) {
                  // this.testDraw.push({
                  //   color: "red",
                  //   x: finalCoords.x,
                  //   y: finalCoords.y,
                  // });
                  // console.log('attacking elastic count coords: countUp: ',plyr.elasticCounter.countUp.count,finalCoords,plyr.elasticCounter.direction);
                }
                if (plyr.elasticCounter.countDown.state === true) {
                  // this.testDraw.push({
                  //   color: "blue",
                  //   x: finalCoords.x,
                  //   y: finalCoords.y,
                  // });
                  // console.log('attacking elastic count coords: countDown: ',plyr.elasticCounter.countDown.count,finalCoords,plyr.elasticCounter.direction);
                }
                if (plyr.elasticCounter.pause.state === true) {
                  // this.testDraw.push({
                  //   color: "blue",
                  //   x: finalCoords.x,
                  //   y: finalCoords.y,
                  // });
                  // console.log('attacking elastic count coords: pause: ',plyr.elasticCounter.pause.count,finalCoords,plyr.elasticCounter.direction);
                }
              }

              if (
                !this.gridInfo.find(
                  (x) =>
                    x.number.x ===
                      this.getCellFromDirection(
                        1,
                        plyr.currentPosition.cell.number,
                        plyr.elasticCounter.direction
                      ).x &&
                    x.number.y ===
                      this.getCellFromDirection(
                        1,
                        plyr.currentPosition.cell.number,
                        plyr.elasticCounter.direction
                      ).y
                )
              ) {
                if (
                  x === plyr.currentPosition.cell.number.x &&
                  y === plyr.currentPosition.cell.number.y
                ) {
                  context.drawImage(
                    updatedPlayerImg,
                    sx,
                    sy,
                    sWidth,
                    sHeight,
                    finalCoords.x,
                    finalCoords.y,
                    this.playerDrawWidth2,
                    this.playerDrawHeight2
                  );
                }
              } else {
                if (plyr.elasticCounter.direction === "north") {
                  if (
                    x === plyr.currentPosition.cell.number.x &&
                    y === plyr.currentPosition.cell.number.y
                  ) {
                    context.drawImage(
                      updatedPlayerImg,
                      sx,
                      sy,
                      sWidth,
                      sHeight,
                      finalCoords.x,
                      finalCoords.y,
                      this.playerDrawWidth2,
                      this.playerDrawHeight2
                    );
                  }
                }
                if (plyr.elasticCounter.direction === "east") {
                  if (
                    x === plyr.currentPosition.cell.number.x + 1 &&
                    y === plyr.currentPosition.cell.number.y
                  ) {
                    context.drawImage(
                      updatedPlayerImg,
                      sx,
                      sy,
                      sWidth,
                      sHeight,
                      finalCoords.x,
                      finalCoords.y,
                      this.playerDrawWidth2,
                      this.playerDrawHeight2
                    );
                  }
                }
                if (plyr.elasticCounter.direction === "west") {
                  if (
                    x === plyr.currentPosition.cell.number.x &&
                    y === plyr.currentPosition.cell.number.y
                  ) {
                    context.drawImage(
                      updatedPlayerImg,
                      sx,
                      sy,
                      sWidth,
                      sHeight,
                      finalCoords.x,
                      finalCoords.y,
                      this.playerDrawWidth2,
                      this.playerDrawHeight2
                    );
                  }
                }
                if (plyr.elasticCounter.direction === "south") {
                  if (
                    x === plyr.currentPosition.cell.number.x &&
                    y === plyr.currentPosition.cell.number.y + 1
                  ) {
                    context.drawImage(
                      updatedPlayerImg,
                      sx,
                      sy,
                      sWidth,
                      sHeight,
                      finalCoords.x,
                      finalCoords.y,
                      this.playerDrawWidth2,
                      this.playerDrawHeight2
                    );
                  }
                }
              }
            } else {
              if (
                x === plyr.moving.origin.number.x &&
                y === plyr.moving.origin.number.y &&
                plyr.success.deflected.state === false
              ) {
                context.drawImage(
                  updatedPlayerImg,
                  sx,
                  sy,
                  sWidth,
                  sHeight,
                  newCharDarwPoint.x - 5,
                  newCharDarwPoint.y - 10,
                  this.playerDrawWidth2,
                  this.playerDrawHeight2
                );
              }
            }

            // if (x === plyr.moving.origin.number.x && y === plyr.moving.origin.number.y && plyr.success.deflected.state === false) {
            //
            //   context.drawImage(updatedPlayerImg, sx, sy, sWidth, sHeight, point.x-(this.playerDrawWidth/2), point.y-(this.playerDrawHeight/2), this.playerDrawWidth, this.playerDrawHeight);
            //
            // }
          }
          // ELASTIC COUNTER DEFENDING
          if (
            (plyr.defending.state === true || plyr.action === "defending") &&
            plyr.moving.state === false &&
            plyr.ghost.state !== true &&
            plyr.dodging.state !== true
          ) {
            if (
              plyr.elasticCounter.state === true &&
              plyr.elasticCounter.type === "defending"
            ) {
              let finalCoords = this.calcElasticCountCoords(
                "defending",
                "player",
                plyr
              ).coords;
              let drawCell = this.calcElasticCountCoords(
                "defending",
                "player",
                plyr
              ).drawCell;
              plyr = this.calcElasticCountCoords("defending", "player", plyr).player;

              finalCoords.x -= 5;
              finalCoords.y -= 10;

              // test logging
              if (x === this.gridWidth && y === this.gridWidth) {
                this.testDraw.push({ color: "red", x: finalCoords.x, y: finalCoords.y });
                if (plyr.elasticCounter.countUp.state === true) {
                  // this.testDraw.push({
                  //   color: "red",
                  //   x: finalCoords.x,
                  //   y: finalCoords.y,
                  // });
                  // console.log('attacking elastic count coords: countUp: ',plyr.elasticCounter.countUp.count,finalCoords,plyr.elasticCounter.direction);
                }
                if (plyr.elasticCounter.countDown.state === true) {
                  // this.testDraw.push({
                  //   color: "blue",
                  //   x: finalCoords.x,
                  //   y: finalCoords.y,
                  // });
                  // console.log('attacking elastic count coords: countDown: ',plyr.elasticCounter.countDown.count,finalCoords,plyr.elasticCounter.direction);
                }
                if (plyr.elasticCounter.pause.state === true) {
                  // this.testDraw.push({
                  //   color: "blue",
                  //   x: finalCoords.x,
                  //   y: finalCoords.y,
                  // });
                  // console.log('attacking elastic count coords: pause: ',plyr.elasticCounter.pause.count,finalCoords,plyr.elasticCounter.direction);
                }
              }

              if (
                !this.gridInfo.find(
                  (x) =>
                    x.number.x ===
                      this.getCellFromDirection(
                        1,
                        plyr.currentPosition.cell.number,
                        plyr.elasticCounter.direction
                      ).x &&
                    x.number.y ===
                      this.getCellFromDirection(
                        1,
                        plyr.currentPosition.cell.number,
                        plyr.elasticCounter.direction
                      ).y
                )
              ) {
                if (
                  x === plyr.currentPosition.cell.number.x &&
                  y === plyr.currentPosition.cell.number.y
                ) {
                  context.drawImage(
                    updatedPlayerImg,
                    sx,
                    sy,
                    sWidth,
                    sHeight,
                    finalCoords.x,
                    finalCoords.y,
                    this.playerDrawWidth2,
                    this.playerDrawHeight2
                  );
                }
              } else {
                if (plyr.elasticCounter.direction === "north") {
                  if (
                    x === plyr.currentPosition.cell.number.x &&
                    y === plyr.currentPosition.cell.number.y
                  ) {
                    context.drawImage(
                      updatedPlayerImg,
                      sx,
                      sy,
                      sWidth,
                      sHeight,
                      finalCoords.x,
                      finalCoords.y,
                      this.playerDrawWidth2,
                      this.playerDrawHeight2
                    );
                  }
                }
                if (plyr.elasticCounter.direction === "east") {
                  if (
                    x === plyr.currentPosition.cell.number.x + 1 &&
                    y === plyr.currentPosition.cell.number.y
                  ) {
                    context.drawImage(
                      updatedPlayerImg,
                      sx,
                      sy,
                      sWidth,
                      sHeight,
                      finalCoords.x,
                      finalCoords.y,
                      this.playerDrawWidth2,
                      this.playerDrawHeight2
                    );
                  }
                }
                if (plyr.elasticCounter.direction === "west") {
                  if (
                    x === plyr.currentPosition.cell.number.x &&
                    y === plyr.currentPosition.cell.number.y
                  ) {
                    context.drawImage(
                      updatedPlayerImg,
                      sx,
                      sy,
                      sWidth,
                      sHeight,
                      finalCoords.x,
                      finalCoords.y,
                      this.playerDrawWidth2,
                      this.playerDrawHeight2
                    );
                  }
                }
                if (plyr.elasticCounter.direction === "south") {
                  if (
                    x === plyr.currentPosition.cell.number.x &&
                    y === plyr.currentPosition.cell.number.y + 1
                  ) {
                    context.drawImage(
                      updatedPlayerImg,
                      sx,
                      sy,
                      sWidth,
                      sHeight,
                      finalCoords.x,
                      finalCoords.y,
                      this.playerDrawWidth2,
                      this.playerDrawHeight2
                    );
                  }
                }
              }
            }
          }

          if (plyr.jumping.state === true) {
            let jumpYCalc = 10 - this.moveStepRef[1].indexOf(plyr.moving.step);

            if (plyr.direction === "north") {
              if (
                x === plyr.moving.origin.number.x &&
                y === plyr.moving.origin.number.y
              ) {
                context.drawImage(
                  updatedPlayerImg,
                  sx,
                  sy,
                  sWidth,
                  sHeight,
                  newCharDarwPoint.x - 5,
                  newCharDarwPoint.y - 10 - jumpYCalc * 3,
                  this.playerDrawWidth2,
                  this.playerDrawHeight2
                );
              }
            }
            if (plyr.direction === "west") {
              if (
                x === plyr.moving.origin.number.x &&
                y === plyr.moving.origin.number.y
              ) {
                context.drawImage(
                  updatedPlayerImg,
                  sx,
                  sy,
                  sWidth,
                  sHeight,
                  newCharDarwPoint.x - 5,
                  newCharDarwPoint.y - 10 - jumpYCalc * 3,
                  this.playerDrawWidth2,
                  this.playerDrawHeight2
                );
              }
            }
            if (plyr.direction === "east") {
              if (x === plyr.target.cell2.number.x && y === plyr.target.cell2.number.y) {
                context.drawImage(
                  updatedPlayerImg,
                  sx,
                  sy,
                  sWidth,
                  sHeight,
                  newCharDarwPoint.x - 5,
                  newCharDarwPoint.y - 10 - jumpYCalc * 3,
                  this.playerDrawWidth2,
                  this.playerDrawHeight2
                );
              }
            }
            if (plyr.direction === "south") {
              if (x === plyr.target.cell2.number.x && y === plyr.target.cell2.number.y) {
                context.drawImage(
                  updatedPlayerImg,
                  sx,
                  sy,
                  sWidth,
                  sHeight,
                  newCharDarwPoint.x - 5,
                  newCharDarwPoint.y - 10 - jumpYCalc * 3,
                  this.playerDrawWidth2,
                  this.playerDrawHeight2
                );
              }
            }
          }
          // STRAFE MOVEMENT
          if (
            plyr.strafing.state === true &&
            plyr.falling.state !== true &&
            plyr.jumping.state !== true
          ) {
            if (
              plyr.strafing.direction === "north" ||
              plyr.strafing.direction === "northWest" ||
              plyr.strafing.direction === "west"
            ) {
              if (
                x === plyr.moving.origin.number.x &&
                y === plyr.moving.origin.number.y
              ) {
                // context.drawImage(updatedPlayerImg, point.x-25, point.y-25, 55,55);
                context.drawImage(
                  updatedPlayerImg,
                  sx,
                  sy,
                  sWidth,
                  sHeight,
                  newCharDarwPoint.x - 5,
                  newCharDarwPoint.y - 10,
                  this.playerDrawWidth2,
                  this.playerDrawHeight2
                );
              }
            }
            if (plyr.strafing.direction === "east" || plyr.direction === "east") {
              if (
                x === plyr.moving.origin.number.x + 1 &&
                y === plyr.moving.origin.number.y
              ) {
                // if (x === plyr.target.cell1.number.x && y === plyr.target.cell1.number.y) {
                // context.drawImage(updatedPlayerImg, point.x-25, point.y-25, 55,55);
                context.drawImage(
                  updatedPlayerImg,
                  sx,
                  sy,
                  sWidth,
                  sHeight,
                  newCharDarwPoint.x - 5,
                  newCharDarwPoint.y - 10,
                  this.playerDrawWidth2,
                  this.playerDrawHeight2
                );
              }
            }
            if (plyr.strafing.direction === "south" || plyr.direction === "south") {
              if (
                x === plyr.moving.origin.number.x &&
                y === plyr.moving.origin.number.y + 1
              ) {
                // if (x === plyr.moving.destination.number.x && y === plyr.moving.destination.number.y) {
                // if (x === plyr.target.cell1.number.x && y === plyr.target.cell1.number.y) {
                // context.drawImage(updatedPlayerImg, point.x-25, point.y-25, 55,55);
                context.drawImage(
                  updatedPlayerImg,
                  sx,
                  sy,
                  sWidth,
                  sHeight,
                  newCharDarwPoint.x - 5,
                  newCharDarwPoint.y - 10,
                  this.playerDrawWidth2,
                  this.playerDrawHeight2
                );
              }
            }

            if (plyr.strafing.direction === "northEast") {
              if (
                x === plyr.moving.origin.number.x + 1 &&
                y === plyr.moving.origin.number.y
              ) {
                // context.drawImage(updatedPlayerImg, point.x-25, point.y-25, 55,55);
                context.drawImage(
                  updatedPlayerImg,
                  sx,
                  sy,
                  sWidth,
                  sHeight,
                  newCharDarwPoint.x - 5,
                  newCharDarwPoint.y - 10,
                  this.playerDrawWidth2,
                  this.playerDrawHeight2
                );
              }
            }
            if (plyr.strafing.direction === "southWest") {
              if (
                x === plyr.moving.origin.number.x &&
                y === plyr.moving.origin.number.y + 1
              ) {
                // context.drawImage(updatedPlayerImg, point.x-25, point.y-25, 55,55);
                context.drawImage(
                  updatedPlayerImg,
                  sx,
                  sy,
                  sWidth,
                  sHeight,
                  newCharDarwPoint.x - 5,
                  newCharDarwPoint.y - 10,
                  this.playerDrawWidth2,
                  this.playerDrawHeight2
                );
              }
            }
          }
          // FLANKING
          if (plyr.flanking.state === true && plyr.falling.state !== true) {
            if (plyr.flanking.step === 1) {
              if (plyr.flanking.direction === "north") {
                if (
                  x === plyr.moving.origin.number.x &&
                  y === plyr.moving.origin.number.y
                ) {
                  // console.log('draw flank north',);
                  context.drawImage(
                    updatedPlayerImg,
                    sx,
                    sy,
                    sWidth,
                    sHeight,
                    newCharDarwPoint.x - 5,
                    newCharDarwPoint.y - 10,
                    this.playerDrawWidth2,
                    this.playerDrawHeight2
                  );
                }
              }

              if (plyr.flanking.direction === "west") {
                if (
                  x === plyr.moving.origin.number.x &&
                  y === plyr.moving.origin.number.y
                ) {
                  // console.log('draw flank west',);
                  context.drawImage(
                    updatedPlayerImg,
                    sx,
                    sy,
                    sWidth,
                    sHeight,
                    newCharDarwPoint.x - 5,
                    newCharDarwPoint.y - 10,
                    this.playerDrawWidth2,
                    this.playerDrawHeight2
                  );
                }
              }

              if (plyr.flanking.direction === "east") {
                if (
                  x === plyr.moving.origin.number.x + 1 &&
                  y === plyr.moving.origin.number.y
                ) {
                  // console.log('draw flank east',);
                  context.drawImage(
                    updatedPlayerImg,
                    sx,
                    sy,
                    sWidth,
                    sHeight,
                    newCharDarwPoint.x - 5,
                    newCharDarwPoint.y - 10,
                    this.playerDrawWidth2,
                    this.playerDrawHeight2
                  );
                }
              }

              if (plyr.flanking.direction === "south") {
                if (
                  x === plyr.moving.origin.number.x &&
                  y === plyr.moving.origin.number.y + 1
                ) {
                  // console.log('draw flank south',);
                  context.drawImage(
                    updatedPlayerImg,
                    sx,
                    sy,
                    sWidth,
                    sHeight,
                    newCharDarwPoint.x - 5,
                    newCharDarwPoint.y - 10,
                    this.playerDrawWidth2,
                    this.playerDrawHeight2
                  );
                }
              }
            }

            if (plyr.flanking.step === 2) {
              if (plyr.direction === "north") {
                if (
                  x === plyr.moving.origin.number.x &&
                  y === plyr.moving.origin.number.y
                ) {
                  context.drawImage(
                    updatedPlayerImg,
                    sx,
                    sy,
                    sWidth,
                    sHeight,
                    newCharDarwPoint.x - 5,
                    newCharDarwPoint.y - 10,
                    this.playerDrawWidth2,
                    this.playerDrawHeight2
                  );
                }
              }

              if (plyr.direction === "west") {
                if (
                  x === plyr.moving.origin.number.x &&
                  y === plyr.moving.origin.number.y
                ) {
                  context.drawImage(
                    updatedPlayerImg,
                    sx,
                    sy,
                    sWidth,
                    sHeight,
                    newCharDarwPoint.x - 5,
                    newCharDarwPoint.y - 10,
                    this.playerDrawWidth2,
                    this.playerDrawHeight2
                  );
                }
              }

              if (plyr.direction === "east") {
                if (
                  x === plyr.moving.origin.number.x + 1 &&
                  y === plyr.moving.origin.number.y
                ) {
                  context.drawImage(
                    updatedPlayerImg,
                    sx,
                    sy,
                    sWidth,
                    sHeight,
                    newCharDarwPoint.x - 5,
                    newCharDarwPoint.y - 10,
                    this.playerDrawWidth2,
                    this.playerDrawHeight2
                  );
                }
              }

              if (plyr.direction === "south") {
                if (
                  x === plyr.moving.origin.number.x &&
                  y === plyr.moving.origin.number.y + 1
                ) {
                  context.drawImage(
                    updatedPlayerImg,
                    sx,
                    sy,
                    sWidth,
                    sHeight,
                    newCharDarwPoint.x - 5,
                    newCharDarwPoint.y - 10,
                    this.playerDrawWidth2,
                    this.playerDrawHeight2
                  );
                }
              }
            }
          }
          // FALLING
          if (plyr.falling.state === true) {
            // IN BOUNDS
            if (x === plyr.target.cell1.number.x && y === plyr.target.cell1.number.y) {
              context.drawImage(
                updatedPlayerImg,
                sx,
                sy,
                sWidth,
                sHeight,
                newCharDarwPoint.x - 5,
                newCharDarwPoint.y - 10,
                this.playerDrawWidth2,
                this.playerDrawHeight2
              );
            }

            // OUT OF BOUNDS
            if (
              plyr.target.cell1.number.x < 0 ||
              plyr.target.cell1.number.y < 0 ||
              plyr.target.cell1.number.x > this.gridWidth ||
              plyr.target.cell1.number.y > this.gridWidth
            ) {
              if (
                x === plyr.moving.origin.number.x &&
                y === plyr.moving.origin.number.y
              ) {
                context.drawImage(
                  updatedPlayerImg,
                  sx,
                  sy,
                  sWidth,
                  sHeight,
                  newCharDarwPoint.x - 5,
                  newCharDarwPoint.y - 10,
                  this.playerDrawWidth2,
                  this.playerDrawHeight2
                );
              }
            }
          }
          // DEFLECTED
          if (plyr.success.deflected.state === true) {
            if (
              plyr.elasticCounter.state === true &&
              plyr.elasticCounter.type === "deflected"
            ) {
              let finalCoords = this.calcElasticCountCoords(
                "deflected",
                "player",
                plyr
              ).coords;
              let drawCell = this.calcElasticCountCoords(
                "deflected",
                "player",
                plyr
              ).drawCell;
              plyr = this.calcElasticCountCoords("deflected", "player", plyr).player;
              finalCoords.x -= 5;
              finalCoords.y -= 10;

              if (
                !this.gridInfo.find(
                  (x) =>
                    x.number.x ===
                      this.getCellFromDirection(
                        1,
                        plyr.currentPosition.cell.number,
                        plyr.elasticCounter.direction
                      ).x &&
                    x.number.y ===
                      this.getCellFromDirection(
                        1,
                        plyr.currentPosition.cell.number,
                        plyr.elasticCounter.direction
                      ).y
                )
              ) {
                if (
                  x === plyr.currentPosition.cell.number.x &&
                  y === plyr.currentPosition.cell.number.y
                ) {
                  context.drawImage(
                    updatedPlayerImg,
                    sx,
                    sy,
                    sWidth,
                    sHeight,
                    finalCoords.x,
                    finalCoords.y,
                    this.playerDrawWidth2,
                    this.playerDrawHeight2
                  );
                }
              } else {
                if (plyr.elasticCounter.direction === "south") {
                  if (
                    x === plyr.currentPosition.cell.number.x &&
                    y === plyr.currentPosition.cell.number.y + 1
                  ) {
                    context.drawImage(
                      updatedPlayerImg,
                      sx,
                      sy,
                      sWidth,
                      sHeight,
                      finalCoords.x,
                      finalCoords.y,
                      this.playerDrawWidth2,
                      this.playerDrawHeight2
                    );
                  }
                }
                if (plyr.elasticCounter.direction === "west") {
                  if (
                    x === plyr.currentPosition.cell.number.x &&
                    y === plyr.currentPosition.cell.number.y
                  ) {
                    context.drawImage(
                      updatedPlayerImg,
                      sx,
                      sy,
                      sWidth,
                      sHeight,
                      finalCoords.x,
                      finalCoords.y,
                      this.playerDrawWidth2,
                      this.playerDrawHeight2
                    );
                  }
                }
                if (plyr.elasticCounter.direction === "east") {
                  if (
                    x === plyr.currentPosition.cell.number.x + 1 &&
                    y === plyr.currentPosition.cell.number.y
                  ) {
                    context.drawImage(
                      updatedPlayerImg,
                      sx,
                      sy,
                      sWidth,
                      sHeight,
                      finalCoords.x,
                      finalCoords.y,
                      this.playerDrawWidth2,
                      this.playerDrawHeight2
                    );
                  }
                }
                if (plyr.elasticCounter.direction === "north") {
                  if (
                    x === plyr.currentPosition.cell.number.x + 1 &&
                    y === plyr.currentPosition.cell.number.y
                  ) {
                    context.drawImage(
                      updatedPlayerImg,
                      sx,
                      sy,
                      sWidth,
                      sHeight,
                      finalCoords.x,
                      finalCoords.y,
                      this.playerDrawWidth2,
                      this.playerDrawHeight2
                    );
                  }
                }
              }
            }
            if (
              plyr.elasticCounter.state !== true &&
              plyr.elasticCounter.type === "deflected" &&
              x === this.gridWidth &&
              y === this.gridWidth
            ) {
              // console.log('deflected elastic counter overflow?',plyr.success.deflected.count);
            }
          }
          // DODGING
          if (plyr.action === "dodging" && plyr.success.deflected.state !== true) {
            if (
              plyr.elasticCounter.state === true &&
              plyr.elasticCounter.type === "dodging"
            ) {
              let finalCoords = this.calcElasticCountCoords(
                "dodging",
                "player",
                plyr
              ).coords;
              let drawCell = this.calcElasticCountCoords(
                "dodging",
                "player",
                plyr
              ).drawCell;

              plyr = this.calcElasticCountCoords("dodging", "player", plyr).player;
              finalCoords.x -= 5;
              finalCoords.y -= 10;

              // test logging
              if (x === this.gridWidth && y === this.gridWidth) {
                if (plyr.elasticCounter.countUp.state === true) {
                  // this.testDraw.push({color: 'red',x:finalCoords.x,y:finalCoords.y })
                  // console.log('dodging elastic coount coords: countUp: ',plyr.elasticCounter.countUp.count,finalCoords,plyr.elasticCounter.direction);
                }
                if (plyr.elasticCounter.countDown.state === true) {
                  // this.testDraw.push({color: 'blue',x:finalCoords.x,y:finalCoords.y })
                  // console.log('dodging elastic coount coords: countDown: ',plyr.elasticCounter.countDown.count,finalCoords,plyr.elasticCounter.direction);
                }
                if (plyr.elasticCounter.pause.state === true) {
                  // this.testDraw.push({color: 'blue',x:finalCoords.x,y:finalCoords.y })
                  // console.log('dodging elastic coount coords: pause: ',plyr.elasticCounter.pause.count,finalCoords,plyr.elasticCounter.direction);
                }
              }

              if (
                !this.gridInfo.find(
                  (x) =>
                    x.number.x ===
                      this.getCellFromDirection(
                        1,
                        plyr.currentPosition.cell.number,
                        plyr.elasticCounter.direction
                      ).x &&
                    x.number.y ===
                      this.getCellFromDirection(
                        1,
                        plyr.currentPosition.cell.number,
                        plyr.elasticCounter.direction
                      ).y
                )
              ) {
                if (
                  x === plyr.currentPosition.cell.number.x &&
                  y === plyr.currentPosition.cell.number.y
                ) {
                  context.drawImage(
                    updatedPlayerImg,
                    sx,
                    sy,
                    sWidth,
                    sHeight,
                    finalCoords.x,
                    finalCoords.y,
                    this.playerDrawWidth2,
                    this.playerDrawHeight2
                  );
                }
              } else {
                if (plyr.elasticCounter.direction === "north") {
                  if (
                    x === plyr.currentPosition.cell.number.x &&
                    y === plyr.currentPosition.cell.number.y
                  ) {
                    context.drawImage(
                      updatedPlayerImg,
                      sx,
                      sy,
                      sWidth,
                      sHeight,
                      finalCoords.x,
                      finalCoords.y,
                      this.playerDrawWidth2,
                      this.playerDrawHeight2
                    );
                  }
                }
                if (plyr.elasticCounter.direction === "east") {
                  if (
                    x === plyr.currentPosition.cell.number.x + 1 &&
                    y === plyr.currentPosition.cell.number.y
                  ) {
                    context.drawImage(
                      updatedPlayerImg,
                      sx,
                      sy,
                      sWidth,
                      sHeight,
                      finalCoords.x,
                      finalCoords.y,
                      this.playerDrawWidth2,
                      this.playerDrawHeight2
                    );
                  }
                }
                if (plyr.elasticCounter.direction === "west") {
                  if (
                    x === plyr.currentPosition.cell.number.x &&
                    y === plyr.currentPosition.cell.number.y
                  ) {
                    context.drawImage(
                      updatedPlayerImg,
                      sx,
                      sy,
                      sWidth,
                      sHeight,
                      finalCoords.x,
                      finalCoords.y,
                      this.playerDrawWidth2,
                      this.playerDrawHeight2
                    );
                  }
                }
                if (plyr.elasticCounter.direction === "south") {
                  if (
                    x === plyr.currentPosition.cell.number.x &&
                    y === plyr.currentPosition.cell.number.y + 1
                  ) {
                    context.drawImage(
                      updatedPlayerImg,
                      sx,
                      sy,
                      sWidth,
                      sHeight,
                      finalCoords.x,
                      finalCoords.y,
                      this.playerDrawWidth2,
                      this.playerDrawHeight2
                    );
                  }
                }
              }
            }
          }

          // DEPTH SORTING END!!

          // RESPAWN
          if (plyr.respawn === true) {
            if (
              x === plyr.startPosition.cell.number.x &&
              y === plyr.startPosition.cell.number.y
            ) {
              // console.log('respawning... confirm dead player',plyr.dead.state,x,y);

              let canRespawn = false;
              let positionOccupied = false;
              let respawnPosCellRef = this.gridInfo.find(
                (x) =>
                  x.number.x === plyr.startPosition.cell.number.x &&
                  x.number.y === plyr.startPosition.cell.number.y
              );
              let respawnCellNo;
              let respawnCellCenter;

              for (const plyrx of this.players) {
                if (
                  plyrx.currentPosition.cell.number.x ===
                    plyr.startPosition.cell.number.x &&
                  plyrx.currentPosition.cell.number.y === plyr.startPosition.cell.number.y
                ) {
                  positionOccupied = true;
                }
              }
              if (
                respawnPosCellRef.obstacle.state === true ||
                respawnPosCellRef.terrain.type === "deep" ||
                respawnPosCellRef.void === true
              ) {
                positionOccupied = true;
              }

              if (positionOccupied === true) {
                respawnCellNo = this.getRandomFreeCell();
                respawnPosCellRef = this.gridInfo.find(
                  (x) =>
                    x.number.x === respawnCellNo.number.x &&
                    x.number.y === respawnCellNo.number.y
                );

                if (respawnCellNo) {
                  canRespawn = true;
                } else {
                  console.log(
                    "no cells for respawn. Unlikely but true. Reassign obstacle cell"
                  );
                  if (this.gridInfo.filter((x) => x.obstacle.state === true)[0]) {
                    this.gridInfo.filter(
                      (x) => x.obstacle.state === true
                    )[0].obstacle.state = false;
                    respawnPosCellRef = this.gridInfo.find(
                      (x) =>
                        x.number.x === respawnCellNo.number.x &&
                        x.number.y === respawnCellNo.number.y
                    );
                    let oldLvlData = this.gridInfo
                      .filter((x) => x.obstacle.state === true)[0]
                      .levelData.split("_");
                    oldLvlData[1] = "*";
                    this.gridInfo.filter((x) => x.obstacle.state === true)[0].levelData =
                      oldLvlData.join("_");
                    canRespawn = true;
                  } else {
                    console.log(
                      "no free cells for respawn and no obstacle cell to comandeer. Highly unlikley"
                    );

                    if (this.gridInfo.filter((x) => x.void.state === true)[0]) {
                      this.gridInfo.filter(
                        (x) => x.void.state === true
                      )[0].void.state = false;
                      respawnPosCellRef = this.gridInfo.find(
                        (x) =>
                          x.number.x === respawnCellNo.number.x &&
                          x.number.y === respawnCellNo.number.y
                      );
                      let oldLvlData = this.gridInfo
                        .filter((x) => x.void.state === true)[0]
                        .levelData.split("_");
                      oldLvlData[3] = "a";
                      this.gridInfo.filter((x) => x.void.state === true)[0].levelData =
                        oldLvlData.join("_");
                      canRespawn = true;
                    }
                  }
                }
              } else if ((canRespawn = true && respawnPosCellRef)) {
                canRespawn = true;
              }

              if (canRespawn === true) {
                // console.log('can respawn');
                let respawnPoint = respawnPosCellRef;
                plyr.dead.state = false;
                plyr.currentPosition.cell.number = respawnPoint.number;
                plyr.currentPosition.cell.center = respawnPoint.center;
                plyr.nextPosition = respawnPoint.center;
                this.getTarget(plyr);
                plyr.moving = {
                  state: false,
                  step: 0,
                  course: "",
                  origin: {
                    number: {
                      x: respawnPoint.number.x,
                      y: respawnPoint.number.y,
                    },
                    center: {
                      x: respawnPoint.center.x,
                      y: respawnPoint.center.y,
                    },
                  },
                  destination: {
                    x: this.players[plyr.number - 1].target.cell1.center.x,
                    y: this.players[plyr.number - 1].target.cell1.center.y,
                  },
                };
                let origin2 = {
                  x: plyr.nextPosition.x - this.floorImageHeight / 2,
                  y: plyr.nextPosition.y - this.floorImageHeight,
                };

                plyr.direction = "north";
                plyr.respawn = false;
                this.players[plyr.number - 1] = plyr;

                context.drawImage(
                  updatedPlayerImg,
                  sx,
                  sy,
                  sWidth,
                  sHeight,
                  // respawnPoint.center.x - 25,
                  // respawnPoint.center.y - 50,
                  origin2.x - 5,
                  origin2.y - 10,
                  this.playerDrawWidth2,
                  this.playerDrawHeight2
                );

                if (
                  this.camera.customView.state !== true &&
                  this.settingAutoCamera === false &&
                  plyr.ai.state !== true &&
                  this.camera.preInstructions.length === 0 &&
                  this.camera.instructions.length === 0
                ) {
                  this.setAutoCamera("playerSpawnFocus", plyr);
                } else {
                  console.log("no setting auto cam: playerSpawnFocus");
                }
              }
            }
          }
          // DEAD
          if (
            plyr.dead.state === true &&
            player.dead.count > 0 &&
            plyr.dead.count < plyr.dead.limit
          ) {
            if (
              x === plyr.ghost.position.cell.number.x &&
              y === plyr.ghost.position.cell.number.y
            ) {
              // console.log('player',plyr.number,'dying',player.dead.count);
              context.drawImage(
                this.indicatorImgs.death,
                plyr.ghost.position.cell.center.x - 15,
                plyr.ghost.position.cell.center.y - 15,
                25,
                25
              );
            }
          }
          // GHOST
          if (plyr.ghost.state === true && player.dead.count === 0) {
            if (
              x === plyr.ghost.position.cell.number.x &&
              y === plyr.ghost.position.cell.number.y
            ) {
              // console.log(
              //   "player ",
              //   plyr.number,
              //   "ghost @",
              //   plyr.ghost.position.cell.number,
              //   plyr.ghost.position.cell.center
              // );
              context.drawImage(
                this.indicatorImgs.ghost,
                plyr.ghost.position.cell.center.x - 20,
                plyr.ghost.position.cell.center.y - 20,
                25,
                25
              );
            }
          }

          // PLAYER POPUPS
          if (x === this.gridWidth && y === this.gridWidth) {
            let popupBorderColor = this.playerColourRef["player" + plyr.number + ""];

            if (plyr.dead.state !== true && plyr.popups.length > 0) {
              for (const popup of plyr.popups) {
                if (popup.state === true) {
                  // console.log('drawing a popup');
                  let popupDrawCoords;
                  if (popup.position === "" || !popup.position) {
                    let currentPopups = plyr.popups.filter((x) => x.state === true);
                    // let positions = ['north','east','south','west','northEast','southEast','southWest']
                    let positions = [
                      "north",
                      "east",
                      "south",
                      "west",
                      "northEast",
                      "northWest",
                      "southEast",
                      "southWest",
                    ];

                    if (plyr.strafing.state === true) {
                      if (positions[0] === plyr.strafing.direction) {
                        const first = positions.shift();
                        positions.push(first);
                      }
                    } else {
                      if (positions[0] === plyr.direction) {
                        const first = positions.shift();
                        positions.push(first);
                      }
                    }

                    // REMOVE POSITIONS ALREADY TAKEN BY PLAYERS' OTHER POPUPS
                    for (const popup2 of currentPopups) {
                      if (popup2.position && popup2.position !== "") {
                        let indx = positions.indexOf(popup2.position);
                        positions.splice(indx, 1);
                      }
                    }

                    let dir = undefined;

                    // CHECK OTHER PLAYER'S POSITION AND THE POPUPS POSITION
                    for (const plyr2 of this.players) {
                      if (plyr2.ai.state !== true && plyr2.number !== plyr.number) {
                        let myPos = plyr.currentPosition.cell.number;
                        let invalidPos =
                          this.players[plyr2.number - 1].currentPosition.cell.number;

                        dir = undefined;
                        // let invalidPositions = [invalidPos];

                        // GET DIRECTION OF OTHER PLAYER CELL RELATIVE TO ME
                        dir = this.getDirectionFromCells(myPos, invalidPos);

                        if (dir && positions.includes(dir) === true) {
                          positions.splice(positions.indexOf(dir), 1);
                          // console.log('player popups (unset): human player position is close to player',plyr.number,' @ ',invalidPos,'dir',dir);
                          // console.log('dont draw over player @',dir,'choose frome these position',positions);
                        }

                        // GET DIRECTION OF ALL OTHER PLAYERS' POPUPS OCCUPY, RELATIVE TO ME
                        for (const pop of plyr2.popups) {
                          dir = undefined;

                          if (pop.state === true) {
                            let invalidPos2 = {
                              x: undefined,
                              y: undefined,
                            };

                            invalidPos2 = this.getCellFromDirection(
                              1,
                              invalidPos,
                              pop.position
                            );

                            dir = this.getDirectionFromCells(myPos, invalidPos2);

                            if (dir && positions.includes(dir) === true) {
                              positions.splice(positions.indexOf(dir), 1);
                              // console.log('player popups (unset): human player popup position is close to player',plyr.number,' @ ',invalidPos2,'dir',dir);
                              // console.log('dont draw over player @',dir,'choose frome these position',positions);
                            }
                          }
                        }
                      }
                    }

                    // GET DIRECTION OF CELL POPUPS' POPUPS  CELLS RELATIVE TO ME
                    for (const popup2 of this.cellPopups) {
                      dir = undefined;

                      if (popup2.state === true) {
                        let myPos = plyr.currentPosition.cell.number;
                        let cellPos = popup2.cell.number;
                        let invalidPos2 = {
                          x: undefined,
                          y: undefined,
                        };

                        invalidPos2 = this.getCellFromDirection(
                          1,
                          cellPos,
                          popup2.position
                        );

                        dir = this.getDirectionFromCells(myPos, invalidPos2);

                        if (dir && positions.includes(dir) === true) {
                          positions.splice(positions.indexOf(dir), 1);
                          // console.log('player popups (unset): cell popup position is close to player',plyr.number,' @ ',invalidPos2,'dir',dir);
                          // console.log('dont draw over player @',dir,'choose frome these position',positions);
                        }

                        // let indx = positions.indexOf(popup2.position);
                        // positions.splice(indx,1)
                      }
                    }

                    // console.log('new or postponed popup ',popup.msg,'position',positions[0]);

                    if (!positions[0]) {
                      // console.log('no open positions for new or postponed popup', popup.msg);
                      popup.state = false;
                      popup.count = 0;
                    } else {
                      popup.position = positions[0];
                    }

                    let popupProgress = false;
                    let showProgress = false;
                    let writeValue = false;
                    if (
                      plyr.prePush.state === true ||
                      plyr.prePull.state === true ||
                      plyr.dodging.state === true ||
                      plyr.action === "dodging" ||
                      plyr.action === "defending" ||
                      plyr.action === "attacking" ||
                      plyr.attacking.state === true
                    ) {
                      showProgress = true;
                    }
                    if (
                      popup.msg === "attacking1" ||
                      popup.msg === "attacking2" ||
                      popup.msg === "defending" ||
                      popup.msg === "prePush" ||
                      popup.msg === "prePull" ||
                      popup.msg === "dodging" ||
                      popup.msg === "charging"
                    ) {
                      popupProgress = true;
                    }

                    if (popup.img === "") {
                      popup.img = this.popupImageRef[popup.msg];
                    }

                    if (popup.msg.split("_")) {
                      if (
                        popup.msg.split("_")[0] === "hpUp" ||
                        popup.msg.split("_")[0] === "hpDown"
                      ) {
                        writeValue = true;
                        popup.img = this.popupImageRef[popup.msg.split("_")[0]];
                      }
                    }

                    popupDrawCoords = this.popupDrawCalc(
                      popup.position,
                      { x: point.x - 25, y: point.y - 25 },
                      plyr.number
                    );

                    this.drawPopupBubble(
                      context,
                      popupDrawCoords.origin.x,
                      popupDrawCoords.origin.y,
                      this.popupSize,
                      this.popupSize,
                      5,
                      popupDrawCoords.anchor.x,
                      popupDrawCoords.anchor.y,
                      popupBorderColor
                    );
                    let centerPopupOffset = (this.popupSize - this.popupImgSize) / 2;

                    if (showProgress === true && popupProgress === true) {
                      let perc = this.playerPopupProgressCalc(plyr, popup);
                      context.fillStyle = this.popupProgressImgGradColor2;
                      context.beginPath();
                      // context.roundRect(popupDrawCoords.origin.x,(popupDrawCoords.origin.y)+this.popupSize, this.popupSize, this.popupSize*perc, 5);
                      // context.stroke();
                      context.fillStyle = this.popupProgressImgGradColor1;
                      context.roundRect(
                        popupDrawCoords.origin.x,
                        popupDrawCoords.origin.y + this.popupSize,
                        10,
                        this.popupSize * perc,
                        5
                      );
                      context.fill();
                      // console.log("playerPopupProgress init", perc);
                    }

                    if (writeValue === true) {
                      context.font = "15px Arial";
                      context.fillStyle = "black";
                      context.fillText(
                        popup.msg.split("_")[1],
                        popupDrawCoords.origin.x +
                          (this.popupSize - popup.msg.split("_")[1].length * 7) / 2,
                        popupDrawCoords.origin.y + 15
                      );

                      centerPopupOffset = (this.popupSize - this.popupImgSize * 0.75) / 2;
                      context.drawImage(
                        popup.img,
                        popupDrawCoords.origin.x + centerPopupOffset,
                        popupDrawCoords.origin.y + (centerPopupOffset + 5),
                        this.popupImgSize * 0.75,
                        this.popupImgSize * 0.75
                      );
                    } else {
                      context.drawImage(
                        popup.img,
                        popupDrawCoords.origin.x + centerPopupOffset,
                        popupDrawCoords.origin.y + centerPopupOffset,
                        this.popupImgSize,
                        this.popupImgSize
                      );
                    }
                  } else if (popup.position !== "northWest") {
                    let dir = undefined;
                    let dirs = [];

                    let currentPopups = this.cellPopups.filter((x) => x.state === true);

                    // HAVE ANY OTHER PLAYERS OR OTHER PLAYERS' POPUPS MOVED TO INVALID POSITIONS SINCE POPUP'S 1ST DRAW
                    for (const plyr2 of this.players) {
                      if (plyr2.ai.state !== true && plyr2.number !== plyr.number) {
                        let myPos = plyr.currentPosition.cell.number;
                        let invalidPos =
                          this.players[plyr2.number - 1].currentPosition.cell.number;

                        dir = this.getDirectionFromCells(myPos, invalidPos);

                        if (dir) {
                          // console.log('player popups (set): human player position is close to player',plyr.number,' @ ',invalidPos,' dir ',dir);
                          dirs.push(dir);
                        }

                        for (const pop of plyr2.popups) {
                          dir = undefined;
                          let invalidPos2 = {
                            x: undefined,
                            y: undefined,
                          };

                          invalidPos2 = this.getCellFromDirection(
                            1,
                            invalidPos,
                            pop.position
                          );

                          dir = this.getDirectionFromCells(myPos, invalidPos2);

                          // if (dir && positions.includes(dir) === true) {
                          //   positions.splice(positions.indexOf(dir),1);
                          //   // console.log('dont draw over player @',dir,'choose frome these position',positions);
                          // }
                          if (dir) {
                            // console.log('player popups (set): human player popup position is close to player',plyr.number,' @ ',invalidPos2,' dir ',dir);
                            dirs.push(dir);
                          }
                        }
                      }
                    }

                    // HAVE ANY CELL POPUPS MOVED TO A NEARBY CELL TO ME
                    for (const popup2 of currentPopups) {
                      dir = undefined;

                      let myPos = plyr.currentPosition.cell.number;

                      let cellPos = popup2.cell.number;
                      let invalidPos2 = {
                        x: undefined,
                        y: undefined,
                      };

                      invalidPos2 = this.getCellFromDirection(
                        1,
                        cellPos,
                        popup2.position
                      );

                      dir = this.getDirectionFromCells(myPos, invalidPos2);

                      if (dir) {
                        // console.log('player popups (set): cell popup position is close to player',plyr.number,' @ ',invalidPos2,' dir ',dir);
                        dirs.push(dir);
                      }
                    }

                    // console.log('dirs',dirs,'popup.position',popup.position);
                    // if (popup.position === dir ) {
                    if (dirs.find((x) => x === popup.position)) {
                      plyr.popups.find((x) => x.msg === popup.msg).position = "";
                      plyr.popups.find((x) => x.msg === popup.msg).state = false;
                      // console.log("A new invalid direction === popup's position. reconsidering...",popup.msg);
                    } else {
                      let popupProgress = false;
                      let showProgress = false;
                      let writeValue = false;
                      if (
                        plyr.prePush.state === true ||
                        plyr.prePull.state === true ||
                        plyr.dodging.state === true ||
                        plyr.action === "dodging" ||
                        plyr.action === "defending" ||
                        plyr.action === "attacking" ||
                        plyr.attacking.state === true
                      ) {
                        showProgress = true;
                      }
                      if (
                        popup.msg === "attacking" ||
                        popup.msg === "attacking1" ||
                        popup.msg === "attacking2" ||
                        popup.msg === "defending" ||
                        popup.msg === "prePush" ||
                        popup.msg === "prePull" ||
                        popup.msg === "dodging" ||
                        popup.msg === "charging"
                      ) {
                        popupProgress = true;
                      }

                      if (popup.img === "") {
                        popup.img = this.popupImageRef[popup.msg];
                      }

                      if (popup.msg.split("_")) {
                        if (
                          popup.msg.split("_")[0] === "hpUp" ||
                          popup.msg.split("_")[0] === "hpDown"
                        ) {
                          writeValue = true;
                          popup.img = this.popupImageRef[popup.msg.split("_")[0]];
                        }
                      }

                      popupDrawCoords = this.popupDrawCalc(
                        popup.position,
                        { x: point.x - 25, y: point.y - 25 },
                        plyr.number
                      );
                      this.drawPopupBubble(
                        context,
                        popupDrawCoords.origin.x,
                        popupDrawCoords.origin.y,
                        this.popupSize,
                        this.popupSize,
                        5,
                        popupDrawCoords.anchor.x,
                        popupDrawCoords.anchor.y,
                        popupBorderColor
                      );
                      let centerPopupOffset = (this.popupSize - this.popupImgSize) / 2;

                      if (showProgress === true && popupProgress === true) {
                        let perc = this.playerPopupProgressCalc(plyr, popup);
                        context.fillStyle = this.popupProgressImgGradColor2;
                        context.beginPath();
                        // context.roundRect(popupDrawCoords.origin.x,(popupDrawCoords.origin.y)+this.popupSize, this.popupSize, this.popupSize*perc, 5);
                        // context.stroke();
                        context.fillStyle = this.popupProgressImgGradColor1;
                        context.roundRect(
                          popupDrawCoords.origin.x,
                          popupDrawCoords.origin.y + this.popupSize,
                          10,
                          this.popupSize * perc,
                          5
                        );
                        context.fill();
                        // console.log(
                        //   "playerPopupProgress continue",
                        //   perc,
                        //   this.popupSize * perc
                        // );
                      }

                      if (writeValue === true) {
                        context.font = "15px Arial";
                        context.fillStyle = "black";
                        context.fillText(
                          popup.msg.split("_")[1],
                          popupDrawCoords.origin.x +
                            (this.popupSize - popup.msg.split("_")[1].length * 7) / 2,
                          popupDrawCoords.origin.y + 15
                        );

                        centerPopupOffset =
                          (this.popupSize - this.popupImgSize * 0.75) / 2;
                        context.drawImage(
                          popup.img,
                          popupDrawCoords.origin.x + centerPopupOffset,
                          popupDrawCoords.origin.y + (centerPopupOffset + 5),
                          this.popupImgSize * 0.75,
                          this.popupImgSize * 0.75
                        );
                      } else {
                        if (player.action === "defending") {
                          if (player.defending.peak === true) {
                            popup.img = this.popupImageRef.defending_1;
                          }
                          if (player.defending.decay.state === true) {
                            let prog =
                              100 -
                              (player.defending.decay.count /
                                player.defending.decay.limit) *
                                100;
                            if (prog > 10) {
                              popup.img = this.popupImageRef.defending_4;
                            }
                            if (prog > 30) {
                              popup.img = this.popupImageRef.defending_3;
                            }
                            if (prog > 50) {
                              popup.img = this.popupImageRef.defending_2;
                            }
                            if (prog > 70) {
                              popup.img = this.popupImageRef.defending_1;
                            }
                          }
                        }
                        context.drawImage(
                          popup.img,
                          popupDrawCoords.origin.x + centerPopupOffset,
                          popupDrawCoords.origin.y + centerPopupOffset,
                          this.popupImgSize,
                          this.popupImgSize
                        );
                      }
                    }
                  }
                }
              }
            }
          }

          this.players[plyr.number - 1] = plyr;
        }

        // OBSTACLES & BARRIERS
        // FALLING
        // IN BOUNDS
        if (
          gridInfoCell.obstacle.state === true &&
          gridInfoCell.obstacle.moving.falling.state === true
        ) {
          let obstacleImg = this.obstacleImgs[gridInfoCell.obstacle.type];

          context.drawImage(
            obstacleImg,
            gridInfoCell.obstacle.moving.nextPosition.x,
            gridInfoCell.obstacle.moving.nextPosition.y
          );
          gridInfoCell.obstacle.moving.nextPosition.y += 2;

          // console.log('falling obstacle',gridInfoCell.obstacle.moving.nextPosition,'x/y',x,y);
        }
        // OUT OF BOUNDS
        for (const obstacle of this.obstaclesOutOfBoundsFall) {
          // here!! draw at origin cell x/y
          // if (x === 0 && y === 0) {
          if (
            x === obstacle.moving.origin.number.x &&
            y === obstacle.moving.origin.number.y
          ) {
            // console.log('obstacle falling out of bounds b count',obstacle.moving.origin.center,'position',obstacle.moving.nextPosition);
            let obstacleImg = this.obstacleImgs[obstacle.type];
            context.drawImage(
              obstacleImg,
              obstacle.moving.nextPosition.x,
              obstacle.moving.nextPosition.y
            );
            obstacle.moving.nextPosition = {
              x: obstacle.moving.nextPosition.x,
              y: obstacle.moving.nextPosition.y + 2,
              // y: obstacle.moving.nextPosition.y+obstacle.moving.falling.count*5
            };
          }
        }

        // STATIONARY
        if (
          gridInfoCell.obstacle.state === true &&
          gridInfoCell.void.state !== true &&
          gridInfoCell.terrain.type !== "deep" &&
          gridInfoCell.obstacle.moving.falling.state !== true
        ) {
          let hide = false;

          if (this.obstacleBarrierToDestroy.length > 0) {
            for (const cell of this.obstacleBarrierToDestroy) {
              if (
                cell.type === "obstacle" &&
                gridInfoCell.number.x === cell.cell.number.x &&
                gridInfoCell.number.y === cell.cell.number.y &&
                gridInfoCell.obstacle.name === cell.cell.obstacle.name
              ) {
                hide = true;
              }
            }
          }

          if (this.halfPushBackObstacles.length > 0) {
            let obstacleImg = this.obstacleImgs[gridInfoCell.obstacle.type];

            for (const obs of this.halfPushBackObstacles) {
              if (
                obs.myCellNo.x === gridInfoCell.number.x &&
                obs.myCellNo.y === gridInfoCell.number.y
              ) {
                if (obs.state === true) {
                  if (obs.countUp.state === true) {
                    hide = true;
                  }
                }
              }
            }
          }

          if (hide !== true) {
            let obstacleImg = this.obstacleImgs[gridInfoCell.obstacle.type];

            if (gridInfoCell.obstacle.moving.state !== true) {
              context.drawImage(
                obstacleImg,
                iso.x - offset.x,
                iso.y - obstacleImg.height
              );
            } else {
              // console.log('x/y',x,y);
              // context.drawImage(obstacleImg, gridInfoCell.obstacle.moving.nextPosition.x-offset.x, gridInfoCell.obstacle.moving.nextPosition.y- Math.ceil(obstacleImg.height/2));
            }
          }
        }

        // MOVING
        for (const cell of this.gridInfo) {
          if (cell.obstacle.state === true && cell.obstacle.moving.state === true) {
            let drawHere = {
              x: cell.obstacle.moving.origin.number.x,
              y: cell.obstacle.moving.origin.number.y,
            };
            let direction = undefined;
            if (
              cell.obstacle.moving.destination.number.y ===
              cell.obstacle.moving.origin.number.y + 1
            ) {
              direction = "south";
            }
            if (
              cell.obstacle.moving.destination.number.y ===
              cell.obstacle.moving.origin.number.y - 1
            ) {
              direction = "north";
            }
            if (
              cell.obstacle.moving.destination.number.x ===
              cell.obstacle.moving.origin.number.x - 1
            ) {
              direction = "west";
            }
            if (
              cell.obstacle.moving.destination.number.x ===
              cell.obstacle.moving.origin.number.x + 1
            ) {
              direction = "east";
            }

            if (
              cell.obstacle.moving.destination.number.x !== null &&
              cell.obstacle.moving.destination.number.x > -1 &&
              cell.obstacle.moving.destination.number.x < this.gridWidth + 1
            ) {
              if (direction === "south" || direction === "east") {
                drawHere = cell.obstacle.moving.destination.number;
              }
            }

            if (x === drawHere.x && y === drawHere.y) {
              // console.log('x/y',x,y,direction,cell.obstacle.moving.step);

              let obstacleImg = this.obstacleImgs[cell.obstacle.type];
              context.drawImage(
                obstacleImg,
                cell.obstacle.moving.nextPosition.x - offset.x,
                cell.obstacle.moving.nextPosition.y -
                  Math.ceil(obstacleImg.height / 2, 30, 30)
              );
            }

            // console.log('falling obstacle',gridInfoCell.obstacle.moving.nextPosition,'x/y',x,y);
          }
        }
        // HALFPUSHBACK
        if (this.halfPushBackObstacles.length > 0) {
          let drawCell;
          for (const obs of this.halfPushBackObstacles) {
            // if (obs.state === true) {
            //   if (obs.countUp.state === true) {
            //     if (obs.countUp.count === 1 && !obs.coords.x && !obs.coords.y) {
            //       obs.coords = {
            //         x: (iso.x - offset.x),
            //         y: (iso.y - (obstacleImg.height)),
            //       }
            //       drawCell = this.calcElasticCountCoords('halfPushBack','obstacle',obs).drawCell;
            //       console.log('drawCell1',drawCell);
            //       if (x === drawCell.x && y === drawCell.y) {
            //           context.drawImage(obstacleImg, obs.coords.x, obs.coords.y);
            //       }
            //
            //     }
            //     else {
            //
            //       obs.coords = this.calcElasticCountCoords('halfPushBack','obstacle',obs).coords;
            //       drawCell = this.calcElasticCountCoords('halfPushBack','obstacle',obs).drawCell;
            //       console.log('drawCell2',drawCell);
            //       if (x === drawCell.x && y === drawCell.y) {
            //           context.drawImage(obstacleImg, obs.coords.x, obs.coords.y);
            //       }
            //     }
            //   }
            // }
            if (
              obs.myCellNo.x === gridInfoCell.number.x &&
              obs.myCellNo.y === gridInfoCell.number.y &&
              gridInfoCell.obstacle.type
            ) {
              if (obs.state === true) {
                if (obs.countUp.state === true) {
                  let obstacleImg = this.obstacleImgs[gridInfoCell.obstacle.type];
                  if (obs.countUp.count === 1 && !obs.coords.x && !obs.coords.y) {
                    obs.coords = {
                      x: iso.x - offset.x,
                      y: iso.y - obstacleImg.height,
                    };
                    context.drawImage(obstacleImg, obs.coords.x, obs.coords.y);
                  } else {
                    obs.coords = this.calcElasticCountCoords(
                      "halfPushBack",
                      "obstacle",
                      obs
                    ).coords;
                    context.drawImage(obstacleImg, obs.coords.x, obs.coords.y);
                  }
                }
              }
            }
          }
        }

        // DROP ITEMS & DAMAGE/DESTROY OBSTACLES & BARRIERS
        for (const cell of this.obstacleBarrierToDestroy) {
          if (
            gridInfoCell.number.x === cell.cell.number.x &&
            gridInfoCell.number.y === cell.cell.number.y
          ) {
            // if (gridInfoCell.number.x === cell.cell.number.x && gridInfoCell.number.y === cell.cell.number.y && (cell.cell.obstacle.type || cell.cell.barrier.type)) {
            if (cell.count % 3 === 0) {
              if (cell.type === "obstacle" && cell.cell.obstacle.type) {
                let obstacleImg = this.obstacleImgs[cell.cell.obstacle.type];
                context.drawImage(
                  obstacleImg,
                  iso.x - offset.x,
                  iso.y - obstacleImg.height
                );
              }
              if (cell.type === "barrier" && cell.cell.barrier.type) {
                let barrierImg =
                  this.barrierImgs[cell.cell.barrier.type][cell.cell.barrier.position];
                context.drawImage(
                  barrierImg,
                  iso.x - offset.x,
                  iso.y - barrierImg.height,
                  barrierImg.width,
                  barrierImg.height
                );
              }
            }
          }
        }
        for (const cell of this.obstacleItemsToDrop) {
          // console.log('obstacleItemsToDrop',cell);
          if (
            gridInfoCell.number.x === cell.target.x &&
            gridInfoCell.number.y === cell.target.y
          ) {
            if (cell.count % 3 === 0) {
              let itemImg;
              if (cell.item.type === "item") {
                itemImg = this.itemImgs[cell.item.name];
              }
              if (cell.item.type === "weapon" || cell.item.type === "armor") {
                itemImg = this.itemImgs[cell.item.subType];
              }
              context.drawImage(itemImg, center.x - 15, center.y - 15);
            }
          }
        }

        // STATIONARY BARRIERS
        if (gridInfoCell.barrier.state === true && gridInfoCell.void.state !== true) {
          let hide = false;

          if (this.obstacleBarrierToDestroy.length > 0) {
            for (const cell of this.obstacleBarrierToDestroy) {
              if (
                cell.type === "barrier" &&
                gridInfoCell.number.x === cell.cell.number.x &&
                gridInfoCell.number.y === cell.cell.number.y &&
                gridInfoCell.barrier.name === cell.cell.barrier.name
              ) {
                hide = true;
              }
            }
          }

          if (hide !== true) {
            let barrierImg =
              this.barrierImgs[gridInfoCell.barrier.type][gridInfoCell.barrier.position];
            context.drawImage(
              barrierImg,
              iso.x - offset.x,
              iso.y - barrierImg.height,
              barrierImg.width,
              barrierImg.height
            );
          }
        }

        // PROJECTILES
        for (const bolt of this.projectiles) {
          if (
            bolt.currentPosition.number.x === x &&
            bolt.currentPosition.number.y === y
          ) {
            let boltImg;
            switch (bolt.direction) {
              case "north":
                boltImg = this.boltImgs[bolt.direction];
                break;
              case "south":
                boltImg = this.boltImgs[bolt.direction];
                break;
              case "east":
                boltImg = this.boltImgs[bolt.direction];
                break;
              case "west":
                boltImg = this.boltImgs[bolt.direction];
                break;
            }
            // console.log("dd", boltImg, bolt.direction);

            // context2.fillStyle = "black";
            // context2.fillRect(bolt.currentPosition.center.x, bolt.currentPosition.center.y,10,5);
            // this.testDraw.push({color:'green',x:bolt.currentPosition.center.x,y:bolt.currentPosition.center.y})
            context.drawImage(
              boltImg,
              bolt.currentPosition.center.x - 15,
              bolt.currentPosition.center.y - 15,
              35,
              35
            );
          }
        }

        // CAMERA FOCUS POINT
        if (x === this.gridWidth && y === this.gridWidth) {
          // console.log('Camera centered');
          context.fillStyle = "yellow";
          context.beginPath();
          context.arc(this.camera.focus.x, this.camera.focus.y, 10, 0, 2 * Math.PI);
          // context.arc(this.camera.zoomFocusPan.x, this.camera.zoomFocusPan.y, 10, 0, 2 * Math.PI);
          context.fill();
        }

        // TEST DRAW
        for (const point of this.testDraw) {
          context.fillStyle = point.color;
          context.beginPath();
          context.arc(point.x, point.y, 5, 0, 2 * Math.PI);
          context.fill();
        }
      }
    }

    this.players[player.number - 1] = player;

    // if (player.ai.state === true ) {
    //   this.aiEvaluate(player)
    // }
  };

  startProcessLevelData = (canvas) => {
    // console.log('startProcessLevelData',this.gridWidth);

    let gridInfo = [];
    let settingsGridInfo = [];

    canvas.width = this.canvasWidth;
    canvas.height = this.canvasHeight;

    let floorImageWidth = this.floorImageWidth;
    let floorImageHeight = this.floorImageHeight;
    let wallImageWidth = this.wallImageWidth;
    let wallImageHeight = this.wallImageHeight;
    let sceneX = this.canvasWidth / 2;
    let sceneY = this.sceneY;
    let tileWidth = this.tileWidth;

    class Point {
      constructor(x, y) {
        this.x = x;
        this.y = y;
      }
    }

    for (var x = 0; x < this.gridWidth + 1; x++) {
      for (var y = 0; y < this.gridWidth + 1; y++) {
        let p = new Point();
        p.x = x * tileWidth;
        p.y = y * tileWidth;

        let iso = this.cartesianToIsometric(p);
        let offset = { x: floorImageWidth / 2, y: floorImageHeight };

        // apply offset to center scene for a better view
        iso.x += sceneX;
        iso.y += sceneY;

        let center = {
          x: Math.round(iso.x - offset.x / 2 + this.cellCenterOffsetX),
          y: Math.round(iso.y - offset.y / 2 - this.cellCenterOffsetY),
        };

        gridInfo.push({
          number: { x: x, y: y },
          center: { x: center.x, y: center.y },
          drawCenter: { x: center.x, y: center.y },
          vertices: [
            { x: center.x, y: center.y + this.tileWidth / 2 },
            { x: center.x + this.tileWidth, y: center.y },
            { x: center.x, y: center.y - this.tileWidth / 2 },
            { x: center.x - this.tileWidth, y: center.y },
          ],
          side: Math.sqrt((this.tileWidth / 2) ^ (2 + this.tileWidth) ^ 2),
          levelData: "",
          edge: {
            state: false,
            side: "",
          },
          terrain: {
            name: "",
            type: "",
            effect: "",
          },
          item: {
            name: "",
            type: "",
            subType: "",
            effect: "",
            initDrawn: false,
          },
          void: {
            state: false,
          },
          obstacle: {
            id: 0,
            trap: {},
            state: false,
            name: "",
            type: "",
            hp: 2,
            destructible: {
              state: false,
              weapons: [],
              leaveRubble: false,
            },
            locked: {
              state: false,
              key: "",
            },
            weight: 1,
            height: 0.5,
            items: [],
            effects: [],
            moving: {
              state: false,
              step: 0,
              origin: {
                number: { x: x, y: y },
                center: { x: center.x, y: center.y },
              },
              destination: {
                number: {
                  x: undefined,
                  y: undefined,
                },
                center: {
                  x: undefined,
                  y: undefined,
                },
              },
              currentPosition: {
                x: undefined,
                y: undefined,
              },
              nextPosition: {
                x: undefined,
                y: undefined,
              },
              moveSpeed: 0,
              pushable: true,
              pushed: false,
              pusher: undefined,
              falling: {
                state: false,
                count: 0,
                limit: 10,
              },
            },
          },
          barrier: {
            id: 0,
            trap: {},
            state: false,
            name: "",
            type: "",
            hp: 2,
            destructible: {
              state: false,
              weapons: [],
              leaveRubble: false,
            },
            locked: {
              state: false,
              key: "",
            },
            position: "",
            height: 1,
          },
          elevation: {
            number: 0,
            type: "",
            position: "",
          },
          rubble: false,
        });
      }
    }

    for (var x = 0; x < this.settingsGridWidth + 1; x++) {
      for (var y = 0; y < this.settingsGridWidth + 1; y++) {
        let p2 = new Point();
        p2.x = (x * tileWidth) / 2;
        p2.y = (y * tileWidth) / 2;

        let iso2 = this.cartesianToIsometric(p2);
        let offset2 = { x: floorImageWidth / 2 / 2, y: floorImageHeight / 2 };

        // apply offset to center scene for a better view

        iso2.x += this.settingsSceneX;
        iso2.y += this.settingsSceneY;

        let center2 = {
          x: Math.round(iso2.x - offset2.x / 2 + this.cellCenterOffsetX / 2),
          y: Math.round(iso2.y - offset2.y / 2 - this.cellCenterOffsetY / 2),
        };

        settingsGridInfo.push({
          number: { x: x, y: y },
          center: { x: center2.x, y: center2.y },
          drawCenter: { x: center2.x, y: center2.y },
          vertices: [
            { x: center2.x, y: center2.y + this.tileWidth / 4 },
            { x: center2.x + this.tileWidth / 2, y: center2.y },
            { x: center2.x, y: center2.y - this.tileWidth / 4 },
            { x: center2.x - this.tileWidth / 2, y: center2.y },
          ],
          side: Math.sqrt((this.tileWidth / 2 / 2) ^ (2 + this.tileWidth / 2) ^ 2),
          levelData: "",
          edge: {
            state: false,
            side: "",
          },
          terrain: {
            name: "",
            type: "",
            effect: "",
          },
          item: {
            name: "",
            type: "",
            subType: "",
            effect: "",
            initDrawn: false,
          },
          void: {
            state: false,
          },
          obstacle: {
            id: 0,
            trap: {},
            state: false,
            name: "",
            type: "",
            hp: 2,
            destructible: {
              state: false,
              weapons: [],
              leaveRubble: false,
            },
            locked: {
              state: false,
              key: "",
            },
            weight: 1,
            height: 0.5,
            items: [],
            effects: [],
            moving: {
              state: false,
              step: 0,
              origin: {
                number: { x: x, y: y },
                center: { x: center2.x, y: center2.y },
              },
              destination: {
                number: {
                  x: undefined,
                  y: undefined,
                },
                center: {
                  x: undefined,
                  y: undefined,
                },
              },
              currentPosition: {
                x: undefined,
                y: undefined,
              },
              nextPosition: {
                x: undefined,
                y: undefined,
              },
              moveSpeed: 0,
              pushable: true,
              pushed: false,
              pusher: undefined,
              falling: {
                state: false,
                count: 0,
                limit: 10,
              },
            },
          },
          barrier: {
            id: 0,
            trap: {},
            state: false,
            name: "",
            type: "",
            hp: 2,
            destructible: {
              state: false,
              weapons: [],
              leaveRubble: false,
            },
            locked: {
              state: false,
              key: "",
            },
            position: "",
            height: 1,
          },
          elevation: {
            number: 0,
            type: "",
            position: "",
          },
          rubble: false,
        });
      }
    }

    this.settingsGridInfo = settingsGridInfo;
    this.gridInfo = gridInfo;
  };
  processLevelData = (allCells) => {
    // console.log('processing level data','grid width',this.gridWidth);

    let obstacleCount = 0;
    let barrierCount = 0;
    // let temp;
    let trap;
    let barrierDir;
    for (let elem of allCells) {
      // APPLY LEVEL DATA TO GRID INFO CELLS!
      let levelData2Row = "row" + elem.number.x;
      let elemLevelData =
        this["levelData" + this.gridWidth][levelData2Row][elem.number.y];

      if (
        (elemLevelData.split("_")[1] !== "*" &&
          this.terrainLevelDataRef[elemLevelData.split("_")[3]].type === "deep") ||
        (elemLevelData.split("_")[1] !== "*" &&
          this.terrainLevelDataRef[elemLevelData.split("_")[3]].type === "void")
      ) {
        elemLevelData = elemLevelData.replaceAt(3, "*");
      }
      elem.levelData = elemLevelData;
      // console.log('level data processing',elem.levelData);

      // '**_*_0.0_a_0**'
      // barrierType(a,b,c)BarrierPosition(n,s,e,w)_obstacle_x.y_terrain_elevationNumber(0,1,2)ElevationType(a,b,c)ElevationPosition(n,s,e,w)

      elem.terrain = this.terrainLevelDataRef[elem.levelData.split("_")[3]];
      if (elem.terrain.name === "void") {
        elem.void.state = true;
      }

      elem.elevation.number = parseInt(elem.levelData.split("_")[4].charAt(0));
      if (elem.levelData.split("_")[4].charAt(1) !== "*") {
        elem.elevation.type =
          this.elevationTypeLevelDataRef[elem.levelData.split("_")[4].charAt(1)];
      }

      if (elem.levelData.split("_")[4].charAt(1) !== "*") {
        switch (elem.levelData.split("_")[4].charAt(2)) {
          case "n":
            elem.elevation = {
              number: elem.elevation.number,
              type: elem.elevation.type,
              position: "north",
            };
            break;
          case "s":
            elem.elevation = {
              number: elem.elevation.number,
              type: elem.elevation.type,
              position: "south",
            };
            break;
          case "e":
            elem.elevation = {
              number: elem.elevation.number,
              type: elem.elevation.type,
              position: "east",
            };
            break;
          case "w":
            elem.elevation = {
              number: elem.elevation.number,
              type: elem.elevation.type,
              position: "west",
            };
            break;
          default:
            break;
        }
      }

      // OBSTACLE
      if (elem.levelData.split("_")[1] !== "*") {
        elem.obstacle = JSON.parse(
          JSON.stringify(this.obstacleLevelDataRef[elem.levelData.split("_")[1]])
        );
        elem.obstacle.id = obstacleCount;
        elem.obstacle.moving.origin = {
          number: elem.number,
          center: elem.center,
        };
        elem.obstacle.trap = this.obstacleBarrierTrapInitSet("main", "obstacle", elem);
        obstacleCount++;
      }

      // BARRIER
      if (elem.levelData.split("_")[0] !== "**") {
        elem.barrier = JSON.parse(
          JSON.stringify(this.barrierLevelDataRef[elem.levelData.split("_")[0].charAt(0)])
        );
        elem.barrier.id = barrierCount;
        switch (elem.levelData.split("_")[0].charAt(1)) {
          case "n":
            elem.barrier = {
              id: elem.barrier.id,
              trap: elem.barrier.trap,
              state: elem.barrier.state,
              name: elem.barrier.name,
              type: elem.barrier.type,
              hp: elem.barrier.hp,
              destructible: elem.barrier.destructible,
              locked: elem.barrier.locked,
              position: "north",
              height: elem.barrier.height,
            };
            break;
          case "s":
            elem.barrier = {
              id: elem.barrier.id,
              trap: elem.barrier.trap,
              state: elem.barrier.state,
              name: elem.barrier.name,
              type: elem.barrier.type,
              hp: elem.barrier.hp,
              destructible: elem.barrier.destructible,
              locked: elem.barrier.locked,
              position: "south",
              height: elem.barrier.height,
            };
            break;
          case "e":
            elem.barrier = {
              id: elem.barrier.id,
              trap: elem.barrier.trap,
              state: elem.barrier.state,
              name: elem.barrier.name,
              type: elem.barrier.type,
              hp: elem.barrier.hp,
              destructible: elem.barrier.destructible,
              locked: elem.barrier.locked,
              position: "east",
              height: elem.barrier.height,
            };
            break;
          case "w":
            elem.barrier = {
              id: elem.barrier.id,
              trap: elem.barrier.trap,
              state: elem.barrier.state,
              name: elem.barrier.name,
              type: elem.barrier.type,
              hp: elem.barrier.hp,
              destructible: elem.barrier.destructible,
              locked: elem.barrier.locked,
              position: "west",
              height: elem.barrier.height,
            };
            break;
          default:
            break;
        }
        elem.barrier.trap = this.obstacleBarrierTrapInitSet("main", "barrier", elem);
        barrierCount++;
      }

      // console.log('oo2',elem.levelData,elem.number,elem.terrain);

      // SET EDGES!
      if (elem.number.x === 0) {
        elem.edge = {
          state: true,
          side: "west",
        };
      }
      if (elem.number.x === this.gridWidth) {
        elem.edge = {
          state: true,
          side: "east",
        };
      }
      if (elem.number.y === this.gridWidth) {
        elem.edge = {
          state: true,
          side: "south",
        };
      }
      if (elem.number.y === 0) {
        elem.edge = {
          state: true,
          side: "north",
        };
      }
    }

    obstacleCount = 0;
    barrierCount = 0;
    for (const elem2 of this.settingsGridInfo) {
      // SET LEVEL DATA!
      let levelData2Row = "row" + elem2.number.x;
      let elemLevelData =
        this["levelData" + this.settingsGridWidth][levelData2Row][elem2.number.y];
      if (
        (elemLevelData.split("_")[1] !== "*" &&
          this.terrainLevelDataRef[elemLevelData.split("_")[3]].type === "deep") ||
        (elemLevelData.split("_")[1] !== "*" &&
          this.terrainLevelDataRef[elemLevelData.split("_")[3]].type === "void")
      ) {
        elemLevelData = elemLevelData.replaceAt(3, "*");
      }
      elem2.levelData = elemLevelData;

      // TERRAIN
      elem2.terrain = this.terrainLevelDataRef[elem2.levelData.split("_")[3]];
      if (elem2.terrain.name === "void") {
        elem2.void.state = true;
      }

      // ELEVATION NUMBER
      elem2.elevation.number = parseInt(elem2.levelData.split("_")[4].charAt(0));
      if (elem2.levelData.split("_")[4].charAt(1) !== "*") {
        elem2.elevation.type =
          this.elevationTypeLevelDataRef[elem2.levelData.split("_")[4].charAt(1)];
      }

      // ELEVATION POSITION
      if (elem2.levelData.split("_")[4].charAt(1) !== "*") {
        switch (elem2.levelData.split("_")[4].charAt(2)) {
          case "n":
            elem2.elevation = {
              number: elem2.elevation.number,
              type: elem2.elevation.type,
              position: "north",
            };
            break;
          case "s":
            elem2.elevation = {
              number: elem2.elevation.number,
              type: elem2.elevation.type,
              position: "south",
            };
            break;
          case "e":
            elem2.elevation = {
              number: elem2.elevation.number,
              type: elem2.elevation.type,
              position: "east",
            };
            break;
          case "w":
            elem2.elevation = {
              number: elem2.elevation.number,
              type: elem2.elevation.type,
              position: "west",
            };
            break;
          default:
        }
      }

      // OBSTACLE
      if (elem2.levelData.split("_")[1] !== "*") {
        elem2.obstacle = JSON.parse(
          JSON.stringify(this.obstacleLevelDataRef[elem2.levelData.split("_")[1]])
        );
        elem2.obstacle.id = obstacleCount;
        elem2.obstacle.moving.origin = {
          number: elem2.number,
          center: elem2.center,
        };
        elem2.obstacle.trap = this.obstacleBarrierTrapInitSet("main", "obstacle", elem2);
        obstacleCount++;
      }

      // BARRIER
      if (elem2.levelData.split("_")[0] !== "**") {
        elem2.barrier = JSON.parse(
          JSON.stringify(
            this.barrierLevelDataRef[elem2.levelData.split("_")[0].charAt(0)]
          )
        );
        elem2.barrier.id = barrierCount;
        switch (elem2.levelData.split("_")[0].charAt(1)) {
          case "n":
            elem2.barrier = {
              id: elem2.barrier.id,
              trap: elem2.barrier.trap,
              state: elem2.barrier.state,
              name: elem2.barrier.name,
              type: elem2.barrier.type,
              hp: elem2.barrier.hp,
              destructible: elem2.barrier.destructible,
              locked: elem2.barrier.locked,
              position: "north",
              height: elem2.barrier.height,
            };
            break;
          case "s":
            elem2.barrier = {
              id: elem2.barrier.id,
              trap: elem2.barrier.trap,
              state: elem2.barrier.state,
              name: elem2.barrier.name,
              type: elem2.barrier.type,
              hp: elem2.barrier.hp,
              destructible: elem2.barrier.destructible,
              locked: elem2.barrier.locked,
              position: "south",
              height: elem2.barrier.height,
            };
            break;
          case "e":
            elem2.barrier = {
              id: elem2.barrier.id,
              trap: elem2.barrier.trap,
              state: elem2.barrier.state,
              name: elem2.barrier.name,
              type: elem2.barrier.type,
              hp: elem2.barrier.hp,
              destructible: elem2.barrier.destructible,
              locked: elem2.barrier.locked,
              position: "east",
              height: elem2.barrier.height,
            };
            break;
          case "w":
            elem2.barrier = {
              id: elem2.barrier.id,
              trap: elem2.barrier.trap,
              state: elem2.barrier.state,
              name: elem2.barrier.name,
              type: elem2.barrier.type,
              hp: elem2.barrier.hp,
              destructible: elem2.barrier.destructible,
              locked: elem2.barrier.locked,
              position: "west",
              height: elem2.barrier.height,
            };
            break;
          default:
            break;
        }
        elem2.barrier.trap = this.obstacleBarrierTrapInitSet("main", "barrier", elem2);
        barrierCount++;
      }

      // console.log('oo2',elem2.levelData,elem2.number,elem2.terrain);

      // SET EDGES!
      if (elem2.number.x === 0) {
        elem2.edge = {
          state: true,
          side: "west",
        };
      }
      if (elem2.number.x === this.settingsGridWidth) {
        elem2.edge = {
          state: true,
          side: "east",
        };
      }
      if (elem2.number.y === this.settingsGridWidth) {
        elem2.edge = {
          state: true,
          side: "south",
        };
      }
      if (elem2.number.y === 0) {
        elem2.edge = {
          state: true,
          side: "north",
        };
      }
    }

    // gridInfo to 2D array
    let gridInfo2d = [];
    for (let i = 0; i <= this.gridWidth; i++) {
      // for (let i = 9; i >= 0; i--) {
      let newArray = [];
      for (var j = 0; j < allCells.length; j++) {
        if (allCells[j]["number"].x === i) {
          newArray.push(allCells[j]);
        }
      }
      gridInfo2d.push(newArray);
    }

    this.gridInfo2D = gridInfo2d;
    // console.log('gridInfo2d',this.gridInfo2D);
    this.gridInfo = allCells;

    // this.settingsFormAiGridInfo = this.gridInfo;
    // console.log('post parse gridInfo',this.gridInfo);

    // console.log('yyy',allCells.filter(x => x.barrier.state === true).map(y => y = y.barrier.position));
    // console.log('yyy2',this.settingsGridInfo.filter(x => x.barrier.state === true).map(y => y = y.barrier.position));

    this.updatePathArray();
  };
  drawGridInit = (canvas, context, canvas2, context2) => {
    // console.log('drawing initial');

    context.clearRect(0, 0, this.canvasWidth, this.canvasHeight);
    context2.clearRect(0, 0, this.canvasWidth, this.canvasHeight);

    let gridInfo = [];
    class Point {
      constructor(x, y) {
        this.x = x;
        this.y = y;
      }
    }

    this.popupImageRef = {
      attackStart: this.preAttackIndicateRef.current,
      preAction1: this.preAction1IndicateRef.current,
      preAction2: this.preAction2IndicateRef.current,
      attacking: this.attack3IndicateRef.current,
      attacking1: this.attack1IndicateRef.current,
      attacking2: this.attack2IndicateRef.current,
      missedAttack: this.missedIndicateRef.current,
      attackingBlunt: this.attackBluntIndicate2Ref.current,
      attackingUnarmed: this.attackUnarmedIndicateRef.current,
      attacked1: this.attack1IndicateRef.current,
      attacked2: this.attack2IndicateRef.current,
      attackDefended: this.attackBreakIndicateRef.current,
      attackParried: this.attackParriedIndicateRef.current,
      boltKilled: this.boltKilledIndicateRef.current,
      attackCancelled: this.attackBreakIndicateRef.current,
      injured: this.deflectInjuredIndicateRef.current,
      hpDown: this.deflectInjuredIndicate2Ref.current,
      hpUp: this.healIndicateRef.current,
      defending: this.defendIndicateRef.current,
      defending_1: this.defendIndicate1Ref.current,
      defending_2: this.defendIndicate2Ref.current,
      defending_3: this.defendIndicate3Ref.current,
      defending_4: this.defendIndicate4Ref.current,
      defendSuccess: this.defendSuccessIndicateRef.current,
      guardBroken: this.defendBreakIndicateRef.current,
      deflected: this.deflectBluntIndicateRef.current,
      dodgeStart: this.preAction2IndicateRef.current,
      dodgeSuccess: this.dodgeIndicateRef.current,
      dodging: this.dodgeIndicateRef.current,
      flanking: this.flankIndicateRef.current,
      pushedBack: this.pushbackIndicateRef.current,
      falling: this.fallingIndicateRef.current,
      outOfStamina: this.outOfStaminaIndicateRef.current,
      outOfAmmo: this.outOfAmmoIndicateRef.current,
      missionEngage: this.deflectIndicate2Ref.current,
      missionPursue: this.pursueMissionIndicate2Ref.current,
      missionRetrieve: this.retrieveMissionIndicateRef.current,
      missionDefend: this.defendMissionIndicateRef.current,
      missionPatrol: this.patrolMissionIndicateRef.current,
      missionRetreat: this.retreatIndicateRef.current,
      missionEnroute: this.enrouteIndicateRef.current,
      missionComplete: this.completeMissionIndicateRef.current,
      thinking: this.thinkingIndicateRef.current,
      alarmed: this.preAttack2IndicateRef.current,
      pathSwitch: this.pathSwitchIndicateRef.current,
      targetSwitch: this.targetSwitchIndicateRef.current,
      aggressiveMode: this.aggressiveModeIndicateRef.current,
      passiveMode: this.passiveModeIndicateRef.current,
      pickupWeapon: this.pickupWeaponIndicateRef.current,
      pickupArmor: this.pickupArmorIndicateRef.current,
      dropWeapon: this.dropWeaponIndicateRef.current,
      dropArmor: this.dropArmorIndicateRef.current,
      pickupBuff: this.pickupBuffIndicateRef.current,
      pickupDebuff: this.pickupDebuffIndicateRef.current,
      pickupAmmo: this.pickupAmmoIndicateRef.current,
      inventoryFull: this.inventoryFullIndicateRef.current,
      stop: this.boltDefendIndicateRef.current,
      dropWeapon: this.dropWeaponIndicateRef.current,
      dropArmor: this.dropArmorIndicateRef.current,
      drowning: this.drowningIndicateRef.current,
      terrainSlowdown: this.terrainSlowdownIndicateRef.current,
      terrainSpeedup: this.terrainSpeedupIndicateRef.current,
      terrainInjured: this.terrainInjuredIndicateRef.current,
      destroyedItem: this.destroyedItemIndicateRef.current,
      sword: this.itemSwordRef.current,
      spear: this.itemSpearRef.current,
      crossbow: this.itemCrossbowRef.current,
      longbow: this.itemBowRef.current,
      helmet: this.itemHelmet1Ref.current,
      mail: this.itemMail1Ref.current,
      greaves: this.itemGreaves1Ref.current,

      missedAttack2: this.missedIndicate2Ref.current,
      prePush: this.prePushIndicateRef.current,
      canPush: this.canPushIndicateRef.current,
      noPush: this.noPushingIndicateRef.current,
      pushing: this.pushingIndicateRef.current,
      prePull: this.prePullIndicateRef.current,
      canPull: this.canPullIndicateRef.current,
      noPull: this.noPullingIndicateRef.current,
      pulling: this.pullingIndicateRef.current,
      pushedPulled: this.pushedPulledIndicateRef.current,
      unbreakable: this.unbreakableIndicateRef.current,
      dodging2: this.dodgeIndicate2Ref.current,
      attackFeint: this.attackFeintIndicateRef.current,
      attackFeint2: this.attackFeintIndicate2Ref.current,
      attackFeint3: this.attackFeintIndicate3Ref.current,
      defendFeint: this.defendFeintIndicateRef.current,
      defendFeint2: this.defendFeintIndicate2Ref.current,
      defendFeint3: this.defendFeintIndicate3Ref.current,
      dodgeFeint: this.dodgeFeintIndicateRef.current,
      dodgeFeint2: this.dodgeFeintIndicate2Ref.current,
      boltDefend2: this.boltDefendIndicate2Ref.current,
      flanking2: this.flankIndicate2Ref.current,
      noFlanking: this.noFlankIndicateRef.current,
      cellVoiding: this.cellVoidingIndicateRef.current,
      cellVoiding2: this.cellVoidingIndicate2Ref.current,
      clashing: this.deflectIndicate2Ref.current,
      timer: this.timerIndicateRef.current,
      charging: this.chargeIndicateRef.current,
    };
    this.indicatorImgs = {
      preAttack: this.preAttackIndicateRef.current,
      preAttack2: this.preAttack2IndicateRef.current,
      attack1: this.attack1IndicateRef.current,
      attack2: this.attack2IndicateRef.current,
      attack3: this.attack3IndicateRef.current,
      attackUnarmed: this.attackUnarmedIndicateRef.current,
      attackBlunt: this.attackBluntIndicateRef.current,
      attackSuccess: this.attackSuccessIndicateRef.current,
      defend: this.defendIndicateRef.current,
      deflect: this.deflectIndicateRef.current,
      deflectInjured: this.deflectInjuredIndicateRef.current,
      deflectBlunt: this.deflectBluntIndicateRef.current,
      pushback: this.pushbackIndicateRef.current,
      ghost: this.ghostIndicateRef.current,
      death: this.deathIndicateRef.current,
      attackBreak: this.attackBreakIndicateRef.current,
      defendBreak: this.defendBreakIndicateRef.current,
      dodge: this.dodgeIndicateRef.current,
    };
    this.playerImgs = [
      {
        idle: {
          unarmed: this.idleSheetNew2Ref.current,
          sword: this.idleSheetNew2Ref.current,
          spear: this.idleSheetNew2Ref.current,
          crossbow: this.idleSheetNew2Ref.current,
        },
        walking: {
          unarmed: this.moveSheetNewRef.current,
          sword: this.moveSheetNewRef.current,
          spear: this.moveSheetNewRef.current,
          crossbow: this.moveSheetNewRef.current,
        },
        jumping: {
          unarmed: this.moveSheetNewRef.current,
          sword: this.moveSheetNewRef.current,
          spear: this.moveSheetNewRef.current,
          crossbow: this.moveSheetNewRef.current,
        },
        dodging: {
          unarmed: this.dodgeSheetNewRef.current,
          sword: this.dodgeSheetNewRef.current,
          spear: this.dodgeSheetNewRef.current,
          crossbow: this.dodgeSheetNewRef.current,
        },
        flanking: {
          unarmed: this.moveSheetNewRef.current,
          sword: this.moveSheetNewRef.current,
          spear: this.moveSheetNewRef.current,
          crossbow: this.moveSheetNewRef.current,
        },
        strafing: {
          unarmed: this.moveSheetNewRef.current,
          sword: this.moveSheetNewRef.current,
          spear: this.moveSheetNewRef.current,
          crossbow: this.moveSheetNewRef.current,
        },
        attacking: {
          unarmed: this.attackSheetNewRef.current,
          sword: this.attackSheetNewRef.current,
          spear: this.attackSheetNewRef.current,
          crossbow: this.attackSheetNewRef.current,
        },
        defending: {
          unarmed: this.defendSheetNewRef.current,
          sword: this.defendSheetNewRef.current,
          spear: this.defendSheetNewRef.current,
          crossbow: this.defendSheetNewRef.current,
        },
        deflected: {
          unarmed: this.deflectedFallingSheetNewRef.current,
          sword: this.deflectedFallingSheetNewRef.current,
          spear: this.deflectedFallingSheetNewRef.current,
          crossbow: this.deflectedFallingSheetNewRef.current,
        },
        pushBack: {
          unarmed: this.moveSheetNewRef.current,
          sword: this.moveSheetNewRef.current,
          spear: this.moveSheetNewRef.current,
          crossbow: this.moveSheetNewRef.current,
        },
        falling: {
          unarmed: this.deflectedFallingSheetNewRef.current,
          sword: this.deflectedFallingSheetNewRef.current,
          spear: this.deflectedFallingSheetNewRef.current,
          crossbow: this.deflectedFallingSheetNewRef.current,
        },
        pushing: {
          unarmed: this.moveSheetNewRef.current,
          sword: this.moveSheetNewRef.current,
          spear: this.moveSheetNewRef.current,
          crossbow: this.moveSheetNewRef.current,
        },
        pulling: {
          unarmed: this.moveSheetNewRef.current,
          sword: this.moveSheetNewRef.current,
          spear: this.moveSheetNewRef.current,
          crossbow: this.moveSheetNewRef.current,
        },
        pushed: {
          unarmed: this.moveSheetNewRef.current,
          sword: this.moveSheetNewRef.current,
          spear: this.moveSheetNewRef.current,
          crossbow: this.moveSheetNewRef.current,
        },
        pulled: {
          unarmed: this.moveSheetNewRef.current,
          sword: this.moveSheetNewRef.current,
          spear: this.moveSheetNewRef.current,
          crossbow: this.moveSheetNewRef.current,
        },
      },
      {
        idle: {
          unarmed: this.idleSheetNew2Ref.current,
          sword: this.idleSheetNew2Ref.current,
          spear: this.idleSheetNew2Ref.current,
          crossbow: this.idleSheetNew2Ref.current,
        },
        walking: {
          unarmed: this.moveSheetNewRef.current,
          sword: this.moveSheetNewRef.current,
          spear: this.moveSheetNewRef.current,
          crossbow: this.moveSheetNewRef.current,
        },
        jumping: {
          unarmed: this.moveSheetNewRef.current,
          sword: this.moveSheetNewRef.current,
          spear: this.moveSheetNewRef.current,
          crossbow: this.moveSheetNewRef.current,
        },
        dodging: {
          unarmed: this.dodgeSheetNewRef.current,
          sword: this.dodgeSheetNewRef.current,
          spear: this.dodgeSheetNewRef.current,
          crossbow: this.dodgeSheetNewRef.current,
        },
        flanking: {
          unarmed: this.moveSheetNewRef.current,
          sword: this.moveSheetNewRef.current,
          spear: this.moveSheetNewRef.current,
          crossbow: this.moveSheetNewRef.current,
        },
        strafing: {
          unarmed: this.moveSheetNewRef.current,
          sword: this.moveSheetNewRef.current,
          spear: this.moveSheetNewRef.current,
          crossbow: this.moveSheetNewRef.current,
        },
        attacking: {
          unarmed: this.attackSheetNewRef.current,
          sword: this.attackSheetNewRef.current,
          spear: this.attackSheetNewRef.current,
          crossbow: this.attackSheetNewRef.current,
        },
        defending: {
          unarmed: this.defendSheetNewRef.current,
          sword: this.defendSheetNewRef.current,
          spear: this.defendSheetNewRef.current,
          crossbow: this.defendSheetNewRef.current,
        },
        deflected: {
          unarmed: this.deflectedFallingSheetNewRef.current,
          sword: this.deflectedFallingSheetNewRef.current,
          spear: this.deflectedFallingSheetNewRef.current,
          crossbow: this.deflectedFallingSheetNewRef.current,
        },
        pushBack: {
          unarmed: this.moveSheetNewRef.current,
          sword: this.moveSheetNewRef.current,
          spear: this.moveSheetNewRef.current,
          crossbow: this.moveSheetNewRef.current,
        },
        falling: {
          unarmed: this.deflectedFallingSheetNewRef.current,
          sword: this.deflectedFallingSheetNewRef.current,
          spear: this.deflectedFallingSheetNewRef.current,
          crossbow: this.deflectedFallingSheetNewRef.current,
        },
        pushing: {
          unarmed: this.moveSheetNewRef.current,
          sword: this.moveSheetNewRef.current,
          spear: this.moveSheetNewRef.current,
          crossbow: this.moveSheetNewRef.current,
        },
        pulling: {
          unarmed: this.moveSheetNewRef.current,
          sword: this.moveSheetNewRef.current,
          spear: this.moveSheetNewRef.current,
          crossbow: this.moveSheetNewRef.current,
        },
        pushed: {
          unarmed: this.moveSheetNewRef.current,
          sword: this.moveSheetNewRef.current,
          spear: this.moveSheetNewRef.current,
          crossbow: this.moveSheetNewRef.current,
        },
        pulled: {
          unarmed: this.moveSheetNewRef.current,
          sword: this.moveSheetNewRef.current,
          spear: this.moveSheetNewRef.current,
          crossbow: this.moveSheetNewRef.current,
        },
      },
      {
        idle: {
          unarmed: this.idleSheetNew2Ref.current,
          sword: this.idleSheetNew2Ref.current,
          spear: this.idleSheetNew2Ref.current,
          crossbow: this.idleSheetNew2Ref.current,
        },
        walking: {
          unarmed: this.moveSheetNewRef.current,
          sword: this.moveSheetNewRef.current,
          spear: this.moveSheetNewRef.current,
          crossbow: this.moveSheetNewRef.current,
        },
        jumping: {
          unarmed: this.moveSheetNewRef.current,
          sword: this.moveSheetNewRef.current,
          spear: this.moveSheetNewRef.current,
          crossbow: this.moveSheetNewRef.current,
        },
        dodging: {
          unarmed: this.dodgeSheetNewRef.current,
          sword: this.dodgeSheetNewRef.current,
          spear: this.dodgeSheetNewRef.current,
          crossbow: this.dodgeSheetNewRef.current,
        },
        flanking: {
          unarmed: this.moveSheetNewRef.current,
          sword: this.moveSheetNewRef.current,
          spear: this.moveSheetNewRef.current,
          crossbow: this.moveSheetNewRef.current,
        },
        strafing: {
          unarmed: this.moveSheetNewRef.current,
          sword: this.moveSheetNewRef.current,
          spear: this.moveSheetNewRef.current,
          crossbow: this.moveSheetNewRef.current,
        },
        attacking: {
          unarmed: this.attackSheetNewRef.current,
          sword: this.attackSheetNewRef.current,
          spear: this.attackSheetNewRef.current,
          crossbow: this.attackSheetNewRef.current,
        },
        defending: {
          unarmed: this.defendSheetNewRef.current,
          sword: this.defendSheetNewRef.current,
          spear: this.defendSheetNewRef.current,
          crossbow: this.defendSheetNewRef.current,
        },
        deflected: {
          unarmed: this.deflectedFallingSheetNewRef.current,
          sword: this.deflectedFallingSheetNewRef.current,
          spear: this.deflectedFallingSheetNewRef.current,
          crossbow: this.deflectedFallingSheetNewRef.current,
        },
        pushBack: {
          unarmed: this.moveSheetNewRef.current,
          sword: this.moveSheetNewRef.current,
          spear: this.moveSheetNewRef.current,
          crossbow: this.moveSheetNewRef.current,
        },
        falling: {
          unarmed: this.deflectedFallingSheetNewRef.current,
          sword: this.deflectedFallingSheetNewRef.current,
          spear: this.deflectedFallingSheetNewRef.current,
          crossbow: this.deflectedFallingSheetNewRef.current,
        },
        pushing: {
          unarmed: this.moveSheetNewRef.current,
          sword: this.moveSheetNewRef.current,
          spear: this.moveSheetNewRef.current,
          crossbow: this.moveSheetNewRef.current,
        },
        pulling: {
          unarmed: this.moveSheetNewRef.current,
          sword: this.moveSheetNewRef.current,
          spear: this.moveSheetNewRef.current,
          crossbow: this.moveSheetNewRef.current,
        },
        pushed: {
          unarmed: this.moveSheetNewRef.current,
          sword: this.moveSheetNewRef.current,
          spear: this.moveSheetNewRef.current,
          crossbow: this.moveSheetNewRef.current,
        },
        pulled: {
          unarmed: this.moveSheetNewRef.current,
          sword: this.moveSheetNewRef.current,
          spear: this.moveSheetNewRef.current,
          crossbow: this.moveSheetNewRef.current,
        },
      },
      {
        idle: {
          unarmed: this.idleSheetNew2Ref.current,
          sword: this.idleSheetNew2Ref.current,
          spear: this.idleSheetNew2Ref.current,
          crossbow: this.idleSheetNew2Ref.current,
        },
        walking: {
          unarmed: this.moveSheetNewRef.current,
          sword: this.moveSheetNewRef.current,
          spear: this.moveSheetNewRef.current,
          crossbow: this.moveSheetNewRef.current,
        },
        jumping: {
          unarmed: this.moveSheetNewRef.current,
          sword: this.moveSheetNewRef.current,
          spear: this.moveSheetNewRef.current,
          crossbow: this.moveSheetNewRef.current,
        },
        dodging: {
          unarmed: this.dodgeSheetNewRef.current,
          sword: this.dodgeSheetNewRef.current,
          spear: this.dodgeSheetNewRef.current,
          crossbow: this.dodgeSheetNewRef.current,
        },
        flanking: {
          unarmed: this.moveSheetNewRef.current,
          sword: this.moveSheetNewRef.current,
          spear: this.moveSheetNewRef.current,
          crossbow: this.moveSheetNewRef.current,
        },
        strafing: {
          unarmed: this.moveSheetNewRef.current,
          sword: this.moveSheetNewRef.current,
          spear: this.moveSheetNewRef.current,
          crossbow: this.moveSheetNewRef.current,
        },
        attacking: {
          unarmed: this.attackSheetNewRef.current,
          sword: this.attackSheetNewRef.current,
          spear: this.attackSheetNewRef.current,
          crossbow: this.attackSheetNewRef.current,
        },
        defending: {
          unarmed: this.defendSheetNewRef.current,
          sword: this.defendSheetNewRef.current,
          spear: this.defendSheetNewRef.current,
          crossbow: this.defendSheetNewRef.current,
        },
        deflected: {
          unarmed: this.deflectedFallingSheetNewRef.current,
          sword: this.deflectedFallingSheetNewRef.current,
          spear: this.deflectedFallingSheetNewRef.current,
          crossbow: this.deflectedFallingSheetNewRef.current,
        },
        pushBack: {
          unarmed: this.moveSheetNewRef.current,
          sword: this.moveSheetNewRef.current,
          spear: this.moveSheetNewRef.current,
          crossbow: this.moveSheetNewRef.current,
        },
        falling: {
          unarmed: this.deflectedFallingSheetNewRef.current,
          sword: this.deflectedFallingSheetNewRef.current,
          spear: this.deflectedFallingSheetNewRef.current,
          crossbow: this.deflectedFallingSheetNewRef.current,
        },
        pushing: {
          unarmed: this.moveSheetNewRef.current,
          sword: this.moveSheetNewRef.current,
          spear: this.moveSheetNewRef.current,
          crossbow: this.moveSheetNewRef.current,
        },
        pulling: {
          unarmed: this.moveSheetNewRef.current,
          sword: this.moveSheetNewRef.current,
          spear: this.moveSheetNewRef.current,
          crossbow: this.moveSheetNewRef.current,
        },
        pushed: {
          unarmed: this.moveSheetNewRef.current,
          sword: this.moveSheetNewRef.current,
          spear: this.moveSheetNewRef.current,
          crossbow: this.moveSheetNewRef.current,
        },
        pulled: {
          unarmed: this.moveSheetNewRef.current,
          sword: this.moveSheetNewRef.current,
          spear: this.moveSheetNewRef.current,
          crossbow: this.moveSheetNewRef.current,
        },
      },
    ];
    this.itemImgs = {
      moveSpeedUp: this.itemSpdUpRef.current,
      moveSpeedDown: this.itemSpdDownRef.current,
      hpUp: this.itemHpUpRef.current,
      hpDown: this.itemHpDownRef.current,
      focusUp: this.itemFocusUpRef.current,
      focusDown: this.itemFocusDownRef.current,
      strengthUp: this.itemStrUpRef.current,
      strengthDown: this.itemStrDownRef.current,
      sword: this.itemSwordRef.current,
      spear: this.itemSpearRef.current,
      crossbow: this.itemBowRef.current,
      helmet: this.itemHelmet1Ref.current,
      ammo5: this.itemAmmoRef.current,
      ammo10: this.itemAmmoRef.current,
      mail: this.itemMail1Ref.current,
      greaves: this.itemGreaves1Ref.current,
    };
    this.boltImgs = {
      north: this.itemBoltNorthRef.current,
      south: this.itemBoltSouthRef.current,
      east: this.itemBoltEastRef.current,
      west: this.itemBoltWestRef.current,
    };
    this.floorImgs = {
      grass: this.floorGrassRef.current,
      stone: this.floorStoneRef.current,
      dirt: this.floorDirtRef.current,
      pond: this.floorPondRef.current,
      mud: this.floorMudRef.current,
      sand: this.floorSandRef.current,
      ice: this.floorIceRef.current,
      lava: this.floorLavaRef.current,
      bramble: this.floorBrambleRef.current,
      river: this.floorRiverRef.current,
      void: this.floorVoidRef.current,
      void2: this.floorVoid2Ref.current,
      void3: this.floorVoid3Ref.current,
      rubble: this.floorRubbleRef.current,
    };
    this.obstacleImgs = {
      // table: this.obstacleAHalfRef.current,
      closet: this.obstacleAFullRef.current,
      // chair: this.obstacleBHalfRef.current,
      // shelf: this.obstacleBFullRef.current,
      // smallBox: this.obstacleCHalfRef.current, //and me
      // largeBox: this.obstacleCFullRef.current, //revive me
      // counter: this.obstacleDHalfRef.current,
      // chest: this.obstacleEHalfRef.current,
      crate: this.obstacleCrateRef.current,
      barrel: this.obstacleBarrelRef.current,
      chest: this.obstacleCrateRef.current,
      table: this.obstacleCrateRef.current,
      chair: this.obstacleCrateRef.current,
      shelf: this.obstacleCrateRef.current,
      counter: this.obstacleCrateRef.current,
      smallBox: this.obstacleCrateRef.current,
      largeBox: this.obstacleBarrelRef.current, //remove me when obs imgs added
    };
    this.barrierImgs = {
      wall: {
        north: this.barrierANorthRef.current,
        south: this.barrierASouthRef.current,
        east: this.barrierAEastRef.current,
        west: this.barrierAWestRef.current,
      },
      door: {
        north: this.barrierANorthRef.current,
        south: this.barrierASouthRef.current,
        east: this.barrierAEastRef.current,
        west: this.barrierAWestRef.current,
      },
      balcony: {
        north: this.barrierANorthRef.current,
        south: this.barrierASouthRef.current,
        east: this.barrierAEastRef.current,
        west: this.barrierAWestRef.current,
      },
    };

    // LOAD CROSSBOW AMMO
    for (const plyr of this.players) {
      if (plyr.currentWeapon.type === "crossbow") {
        let ammo = parseInt(plyr.currentWeapon.effect.split("+")[1]);
        plyr.items.ammo = plyr.items.ammo + ammo;
      }
    }

    let floor;
    let wall = this.wallRef.current;
    let wall2 = this.wall2Ref.current;
    let wall3 = this.wall3Ref.current;

    canvas.width = this.canvasWidth;
    canvas.height = this.canvasHeight;

    let floorImageWidth = this.floorImageWidth;
    let floorImageHeight = this.floorImageHeight;
    let wallImageWidth = this.wallImageWidth;
    let wallImageHeight = this.wallImageHeight;
    let sceneX = this.canvasWidth / 2;
    let sceneY = this.sceneY;
    let tileWidth = this.tileWidth;

    this.startProcessLevelData(canvas);
    // gridInfo = this.gridInfo;

    this.processLevelData(this.gridInfo);

    // RESET START POSITION IF DOESN'T EXIST IN CURRENT GRID OR CONFLICTING W/ THIS MAP
    for (const plyr of this.players) {
      // if (!this.gridInfo.find(x => x.number.x === plyr.startPosition.cell.number.x && x.number.y === plyr.startPosition.cell.number.y)) {
      if (
        !this.gridInfo.find(
          (x) =>
            x.number.x === plyr.startPosition.cell.number.x &&
            x.number.y === plyr.startPosition.cell.number.y
        )
      ) {
        let cll = { x: undefined, y: undefined };
        let randomFreeCellChosen = false;

        while (randomFreeCellChosen !== true) {
          cll.x = this.rnJesus(0, this.gridWidth);
          cll.y = this.rnJesus(0, this.gridWidth);
          randomFreeCellChosen = this.checkCell(cll);
        }

        if (randomFreeCellChosen === true) {
          plyr.startPosition.cell.number = cll;
        }
      }

      // RECONSIDER/RANDOM CHOOSE START POSTION IF CONFLICTING W/ THIS MAP
      if (
        this.gridInfo.find(
          (x) =>
            x.number.x === plyr.startPosition.cell.number.x &&
            x.number.y === plyr.startPosition.cell.number.y
        ).terrain.type === "deep" ||
        this.gridInfo.find(
          (x) =>
            x.number.x === plyr.startPosition.cell.number.x &&
            x.number.y === plyr.startPosition.cell.number.y
        ).terrain.type === "void" ||
        this.gridInfo.find(
          (x) =>
            x.number.x === plyr.startPosition.cell.number.x &&
            x.number.y === plyr.startPosition.cell.number.y
        ).void.state === true ||
        this.gridInfo.find(
          (x) =>
            x.number.x === plyr.startPosition.cell.number.x &&
            x.number.y === plyr.startPosition.cell.number.y
        ).obstacle.state === true
      ) {
        let cll = { x: undefined, y: undefined };
        let randomFreeCellChosen = false;

        while (randomFreeCellChosen !== true) {
          cll.x = this.rnJesus(0, this.gridWidth);
          cll.y = this.rnJesus(0, this.gridWidth);
          randomFreeCellChosen = this.checkCell(cll);
        }

        if (randomFreeCellChosen === true) {
          plyr.startPosition.cell.number = cll;
        }
      }
    }
    // console.log('post process barrier check init',this.gridInfo.filter(x => x.barrier.state === true).map(y => y = y.barrier.position));

    if (this.camera.fixed !== true) {
      // this.setCameraFocus('init', canvas, context, canvas2, context2);
    }
    // this.findFocusCell('panToCell',{},canvas,context)

    // CENTER LARGER GRIDS
    if (window.innerWidth < 1100 && this.gridWidth >= 12) {
      // this.camera.zoom.x = 0.7;
      // this.camera.zoom.y = 0.7;

      this.setInitZoom = {
        state: true,
        windowWidth: window.innerWidth,
        gridWidth: this.gridWidth,
      };
    }
    if (window.innerWidth > 1100 && this.gridWidth >= 12) {
      // this.camera.zoom.x = 1;
      // this.camera.zoom.y = 1;

      this.setInitZoom = {
        state: true,
        windowWidth: window.innerWidth,
        gridWidth: this.gridWidth,
      };
    }
    if (window.innerWidth < 1100 && this.gridWidth < 12) {
      // this.camera.zoom.x = 1;
      // this.camera.zoom.y = 1;
      // this.setInitZoom = {
      //   state: true,
      //   windowWidth: window.innerWidth,
      //   gridWidth: this.gridWidth,
      // }
    }

    let diff = 1 - this.camera.zoom.x;

    // FOCUSED ZOOMING INIT SET
    this.camera.pan.x = (diff * this.canvasWidth) / 2;
    this.camera.pan.y = (diff * this.canvasWidth) / 2 - diff * 350;
    if (this.camera.pan.x === 0) {
      this.camera.pan.x = -1;
      this.camera.pan.y = -1;
    }

    this.setZoomPan(canvas);
    this.findFocusCell("panToCell", "", {}, canvas, context);

    if (this.showSettingsCanvasData.state === true) {
      this.settingsFormGridWidthUpdate(this.settingsGridWidth);
    }

    this.placeItems({ init: true, items: "" });

    // CELL COLOR REF
    let preCellColorRef = this.gridInfo.map(
      (x) => (x = { x: x.number.x, y: x.number.y, color: "" })
    );
    for (const cell of preCellColorRef) {
      let colorCheckPass = false;
      while (colorCheckPass === false) {
        let randomColor = `rgb(${this.rnJesus(0, 255)},${this.rnJesus(
          0,
          255
        )},${this.rnJesus(0, 255)})`;
        let colorsInUse = preCellColorRef
          .filter((x) => x.color !== "")
          .map((y) => y === y.color);
        if (colorsInUse.find((x) => x === randomColor)) {
          colorCheckPass = false;
        } else {
          cell.color = randomColor;
          colorCheckPass = true;
        }
      }
    }
    this.cellColorRef = preCellColorRef;

    for (var x = 0; x < this.gridWidth + 1; x++) {
      for (var y = 0; y < this.gridWidth + 1; y++) {
        let p = new Point();
        p.x = x * tileWidth;
        p.y = y * tileWidth;

        let iso = this.cartesianToIsometric(p);
        let offset = { x: floorImageWidth / 2, y: floorImageHeight };

        // apply offset to center scene for a better view
        iso.x += sceneX;
        iso.y += sceneY;

        let center = {
          x: iso.x - offset.x / 2 + this.cellCenterOffsetX,
          y: iso.y - offset.y / 2 - this.cellCenterOffsetY,
        };

        let cell = this.gridInfo.find(
          (elem) => elem.number.x === x && elem.number.y === y
        );
        let cellLevelData = this.gridInfo.find(
          (elem) => elem.number.x === x && elem.number.y === y
        ).levelData;

        floor = this.floorImgs[cell.terrain.name];

        if (cell.void.state === true) {
          // drawFloor = false;
          floor = this.floorImgs.void3;
        }

        // context.drawImage(floor, iso.x - offset.x, iso.y - offset.y, 100, 100);
        context.drawImage(floor, iso.x - offset.x, iso.y - offset.y);

        context.fillStyle = "black";
        context.fillText(
          "" + x + "," + y + "",
          iso.x - offset.x / 2 + 18,
          iso.y - offset.y / 2 + 12
        );

        context.fillStyle = "black";
        context.fillRect(center.x, center.y, 5, 5);

        // INITIAL ITEM DISTRIBUTION!!
        let cell2 = this.gridInfo.find(
          (elem) => elem.number.x === x && elem.number.y === y
        );
        if (cell2.item.name !== "") {
          // console.log('found cell with item');
          if (cell2.item.initDrawn === false) {
            // console.log('found cell with item undrawn');
            let itemImg;
            let fillClr;
            if (cell2.item.type === "item") {
              switch (cell2.item.name) {
                case "moveSpeedUp":
                  fillClr = "purple";
                  itemImg = this.itemImgs[cell2.item.name];
                  break;
                case "moveSpeedDown":
                  fillClr = "blue";
                  itemImg = this.itemImgs[cell2.item.name];
                  break;
                case "hpUp":
                  fillClr = "yellow";
                  itemImg = this.itemImgs[cell2.item.name];
                  break;
                case "hpDown":
                  fillClr = "brown";
                  itemImg = this.itemImgs[cell2.item.name];
                  break;
                case "focusUp":
                  fillClr = "white";
                  itemImg = this.itemImgs[cell2.item.name];
                  break;
                case "focusDown":
                  fillClr = "black";
                  itemImg = this.itemImgs[cell2.item.name];
                  break;
                case "strengthUp":
                  fillClr = "green";
                  itemImg = this.itemImgs[cell2.item.name];
                  break;
                case "strengthDown":
                  fillClr = "red";
                  itemImg = this.itemImgs[cell2.item.name];
                  break;
                case "ammo5":
                  fillClr = "#283618";
                  itemImg = this.itemImgs[cell2.item.name];
                  break;
                case "ammo10":
                  fillClr = "#283618";
                  itemImg = this.itemImgs[cell2.item.name];
                  break;
              }
            } else if (cell2.item.type === "weapon") {
              switch (cell2.item.subType) {
                case "sword":
                  fillClr = "orange";
                  itemImg = this.itemImgs[cell2.item.subType];
                  break;
                case "spear":
                  fillClr = "maroon";
                  itemImg = this.itemImgs[cell2.item.subType];
                  break;
                case "crossbow":
                  fillClr = "navy";
                  itemImg = this.itemImgs[cell2.item.subType];
                  break;
              }
            } else if (cell2.item.type === "armor") {
              switch (cell2.item.subType) {
                case "helmet":
                  fillClr = "grey";
                  itemImg = this.itemImgs[cell2.item.subType];
                  break;
                case "mail":
                  fillClr = "olive";
                  itemImg = this.itemImgs[cell2.item.subType];
                  break;
                case "greaves":
                  fillClr = "#b5179e";
                  itemImg = this.itemImgs[cell2.item.subType];
                  break;
              }
            }

            // context.fillStyle = fillClr;
            // context.beginPath();
            // context.arc(center.x, center.y, 15, 0, 2 * Math.PI);
            // context.fill();

            context.drawImage(itemImg, center.x - 15, center.y - 15, 30, 30);
          }
        }

        let vertices = [
          { x: center.x, y: center.y + tileWidth / 2 },
          { x: center.x + tileWidth, y: center.y },
          { x: center.x, y: center.y - tileWidth / 2 },
          { x: center.x - tileWidth, y: center.y },
        ];
        for (const vertex of vertices) {
          context.fillStyle = "yellow";
          context.fillRect(vertex.x - 2.5, vertex.y - 2.5, 5, 5);
        }

        for (const player of this.players) {
          if (
            x === player.startPosition.cell.number.x &&
            y === player.startPosition.cell.number.y
          ) {
            let playerImg;
            let playerImgIndex;
            let atkType = player.currentWeapon.type;
            if (player.currentWeapon.name === "") {
              atkType = "unarmed";
            }

            if (player.ai.state === true) {
              if (player.ai.imgType === "A") {
                playerImgIndex = 2;
              } else if (player.ai.imgType === "B") {
                playerImgIndex = 3;
              }

              playerImg = this.playerImgs[playerImgIndex].idle[atkType];
            } else {
              playerImg = this.playerImgs[player.number - 1].idle[atkType];
            }

            let dirs = ["north", "south", "east", "west"];
            let dirIndex = dirs.indexOf(player.direction);
            let sHeight = this.charSpriteHeight;
            let sWidth = this.charSpriteWidth;
            let sy = dirIndex * sHeight;
            let sx = 0 * sWidth;

            // player.speed.move = .1;
            player.dead.state = false;
            player.dead.count = 0;

            let point = {
              x: 0,
              y: 0,
            };

            let cell = this.gridInfo.find(
              (elem) =>
                elem.number.x === player.startPosition.cell.number.x &&
                elem.number.y === player.startPosition.cell.number.y
            );
            point.x = cell.center.x;
            point.y = cell.center.y;

            player.currentPosition.cell = {
              number: {
                x: player.startPosition.cell.number.x,
                y: player.startPosition.cell.number.y,
              },
              center: {
                x: point.x,
                y: point.y,
              },
            };
            player.moving = {
              state: false,
              step: 0,
              course: "",
              origin: {
                number: {
                  x: player.startPosition.cell.number.x,
                  y: player.startPosition.cell.number.y,
                },
                center: {
                  x: point.x,
                  y: point.y,
                },
              },
              destination: {
                x: 0,
                y: 0,
              },
            };
            player.nextPosition = {
              x: point.x,
              y: point.y,
            };

            this.players[player.number - 1] = player;

            this.getTarget(player);

            let newCharDarwPoint = {
              x: player.nextPosition.x - this.floorImageHeight / 2,
              y: player.nextPosition.y - this.floorImageHeight,
            };

            context.drawImage(
              playerImg,
              sx,
              sy,
              sWidth,
              sHeight,
              newCharDarwPoint.x,
              newCharDarwPoint.y,
              this.playerDrawWidth2,
              this.playerDrawHeight2
            );
          }
        }

        // OBSTACLES & BARRIERS
        if (cell.barrier.state === true && cell.void.state !== true) {
          let barrierImg = this.barrierImgs[cell.barrier.type][cell.barrier.position];
          context.drawImage(
            barrierImg,
            iso.x - offset.x,
            iso.y - barrierImg.height,
            barrierImg.width,
            barrierImg.height
          );
        }

        if (cell.obstacle.state === true && cell.void.state !== true) {
          let obstacleImg = this.obstacleImgs[cell.obstacle.type];
          context.drawImage(obstacleImg, iso.x - offset.x, iso.y - obstacleImg.height);
        }

        this.init = false;
        this.setState({
          loading: false,
        });
      }
    }
  };

  render() {
    return (
      <React.Fragment>
        {this.state.loading === true && <Loading />}

        <div className="containerTop">
          <div className="timer">
            <p className="timerText">{this.time}</p>
          </div>
          <Helper players={this.players} />
          <div className={this.state.containerInnerClass}>
            <canvas
              width={this.canvasWidth}
              height={this.canvasHeight}
              ref={this.canvasRef}
              className="canvas"
            />
            <canvas
              width={this.canvasWidth}
              height={this.canvasHeight}
              ref={this.canvasRef2}
              className="canvas2"
            />
            // DEBUB BOX
            <div className={this.debugBoxStyle}>
              <DebugBox
                player={this.players[0]}
                expand={this.expandDebugBox}
                minimize={this.minimizeDebugBox}
              />
            </div>
            {this.players.length > 1 && (
              <div className={this.debugBoxStyle2}>
                <DebugBox
                  player={this.players[1]}
                  expand={this.expandDebugBox}
                  minimize={this.minimizeDebugBox}
                />
              </div>
            )}
            //BACKGROUND COMPASS
            <img
              src={bgCompass}
              className="bgCompass"
              ref={this.bgCompassRef}
              alt="logo"
            />
            // SETTINGS BOX
            <div className="settingsSwitch">
              <a className="setSwitchLink" onClick={this.openSettings}>
                <OverlayTrigger
                  placement={"top"}
                  overlay={
                    <Popover id={`popover-positioned-${"top"}`}>
                      <Popover.Body>
                        <strong>Show Settings</strong>
                      </Popover.Body>
                    </Popover>
                  }>
                  <FontAwesomeIcon icon={faCogs} size="sm" className="setSwitchIcon" />
                </OverlayTrigger>
              </a>
              {this.aiPlayers[0] && (
                // {this.updateSettingsFormAiDataData.random &&(
                <a
                  className="setSwitchLink cameraModeHighlighted"
                  onClick={this.toggleAiDisplay}>
                  <OverlayTrigger
                    placement={"top"}
                    overlay={
                      <Popover id={`popover-positioned-${"top"}`}>
                        <Popover.Body>
                          <strong>Toggle Ai Sub-menu</strong>
                        </Popover.Body>
                      </Popover>
                    }>
                    <FontAwesomeIcon icon={faRobot} size="sm" className="setSwitchIcon" />
                  </OverlayTrigger>
                </a>
              )}
              {!this.aiPlayers[0] && (
                // {!this.updateSettingsFormAiDataData.random &&(
                <a className="setSwitchLink" onClick={this.toggleAiDisplay}>
                  <OverlayTrigger
                    placement={"top"}
                    overlay={
                      <Popover id={`popover-positioned-${"top"}`}>
                        <Popover.Body>
                          <strong>Toggle Ai Sub-menu</strong>
                        </Popover.Body>
                      </Popover>
                    }>
                    <FontAwesomeIcon icon={faRobot} size="sm" className="setSwitchIcon" />
                  </OverlayTrigger>
                </a>
              )}
              {this.camera.state === false && (
                <a className="setSwitchLink" onClick={this.menuToggleCamera}>
                  <OverlayTrigger
                    placement={"top"}
                    overlay={
                      <Popover id={`popover-positioned-${"top"}`}>
                        <Popover.Body>
                          {this.camera.customView.state !== true && (
                            <strong>Toggle Camera Sub-menu</strong>
                          )}
                          {this.camera.customView.state === true && (
                            <strong>Toggle Camera Sub-menu (Custom View is set)</strong>
                          )}
                        </Popover.Body>
                      </Popover>
                    }>
                    <div className="icon-container">
                      <FontAwesomeIcon
                        icon={faVideo}
                        size="sm"
                        className="setSwitchIcon"
                      />
                      {this.camera.customView.state === true && (
                        <FontAwesomeIcon
                          icon={faCheckSquare}
                          size="sm"
                          className="setSwitchIcon top-right-icon"
                        />
                      )}
                    </div>
                  </OverlayTrigger>
                </a>
              )}
              <a className="setSwitchLink" onClick={this.gameReset.bind(this, "soft")}>
                <OverlayTrigger
                  placement={"top"}
                  overlay={
                    <Popover id={`popover-positioned-${"top"}`}>
                      <Popover.Body>
                        <strong>Reset Game (w/ last settings)</strong>
                      </Popover.Body>
                    </Popover>
                  }>
                  <FontAwesomeIcon icon={faUndo} size="sm" className="setSwitchIcon" />
                </OverlayTrigger>
              </a>
            </div>
            // CAMERA BOX
            {this.camera.state === true && (
              <div className="cameraBox">
                <CameraControl
                  camera={this.camera}
                  close={this.closeCamera}
                  toggleMode={this.toggleCameraModeUI}
                  preReset={this.preResetCamera}
                  toggleCustomView={this.toggleCameraCustomView}
                />
              </div>
            )}
            // CELL INFO
            {this.showCellInfoBox !== true && (
              <div className="cellInfoSwitch">
                <OverlayTrigger
                  placement={"top"}
                  overlay={
                    <Popover id={`popover-positioned-${"top"}`}>
                      <Popover.Body>
                        <strong>Click or mouse over a cell to get more info</strong>
                      </Popover.Body>
                    </Popover>
                  }>
                  <FontAwesomeIcon
                    icon={faChessBoard}
                    size="sm"
                    className="setSwitchIcon"
                  />
                </OverlayTrigger>
              </div>
            )}
            {this.showCellInfoBox === true && (
              <CellInfo
                ref={this.cellInfoBoxRef}
                clicked={this.clicked}
                close={this.closeCellInfoBox}
                setCellInfoMouseOver={this.setCellInfoMouseOver}
              />
            )}
            // AI STATUS BOX
            {this.state.showAiStatus === true && (
              <AiStatus
                players={this.players}
                aiPlayers={this.aiPlayers}
                onAiAdd={this.addAiRandomPlayer}
              />
            )}
          </div>
          {this.state.showSettings === true && (
            <Settings
              gridWidth={this.gridWidth}
              onConfirm={this.loadSettings}
              onCancel={this.cancelSettings}
              getCustomAiStartPosList={this.getCustomAiStartPosList}
              aiStartPosList={this.settingsFormAiStartPosList}
              aiSettingsFormHandler={this.aiSettingsFormHandler}
              updateSettingsFormAiDataData={this.updateSettingsFormAiDataData}
              updateSettingsFormAiData={this.updateSettingsFormAiData}
              rnJesus={this.rnJesus}
              settingsFormGridWidthUpdate={this.settingsFormGridWidthUpdate}
              plyrStartPosList={this.settingsFormPlyrStartPosList}
              getCustomPlyrStartPosList={this.getCustomPlyrStartPosList}
              gamepad={this.gamepad}
              canvasRef={this.canvasRef3}
              canvasRef2={this.canvasRef4}
              canvasHeight={this.settingsCanvasHeight}
              canvasWidth={this.settingsCanvasWidth}
              gridInfo={this.settingsGridInfo}
              clickedCell={this.settingsClicked}
              showCanvasData={this.showSettingsCanvasData}
              updateSettingsCanvasData={this.updateSettingsCanvasData}
              disableInitItems={this.disableInitItems}
              settingsFormPlayerData={this.settingsFormPlayerData}
              updateSettingsFormPlayerData={this.updateSettingsFormPlayerData}
            />
          )}
          <svg
            className="popupProgressSvg hidden"
            ref={this.popupProgressSvgRef}
            xmlns="http://www.w3.org/2000/svg"
            viewBox="0 -0.5 30 30"
            shapeRendering="crispEdges">
            <metadata>
              Made with Pixels to Svg https://codepen.io/shshaw/pen/XbxvNj
            </metadata>
            <path
              id="border"
              stroke="yellow"
              strokeWidth="5px"
              d="M4 0h21M2 1h26M1 2h2M27 2h2M1 3h1M28 3h1M1 4h1M28 4h2M0 5h2M28 5h2M0 6h2M28 6h2M0 7h2M28 7h2M0 8h2M28 8h2M0 9h2M28 9h2M0 10h2M28 10h2M0 11h2M28 11h2M0 12h2M28 12h2M0 13h2M28 13h2M0 14h2M28 14h2M0 15h2M28 15h2M0 16h2M28 16h2M0 17h2M28 17h2M0 18h2M28 18h2M0 19h2M28 19h2M0 20h2M28 20h2M0 21h2M28 21h2M0 22h2M28 22h2M0 23h2M28 23h2M0 24h2M28 24h2M0 25h2M28 25h1M1 26h1M28 26h1M1 27h2M27 27h2M2 28h26M5 29h21"
            />
            <rect
              id="rect"
              x="1"
              y="1"
              rx="5"
              ry="5"
              width="95%"
              height="0%"
              fill="url(#grad)"
            />
            <defs>
              <linearGradient id="grad" x1="0%" y1="0%" x2="0%" y2="100%">
                <stop
                  offset="0%"
                  stopColor={this.popupProgressSvgGradColor1}
                  stopOpacity="100%"
                />
                <stop
                  offset="100%"
                  stopColor={this.popupProgressSvgGradColor2}
                  stopOpacity="100%"
                />
              </linearGradient>
            </defs>
          </svg>
          <img
            src=""
            className="hidden"
            height={this.popupImgSize}
            width={this.popupImgSize}
            ref={this.popupProgressImgRef}
            alt="logo"
          />
          <img
            src={bgCompass}
            className="hidden bgCompass"
            ref={this.bgCompassRef}
            alt="logo"
          />

          <img src={floorGrass} className="hidden" ref={this.floorGrassRef} alt="logo" />
          <img src={floorDirt} className="hidden" ref={this.floorDirtRef} alt="logo" />
          <img src={floorIce} className="hidden" ref={this.floorIceRef} alt="logo" />
          <img src={floorStone} className="hidden" ref={this.floorStoneRef} alt="logo" />
          <img src={floorSand} className="hidden" ref={this.floorSandRef} alt="logo" />
          <img src={floorMud} className="hidden" ref={this.floorMudRef} alt="logo" />
          <img src={floorPond} className="hidden" ref={this.floorPondRef} alt="logo" />
          <img src={floorRiver} className="hidden" ref={this.floorRiverRef} alt="logo" />
          <img
            src={floorBramble}
            className="hidden"
            ref={this.floorBrambleRef}
            alt="logo"
          />
          <img src={floorLava} className="hidden" ref={this.floorLavaRef} alt="logo" />
          <img
            src={floorAttack}
            className="hidden"
            ref={this.floorAttackRef}
            alt="logo"
          />
          <img
            src={floorAttack2}
            className="hidden"
            ref={this.floorAttack2Ref}
            alt="logo"
          />
          <img src={floorVoid} className="hidden" ref={this.floorVoidRef} alt="logo" />
          <img src={floorVoid2} className="hidden" ref={this.floorVoid2Ref} alt="logo" />
          <img src={floorVoid3} className="hidden" ref={this.floorVoid3Ref} alt="logo" />
          <img
            src={floorHighlight}
            className="hidden"
            ref={this.floorHighlightRef}
            alt="logo"
          />
          <img
            src={floorRubble}
            className="hidden"
            ref={this.floorRubbleRef}
            alt="logo"
          />
          <img src={wall} className="hidden" ref={this.wallRef} alt="logo" />
          <img src={wall2} className="hidden" ref={this.wall2Ref} alt="logo" />
          <img src={wall3} className="hidden" ref={this.wall3Ref} alt="logo" />
          <img
            src={obstacleAHalf}
            className="hidden"
            ref={this.obstacleAHalfRef}
            alt="logo"
          />
          <img
            src={obstacleAFull}
            className="hidden"
            ref={this.obstacleAFullRef}
            alt="logo"
          />
          <img
            src={obstacleBHalf}
            className="hidden"
            ref={this.obstacleBHalfRef}
            alt="logo"
          />
          <img
            src={obstacleBFull}
            className="hidden"
            ref={this.obstacleBFullRef}
            alt="logo"
          />
          <img
            src={obstacleCHalf}
            className="hidden"
            ref={this.obstacleCHalfRef}
            alt="logo"
          />
          <img
            src={obstacleCFull}
            className="hidden"
            ref={this.obstacleCFullRef}
            alt="logo"
          />
          <img
            src={obstacleDHalf}
            className="hidden"
            ref={this.obstacleDHalfRef}
            alt="logo"
          />
          <img
            src={obstacleDFull}
            className="hidden"
            ref={this.obstacleDFullRef}
            alt="logo"
          />
          <img
            src={obstacleEHalf}
            className="hidden"
            ref={this.obstacleEHalfRef}
            alt="logo"
          />
          <img
            src={obstacleEFull}
            className="hidden"
            ref={this.obstacleEFullRef}
            alt="logo"
          />
          <img
            src={obstacleCrate}
            className="hidden"
            ref={this.obstacleCrateRef}
            alt="logo"
          />
          <img
            src={obstacleBarrel}
            className="hidden"
            ref={this.obstacleBarrelRef}
            alt="logo"
          />
          <img
            src={barrierANorth}
            className="hidden"
            ref={this.barrierANorthRef}
            alt="logo"
          />
          <img
            src={barrierASouth}
            className="hidden"
            ref={this.barrierASouthRef}
            alt="logo"
          />
          <img
            src={barrierAEast}
            className="hidden"
            ref={this.barrierAEastRef}
            alt="logo"
          />
          <img
            src={barrierAWest}
            className="hidden"
            ref={this.barrierAWestRef}
            alt="logo"
          />
          <img
            src={attack1Indicate}
            className="hidden playerImgs"
            ref={this.attack1IndicateRef}
            alt="logo"
          />
          <img
            src={attack2Indicate}
            className="hidden playerImgs"
            ref={this.attack2IndicateRef}
            alt="logo"
          />
          <img
            src={attack3Indicate}
            className="hidden playerImgs"
            ref={this.attack3IndicateRef}
            alt="logo"
          />
          <img
            src={attackUnarmedIndicate}
            className="hidden playerImgs"
            ref={this.attackUnarmedIndicateRef}
            alt="logo"
          />
          <img
            src={attackBluntIndicate}
            className="hidden playerImgs"
            ref={this.attackBluntIndicateRef}
            alt="logo"
          />
          <img
            src={attackSuccessIndicate}
            className="hidden playerImgs"
            ref={this.attackSuccessIndicateRef}
            alt="logo"
          />
          <img
            src={defendIndicate}
            className="hidden playerImgs"
            ref={this.defendIndicateRef}
            alt="logo"
          />
          <img
            src={defendIndicate1}
            className="hidden playerImgs"
            ref={this.defendIndicate1Ref}
            alt="logo"
          />
          <img
            src={defendIndicate2}
            className="hidden playerImgs"
            ref={this.defendIndicate2Ref}
            alt="logo"
          />
          <img
            src={defendIndicate3}
            className="hidden playerImgs"
            ref={this.defendIndicate3Ref}
            alt="logo"
          />
          <img
            src={defendIndicate4}
            className="hidden playerImgs"
            ref={this.defendIndicate4Ref}
            alt="logo"
          />
          <img
            src={deflectIndicate}
            className="hidden playerImgs"
            ref={this.deflectIndicateRef}
            alt="logo"
          />
          <img
            src={deflectIndicate2}
            className="hidden playerImgs"
            ref={this.deflectIndicate2Ref}
            alt="logo"
          />
          <img
            src={deflectInjuredIndicate}
            className="hidden playerImgs"
            ref={this.deflectInjuredIndicateRef}
            alt="logo"
          />
          <img
            src={deflectInjuredIndicate2}
            className="hidden playerImgs"
            ref={this.deflectInjuredIndicate2Ref}
            alt="logo"
          />
          <img
            src={deflectBluntIndicate}
            className="hidden playerImgs"
            ref={this.deflectBluntIndicateRef}
            alt="logo"
          />
          <img
            src={pushbackIndicate}
            className="hidden playerImgs"
            ref={this.pushbackIndicateRef}
            alt="logo"
          />
          <img
            src={ghostIndicate}
            className="hidden playerImgs"
            ref={this.ghostIndicateRef}
            alt="logo"
          />
          <img
            src={deathIndicate}
            className="hidden playerImgs"
            ref={this.deathIndicateRef}
            alt="logo"
          />
          <img
            src={preAttackIndicate}
            className="hidden playerImgs"
            ref={this.preAttackIndicateRef}
            alt="logo"
          />
          <img
            src={preAttack2Indicate}
            className="hidden playerImgs"
            ref={this.preAttack2IndicateRef}
            alt="logo"
          />
          <img
            src={attackBreakIndicate}
            className="hidden playerImgs"
            ref={this.attackBreakIndicateRef}
            alt="logo"
          />
          <img
            src={defendBreakIndicate}
            className="hidden playerImgs"
            ref={this.defendBreakIndicateRef}
            alt="logo"
          />
          <img
            src={defendSuccessIndicate}
            className="hidden playerImgs"
            ref={this.defendSuccessIndicateRef}
            alt="logo"
          />
          <img
            src={boltDefendIndicate}
            className="hidden playerImgs"
            ref={this.boltDefendIndicateRef}
            alt="logo"
          />
          <img
            src={dodgeIndicate}
            className="hidden playerImgs"
            ref={this.dodgeIndicateRef}
            alt="logo"
          />
          <img
            src={preAction1Indicate}
            className="hidden playerImgs"
            ref={this.preAction1IndicateRef}
            alt="logo"
          />
          <img
            src={preAction2Indicate}
            className="hidden playerImgs"
            ref={this.preAction2IndicateRef}
            alt="logo"
          />
          <img
            src={fallingIndicate}
            className="hidden playerImgs"
            ref={this.fallingIndicateRef}
            alt="logo"
          />
          <img
            src={completeMissionIndicate}
            className="hidden playerImgs"
            ref={this.completeMissionIndicateRef}
            alt="logo"
          />
          <img
            src={flankIndicate}
            className="hidden playerImgs"
            ref={this.flankIndicateRef}
            alt="logo"
          />
          <img
            src={attackBluntIndicate2}
            className="hidden playerImgs"
            ref={this.attackBluntIndicate2Ref}
            alt="logo"
          />
          <img
            src={enrouteIndicate}
            className="hidden playerImgs"
            ref={this.enrouteIndicateRef}
            alt="logo"
          />
          <img
            src={targetSwitchIndicate}
            className="hidden playerImgs"
            ref={this.targetSwitchIndicateRef}
            alt="logo"
          />
          <img
            src={pathSwitchIndicate}
            className="hidden playerImgs"
            ref={this.pathSwitchIndicateRef}
            alt="logo"
          />
          <img
            src={retreatIndicate}
            className="hidden playerImgs"
            ref={this.retreatIndicateRef}
            alt="logo"
          />
          <img
            src={defendSuccessIndicate}
            className="hidden playerImgs"
            ref={this.defendSuccessIndicateRef}
            alt="logo"
          />
          <img
            src={healIndicate}
            className="hidden playerImgs"
            ref={this.healIndicateRef}
            alt="logo"
          />
          <img
            src={preAttack2Indicate}
            className="hidden playerImgs"
            ref={this.preAttack2IndicateRef}
            alt="logo"
          />
          <img
            src={preAction1Indicate}
            className="hidden playerImgs"
            ref={this.preAction1IndicateRef}
            alt="logo"
          />
          <img
            src={preAction2Indicate}
            className="hidden playerImgs"
            ref={this.preAction2IndicateRef}
            alt="logo"
          />
          <img
            src={attackBreakIndicate}
            className="hidden playerImgs"
            ref={this.attackBreakIndicateRef}
            alt="logo"
          />
          <img
            src={missedIndicate}
            className="hidden playerImgs"
            ref={this.missedIndicateRef}
            alt="logo"
          />
          <img
            src={defendBreakIndicate}
            className="hidden playerImgs"
            ref={this.defendBreakIndicateRef}
            alt="logo"
          />
          <img
            src={boltDefendIndicate}
            className="hidden playerImgs"
            ref={this.boltDefendIndicateRef}
            alt="logo"
          />
          <img
            src={dodgeIndicate}
            className="hidden playerImgs"
            ref={this.dodgeIndicateRef}
            alt="logo"
          />
          <img
            src={fallingIndicate}
            className="hidden playerImgs"
            ref={this.fallingIndicateRef}
            alt="logo"
          />
          <img
            src={completeMissionIndicate}
            className="hidden playerImgs"
            ref={this.completeMissionIndicateRef}
            alt="logo"
          />
          <img
            src={flankIndicate}
            className="hidden playerImgs"
            ref={this.flankIndicateRef}
            alt="log"
          />
          <img
            src={attackBluntIndicate2}
            className="hidden playerImgs"
            ref={this.attackBluntIndicate2Ref}
            alt="logo"
          />
          <img
            src={enrouteIndicate}
            className="hidden playerImgs"
            ref={this.enrouteIndicateRef}
            alt="logo"
          />
          <img
            src={targetSwitchIndicate}
            className="hidden playerImgs"
            ref={this.targetSwitchIndicateRef}
            alt="logo"
          />
          <img
            src={pathSwitchIndicate}
            className="hidden playerImgs"
            ref={this.pathSwitchIndicateRef}
            alt="logo"
          />
          <img
            src={retreatIndicate}
            className="hidden playerImgs"
            ref={this.retreatIndicateRef}
            alt="logo"
          />
          <img
            src={defendSuccessIndicate}
            className="hidden playerImgs"
            ref={this.defendSuccessIndicateRef}
            alt="logo"
          />
          <img
            src={aggressiveModeIndicate}
            className="hidden playerImgs"
            ref={this.aggressiveModeIndicateRef}
            alt="logo"
          />
          <img
            src={passiveModeIndicate}
            className="hidden playerImgs"
            ref={this.passiveModeIndicateRef}
            alt="logo"
          />
          <img
            src={thinkingIndicate}
            className="hidden playerImgs"
            ref={this.thinkingIndicateRef}
            alt="logo"
          />
          <img
            src={defendMissionIndicate}
            className="hidden playerImgs"
            ref={this.defendMissionIndicateRef}
            alt="logo"
          />
          <img
            src={patrolMissionIndicate}
            className="hidden playerImgs"
            ref={this.patrolMissionIndicateRef}
            alt="logo"
          />
          <img
            src={pursueMissionIndicate}
            className="hidden playerImgs"
            ref={this.pursueMissionIndicateRef}
            alt="logo"
          />
          <img
            src={pursueMissionIndicate2}
            className="hidden playerImgs"
            ref={this.pursueMissionIndicate2Ref}
            alt="logo"
          />
          <img
            src={retrieveMissionIndicate}
            className="hidden playerImgs"
            ref={this.retrieveMissionIndicateRef}
            alt="logo"
          />
          <img
            src={drowningIndicate}
            className="hidden playerImgs"
            ref={this.drowningIndicateRef}
            alt="logo"
          />
          <img
            src={destroyedItemIndicate}
            className="hidden playerImgs"
            ref={this.destroyedItemIndicateRef}
            alt="logo"
          />
          <img
            src={pickupBuffIndicate}
            className="hidden playerImgs"
            ref={this.pickupBuffIndicateRef}
            alt="logo"
          />
          <img
            src={pickupDebuffIndicate}
            className="hidden playerImgs"
            ref={this.pickupDebuffIndicateRef}
            alt="logo"
          />
          <img
            src={pickupWeaponIndicate}
            className="hidden playerImgs"
            ref={this.pickupWeaponIndicateRef}
            alt="logo"
          />
          <img
            src={dropWeaponIndicate}
            className="hidden playerImgs"
            ref={this.dropWeaponIndicateRef}
            alt="logo"
          />
          <img
            src={dropArmorIndicate}
            className="hidden playerImgs"
            ref={this.dropArmorIndicateRef}
            alt="logo"
          />
          <img
            src={pickupArmorIndicate}
            className="hidden playerImgs"
            ref={this.pickupArmorIndicateRef}
            alt="logo"
          />
          <img
            src={pickupAmmoIndicate}
            className="hidden playerImgs"
            ref={this.pickupAmmoIndicateRef}
            alt="logo"
          />
          <img
            src={terrainSpeedupIndicate}
            className="hidden playerImgs"
            ref={this.terrainSpeedupIndicateRef}
            alt="logo"
          />
          <img
            src={terrainSlowdownIndicate}
            className="hidden playerImgs"
            ref={this.terrainSlowdownIndicateRef}
            alt="logo"
          />
          <img
            src={terrainInjuredIndicate}
            className="hidden playerImgs"
            ref={this.terrainInjuredIndicateRef}
            alt="logo"
          />
          <img
            src={outOfStaminaIndicate}
            className="hidden playerImgs"
            ref={this.outOfStaminaIndicateRef}
            alt="logo"
          />
          <img
            src={boltKilledIndicate}
            className="hidden playerImgs"
            ref={this.boltKilledIndicateRef}
            alt="logo"
          />
          <img
            src={attackParriedIndicate}
            className="hidden playerImgs"
            ref={this.attackParriedIndicateRef}
            alt="logo"
          />
          <img
            src={inventoryFullIndicate}
            className="hidden playerImgs"
            ref={this.inventoryFullIndicateRef}
            alt="logo"
          />
          <img
            src={outOfAmmoIndicate}
            className="hidden playerImgs"
            ref={this.outOfAmmoIndicateRef}
            alt="logo"
          />
          <img
            src={missedIndicate2}
            className="hidden playerImgs"
            ref={this.missedIndicate2Ref}
            alt="logo"
          />
          <img
            src={prePushIndicate}
            className="hidden playerImgs"
            ref={this.prePushIndicateRef}
            alt="logo"
          />
          <img
            src={canPushIndicate}
            className="hidden playerImgs"
            ref={this.canPushIndicateRef}
            alt="logo"
          />
          <img
            src={noPushingIndicate}
            className="hidden playerImgs"
            ref={this.noPushingIndicateRef}
            alt="logo"
          />
          <img
            src={pushingIndicate}
            className="hidden playerImgs"
            ref={this.pushingIndicateRef}
            alt="logo"
          />
          <img
            src={prePullIndicate}
            className="hidden playerImgs"
            ref={this.prePullIndicateRef}
            alt="logo"
          />
          <img
            src={canPullIndicate}
            className="hidden playerImgs"
            ref={this.canPullIndicateRef}
            alt="logo"
          />
          <img
            src={noPullingIndicate}
            className="hidden playerImgs"
            ref={this.noPullingIndicateRef}
            alt="logo"
          />
          <img
            src={pullingIndicate}
            className="hidden playerImgs"
            ref={this.pullingIndicateRef}
            alt="logo"
          />
          <img
            src={pushedPulledIndicate}
            className="hidden playerImgs"
            ref={this.pushedPulledIndicateRef}
            alt="logo"
          />
          <img
            src={unbreakableIndicate}
            className="hidden playerImgs"
            ref={this.unbreakableIndicateRef}
            alt="logo"
          />
          <img
            src={dodgeIndicate2}
            className="hidden playerImgs"
            ref={this.dodgeIndicate2Ref}
            alt="logo"
          />
          <img
            src={attackFeintIndicate}
            className="hidden playerImgs"
            ref={this.attackFeintIndicateRef}
            alt="logo"
          />
          <img
            src={attackFeintIndicate2}
            className="hidden playerImgs"
            ref={this.attackFeintIndicate2Ref}
            alt="logo"
          />
          <img
            src={attackFeintIndicate3}
            className="hidden playerImgs"
            ref={this.attackFeintIndicate3Ref}
            alt="logo"
          />
          <img
            src={defendFeintIndicate}
            className="hidden playerImgs"
            ref={this.defendFeintIndicateRef}
            alt="logo"
          />
          <img
            src={defendFeintIndicate2}
            className="hidden playerImgs"
            ref={this.defendFeintIndicate2Ref}
            alt="logo"
          />
          <img
            src={defendFeintIndicate3}
            className="hidden playerImgs"
            ref={this.defendFeintIndicate3Ref}
            alt="logo"
          />
          <img
            src={dodgeFeintIndicate}
            className="hidden playerImgs"
            ref={this.dodgeFeintIndicateRef}
            alt="logo"
          />
          <img
            src={dodgeFeintIndicate2}
            className="hidden playerImgs"
            ref={this.dodgeFeintIndicate2Ref}
            alt="logo"
          />
          <img
            src={boltDefendIndicate2}
            className="hidden playerImgs"
            ref={this.boltDefendIndicate2Ref}
            alt="logo"
          />
          <img
            src={flankIndicate2}
            className="hidden playerImgs"
            ref={this.flankIndicate2Ref}
            alt="logo"
          />
          <img
            src={noFlankIndicate}
            className="hidden playerImgs"
            ref={this.noFlankIndicateRef}
            alt="logo"
          />
          <img
            src={cellVoidingIndicate}
            className="hidden playerImgs"
            ref={this.cellVoidingIndicateRef}
            alt="logo"
          />
          <img
            src={cellVoidingIndicate2}
            className="hidden playerImgs"
            ref={this.cellVoidingIndicate2Ref}
            alt="logo"
          />
          <img
            src={timerIndicate}
            className="hidden playerImgs"
            ref={this.timerIndicateRef}
            alt="logo"
          />
          <img
            src={chargeIndicate}
            className="hidden playerImgs"
            ref={this.chargeIndicateRef}
            alt="logo"
          />
          <img
            src={sword}
            className="hidden playerImgs"
            ref={this.itemSwordRef}
            alt="logo"
          />
          <img
            src={spear}
            className="hidden playerImgs"
            ref={this.itemSpearRef}
            alt="logo"
          />
          <img src={bow} className="hidden playerImgs" ref={this.itemBowRef} alt="logo" />
          <img
            src={crossbow}
            className="hidden playerImgs"
            ref={this.itemCrossbowRef}
            alt="logo"
          />
          <img
            src={boltNorth}
            className="hidden playerImgs"
            ref={this.itemBoltNorthRef}
            alt="logo"
          />
          <img
            src={boltSouth}
            className="hidden playerImgs"
            ref={this.itemBoltSouthRef}
            alt="logo"
          />
          <img
            src={boltEast}
            className="hidden playerImgs"
            ref={this.itemBoltEastRef}
            alt="logo"
          />
          <img
            src={boltWest}
            className="hidden playerImgs"
            ref={this.itemBoltWestRef}
            alt="logo"
          />
          <img
            src={ammo}
            className="hidden playerImgs"
            ref={this.itemAmmoRef}
            alt="logo"
          />
          <img
            src={mail1}
            className="hidden playerImgs"
            ref={this.itemMail1Ref}
            alt="logo"
          />
          <img
            src={mail2}
            className="hidden playerImgs"
            ref={this.itemMail2Ref}
            alt="logo"
          />
          <img
            src={mail3}
            className="hidden playerImgs"
            ref={this.itemMail3Ref}
            alt="logo"
          />
          <img
            src={greaves1}
            className="hidden playerImgs"
            ref={this.itemGreaves1Ref}
            alt="logo"
          />
          <img
            src={greaves2}
            className="hidden playerImgs"
            ref={this.itemGreaves2Ref}
            alt="logo"
          />
          <img
            src={greaves3}
            className="hidden playerImgs"
            ref={this.itemGreaves3Ref}
            alt="logo"
          />
          <img
            src={helmet1}
            className="hidden playerImgs"
            ref={this.itemHelmet1Ref}
            alt="logo"
          />
          <img
            src={hpUp}
            className="hidden playerImgs"
            ref={this.itemHpUpRef}
            alt="logo"
          />
          <img
            src={hpDown}
            className="hidden playerImgs"
            ref={this.itemHpDownRef}
            alt="logo"
          />
          <img
            src={spdUp}
            className="hidden playerImgs"
            ref={this.itemSpdUpRef}
            alt="logo"
          />
          <img
            src={spdDown}
            className="hidden playerImgs"
            ref={this.itemSpdDownRef}
            alt="logo"
          />
          <img
            src={strUp}
            className="hidden playerImgs"
            ref={this.itemStrUpRef}
            alt="logo"
          />
          <img
            src={strDown}
            className="hidden playerImgs"
            ref={this.itemStrDownRef}
            alt="logo"
          />
          <img
            src={focusUp}
            className="hidden playerImgs"
            ref={this.itemFocusUpRef}
            alt="logo"
          />
          <img
            src={focusDown}
            className="hidden playerImgs"
            ref={this.itemFocusDownRef}
            alt="logo"
          />
          <img
            src={playerImgIdleSheet}
            className="hidden playerImgs"
            ref={this.playerImgIdleSheetRef}
            alt="logo"
          />
          <img
            src={player2ImgIdleSheet}
            className="hidden playerImgs"
            ref={this.player2ImgIdleSheetRef}
            alt="logo"
          />
          <img
            src={playerComAImgIdleSheet}
            className="hidden playerImgs"
            ref={this.playerComAImgIdleSheetRef}
            alt="logo"
          />
          <img
            src={playerComBImgIdleSheet}
            className="hidden playerImgs"
            ref={this.playerComBImgIdleSheetRef}
            alt="logo"
          />
          <img
            src={playerImgMoveSheet}
            className="hidden playerImgs"
            ref={this.playerImgMoveSheetRef}
            alt="logo"
          />
          <img
            src={player2ImgMoveSheet}
            className="hidden playerImgs"
            ref={this.player2ImgMoveSheetRef}
            alt="logo"
          />
          <img
            src={comAImgMoveSheet}
            className="hidden playerImgs"
            ref={this.comAImgMoveSheetRef}
            alt="logo"
          />
          <img
            src={comBImgMoveSheet}
            className="hidden playerImgs"
            ref={this.comBImgMoveSheetRef}
            alt="logo"
          />
          <img
            src={player1DefendSheet}
            className="hidden playerImgs"
            ref={this.player1ImgDefendSheetRef}
            alt="logo"
          />
          <img
            src={player2DefendSheet}
            className="hidden playerImgs"
            ref={this.player2ImgDefendSheetRef}
            alt="logo"
          />
          <img
            src={comADefendSheet}
            className="hidden playerImgs"
            ref={this.comAImgDefendSheetRef}
            alt="logo"
          />
          <img
            src={comBDefendSheet}
            className="hidden playerImgs"
            ref={this.comBImgDefendSheetRef}
            alt="logo"
          />
          <img
            src={player1AttackSheet}
            className="hidden playerImgs"
            ref={this.player1ImgAttackSheetRef}
            alt="logo"
          />
          <img
            src={player2AttackSheet}
            className="hidden playerImgs"
            ref={this.player2ImgAttackSheetRef}
            alt="logo"
          />
          <img
            src={comAAttackSheet}
            className="hidden playerImgs"
            ref={this.comAImgAttackSheetRef}
            alt="logo"
          />
          <img
            src={comBAttackSheet}
            className="hidden playerImgs"
            ref={this.comBImgAttackSheetRef}
            alt="logo"
          />
          <img
            src={testSpriteNorth}
            className="hidden playerImgs"
            ref={this.testRefNorth}
            alt="logo"
          />
          <img
            src={testSpriteSouth}
            className="hidden playerImgs"
            ref={this.testRefSouth}
            alt="logo"
          />
          <img
            src={testSpriteEast}
            className="hidden playerImgs"
            ref={this.testRefEast}
            alt="logo"
          />
          <img
            src={testSpriteWest}
            className="hidden playerImgs"
            ref={this.testRefWest}
            alt="logo"
          />
          <img
            src={moveSheetNew}
            className="hidden playerImgs"
            ref={this.moveSheetNewRef}
            alt="logo"
          />
          <img
            src={idleSheetNew}
            className="hidden playerImgs"
            ref={this.idleSheetNewRef}
            alt="logo"
          />
          <img
            src={idleSheetNew2}
            className="hidden playerImgs"
            ref={this.idleSheetNew2Ref}
            alt="logo"
          />
          <img
            src={attackSheetNew}
            className="hidden playerImgs"
            ref={this.attackSheetNewRef}
            alt="logo"
          />
          <img
            src={defendSheetNew}
            className="hidden playerImgs"
            ref={this.defendSheetNewRef}
            alt="logo"
          />
          <img
            src={dodgeSheetNew}
            className="hidden playerImgs"
            ref={this.dodgeSheetNewRef}
            alt="logo"
          />
          <img
            src={deflectedFallingSheetNew}
            className="hidden playerImgs"
            ref={this.deflectedFallingSheetNewRef}
            alt="logo"
          />
        </div>
      </React.Fragment>
    );
  }
}

export default App;
